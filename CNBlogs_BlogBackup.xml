<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:trackback="http://madskills.com/public/xml/rss/module/trackback/" xmlns:wfw="http://wellformedweb.org/CommentAPI/" xmlns:slash="http://purl.org/rss/1.0/modules/slash/"><channel><title>博客园-codingbigdog</title><link>https://www.cnblogs.com/codingbigdog/</link><description /><language>zh-cn</language><lastBuildDate>Tue, 26 Jul 2022 11:36:12 GMT</lastBuildDate><pubDate>Tue, 26 Jul 2022 11:36:12 GMT</pubDate><ttl>60</ttl><item><title>C++ 正则表达式 string替换</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/25/16516545.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Mon, 25 Jul 2022 02:21:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/25/16516545.html</guid><description><![CDATA[```
time_t curr_time;
time(&curr_time);
char *curr_time2 = asctime(localtime(&curr_time));
regex pattern1(" "); // 规则一：匹配空格
regex pattern2("\n"); // 规则二：匹配换行
string s1 = regex_replace(regex_replace(curr_time2, pattern1, "_"), pattern2, "");
```]]></description></item><item><title>string转化成const char *：.c_str()</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/25/16516505.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Mon, 25 Jul 2022 02:15:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/25/16516505.html</guid><description><![CDATA[string result_path = "images/" + labels + "/image" + s1 + ".jpg";
FILE *file = fopen(result_path.c_str(), "r")]]></description></item><item><title>宏变量</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/24/16515334.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Sun, 24 Jul 2022 12:06:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/24/16515334.html</guid><description><![CDATA[```
#include <iostream>
#include <stdexcept>
#include<bitset>
#define CheckBuffer(x) { if ((nBufSize-nOffset)<(x)) { nUsedLen = nOffset; return 0;} } 

using namespace std;

int main(void)
{
    int nBufSize=1;
    int nOffset=1;
    int nUsedLen =1;
    CheckBuffer(9);  // 上面三个局部变量会传进宏CheckBuffer中。
    return 0;
}
```]]></description></item><item><title>使用fopen打开文件时，如果文件不存在，就不需要执行fclose，否则会产生段错误</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/24/16514423.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Sun, 24 Jul 2022 05:59:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/24/16514423.html</guid><description><![CDATA[使用fopen打开文件时，如果文件不存在，就不需要执行fclose，否则会产生段错误，如下：
```
// test.cpp  
#include <stdio.h>

int main() {
    FILE *outfp_ = NULL;
    outfp_ = fopen("output.h264", "rb");
    if (outfp_ == NULL ){
      fclose(outfp_);
    }
}
```
由于output.h264文件不存在，那么上述代码就会产生段错误，执行过程如下：
```
g++ test.cpp 
./a.out 
Segmentation fault (core dumped)
```]]></description></item><item><title>python调用C++程序，C++程序调用python程序：pybind11简单使用</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/23/16512831.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Sat, 23 Jul 2022 11:28:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/23/16512831.html</guid><description><![CDATA[本博客只是对[链接](https://blog.csdn.net/henuyh/article/details/119341884)进行补充说明。

通过git clone https://github.com/pybind/pybind11.git 下载源码，可以发现源码中并没有cpp文件，只有.h文件，也就是说pybind11将实现的代码都放进了.h文件中了。所以pybind11其实是不用进行编译安装，就可以使用的，直接通过include相关头文件就可以。

pyadd.cpp：
```
#include <pybind11/pybind11.h>

/***********************调用普通函数***********************/
template <typename T>
T add(T a, T b) {
  return a + b;
}

PYBIND11_MODULE(pyadd, m) {
  m.doc() = "test for add()";
  m.def("add", &add<int>, "add two number.");
  m.def("add", &add<double>, "add two number.");
  m.def("add", &add<long long>, "add two number.");
  m.attr("__version__") = "dev";
}
```
将pyadd编译成动态库：
```
g++ test.cpp -I ./ -I /home/ubuntu1/anaconda3/envs/test/include/python3.9 -L /home/ubuntu1/anaconda3/envs/test/lib -l python3.9  -fPIC -shared  -o pyadd.so 
```
第一个-I用于指明头文件pybind11.h位置，第二个-I指明Python.h所在位置。
这里动态库的名字为pyadd.so，那么在python程序中使用“import pyadd”进行导入，如：
pytest.py
```
import pyadd
print(pyadd.__version__)
# 'dev' 
print(pyadd.add(1.1, 2.2))  
# 3.3000000000000003 
```
由于pyadd.so是由虚拟环境“test” 中python生成的，所以需要使用虚拟环境test中的python执行脚本pytest.py:
```
conda activate test
python3 pytest.py
```
]]></description></item><item><title>C++ primer总结</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/22/16506475.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Fri, 22 Jul 2022 09:21:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/22/16506475.html</guid><description><![CDATA[可以用少量字总结的就总结一下，如果不行，就只写一下有什么知识

练习答案：https://github.com/applenob/Cpp_Primer_Practice



1.main()函数return的是0，则表示成功；非零表示各种错误类型

不同编译器规定c++源文件的后缀不同，可能是cc,cpp,cp等

UNIX可执行文件后缀为.out，可以没有后缀；windows可执行文件后缀为.exe

ubuntu中直接输入a.out是无法找到可执行文件，需要执行./a.out通过“./”告诉系统可执行文件所在目录。

在命令行中运行完可执行文件后，可以使用echo输出main函数返回的值





2.cin和cout是两个对象，<<是一个运算符。

cerr和clog也是两个输出对象，分别用于输出错误和日志

程序员常常在调试时添加打印语句。这类语句应该保证“一直”刷新流，即cout都应该以<<std::endl结尾。否则，如果程序崩溃，输出可能还留在缓冲区中，此时我们以为某位置没有输出，其实是输出了，只是留在了缓冲区中。这就会导致导致关于程序崩溃位置的错误推断。

<<可以输出不同类型数据，是因为定义了不同版本的<<运算符来处理不同类型的数据。





3.while(std::cin>>value)中std::cin>>value返回的是一个std::cin对象，当对象是文件结束符（或输入错误）时while循环结束。

文件结束符：windows下为ctrl+z或Enter，linux（或MAC os x）下为ctrl+d。

常见错误类型：syntax error（如忘写分号）、type error（int型被字符串进行赋值）、declaration error（名字拼写错误、忘写std::）

修改一部分代码就重新编译调试一次，因为后面很多错误可能只是由前面修改的错误引起的。

类就是一种自定义的数据类型

**标准库的头文件使用#include<>**，非标准库的头文件（自己写的头文件）使用include""。

./test.out <text.txt> text2.txt：代表使用cin的地方从text.txt中读取内容，使用cout的地方将内容输出到text2.txt中





4.空类型（void）：当函数不返回任何值时使用空类型作为返回类型。

不同机器上数据类型（又称算术类型）占用的比特不同，但c++规定了各类型的最小尺寸。

wchar：存放扩展字符；char16_t、char32_t：存放Unicode字符

每个地址上可以存放的比特数称为字节，一个字节一般是八个比特；CPU一次性处理的数据大小称为字，**64位计算机指的是字的大小为8个字节。**

char用signed char或unsigned char来实现，不同的编译器实现的方式不同；所以如果实在必须将char当成整型来用，指明使用的是signed char还是unsigned char。

数值范围int无法表示，一般直接使用long long；浮点运算一般使用double，不使用float。





5.类型转换

类型转换：如char转int——就是将char变量对应的二进制码解读成int。

给**无符号数**赋值超过表示范围时，结果是初始值对无符号类型可表示的数值的个数取模后的**余数**。给**有符号数赋值**超过表示范围时，结果为**未定义**，此时程序可能出现不可预知的风险。

**int和无符号数相加**时，int变量会被转换成**无符号数**。如果此时int变量是负数，则直接将此负数对应的二进制补码解读成原码；

无符号相减得到的结果如果是负数：如u2-u1为负数，则u2-u1=u2+(-u1)，其中-u1的机器码为补码，这里的补码解读为原码。

**for(unsigned u=10;u>=0;- -u)**中当u=-1时，u实际为4294967295。及其解决方法。

**切勿混用带符号类型和无符号**类型进行运算





6.字面值常量

字面值常量：就是告诉你整数、浮点数、字符串等需要怎么表示

八进制：0开头；十六进制：0x或0X开头

默认情况下，十进制字面值是带符号数，八进制和十六进制字面值既可能是带符号的也可能是无符号的。

十进制字面值是利用“int、long、long long”中一个来装载的。具体选的是可容纳此字面值的最小类型来装载。

八进制和十六进制字面值是利用“int、unsigned int、long、unsigned Iong、Iong long和unsigned long long ”中一个来装载的。具体选的是可容纳此字面值的最小类型来装载。

浮点数默认使用**double**来装载。3.14159E0或3.14159e0中的E0或e0代表乘以10的0次方

我们还可以自己选择利用哪个类型来装载，只需要利用**字面值后添加相应的后缀**即可，如42ULL代表42这个数用unsigned long long来装载。如果指定的装载类型太小，编译器会自动用其他更大的类型来装



由单引号括起来的一个字符称为char型字面值，双引号括起来的零个或多个字符则构成字符串型字面值。

**字符串**字面值是由**字符数组**来装载的，编译器在每个字符串的**结尾**处添加一一个**空字符('\0')**， 因此，**字符串字**
**面值的实际长度要比它的内容多1。**

多行字符串实际会被当成一行字符串。

**给字面值添加前缀**来指明用什么类型装在字符或字符串，如L’a’代表用wchar_t装载字符a





7.变量

变量可以当成内置的对象

string在std命名空间中被定义

初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对象的当前值擦除，而以一个新值来替代。

列表初始化：int a={0}或int a{0}。如果我们使用列表初始化且初始值存在丢失信息的风险，则编译器将报错（如**int a{1.111}中的.111会丢失**）

**函数体外**定义的变量对应的机器码会**默认初始化为零**。**函数体内**定义的变量可能会初始化成**没有意义的数或者为未定义**。
一个未被初始化的内置类型变量的值是**未定义的**（还有，给有符号数赋值超过表示范围时，结果也为未定义），如果试图拷贝或以其他形式访问此未定义变量将引发错误。这句话没看懂？？？

为了安全**建议初始化每一个内置类型的变量**

声明：告诉了程序这个变量的存在，但未申请内存。定义：申请了内存。

声明：在变量前面添加extern，如extern int a;

一个文件如**果想使用别处定义的名字**则必须包含对那个**名字的声明**。

变量能且只能被定义一次。但是**可以被多次声明**。

**函数内部**不能声明变量

**显式初始化的声明即成为定义。**“extern int val = 1; ”为定义

**函数的声明是函数**头，也可以在函数头左边加上extern。函数声明的形参可以只写类型，而不写形参的名称。

c++中**不能使用标识符**：不能**连续**出现**两个下划线**；不能以**下划线紧连大写**字母开头；定义在**函数体外**的标识符**不能以下划线开头**。

**变量名**一般用**小写**字母，如index；用户自定义的**类名**一般以**大写字母开头**，如Sales_item;标识符由多个单词组成时，单词之间用下划线隔开或除第一个单词外的其他单词都大写。

不用把**定义**都放在开头，**放在使用的地方的附近**（注意不要重复定义）

cout<<**::reused**;表示访问**全局变量**reused

8.引用就是别名，**引用上的任何改变都是对原变量的改变**。int &a=b;

引用必须初始化；无法更改绑定对象；引用只能绑定在对象上，不能绑定在字面值上

引用的作用：函数fun(int &a)传入实参a时，不需要复制一份a，而直接传入a本身。函数fun(int a)传入实参a时，需要复制一份a。

指针：存储对象的地址。由于引用不是对象，只是别名，所以没有指向引用的指针。利用取地址符&取引用地址时，取到的是引用指向变量的地址。

无效指针：最常见的是，指针所指的内存单元被释放了，此时指针就变为了无效指针，**不遗留任何无效指针总是最好的实践方式。**

如果p是个指针，则\*p代表访问p所指向对象。

空指针：int *p=nullptr;int *p=0;int *p=NULL;

其中NULL是预处理变量，在预处理阶段会被替换成零

把**int变量直接赋给指针是错误的操作**，**即使int变量的值恰好等于0也不行**

建议**所有指针都要进行初始化**

指针一般写成这样：**int \*p**，而不写成int\* p。再如：int* p1, p2; // **p1是指向int的指针，p2是int**

指向指针的引用：给指针取别名，如int *&r=p，从右往左读，首先读到&，代表r是一个引用，其余部分代表r是什么类型数据的引用，即int指针的引用



9、const int k=9;定义一个不可改变的常量，k必须在定义的时候就**初始化**，任何在k上的操作都**不可以修改k**的值

**非常量引用不可以指向一个常量对象；常量引用可以指向一个非常量对象**

在初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可，如**const int &ri = dval ;其中dval为double类型**，此时ri绑定的是一个临时常量而不是dval。而下面这个却是错误的：**int &ri = dval ;其中dval为double类型**。为什么普通引用不可以绑定到临时常量上呢？答：因为一般需要修改dval时，才会使用普通引用。所以如果普通引用被绑定在临时变量上了，就不可以修改dval了

const int *ri = dval ;其中dval为int类型，即dval可以不是const int。dval为int类型时，应该和上面一样：ri实际是绑定了一个临时变量

const指针：指针本身为常量。

int \*const E=&e;const代表E本身是一个常量，int \*代表这个常量是int类型指针。const double \*const pip=\&pi;const代表pip是一个常量，const double \*代表这个常量是double常量类型指针

指针本身是一个常量并不意味着不能通过指针修改其所指对象的值。

顶层const( top-level const)表示本身是个常量，底层const (low-level const)表示指针或引用所指的对象是一个常量。

常量表达式：值不会改变并且在编译过程就能得到计算结果的表达式。如当表达式中含有函数时，计算结果是在运行的时候才能得到。常量表达式在后面会用到。

C++11中判断是否为常量表达式的方法是将表达式赋给constexpr变量。constexpr变量：constexpr int a = A，编译器会验证A是否为常量表达式。

constexpr指针：只能存放地址固定的对象的地址。如一般函数体内的对象（变量）一般不能由constexpr指向（但有例外，例外是啥呢？？？？），函数体内可以。

constexpr const int  \*p=&i; // p是常量指针，指向整型常量i
constexpr int \*p1=&j;// p1是常量指针，指向整数j

10、

取别名:

​		typedef int *p;  // p为int *的别名

​		typedef int p;   // p为int的别名

​		using SI = Sales_ item;  // SI为Sales_ item的别名

​		typedef char *pstring;
​		const pstring cstr = 0; // cstr是指向char的常量指针

​		const char *cstr = 0; // cstr是指向char类型常量的指针

auto item = val1 + val2; // auto推断出val1+val2为类型A，并将item定义成类型A。等号自然是将val1+val2的值，赋给了item。

auto也能在一条语句中声明多个变量以及其注意点

auto a = i; // i是一个引用。auto获取的是i所指对象的类型，而不是获取到引用类型。

auto会忽略顶层const，底层const会被保留下来。

使用auto获取引用类型和顶层const的方法

不能为非常量引用绑定字面值，可以为常量引用绑定字面值。

设置一个类型为auto的引用时，初始值中的顶层常量属性仍然保留。

auto不能确定基本数据类型是什么而导致的错误



decltype：只返回表达式的类型，返回表达式的值（即不用表达式的值进行初始化）

decltype(ci) x=2; \\\ 获取ci的类型A，将x定义成类型A并初始化为2；

decltype处理项层const和引用的方式与auto有些许不同。如果decltype使用的表达式是一个变量，则decltype返回该变量的类型(包括顶层const和引用在内):

需要指出的是，引用从来都作为其所指对象的同义词出现，只有用在decltype处是一个例外。

如果decltype使用的表达式不是一个变量时，则decltype返回表达式结果对应的类型【具体见原文】

如果表达式的内容是解引用操作，则decltype将得到引用类型。

切记: decltype ( (variable)) (注意是双层括号)的结果永远是引用，而decltype (variable)结果只有当生variable本身就是一个引用时才是引用。



使用struct自定义数据结构（类）【struct使用方法和class相似，不需要再看了 】

C++11新标准规定，可以为数据成员提供一个类内初始值

头文件的编写

类名一般和头文件名一样

头文件通常包含那些只能被定义一次的实体，如类、const和constexpr变量(

通过#ifndef和文件保护符防止头文件的重复引用。通常文件保护符的名字和类名有关





接下来看第三章







重载：相同函数名，不同形参

重写：子类对父类中相同函数（函数名、形参和返回值都相同）的覆盖

空的形参列表的两种表示：void f();或void f(void);。void f(void)是为了和C语言兼容

void函数不返回任何值。函数的返回类型不能是数组类型或函数类型，但可以是指向数组或函数的指针。



goto语句：goto label;代表跳转到代码label:所在的位置

# 异常处理
异常处理：throw在try中抛出异常，根据异常的不同选择不同的catch块。

多层函数调用中，出现异常，程序会一层一层的往上寻找对应的catch语句，找不到就终止程序。
catch块中一般进行内存释放等清理操作。
大多数常见的类都是定义在标准库中的，所以调用的时候，都要带std::，如std::runtime_error。
如果异常类型有一个字符串初始值，则what()返回字符串。
具体见原文和[链接](https://www.cnblogs.com/codingbigdog/p/16505862.html)



# 函数指针
将函数名替换成(*pf)就生成了一个函数指针pf。
函数名当成一个值使用时，该函数名被当成地址。
函数指针作为形参
函数指针作为返回值




# 智能指针
智能指针不用自己释放内存，只要没有指针指向内存了，就会自动释放。
shared ptr允许多个指针指向同一个对象
unique_ ptr则“独占”所指向的对象。
标准库还定义了一个名为weak_ ptr的伴随类，它是一种弱引用，指向shared ptr所管理的对象。这三种类型都定义在memory头文件中。
shared_ptr创建出对象，而对象当然有相应的方法可以调用，如返回对象被引用的次数。
make_shared用于动态分配内存并初始化
接下来看404





# IO库
cout<<：代表向对象cout写入内容，<<代表写入的意思
三大IO类：
- iostream针对IO流
- fstream针对文件
- sstream针对string类型
类型ifstream和istringstream都继承自istream。类型ofstream和ostringstream都继承自ostream。所以对istream和ostream进行的操作，对其他两类型也可以。





# 位运算符












# 其他：

补码运算：正数为原码本身，负数为原码取反加一









# 问题：

2.取模运算？答：[链接](https://blog.csdn.net/qq_42775938/article/details/122696829)

3.int转无符号数的规则是什么？

4.为什么说初始化和赋值是两个完全不同的操作，是因为一个使用构造函数，另一个使用别的东西吗？？

5.constexpr变量的变量到底有什么作用？

6.“2.2.1”中有一个问题？ ]]></description></item><item><title>C++ primer总结：C++异常处理</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/22/16505862.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Fri, 22 Jul 2022 07:15:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/22/16505862.html</guid><description><![CDATA[# 1.简介
异常处理：throw在try中抛出异常，根据异常的不同选择不同的catch块。
多层函数调用中，出现异常，程序会一层一层的往上寻找对应的catch语句，找不到就终止程序。
catch块中一般进行内存释放等清理操作。
大多数常见的类都是定义在标准库中的，所以调用的时候，都要带std::，如std::runtime_error。
如果异常类型有一个字符串初始值，则what()返回字符串。
exception是所有标准 C++ 异常的父类

# 2.实例
**1.抛出runtime_error异常：**
```
#include <iostream>
#include <stdexcept>
using std::cin; using std::cout; using std::endl; using std::runtime_error;

int main(void)
{
    for (int i, j; cout << "Input two integers:\n", cin >> i >> j; )
    {
        try 
        {
            if (j == 0) 
                throw runtime_error("divisor is 0");
            cout << i / j << endl;
        }
        catch (runtime_error err) 
        {
            cout << err.what() << "\nTry again? Enter y or n" << endl;
            char c;
            cin >> c;
            if (!cin || c == 'n')
                break;
        }
    }

    return 0;
}
```
**2.直接抛出字符串**
```
#include <iostream>
using namespace std;
 
double division(int a, int b)
{
   if( b == 0 )
   {
      throw "Division by zero condition!";
   }
   return (a/b);
}
 
int main ()
{
   int x = 50;
   int y = 0;
   double z = 0;
 
   try {
     z = division(x, y);
     cout << z << endl;
   }catch (const char* msg) {
     cerr << msg << endl;
   }
 
   return 0;
}
```

**3.catch(...)处理任何异常的代码**

修改“2.直接抛出字符串”中的代码，如下：
```
#include <iostream>
using namespace std;
 
double division(int a, int b)
{
   if( b == 0 )
   {
      throw "Division by zero condition!";
   }
   return (a/b);
}
 
int main ()
{
   int x = 50;
   int y = 0;
   double z = 0;
 
   try {
     z = division(x, y);
     cout << z << endl;
   }catch (...) {
     cerr << "处理异常。。。" << endl;
   }
 
   return 0;
}
```

# 3.定义新的异常
直接看[菜鸟教程](https://www.runoob.com/cplusplus/cpp-exceptions-handling.html)：就是继承了父类exception，重写了成员函数what()
]]></description></item><item><title>音视频学习总结</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/15/16482992.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Fri, 15 Jul 2022 14:33:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/15/16482992.html</guid><description><![CDATA[# 7
07-01-FFmpeg解封装解码：如解析出mp4中的各种流，音频流、视频流、字幕流等。主要涉及两个结构体AVFormatContext和AVPacket。AVFormatContext存储流信息，AVPacket存储包信息（可以将流当成很多个包的集合）
代码：本代码功能：打印媒体文件中的流信息（打印AVFormatContext结构体中的信息）
               打印流中每个包的信息（打印AVPacket 结构体中的信息）

07-02-AAC ADTS格式（音频格式）分析：ADTS可以在任意帧解码，也就是说它每⼀帧都有头信息。AAC⾳频⽂件（ADTS格式）的每⼀帧由ADTS Header和AAC Audio Data组成。⼀般情况下ADTS的头信息都是7个字节，分为2部分： adts_fixed_header();和adts_variable_header();。ADTS Header存放着采样率、码率、声道数、帧长度等信息。
代码：本代码将媒体文件中的音频利用AAC ADTS格式进行保存。从代码中可以看出，视频流中的AAC数据是没有包含头部的，头部需要自己去写。

07-03-H264 NALU分析：H264简介、IDR为I帧、H264将视频组织成为 序列(GOP)、图⽚(pictrue)、⽚(Slice)、宏块(Macroblock)、⼦块(subblock)五个层次进行网络传输。
NALU （视频流的网络传输单元）：H.264原始码流(裸流)是由⼀个接⼀个NALU组成。每个NALU的开头都是一个StartCode（"00 00 00 01" 或"00 00 01"），用于标识一个NALU的开始。
av_bsf_get_by_name("h264_mp4toannexb")将mp4模式转换为annexb模式
代码：本代码将媒体文件中的视频利用H264格式进行保存。

07-04-FLV格式分析-FLV封装格式剖析：FLV常用于直播。FLV封装格式是由⼀个⽂件头(file header)和 ⽂件体(file Body)组成。其中，FLV body由⼀ 对对的(Previous Tag Size字段 + tag)组成。
⼀个flv⽂件最多只有⼀个⾳频流，⼀个视频流。（mp4中就可能存在多个同种流）
每⼀个Tag也是由两部分组成:tag header和tag data。FLV Header和Tag Header中都有标识数据类型和长度的字段
tag data有三种：script、video、audio

代码：本代码一个bit一个bit地对flv文件进行解析。首先解析flv文件的头部和tag头部，然后分别解析tag data中包含的h264文件和aac文件，解析h264就是解析出一个个NALU并在NALU前面加上startcode，解析aac就是解析出一个个AAC Audio data并加上ADTS header。
本代码利用解析得到的信息，重新封装得到一个新的flv文件。
]]></description></item><item><title>ubuntu20.04进入 advanced options for ubuntu  recovery mode </title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/15/16480410.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Fri, 15 Jul 2022 02:30:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/15/16480410.html</guid><description><![CDATA[开机时，按shift+Esc]]></description></item><item><title>音视频处理常用软件</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/13/16472952.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Wed, 13 Jul 2022 02:31:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/13/16472952.html</guid><description><![CDATA[Beyond Compare：比较两个文件的二进制格式
MediaInfo：查看音视频文件的一些信息
winhex：可查看文件的十六进制格式]]></description></item><item><title>C++ opencv画框以及在框上设置标签</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/11/16466816.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Mon, 11 Jul 2022 08:18:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/11/16466816.html</guid><description><![CDATA[
```
int baseline = 0;
string label_string = "labels....";

// 框出图像中的某个物体。cv::Point(a,b)，其中a是相对于图片左边的距离，b是相对于图片上边的距离
cv::rectangle(image, cv::Point(left, top), cv::Point(right, bottom), cv::Scalar(0, 0, 255));   

// text_size中存储文本的宽高；baseline是基线y-相对于最底部文本的基线坐标【我也看不太懂baseline是什么？】
cv::Size text_size = cv::getTextSize(label_string, FONT_HERSHEY_SIMPLEX, 0.4, 1, &baseline);   

// 给文本填充背景颜色。虽然我也看不太懂baseline是什么，但是你把下面的baseline去掉看看效果，就大概知道baseline是个什么了
cv::rectangle(image, cv::Point(left, top - text_size.height - baseline), cv::Point(left+ text_size.width, top), cv::Scalar(255, 0, 255), -1);  

// 添加文字标签
cv::putText(image, label_string, cv::Point(left, top - baseline), FONT_HERSHEY_SIMPLEX, 0.4, cv::Scalar(0, 255, 255));
```
		]]></description></item><item><title>不同的python程序使用不同的虚拟环境</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/11/16465746.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Mon, 11 Jul 2022 03:07:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/11/16465746.html</guid><description><![CDATA[```
import os

def run():
    os.system('xxx/anaconda3/envs/paddle_ocr/bin/python3 ../src/python_scripts/paddleOcr.py')
```
使用指定虚拟环境下的python运行程序即可。]]></description></item><item><title>./my_cmake_exe: error while loading shared libraries: libswresample.so.4: cannot open shared object file: No such file or directory</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/11/16465317.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Mon, 11 Jul 2022 01:08:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/11/16465317.html</guid><description><![CDATA[我使用的编译命令如下：
```
 gcc  demuxing_decoding.c  -o demuxing_decoding -g -I ./ffmpeg-5.0.1/include -L ./ffmpeg-5.0.1/lib/ \
          -l avcodec -l avutil -l avformat -l swresample  -lm -Wl,-rpath=./ffmpeg-5.0.1/lib/                                    
```  
目录./ffmpeg-5.0.1/lib/下明明就有库 libswresample.so.4，但就是提示找不到这个动态库
最好实在没办法了，只能按照网上常用的方法：/etc/ld.so.conf中添加库 libswresample.so.4所在目录，并执行命令ldconfig。]]></description></item><item><title>使用Clion优雅的完全远程自动同步和远程调试c++</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/10/16462736.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Sun, 10 Jul 2022 02:40:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/10/16462736.html</guid><description><![CDATA[直接操作远程的代码就可以了，弄个Mappings不是多此一举吗？？]]></description></item><item><title>明明-Wl,-rpath指定的目录下有所要求的动态库，但是运行时就是说没有找到·</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/08/16459838.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Fri, 08 Jul 2022 14:41:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/08/16459838.html</guid><description><![CDATA[我的原因：
使用gcc  avframe.c avpacket.c  main.c -o main -I /home/ubuntu1/softwares/ffmpeg/include -L /home/ubuntu1/softwares/ffmpeg/lib/ -l avcodec -l avutil  -lm 生成可执行文件main，然后运行main的时候，发现运行时动态库找不到，原来是我忘记加-Wl,-rpath了。
此时加上-Wl,-rpath：gcc  avframe.c avpacket.c  main.c -o main -I /home/ubuntu1/softwares/ffmpeg/include -L /home/ubuntu1/softwares/ffmpeg/lib/ -l avcodec -l avutil  -lm -Wl,-rpath=/home/ubuntu1/softwares/ffmpeg/lib/，然后重新运行main。此时发现动态库还是找不到。
原因是因为前面运行的可执行文件main没有删除，要删除main以后，再重新进行编译。]]></description></item><item><title>cmake入门</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/08/16459532.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Fri, 08 Jul 2022 12:12:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/08/16459532.html</guid><description><![CDATA[# 1 cmake基础
## 1.1 简介
[CMake 和makefile关系](https://blog.csdn.net/u013827488/article/details/123804786)
不同平台有自己的make标准。如果软件想跨平台，必须要保证能够在不同平台编译。而如果使用上面的 Make 工具，就得为每一种标准写一次 Makefile ，这将是一件让人抓狂的工作。
CMake就是针对上面问题所设计的工具：它首先允许开发者编写一种平台无关的 CMakeList.txt 文件来定制整个编译流程，然后再根据目标用户的平台进一步生成所需的本地化 Makefile 和工程文件，如 Unix 的 Makefile 或 Windows 的 Visual Studio 工程。从而做到“Write once, run everywhere”。



## 1.2 语法特性介绍
基本语法格式：指令(参数 1 参数 2...) 
- 参数使用括弧括起
- 参数之间使用空格或分号分开 

指令是大小写无关的，参数和变量是大小写相关的，如：
```
set(HELLO hello.cpp)
add_executable(hello main.cpp hello.cpp)
ADD_EXECUTABLE(hello main.cpp ${HELLO})
```
变量使用${}方式取值，但是在 IF 控制语句中是直接使用变量名


## 1.3 重要指令和CMake常用变量
**重要指令:**
```
cmake_minimum_required(VERSION versionNumber [FATAL_ERROR]) 指定CMake的最小版本要求
# CMake最小版本要求为2.8.3
cmake_minimum_required(VERSION 2.8.3)

project(projectname [CXX] [C] [Java])   定义工程名称，并可指定工程支持的语言。一般只定义工程名称。
# 指定工程名为HELLOWORLD
project(HELLOWORLD) 

set(VAR [VALUE] [CACHE TYPE DOCSTRING [FORCE]])  显式的定义变量
# 定义SRC变量，其值为sayhello.cpp hello.cpp
set(SRC sayhello.cpp hello.cpp)

include_directories([AFTER|BEFORE] [SYSTEM] dir1 dir2 ...)    向工程添加多个特定的头文件搜索路径 --->相当于指定g++编译器的-I参数
# 将/usr/include/myincludefolder 和 ./include 添加到头文件搜索路径
include_directories(/usr/include/myincludefolder ./include)

link_directories(dir1 dir2 ...) 向工程添加多个特定的库文件搜索路径 --->相当于指定g++编译器的-L参数
# 将/usr/lib/mylibfolder 和 ./lib 添加到库文件搜索路径
link_directories(/usr/lib/mylibfolder ./lib)

add_library(libname [SHARED|STATIC|MODULE] [EXCLUDE_FROM_ALL] source1 source2 ... sourceN) 生成库文件
# 通过变量 SRC 生成 libhello.so 共享库，即将SRC中的文件编译成共享库文件
add_library(hello SHARED ${SRC}) 

add_compile_options(）添加编译参数
# 添加编译参数 -Wall -std=c++11 -O2
add_compile_options(-Wall -std=c++11 -O2)

add_executable(exename source1 source2 ... sourceN)  生成可执行文件
# 编译main.cpp生成可执行文件main
add_executable(main main.cpp)

target_link_libraries(target library1<debug | optimized> library2...)  为 target 添加需要链接的共享库 --->相同于指定g++编译器-l参数
# 将hello动态库文件链接到可执行文件main
target_link_libraries(main hello)

add_subdirectory(source_dir [binary_dir] [EXCLUDE_FROM_ALL])  向当前工程添加存放源文件的子目录，并可以指定中间二进制和目标二进制存放的位置
# 添加src子目录，src中需有一个CMakeLists.txt
add_subdirectory(src)
  
aux_source_directory(dir VARIABLE) 发现一个目录下所有的源代码文件并将列表存储在一个变量中，这个指令临时被用来自动构建源文件列表
# 定义SRC变量，其值为当前目录下所有的源代码文件
aux_source_directory(. SRC)
# 编译SRC变量所代表的源代码文件，生成main可执行文件
add_executable(main ${SRC})
```


**CMake常用变量:**
```
CMAKE_C_FLAGS gcc编译选项
CMAKE_CXX_FLAGS g++编译选项
# 在CMAKE_CXX_FLAGS编译选项后追加-std=c++11
set( CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -std=c++11")

CMAKE_BUILD_TYPE 编译类型(Debug, Release)
# 设定编译类型为debug，调试时需要选择debug。相当于gcc中的-g选项
set(CMAKE_BUILD_TYPE Debug)  
# 设定编译类型为release，发布时需要选择release
set(CMAKE_BUILD_TYPE Release)

CMAKE_BINARY_DIR 
PROJECT_BINARY_DIR
_BINARY_DIR
1. 这三个变量指代的内容是一致的。
2. 如果是 in source build，指的就是工程顶层目录。
3. 如果是 out of source 编译,指的是工程编译发生的目录。
4. PROJECT_BINARY_DIR 跟其他指令稍有区别，不过现在，你可以理解为他们是一致的。

CMAKE_SOURCE_DIR
PROJECT_SOURCE_DIR
_SOURCE_DIR
1. 这三个变量指代的内容是一致的,不论采用何种编译方式,都是工程顶层目录。
2. 也就是在 in source build时,他跟 CMAKE_BINARY_DIR 等变量一致。
3. PROJECT_SOURCE_DIR 跟其他指令稍有区别,现在,你可以理解为他们是一致的。

CMAKE_C_COMPILER：指定C编译器
CMAKE_CXX_COMPILER：指定C++编译器
EXECUTABLE_OUTPUT_PATH：可执行文件输出的存放路径
LIBRARY_OUTPUT_PATH：库文件输出的存放路径
```


# 1.4  CMake编译工程
**CMake目录结构：**项目主目录存在一个CMakeLists.txt文件

**两种方式设置编译规则：**
1. 包含源文件的子文件夹包含CMakeLists.txt文件，主目录的CMakeLists.txt通过add_subdirectory添加子目录即可；
2. 包含源文件的子文件夹未包含CMakeLists.txt文件，子目录编译规则体现在主目录的CMakeLists.txt中；

**两种构建方式:**
内部构建(in-source build)【不推荐使用】：内部构建会在同级目录下产生一大堆中间文件，这些中间文件并不是我们最终所需要的，和工程源文件放在一起会显得杂乱无章。
```
## 内部构建
# 在当前目录下，编译本目录的CMakeLists.txt，生成Makefile和其他文件
cmake .
# 执行make命令，生成target
make
```
外部构建(out-of-source build)【推荐使用】：将编译输出文件与源文件放到不同目录中
```
## 外部构建
# 1. 在当前目录下，创建build文件夹
mkdir build 
# 2. 进入到build文件夹
cd build
# 3. 编译上级目录的CMakeLists.txt，生成Makefile和其他文件
cmake ..
# 4. 执行make命令，生成target
make
```



# 2 实例
## 2.1 实例1
helloworld.cpp:
```
#include <iostream>
using namespace std;

int main(int argc, char **argv)
{
    cout << "Hello World!" << endl;
    return 0;
}
```
CMakeLists.txt：
```
cmake_minimum_required(VERSION 3.0) 

project(HELLOWORLD)

add_executable(helloWorld_cmake helloworld.cpp) # 等价于g++ helloworld.cpp -o helloWorld_cmake
```



### 内部构建（in source build）


cmake
```
cmake .
-- The C compiler identification is GNU 9.4.0
-- The CXX compiler identification is GNU 9.4.0
-- Check for working C compiler: /usr/bin/cc
-- Check for working C compiler: /usr/bin/cc -- works
-- Detecting C compiler ABI info
-- Detecting C compiler ABI info - done
-- Detecting C compile features
-- Detecting C compile features - done   #检查c和c++语言编译器
-- Check for working CXX compiler: /usr/bin/c++
-- Check for working CXX compiler: /usr/bin/c++ -- works
-- Detecting CXX compiler ABI info
-- Detecting CXX compiler ABI info - done
-- Detecting CXX compile features
-- Detecting CXX compile features - done
-- Configuring done
-- Generating done
-- Build files have been written to: /home/ubuntu1/projects/test_c++/test2/Class_5/5.3.1 helloWorld
```
cmake命令生成了四个个文件：
```
CMakeCache.txt  
CMakeFiles  
cmake_install.cmake   
# 初学者不需要管上面三个文件
Makefile
```
make:
```
make
Scanning dependencies of target helloWorld_cmake
[50%] Building CXX object CMakeFiles/helloWorld_cmake.dir/helloworld.cpp.o  # 正在生成.o文件
[100%] Linking CXX executable helloWorld_cmake    # 连接
[100%] Built target helloWorld_cmake
```
make命令生成了可执行文件helloWorld_cmake


### 外部构建（out of source）【推荐】

```
mkdir build
cd build
cmake ..
make

```
外部构建就是将cmake生成的中间文件、Makefile和可执行文件都放在build目录中了。


## 2.2 实例2
实例2的目录结构如下所示：
```
tree .   # tree .命令获取当前目录的结构
.
├── CMakeLists.txt
├── include
│   └── swap.h
├── main.cpp
└── src
    └── swap.cpp
```
main.cpp:
```
#include "swap.h"

int main(int argc, char **argv)
{
    swap myswap(10, 20);
    std::cout << "Before swap:" << std::endl;
    myswap.printInfo();
    myswap.run();
    std::cout << "After  swap:" << std::endl;
    myswap.printInfo();

    return 0;

}
```
swap.h:
```
#pragma once   # 用于防止头文件的重复包含
#include <iostream>

class swap
{
public:
    swap(int a, int b){
        this->_a = a;
        this->_b = b;
    }
    void run();
    void printInfo();
private:
    int _a;
    int _b;
};
```
swap.cpp:
```
#include "swap.h"

void swap::run()
{
    int temp;
    temp  = _a;
    _a = _b;
    _b = temp;
}

void swap::printInfo()
{
    std::cout << "_a = " << _a << std::endl;
    std::cout << "_b = " << _b << std::endl;
}
```
CMakeLists.txt:
```
cmake_minimum_required(VERSION 3.0)

project(SWAP)

include_directories(include)  # 等价于-I include

add_executable(main_cmake main.cpp src/swap.cpp)
```
编译：
```
mkdir build
cd build
cmake ..
make

```







# 3  CMakeLists.txt文件学习
## 3.1 实例一

CMakeLists.txt:
```
cmake_minimum_required(VERSION 3.0)

project(SOLIDERFIRE)                             # 项目名为SOLIDERFIRE

set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wall")  # -Wall：输出警告的信息
                                                 # "${CMAKE_CXX_FLAGS} -Wall"表示在原有的CMAKE_CXX_FLAGS后添加-Wall

set(CMAKE_BUILD_TYPE Debug)    # 让输出的可执行文件是可debug的

include_directories(${CMAKE_SOURCE_DIR}/include)

add_executable(my_cmake_exe main.cpp src/Gun.cpp src/Solider.cpp)  # 对main.cpp、src/Gun.cpp和src/Solider.cpp三个cpp文件进行编译
```


## 3.2 实例2
```
cmake_minimum_required(VERSION 3.0)

set(SOURCE_FILES main.c)

project(TEST2)                             # 项目名为SOLIDERFIRE

set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wall")  # -Wall：输出警告的信息
# "${CMAKE_CXX_FLAGS} -Wall"表示在原有的CMAKE_CXX_FLAGS后添加-Wall

set(CMAKE_BUILD_TYPE Debug)    # 让输出的可执行文件是可debug的

include_directories(${CMAKE_SOURCE_DIR}/ffmpeg/include)

link_directories(
		${CMAKE_SOURCE_DIR}/ffmpeg/lib/    # CMakeLists.txt中似乎不需要-l用来指定编译时具体需要什么库
)

add_executable(my_cmake_exe avframe.c avpacket.c  main.c )  # 对avframe.c avpacket.c  main.c 三个cpp文件进行编译

target_link_libraries(my_cmake_exe avcodec avutil m) # 指定运行时需要连接的库
```


## 3.3 实例三
可以对下面实例中，不懂的函数或变量进行百度，并进行注释，从而达到学习的目的。【现在懒得学，以后再说吧。】
```
cmake_minimum_required(VERSION 2.6)
project(pro)
add_definitions(-std=c++11)  # CmakeList支持c++11的方式有两种：
                             # SET(CMAKE_CXX_FLAGS "-std=c++11")
                             # add_definitions(-std=c++11)

option(CUDA_USE_STATIC_CUDA_RUNTIME OFF)
set(CMAKE_CXX_STANDARD 11)
set(CMAKE_BUILD_TYPE Debug)
set(EXECUTABLE_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/workspace)

# 如果你是不同显卡，请设置为显卡对应的号码参考这里：https://developer.nvidia.com/zh-cn/cuda-gpus#compute
set(CUDA_GEN_CODE "-gencode=arch=compute_75,code=sm_75")

# 如果你的opencv找不到，可以自己指定目录
set(OpenCV_DIR   "/data/datav/expstation/lean/opencv4.2.0/lib/cmake/opencv4/")

set(CUDA_DIR     "/data/sxai/lean/cuda-10.2")
set(CUDNN_DIR    "/data/sxai/lean/cudnn8.2.2.26")
set(TENSORRT_DIR "/data/sxai/lean/TensorRT-8.0.1.6-cuda10.2-cudnn8.2")

# set(CUDA_DIR     "/data/sxai/lean/cuda-10.2")
# set(CUDNN_DIR    "/data/sxai/lean/cudnn7.6.5.32-cuda10.2")
# set(TENSORRT_DIR "/data/sxai/lean/TensorRT-7.0.0.11")

# set(CUDA_DIR     "/data/sxai/lean/cuda-11.1")
# set(CUDNN_DIR    "/data/sxai/lean/cudnn8.2.2.26")
# set(TENSORRT_DIR "/data/sxai/lean/TensorRT-7.2.1.6")

find_package(CUDA REQUIRED)
find_package(OpenCV)

include_directories(
    ${PROJECT_SOURCE_DIR}/src
    ${OpenCV_INCLUDE_DIRS}
    ${CUDA_DIR}/include
    ${TENSORRT_DIR}/include
    ${CUDNN_DIR}/include
)

# 切记，protobuf的lib目录一定要比tensorRT目录前面，因为tensorRTlib下带有protobuf的so文件
# 这可能带来错误
link_directories(
    ${TENSORRT_DIR}/lib
    ${CUDA_DIR}/lib64
    ${CUDNN_DIR}/lib
)

set(CMAKE_CXX_FLAGS  "${CMAKE_CXX_FLAGS} -std=c++11 -Wall -O0 -Wfatal-errors -pthread -w -g")
set(CUDA_NVCC_FLAGS "${CUDA_NVCC_FLAGS} -std=c++11 -O0 -Xcompiler -fPIC -g -w ${CUDA_GEN_CODE}")
file(GLOB_RECURSE cpp_srcs ${PROJECT_SOURCE_DIR}/src/*.cpp)
file(GLOB_RECURSE c_srcs ${PROJECT_SOURCE_DIR}/src/*.c)
file(GLOB_RECURSE cuda_srcs ${PROJECT_SOURCE_DIR}/src/*.cu)
cuda_add_library(cucodes SHARED ${cuda_srcs})

add_executable(pro ${cpp_srcs} ${c_srcs})

# 如果提示插件找不到，请使用dlopen(xxx.so, NOW)的方式手动加载可以解决插件找不到问题
target_link_libraries(cucodes nvinfer nvonnxparser)
target_link_libraries(cucodes cuda cublas cudart cudnn)
target_link_libraries(pro ${OpenCV_LIBS})
target_link_libraries(pro cucodes)

add_custom_target(
    run
    DEPENDS pro
    WORKING_DIRECTORY ${PROJECT_SOURCE_DIR}/workspace
    COMMAND ./pro
)
```


gcc中的-Wl,-rpath对应于cmake中的哪个东西？？

参考：https://www.bilibili.com/video/BV1fy4y1b7TC、微信公众号：VSCode、bilibili ：xiaobing1016
]]></description></item><item><title>vscode中配置C/C++调试环境（launch.json和tasks.json）</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/08/16459417.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Fri, 08 Jul 2022 11:09:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/08/16459417.html</guid><description><![CDATA[# launch.json和tasks.json
## launch.json


launch.json中存放运行或者调试可执行文件时的配置：
```
{
    // Use IntelliSense to learn about possible attributes.
    // Hover to view descriptions of existing attributes.
    // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387
    "version": "0.2.0",
    "configurations": [
        {
            "name": "g++.exe build and debug active file",
            "type": "cppdbg",
            "request": "launch",
            "program": "${fileDirname}\\${fileBasenameNoExtension}",
            "args": [],
            "stopAtEntry": false,
            "cwd": "${workspaceFolder}",
            "environment": [],
            "externalConsole": false,
            "MIMode": "gdb",
            "miDebuggerPath": "/usr/bin/gdb",
            "setupCommands": [
                {
                    "description": "为 gdb 启用整齐打印",
                    "text": "-enable-pretty-printing",
                    "ignoreFailures": true
                }
            ],
            "preLaunchTask": "g++.exe build active file"
        }
    ]
}
```
首先使用cmake和make生成可调试的可执行文件，在launch.json中的program字段设置可执行文件所在位置，如设置program为：
```
"program": "${workspaceFolder}/build/my_cmake_exe"
// ${workspaceFolder}/build/my_cmake_exe代表在当前目录下的build文件夹中的可执行文件my_cmake_exe，是一个绝对路径。
```
配置好launch.json文件，我们就可以通过vscode的调试菜单对可执行文件进行调试了。


## tasks.json

tasks.json中存放生成可执行文件的命令：
```
{
    "version": "2.0.0",
    "options": {
        "cwd": "${workspaceFolder}/build"   // 进入本项目目录下的build文件夹下
    },
    "tasks": [
        {
            "type": "shell",
            "label": "cmake",          // 名字
            "command": "cmake",        // 执行cmake命令，参数为..
            "args": [
                ".."
            ]
        },
        {
            "label": "make",
            "group": {            // 不知道有什么用？
                "kind": "build",
                "isDefault": true
            },
            "command": "make",
            "args": [

            ]
        },
        {
            "label": "Build",
            "dependsOrder": "sequence", // 按列出的顺序执行任务依赖项
            "dependsOn":[
                "cmake",
                "make"
            ]
        }
    ]

}
```
在tasks.json中建立了三个任务，分别为Build、cmake和make，其中Build依赖cmake和make。Build任务的含义为：使用cmake和make生成可执行文件。
我们可以将launch.json中的preLaunchTask设置为"preLaunchTask": "Build"，那么在使用launch.json进行调试前，会先执行Build的任务。



launch.json和tasks.json的其他字段？？
]]></description></item><item><title>H264</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/07/16454807.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Thu, 07 Jul 2022 07:19:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/07/16454807.html</guid><description><![CDATA[264和265区别就是后者更高压缩比、占空间小、编码解码更消耗资源，但是现在新的设备对h265做了硬件优化。]]></description></item><item><title>FFmpeg编程入门</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/05/16448954.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Tue, 05 Jul 2022 14:48:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/05/16448954.html</guid><description><![CDATA[# 0.源码编译安装ffmpeg

建议安装4.19版本，因为其他版本没有暂时函数说明文档。
建议直接参考这篇文章[ubuntu20源码编译安装ffmpeg](https://blog.csdn.net/H_Zhang/article/details/123684216)，这篇文档进行的是最简单的安装。如果按照[官方按照教程](https://trac.ffmpeg.org/wiki/CompilationGuide)进行按照可能会由于依赖问题，而无法使用。

如果参考[官方安装教程](https://trac.ffmpeg.org/wiki/CompilationGuide/Ubuntu)进行源码安装。在按照官方安装教程进行安装的时候，需要安装各种库，可以使用命令sudo apt-get install安装库，就尽量使用sudo apt-get install来安装。有些不能使用sudo apt-get install安装的库，就使用教程中的源码编译方式进行安装。


源码安装以后，会生成四个目录，分别为bin、include、lib和share。我们可以将include和lib拷贝到本系统的任何位置进行使用。从share可以学习到ffmpeg的使用实例，可以通过学习这些实例，从而进行进阶学习。

在设置ffmpeg安装配置时，有些库如果你安装失败了或者没有安装，请记得不要在./configure中对这些库进行enable，如：你没有安装库libaom，就要去掉 --enable-libaom。

在安装完ffmpeg后，你需要添加并enable一些库，怎么办？
答：我觉得只能下载这些库，然后重新对ffmpeg进行配置和编译。

参考：[链接](https://www.cnblogs.com/phillee/p/14605815.html)


## 0.1 简单的程序测试
### 0.1.1 c程序测试
测试程序test.c：
```
#include <stdio.h>
 #include "libavutil/avutil.h"
 int main(){
    printf("Hello FFMPEG, version is %s\n", av_version_info());
    return 0;
 }
```
编译和运行：
```
gcc test.c -o test -I /home/ubuntu1/ffmpeg_build/include -L /home/ubuntu1/ffmpeg_build/lib/ -l avutil   # avutil是静态库，所以不需要选项-Wl,-rpath
./test
Hello FFMPEG, version is N-107317-g85bc6b5abf
```


### 0.1.2 c++程序测试
由于 FFmpeg 是用C99标准写成的，有些功能在 C++ 中可能无法直接编译或者使用。
所以需要使用extern "C"显示声明头文件为C格式文件。
测试程序test.cpp：
```
#include <stdio.h>
extern "C" {
#include "libavutil/avutil.h"
}
int main(){
    printf("Hello FFMPEG, version is %s\n", av_version_info());
    return 0;
}
```
编译和运行：
```
g++ test.cpp -o test -I /home/ubuntu1/ffmpeg_build/include -L /home/ubuntu1/ffmpeg_build/lib/ -l avutil -D__STDC_CONSTANT_MACROS   # 没加-D__STDC_CONSTANT_MACROS时，如果不出错，就不加了。
./test
Hello FFMPEG, version is N-107317-g85bc6b5abf
```







# 1 播放器框架
![](https://img2022.cnblogs.com/blog/1617829/202207/1617829-20220705221027151-778735221.png)

图中其实涉及三个数据结构，分别为AVFormatContext、AVPacket和AVFrame。我对这三个数据结构的理解如下：
AVFormatContext可以当成是整个媒体文件，可以从中取出视频流、音频流和字幕流等信息。
而每个流都是由一个一个packet组成的，每个packet使用AVPacket数据结构进行保存。
由于流一般都是被压缩的数据，故AVPacket也是被压缩的数据，AVPacket经过解压就生成了原始数据帧AVFrame


# 2 常用音视频术语
• 容器／文件（Conainer/File）：即特定格式的多媒体文件，比如mp4、flv、mkv等。
• 媒体流（Stream）：表示时间轴上的一段连续数据，如一段声音数据、一段视频数据或一段字幕数据，可以是压缩的，也可以是非压缩的，压缩的数据需要关联特定的编解码器（有些码流音频他是纯PCM，视频流一般不会是未压缩的YUV格式）。
• 数据帧／数据包（Frame/Packet）：通常，一个媒体流是由大量的数据帧组成的，对于压缩数据，帧对应着编解码器的最小处理单元，分属于不同媒体流的数据帧交错存储于容器之中。
• 编解码器：编解码器是以帧为单位实现压缩数据和原始数据之间的相互转换的

# 3 FFmpeg库简介
FFMPEG有8个常用库：
• AVUtil：核心工具库，下面的许多其他模块都会依赖该库做一些基本的音视频处理操作。
• AVFormat：文件格式和协议库，该模块是最重要的模块之一，封装了Protocol层和Demuxer、Muxer层，使得协议和格式对于开发者来说是透明的。
• AVCodec：编解码库，封装了Codec层，但是有一些Codec是具备自己的License的，FFmpeg是不会默认添加像libx264、FDK-AAC等库的，但是FFmpeg就像一个平台一样，可以将其他的第三方的Codec以插件的方式添加进来，然后为开发者提供统一的接口。
• AVFilter：音视频滤镜库，该模块提供了包括音频特效和视频特效的处理，在使用FFmpeg的API进行编解码的过程中，直接使用该模块为音视频数据做特效处理是非常方便同时也非常高效的一种方式。
• AVDevice：输入输出设备库，比如，需要编译出播放声音或者视频的工具ffplay，就需要确保该模块是打开的，同时也需要SDL的预先编译，因为该设备模块播放声音与播放视频使用的都是SDL库。
• SwrRessample：该模块可用于音频重采样，可以对数字音频进行声道数、数据格式、采样率等多种基本信息的转换。
• SWScale：该模块是将图像进行格式转换的模块，比如，可以将YUV的数据转换为RGB的数据，缩放尺寸由1280*720变为800*480。 
• PostProc：该模块可用于进行后期处理，当我们使用AVFilter的时候需要打开该模块的开关，因为Filter中会使用到该模块的一些基础函数

# 4 FFmpeg函数简介
◼ av_register_all()：注册所有组件,4.0已经弃用
◼ avdevice_register_all()对设备进行注册，比如V4L2等。
◼ avformat_network_init();初始化网络库以及网络加密协议相关的库（比如openssl）

# 4.1 封装格式相关
◼ avformat_alloc_context();负责申请一个AVFormatContext结构的内存,并进行简单初始化
◼ avformat_free_context();释放该结构里的所有东西以及该结构本身
◼ avformat_close_input();关闭解复用器。关闭后就不再需要使用avformat_free_context 进行释放。
◼ avformat_open_input();打开输入视频文件
◼ avformat_find_stream_info()：获取音视频文件信息
◼ av_read_frame(); 读取音视频包
◼ avformat_seek_file(); 定位文件，就是起到拉动进度条的作用
◼ av_seek_frame():定位文件

调用流程：
![](https://img2022.cnblogs.com/blog/1617829/202207/1617829-20220705222645225-287401976.png)

# 4.2 解码器相关
• avcodec_alloc_context3(): 分配解码器上下文
• avcodec_find_decoder()：根据ID查找解码器，就是告诉它你要什么解码器，比如你可以告诉它你需要h264解码器
• avcodec_find_decoder_by_name():根据解码器名字，它知道了你需要h264解码器，它还需要知道你需要哪个h264解码器（h264解码器有多个）。不使用avcodec_find_decoder_by_name()时，直接使用第一个h264解码器。
• avcodec_open2()： 打开编解码器
• avcodec_decode_video2()：解码一帧视频数据【不建议使用】
• avcodec_decode_audio4()：解码一帧音频数据【不建议使用】
• avcodec_send_packet(): 发送编码数据包
• avcodec_receive_frame(): 接收解码后数据
• avcodec_free_context():释放解码器上下文，包含了avcodec_close()
• avcodec_close():关闭解码器

解码流程：
![](https://img2022.cnblogs.com/blog/1617829/202207/1617829-20220705224633633-1869952147.png)

# 5 组件注册方式
## 5.1 FFmpeg 3.x 组件注册方式
我们使用ffmpeg，首先要执行av_register_all，把全局的解码器、编码器等结构体注册到各自全局的对象链表里，以便后面查找调用。一个av_register_all函数，做了以下工作：
![](https://img2022.cnblogs.com/blog/1617829/202207/1617829-20220706140056967-1384372148.png)

虽然在FFmpeg 4.x以上的版本没有av_register_all，但是其内部也是经过了上面的注册操作。


## 5.2 Ffmpeg 4.0.2 组件注册方式
av_register_all操作是FFmepg内部去做，不需要用户调用av_register_all去注册。
以codec编解码器为例：
1. 在configure的时候生成要注册的组件
./configure:7203:print_enabled_components libavcodec/codec_list.c 
AVCodec codec_list $CODEC_LIST
这里会生成一个codec_list.c 文件，里面只有static const AVCodec* const codec_list[]数组。
2. 在libavcodec/allcodecs.c将static const AVCodec * const codec_list[]的编解码器用链表的方式组织起来。

对于demuxer/muxer（解复用器，也称容器）则对应：

3. libavformat/muxer_list.c
libavformat/demuxer_list.c 这两个文件也是在configure的时候生成，也就是说直接下载源码是没有这两个文件的。
4. 在libavformat/allformats.c将demuxer_list[]和muexr_list[]以链表的方式组织。
其他组件也是类似的方式。
  
# 6.FFmpeg数据结构简介
AVFormatContext：封装格式上下文结构体，也是统领全局的结构体，保存了视频文件封装格式相关信息。
AVInputFormat demuxer：每种封装格式（例如FLV, MKV, MP4, AVI）对应一个该结构体。
AVOutputFormat muxer
AVStream：视频文件中每个视频（音频）流对应一个该结构体。
AVCodecContext：编解码器上下文结构体，保存了视频（音频）编解码相关信息。
AVCodec：每种视频（音频）编解码器(例如H.264解码器)对应一个该结构体。
AVPacket：存储一帧压缩编码数据。AVPacket 里面也有一个index的字段，通过index就可以区分出不同的码流。
AVFrame：存储一帧解码后像素（采样）数据。

**FFmpeg数据结构之间的关系：**
![](https://img2022.cnblogs.com/blog/1617829/202207/1617829-20220706141810676-1397601431.png)
将音视频包装成AVFormatContext结构的数据，通过访问streams就相当于访问了音视频。音视频中可能存在各种流，通过访问streams就可以得到这些流，然后通过avformat_find_stream_info()获取流的编解码信息。通过avcodec_parameters_to_context()将编解码信息拷贝到上下文AVCodecContext中取。

**AVPacket和AVFrame之间的关系：**
![](https://img2022.cnblogs.com/blog/1617829/202207/1617829-20220706143034067-1488084908.png)
  
**FFmpeg数据结构分析：**
◼ AVFormatContext
• iformat：输入媒体的AVInputFormat，比如指向AVInputFormat ff_flv_demuxer
• nb_streams：输入媒体的AVStream 个数
• streams：输入媒体的AVStream []数组，数组的每一个元素都是一个流。
• duration：输入媒体的时长（以微秒为单位），计算方式可以参考av_dump_format()函数。
• bit_rate：输入媒体的码率
◼ AVInputFormat
• name：封装格式名称
• extensions：封装格式的扩展名
• id：封装格式ID
• 一些封装格式处理的接口函数,比如read_packet()
◼ AVStream
• index：标识该视频/音频流
• time_base：该流的时基，PTS*time_base=真正的时间（秒）
• avg_frame_rate： 该流的帧率
• duration：该视频/音频流长度
• codecpar：编解码器参数属性
◼ AVCodecParameters
• codec_type：媒体类型，比如AVMEDIA_TYPE_VIDEO AVMEDIA_TYPE_AUDIO等
• codec_id：编解码器类型， 比如AV_CODEC_ID_H264 AV_CODEC_ID_AAC等。
◼ AVCodecContext
• codec：编解码器的AVCodec，比如指向AVCodec 
ff_aac_latm_decoder
• width, height：图像的宽高（只针对视频）
• pix_fmt：像素格式（只针对视频）
• sample_rate：采样率（只针对音频）
• channels：声道数（只针对音频）
• sample_fmt：采样格式（只针对音频）
◼ AVCodec
• name：编解码器名称
• type：编解码器类型
• id：编解码器ID
• 一些编解码的接口函数，比如int (*decode)()
◼AVPacket
• pts：显示时间戳
• dts：解码时间戳
• data：压缩编码数据
• size：压缩编码数据大小
• pos:数据的偏移地址
• stream_index：所属的AVStream
◼AVFrame
• data：解码后的图像像素数据（音频采样数据）
• linesize：对视频来说是图像中一行像素的大小；对音频来说是整个音频帧的大小
• width, height：图像的宽高（只针对视频）
• key_frame：是否为关键帧（只针对视频） 。 • pict_type：帧类型（只针对视频） 。例如I， P， B • sample_rate：音频采样率（只针对音频）
• nb_samples：音频每通道采样数（只针对音频）
• pts：显示时间戳


# 7 AVPacket与AVFrame
从下图我们就可以大概看出AVPacket和AVFrame是个什么东西。

![](https://img2022.cnblogs.com/blog/1617829/202207/1617829-20220706153222145-2046250505.png)

AVPacket结构体中有一个AVBufferRef指针，AVBufferRef结构体中有一个AVBuffer指针，AVBuffer指针指向真正的音视频数据。

**AVPacket常用API：**
|   函数原型   |    说明   |    
| ---- | ---- | 
|    AVPacket *av_packet_alloc(void);   |    分配AVPacket。这里没有让AVBuffer指向某一块内存，应该相当于创建一个空的AVPacket  |  
|void av_packet_free(AVPacket **pkt); | 释放AVPacket |
|void av_init_packet(AVPacket *pkt);| 初始化AVPacket，只做了一些简单的初始化操作，没有进行内存分配操作 |
|int av_new_packet(AVPacket *pkt, int size);|引用计数初始化为1，AVBuffer指向某块内存。AVBuffer指向的内存，此内存可能被其他AVBuffer所指向，有多少个AVBuffer指向这一个内存，引用计数就是多少|
|int av_packet_ref(AVPacket *dst, const AVPacket *src);|dst的AVBuffer指向src的AVBuffer所指向的内存，也就是两个指针都指向同一个内存，此时增加此内存的引用计数|
|void av_packet_unref(AVPacket *pkt); |pkt的AVBuffer不再指向内存，此时此内存的引用计数减一|
|void av_packet_move_ref(AVPacket *dst, AVPacket *src); |转移引用计数，即dst继承src的所有东西，然后将src的AVBufferRef置空|
|AVPacket *av_packet_clone(const AVPacket *src); |创建一块新的内存，将src内容拷贝进去|



**AVFrame与AVPacket类似，AVFrame常用API：**
|    函数原型  |  说明    |    
| ---- | ---- | 
|  AVFrame *av_frame_alloc(void);   |   分配AVFrame   |  
|void av_frame_free(AVFrame **frame); |释放AVFrame|
|int av_frame_ref(AVFrame *dst, const AVFrame *src); |增加引用计数|
|void av_frame_unref(AVFrame *frame);|减少引用计数|
|void av_frame_move_ref(AVFrame *dst, AVFrame *src);|转移引用计数|
|int av_frame_get_buffer(AVFrame *frame, int align);|根据AVFrame分配内存|
|AVFrame *av_frame_clone(const AVFrame *src);|等于av_frame_alloc()+av_frame_ref()|
 
## 7.1 AVPacket和AVFrame的测试程序
本测试程序测试了常见的内存泄漏等问题。

目录结构：
```
├── avframe.c
├── avframe.h
├── avpacket.c
├── avpacket.h
└── main.c
```
main.c：
```
#include <stdio.h>
#include "avpacket.h"
#include "avframe.h"
int main()
{
    printf("Hello World!\n");
   av_packet_test();
    // av_frame_test();
    return 0;
}
```
avpacket.h:
```
#ifndef AVPACKET_H
#define AVPACKET_H

#include "libavcodec/avcodec.h"
#include "libavutil/frame.h"

/*
//简单的创建一个AVPacket，将其字段设为默认值（data为空，没有数据缓存空间），data的指针需要另外去赋值。
AVPacket *av_packet_alloc(void);

int av_new_packet(AVPacket *pkt, int size);
//释放使用av_packet_alloc创建的AVPacket，如果该Packet有引用计数（packet->buf不为空），则先调用av_packet_unref(&packet)。
//只有当引用计数为0时，才会在调用av_packet_free()时释放data的缓存。
void av_packet_free(AVPacket **pkt);
// 初始化packet的值为默认值，该函数不会影响buffer引用的数据缓存空间和size，需要单独处理。AVPacket中的buf为空。
// 比如 av_get_packet里调用av_init_packet
void av_init_packet(AVPacket *pkt);

// 使用引用计数的浅拷贝
// 该函数会先拷贝所有非缓存类数据，然后创建一个src->buf的新的引用计数。如果src已经设置了引用计数发（src->buf不为空），则直接将其引用计数+1；
// 如果src没有设置引用计数（src->buf为空），则为dst创建一个新的引用计数buf，并复制src->data到buf->buffer中。
// 最后，复制src的其他字段到dst中。所以av_packet_ref()是将2个AVPacket共用一个缓存的。
int av_packet_ref(AVPacket *dst, const AVPacket *src);

// 使用引用计数清理数据
// 将缓存空间的引用计数-1，并将Packet中的其他字段设为初始值。如果引用计数为0，自动的释放缓存空间。
void av_packet_unref(AVPacket *pkt);

// 把src整个结构体直接赋值给dst，所以引用计数没有发生变化，并且src被av_init_packet重置
void av_packet_move_ref(AVPacket *dst, AVPacket *src);

//其功能是 av_packet_alloc() + av_packet_ref()；
//先创建一个新的AVPacket，然后再进行计数引用+数据拷贝，使得新的AVPacket指向老的AVPacket同一个data。
AVPacket *av_packet_clone(const AVPacket *src);
*/


void av_packet_test();
#endif // AVPACKET_H
```
avpacket.c:
```
#include "avpacket.h"

#define MEM_ITEM_SIZE (20 * 1024 * 102)
#define AVPACKET_LOOP_COUNT 1000
// 测试 内存泄漏
/**
 * @brief 测试av_packet_alloc和av_packet_free的配对使用
 */
void av_packet_test1()
{
    AVPacket *pkt = NULL;
    int ret = 0;

    pkt = av_packet_alloc();
    ret = av_new_packet(pkt, MEM_ITEM_SIZE); // 引用计数初始化为1
    memccpy(pkt->data, (void *)&av_packet_test1, 1, MEM_ITEM_SIZE);
    av_packet_unref(pkt); // 要不要调用。调用av_packet_free，就不需要调用av_packet_unref，因为av_packet_free内部调用了av_packet_unref。但是重复调用也没事，因为av_packet_unref中处理了重复调用的情况
    av_packet_free(&pkt); // 如果不free将会发生内存泄漏,内部调用了 av_packet_unref
}

/**
 * @brief 测试误用av_init_packet将会导致内存泄漏
 */
void av_packet_test2()
{
    AVPacket *pkt = NULL;
    int ret = 0;

    pkt = av_packet_alloc();
    ret = av_new_packet(pkt, MEM_ITEM_SIZE);
    memccpy(pkt->data, (void *)&av_packet_test1, 1, MEM_ITEM_SIZE);
    //    av_init_packet(pkt);        // 这个时候init就会导致内存无法释放。为什么调用av_init_packet，就无法使用 av_packet_free释放内存??
                                        // 答：我觉得：av_init_packet(pkt)将pkt中的buf指向空，但pkt中buf指向的那一块内存还没释放，从而导致了内存泄漏
    av_packet_free(&pkt);
}

/**
 * @brief 测试av_packet_move_ref后，可以av_init_packet
 */
void av_packet_test3()
{
    AVPacket *pkt = NULL;
    AVPacket *pkt2 = NULL;
    int ret = 0;

    pkt = av_packet_alloc();
    ret = av_new_packet(pkt, MEM_ITEM_SIZE);
    memccpy(pkt->data, (void *)&av_packet_test1, 1, MEM_ITEM_SIZE);
    pkt2 = av_packet_alloc();      // 必须先alloc
    av_packet_move_ref(pkt2, pkt); //内部其实也调用了av_init_packet
    av_init_packet(pkt);
    av_packet_free(&pkt); // test2中无法在av_init_packet之后调用av_packet_free，这里为什么又可以了？？
                          // 答：这里pkt中buf指向的内存，由pkt2的buf接管，可以通过pkt2的buf对内存进行释放。【内存泄漏：有内存空间没有释放】
    av_packet_free(&pkt2);
}
/**
 * @brief 测试av_packet_clone
 */
void av_packet_test4()
{
    AVPacket *pkt = NULL;
    // av_packet_alloc()没有必要，因为av_packet_clone内部有调用 av_packet_alloc
    AVPacket *pkt2 = NULL;
    int ret = 0;

    pkt = av_packet_alloc();
    ret = av_new_packet(pkt, MEM_ITEM_SIZE);
    memccpy(pkt->data, (void *)&av_packet_test1, 1, MEM_ITEM_SIZE);
    pkt2 = av_packet_clone(pkt); // av_packet_alloc()+av_packet_ref()
    av_init_packet(pkt);
    av_packet_free(&pkt);
    av_packet_free(&pkt2);
}

/**
 * @brief 多次调用av_packet_ref导致的内存泄漏
 */
void av_packet_test5()
{
    AVPacket *pkt = NULL;
    AVPacket *pkt2 = NULL;
    int ret = 0;

    pkt = av_packet_alloc(); //
    if (pkt->buf)            // 打印referenc-counted，必须保证传入的是有效指针
    {
        printf("%s(%d) ref_count(pkt) = %d\n", __FUNCTION__, __LINE__,
               av_buffer_get_ref_count(pkt->buf));
    }

    ret = av_new_packet(pkt, MEM_ITEM_SIZE);
    if (pkt->buf) // 打印referenc-counted，必须保证传入的是有效指针
    {
        printf("%s(%d) ref_count(pkt) = %d\n", __FUNCTION__, __LINE__,
               av_buffer_get_ref_count(pkt->buf));
    }
    memccpy(pkt->data, (void *)&av_packet_test1, 1, MEM_ITEM_SIZE);

    pkt2 = av_packet_alloc();      // 必须先alloc
    av_packet_move_ref(pkt2, pkt); // av_packet_move_ref
                                   //    av_init_packet(pkt);  //av_packet_move_ref

    av_packet_ref(pkt, pkt2);
    av_packet_ref(pkt, pkt2); // 多次ref如果没有对应多次unref将会内存泄漏。现在此内存的引用计数为3
    if (pkt->buf)             // 打印referenc-counted，必须保证传入的是有效指针
    {
        printf("%s(%d) ref_count(pkt) = %d\n", __FUNCTION__, __LINE__,
               av_buffer_get_ref_count(pkt->buf));
    }
    if (pkt2->buf) // 打印referenc-counted，必须保证传入的是有效指针
    {
        printf("%s(%d) ref_count(pkt) = %d\n", __FUNCTION__, __LINE__,
               av_buffer_get_ref_count(pkt2->buf));
    }
    av_packet_unref(pkt); // 现在引用计数为2
    av_packet_unref(pkt); // 由于pkt的buf已经在前面使用了av_packet_unref(pkt)进行置空，所以再使用一次av_packet_unref(pkt)，将不起到任何作用。内存的引用次数还是2
    if (pkt->buf)
        printf("pkt->buf没有被置NULL\n");
    else
        printf("pkt->buf已经被置NULL\n");
    if (pkt2->buf) // 打印referenc-counted，必须保证传入的是有效指针
    {
        printf("%s(%d) ref_count(pkt) = %d\n", __FUNCTION__, __LINE__,
               av_buffer_get_ref_count(pkt2->buf)); // 为2
    }
    av_packet_unref(pkt2);  // 内存的引用次数为1。由于内存的引用次数无法降低到零，从而导致内存无法释放，从而导致内存泄漏

    av_packet_free(&pkt);  
    av_packet_free(&pkt2);
}

/**
 * @brief 测试AVPacket整个结构体赋值, 和av_packet_move_ref类似
 */
void av_packet_test6()
{
    AVPacket *pkt = NULL;
    AVPacket *pkt2 = NULL;
    int ret = 0;

    pkt = av_packet_alloc();
    ret = av_new_packet(pkt, MEM_ITEM_SIZE);
    memccpy(pkt->data, (void *)&av_packet_test1, 1, MEM_ITEM_SIZE);

    pkt2 = av_packet_alloc(); // 必须先alloc
    *pkt2 = *pkt;             // 有点类似  pkt可以重新分配内存
    av_init_packet(pkt);

    av_packet_free(&pkt);
    av_packet_free(&pkt2);
}

void av_packet_test()
{
    av_packet_test1();
    //    av_packet_test2();
    //    av_packet_test3();
    //    av_packet_test4();
    //    av_packet_test5();
    // av_packet_test6();
}
```
avframe.h:
```
#ifndef AVFRAME_H
#define AVFRAME_H

#include "libavcodec/avcodec.h"

void av_frame_test();
#endif // AVFRAME_H
```

avframe.c:
```
#include "avframe.h"

#define MEM_ITEM_SIZE (20*1024*102)
#define AVPACKET_LOOP_COUNT 1000
// 测试 内存泄漏
void av_frame_test1()
{
    AVFrame *frame = NULL;
    int ret = 0;

    frame = av_frame_alloc();// 没有类似的AVPacket的av_new_packet的API
    // 1024 *2 * (16/8) =
    frame->nb_samples     = 1024;
    frame->format         = AV_SAMPLE_FMT_S16;//AV_SAMPLE_FMT_S16P AV_SAMPLE_FMT_S16
    frame->channel_layout = AV_CH_LAYOUT_STEREO;    //AV_CH_LAYOUT_MONO AV_CH_LAYOUT_STEREO
    ret = av_frame_get_buffer(frame, 0);    // 根据格式分配内存

    // 如果frame->format为AV_SAMPLE_FMT_S16P，这里P是平面的意思，如在双声道中，将两个声道的数据是分开存放的，一个声道存放在一个数组中。
    // 也就是说如果frame->format为AV_SAMPLE_FMT_S16P时，有几个声道，buf就有几个元素。如：双声道时，buf中就有两个元素，即buf[0]和buf[1]
    if(frame->buf && frame->buf[0])
        printf("%s(%d) 1 frame->buf[0]->size = %d\n", __FUNCTION__, __LINE__, frame->buf[0]->size);    //受frame->format等参数影响
    if(frame->buf && frame->buf[1])
        printf("%s(%d) 1 frame->buf[1]->size = %d\n", __FUNCTION__, __LINE__, frame->buf[1]->size);    //受frame->format等参数影响

    
    // 内存引用次数的实验
    if(frame->buf && frame->buf[0])        // 打印referenc-counted，必须保证传入的是有效指针
        printf("%s(%d) ref_count1(frame) = %d\n", __FUNCTION__, __LINE__, av_buffer_get_ref_count(frame->buf[0]));

    ret = av_frame_make_writable(frame);    // 当frame本身为空时不能make writable
    printf("av_frame_make_writable ret = %d\n", ret);

    if(frame->buf && frame->buf[0])        // 打印referenc-counted，必须保证传入的是有效指针
        printf("%s(%d) ref_count2(frame) = %d\n", __FUNCTION__, __LINE__, av_buffer_get_ref_count(frame->buf[0]));

    av_frame_unref(frame);
    if(frame->buf && frame->buf[0])        // 打印referenc-counted，必须保证传入的是有效指针
        printf("%s(%d) ref_count3(frame) = %d\n", __FUNCTION__, __LINE__, av_buffer_get_ref_count(frame->buf[0]));

    av_frame_free(&frame);
}


void av_frame_test()
{
    av_frame_test1();
}
```
















 
 
 
]]></description></item><item><title>对‘TIFFReadDirectory@LIBTIFF_4.0’未定义的引用</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/05/16445936.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Tue, 05 Jul 2022 04:00:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/05/16445936.html</guid><description><![CDATA[
在执行makefile文件时，出现如下错误：
```
/home/zwl/software/opencv4.2/lib/libopencv_imgcodecs.so：对‘TIFFReadDirectory@LIBTIFF_4.0’未定义的引用
/home/zwl/software/opencv4.2/lib/libopencv_imgcodecs.so：对‘TIFFWriteEncodedStrip@LIBTIFF_4.0’未定义的引用
/home/zwl/software/opencv4.2/lib/libopencv_imgcodecs.so：对‘TIFFIsTiled@LIBTIFF_4.0’未定义的引用
/home/zwl/software/opencv4.2/lib/libopencv_imgcodecs.so：对‘TIFFOpen@LIBTIFF_4.0’未定义的引用
/home/zwl/software/opencv4.2/lib/libopencv_imgcodecs.so：对‘TIFFReadEncodedStrip@LIBTIFF_4.0’未定义的引用
/home/zwl/software/opencv4.2/lib/libopencv_imgcodecs.so：对‘TIFFSetField@LIBTIFF_4.0’未定义的引用
/home/zwl/software/opencv4.2/lib/libopencv_imgcodecs.so：对‘TIFFWriteScanline@LIBTIFF_4.0’未定义的引用
/home/zwl/software/opencv4.2/lib/libopencv_imgcodecs.so：对‘TIFFGetField@LIBTIFF_4.0’未定义的引用
/home/zwl/software/opencv4.2/lib/libopencv_imgcodecs.so：对‘TIFFScanlineSize@LIBTIFF_4.0’未定义的引用
/home/zwl/software/opencv4.2/lib/libopencv_imgcodecs.so：对‘TIFFWriteDirectory@LIBTIFF_4.0’未定义的引用
/home/zwl/software/opencv4.2/lib/libopencv_imgcodecs.so：对‘TIFFSetWarningHandler@LIBTIFF_4.0’未定义的引用
/home/zwl/software/opencv4.2/lib/libopencv_imgcodecs.so：对‘TIFFSetErrorHandler@LIBTIFF_4.0’未定义的引用
/home/zwl/software/opencv4.2/lib/libopencv_imgcodecs.so：对‘TIFFReadEncodedTile@LIBTIFF_4.0’未定义的引用
/home/zwl/software/opencv4.2/lib/libopencv_imgcodecs.so：对‘TIFFReadRGBATile@LIBTIFF_4.0’未定义的引用
/home/zwl/software/opencv4.2/lib/libopencv_imgcodecs.so：对‘TIFFClose@LIBTIFF_4.0’未定义的引用
/home/zwl/software/opencv4.2/lib/libopencv_imgcodecs.so：对‘TIFFRGBAImageOK@LIBTIFF_4.0’未定义的引用
/home/zwl/software/opencv4.2/lib/libopencv_imgcodecs.so：对‘TIFFClientOpen@LIBTIFF_4.0’未定义的引用
/home/zwl/software/opencv4.2/lib/libopencv_imgcodecs.so：对‘TIFFReadRGBAStrip@LIBTIFF_4.0’未定义的引用
```
查找libopencv_imgcodecs.so的依赖：
```
ldd /home/zwl/software/opencv4.2/lib/libopencv_imgcodecs.so
        linux-vdso.so.1 (0x00007fff9c1f0000)
        libopencv_imgproc.so.4.2 => /home/zwl/software/opencv4.2/lib/libopencv_imgproc.so.4.2 (0x00007f1a4e0cc000)
        libjpeg.so.8 => /usr/lib/x86_64-linux-gnu/libjpeg.so.8 (0x00007f1a4de64000)
        libpng16.so.16 => /usr/lib/x86_64-linux-gnu/libpng16.so.16 (0x00007f1a4dc32000)
        libtiff.so.5 => /usr/lib/x86_64-linux-gnu/libtiff.so.5 (0x00007f1a4d9ba000)
        libopencv_core.so.4.2 => /home/zwl/software/opencv4.2/lib/libopencv_core.so.4.2 (0x00007f1a4d34f000)
        libz.so.1 => /lib/x86_64-linux-gnu/libz.so.1 (0x00007f1a4d132000)
        libstdc++.so.6 => /usr/lib/x86_64-linux-gnu/libstdc++.so.6 (0x00007f1a4cda9000)
        libm.so.6 => /lib/x86_64-linux-gnu/libm.so.6 (0x00007f1a4ca0b000)
        libgcc_s.so.1 => /lib/x86_64-linux-gnu/libgcc_s.so.1 (0x00007f1a4c7f3000)
        libpthread.so.0 => /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007f1a4c5d4000)
        libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f1a4c1e3000)
        liblzma.so.5 => /lib/x86_64-linux-gnu/liblzma.so.5 (0x00007f1a4bfbd000)
        libjbig.so.0 => /usr/lib/x86_64-linux-gnu/libjbig.so.0 (0x00007f1a4bdaf000)
        libdl.so.2 => /lib/x86_64-linux-gnu/libdl.so.2 (0x00007f1a4bbab000)
        librt.so.1 => /lib/x86_64-linux-gnu/librt.so.1 (0x00007f1a4b9a3000)
        /lib64/ld-linux-x86-64.so.2 (0x00007f1a4ee11000)
```
从libtiff.so.5 => /usr/lib/x86_64-linux-gnu/libtiff.so.5 (0x00007f1a4d9ba000)可看出：libopencv_imgcodecs.so依赖libtiff.so.5，且libtiff.so.5在目录 /usr/lib/x86_64-linux-gnu/下。
也就是说libopencv_imgcodecs.so库会去目录 /usr/lib/x86_64-linux-gnu/下查找依赖libtiff.so.5

然后我发现我用-L指定的目录$(python_path)/lib下也有库libtiff，这就是问题所在：
libopencv_imgcodecs.so首先会去目录$(python_path)/lib下查找库libtiff，然后就找到了libtiff，但是由于版本不一致，就会出现上面的错误。

解决方法：让libopencv_imgcodecs.so先去查找目录 /usr/lib/x86_64-linux-gnu/，而不是目录$(python_path)/lib，即在-L $(python_path)/lib前加上-L /usr/lib/x86_64-linux-gnu/，即：
-L /usr/lib/x86_64-linux-gnu/ -L $(python_path)/lib


出现以上错误，是由于版本不一致导致的。]]></description></item><item><title>30天英语口语训练</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/05/16445333.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Tue, 05 Jul 2022 01:59:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/05/16445333.html</guid><description><![CDATA[# PASSAGE 1: Success in Life
Success means different things for different people. Some may equate it with fame, some with wealth and still some with accomplishments. For me, it means fulfilling one's dreams. Whatever your dreams are, you have a goal there and then focus all your attention on it. 
Dreams bring you hope and happiness. In the process of struggling for it, you cry, sweat, complain or even curse, but the joy of harvesting makes you forget all the pains and troubles you have gone through. So an old proverb says that the sweetest fruit is one that has undergone the bitterest ordeal. 

There are several keys to success. First, your goal must be practical and 
practicable. If you set your goal too high, chances are that you will never 
attain it. Next, you have to make a plan of doing it. You can take some 
steps to realize it. Since the process is quite tough, you need to be 
diligent, patient and persevering.
Even if you meet with some difficulties or frustrations, just take them in 
your stride. You can always tell yourself that there is nothing 
insurmountable. With this will and determination, success is sure to wait 
for you at the end of the tunnel!

**笔记**
equate sth with sth = regard sth as sth
sense of accomplishment：成就感，sense of ……感
fulfill/relize/achieve one's dreams
无论……，whatever,whoever,wherever
spare no effort to do sth/spare no effort in doing sth 全力以赴做

what brings you here?
No sweat 对别人说自己不累，没关系；叫别人不用费事帮我去干嘛了。
'Many thanks.' — 'No sweat. Anything else?' 
'I'll get my purse out of the bedroom.' — 'No sweat, Mrs. Day. We can put it on your tab.'






# 其他
I promise 我保证
your speaking 口语
you have no idea ...你不知道
through thick and thin  经历苦难
I will go on loving James through thick and thin
]]></description></item><item><title>RTMP流媒体服务器</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/01/16435955.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Fri, 01 Jul 2022 12:55:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/01/16435955.html</guid><description><![CDATA[# 0.简介
服务器：SRS(Simple RTMP Server，⽀持RTMP、HTTP-FLV，HLS) 
推流端：ffmpeg + OBS 
拉流端：ffplay +VLC + srs播放器
推流：指的是将视频流推送出去
拉流：指的是将推流端推送出去的视频流拉去下来


# 1.SRS安装和学习
直接参考官方文档，官方文档写得很好：https://github.com/ossrs/srs/wiki/v4_CN_Home


# 
]]></description></item><item><title>使用钉钉提供的工具实现内网穿透</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/01/16435737.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Fri, 01 Jul 2022 11:11:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/01/16435737.html</guid><description><![CDATA[外网访问内网服务器：1.端口映射 2.内网穿透
内网穿透原理是映射端口, 能让外网的电脑找到处于内网的电脑; 简单说就是局域网的服务外网访问不到,通过内网穿透技术来实现外网到内网的端口映射, 进行实现外网访问内网服务.

使用钉钉实现内网穿透：https://github.com/open-dingtalk/pierced
我出现的错误和解决：
[Invalid Host header 服务器域名访问出现的问题](https://blog.csdn.net/Cookysurongbin/article/details/86077241/ )
]]></description></item><item><title>linux快速查找文件 locate </title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/01/16435688.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Fri, 01 Jul 2022 10:49:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/01/16435688.html</guid><description><![CDATA[locate test.cpp # 定位文件test.cpp所在的目录.
locate是在一个资料库中查找的。若找不到文件，终端执行：updatedb，重新建立整个系统所有文件和目录的资料库，方便以后再查找文件。]]></description></item><item><title>C++ opencv保存mp4文件</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/01/16433421.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Fri, 01 Jul 2022 01:30:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/01/16433421.html</guid><description><![CDATA[C++ opencv保存mp4文件
```
cv::VideoWriter w_cap("re_video.mp4", VideoWriter::fourcc('m', 'p', '4', 'v'), rate, cv::Size(width, height));
// VideoWriter::fourcc('m', 'p', '4', 'v')中的mp4v都要小写才不会报错，操!
```]]></description></item><item><title>在指定 python 版本下运行 pip</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/01/16433409.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Fri, 01 Jul 2022 01:26:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/01/16433409.html</guid><description><![CDATA[在指定 python 版本下运行 pip：
python3.9 -m pip install numpy]]></description></item><item><title>webRTC</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/06/30/16428200.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Thu, 30 Jun 2022 11:25:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/06/30/16428200.html</guid><description><![CDATA[直接看给的文档就行


sudo tail -f nohup.out # 监听nohup.out文件的变化
**测试stun:**
测试网址：https://webrtc.github.io/samples/src/content/peerconnection/trickle-ice/，进行如下操作：
![](https://img2022.cnblogs.com/blog/1617829/202206/1617829-20220629220139516-1637691158.png)
出现错误：
Note: errors from onicecandidateerror above are not neccessarily fatal. For example an IPv6 DNS lookup may fail but relay candidates can still be gathered via IPv4.
The server stun:10.16.203.4:3478 returned an error with code=701:
STUN server address is incompatible.
可以了解STUN的具体知识以后，在回过来看。

**测试turn：**
![](https://img2022.cnblogs.com/blog/1617829/202206/1617829-20220629220455320-1770216259.png)
点击Gather candidates后，nohup.out文件应该有所变化


# 实现一对一通信
**main.js代码的执行顺序：**
1.创建websocket对象，用于连接信令服务器。并且设置一些回调函数。以上这些通过下面代码实现：
```
zeroRTCEngine = new ZeroRTCEngine("ws://192.168.221.134:8099");
zeroRTCEngine.createWebsocket();
```
2.点击加入房间，获取视频流，并且使用doJoin(roomId)给信令服务器发送加入信息。





# js的一些知识
]]></description></item><item><title>gdb调试</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/06/29/16424650.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Wed, 29 Jun 2022 11:14:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/06/29/16424650.html</guid><description><![CDATA[我认为与IDE相比，GDB没什么好处，如果能用IDE就尽量用IDE。

# 1.gdb常用命令
可参考：[gdb调试](https://freecplus.net/b72113dda88a43b48728e0552fd8a74c.html)
bt：查看函数的调用栈。比如main函数中调用func函数，那么调用栈为：main在栈底，func在main的上方
info b：查看断点的信息
info threads：查看线程信息

# 2.调试core文件
程序运行时由于非法访问内存，程序可能挂掉，但是不返回发生错误的代码的位置。此时在gdb调试的时候引入core文件，就可以查看到发生core dump的位置。
可参考[gdb调试——②调试core文件](https://blog.csdn.net/shi_xiao_xuan/article/details/117402434)调试core文件
参考[Ubuntu下不产生core文件](https://blog.csdn.net/qq_38229124/article/details/123325016)，解决Ubuntu下不产生core文件问题。

# 3.调试正在运行的程序
可参考：[gdb调试——③调试正在运行的程序](https://blog.csdn.net/shi_xiao_xuan/article/details/117454802)



# 4.父子进程调试

我以为调试子进程，直接在子进程中打断点就可以了，但其实还需要输入set follow-fork-mode child。
```
set follow-fork-mode parent(缺省)
set follow-fork-mode child
```
**实例：**
```
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main()
{
    printf("begin\n");

    if (fork() != 0)
    {
        printf("我是父进程:pid=%d.ppid=%d\n", getpid(), getppid());

        int ii = 0;
        for (ii = 0; ii < 10; ii++)
        {
            printf("ii=%d\n",ii);
            sleep(1);
        }
        exit(0);
    }
    else{
        printf("我是子进程:pid=%d.ppid=%d\n", getpid(), getppid());

        int jj = 0;
        for (jj = 0; jj < 10; jj++)
        {
            printf("jj=%d\n",jj);
            sleep(1);
        }
        exit(0);
    }
}
```
运行命令：
```
(gdb) b 24                             # 在第24行（int jj = 0;）设置断点
Breakpoint 1 at 0x12b6: file test.cpp, line 24.
(gdb) set follow-fork-mode child       # 调试子进程
(gdb) r
Starting program: /home/ubuntu1/projects/c++/restful_api/test/test 
begin
[Attaching after process 42641 fork to child process 42645]
[New inferior 2 (process 42645)]
[Detaching after fork from parent process 42641]
我是父进程:pid=42641.ppid=42594
ii=0
[Inferior 1 (process 42641) detached]
我是子进程:pid=42645.ppid=42641
[Switching to process 42645]

Thread 2.1 "test" hit Breakpoint 1, main () at test.cpp:24
24              int jj = 0;          # 子进程在第24行停止运行
(gdb) ii=1
ii=2                                 # 父进程执行完毕
(gdb) n                              # 输入n，一步一步调试子进程
25              for (jj = 0; jj < 3; jj++)
(gdb) 
·
·
·
```

如果需要同时调试父进程和子进程，需要先介绍一下detach-on-fork。
```
set detach-on-fork [on | off]：默认为on，表示调试当前进程的时候，其它的进程继续运行。如果为off, 调试当前进程的时候，其它进程被GDB挂起。
为off时的运行机制：在fork()函数之后，判断follow-fork-mode类型。当follow-fork-mode为parent时，代表调试的是父进程，此时将子进程挂起。
```
detach-on-fork和follow-fork-mode组合起来的效果如下表：

follow-fork-mode|detach-on-fork|效果 
---|---|---
parent|	on|	只调试父进程
child	|on|	只调试子进程
parent	|off|	同时调试两个进程，子进程暂停
child	|off|	同时调试两个进程，父进程暂停

```
info inferiors，查看当前所有进程
inferior <num>，切换当前GDB调试进程，其中num为上一条指令中列出的进程Num
```
若同时调试两个进程，并且切换进程的效果如下:
```
(gdb) set detach-on-fork off 
(gdb) b 13                 # 在第13行（int jj = 0;）设置断点
Breakpoint 1 at 0x1251: file test.cpp, line 13.
(gdb) b24                   # 在第24行（int ii = 0;）设置断点
Undefined command: "b24".  Try "help".
(gdb) r
Starting program: /home/ubuntu1/projects/c++/restful_api/test/test 
begin
[New inferior 2 (process 44543)]
Reading symbols from /home/ubuntu1/projects/c++/restful_api/test/test...
Reading symbols from /usr/lib/debug/lib/x86_64-linux-gnu/libc-2.31.so...
我是父进程:pid=44539.ppid=44462

Thread 1.1 "test" hit Breakpoint 1, main () at test.cpp:13
warning: Source file is more recent than executable.
13              int ii = 0;
(gdb) n                    # 调试父进程
14              for (ii = 0; ii < 3; ii++)
(gdb) info inferiors
  Num  Description       Executable        
* 1    process 44539     /home/ubuntu1/projects/c++/restful_api/test/test 
  2    process 44543     /home/ubuntu1/projects/c++/restful_api/test/test 
(gdb) inferior 2          # 切换到子进程
[Switching to inferior 2 [process 44543] (/home/ubuntu1/projects/c++/restful_api/test/test)]
[Switching to thread 2.1 (process 44543)]
#0  arch_fork (ctid=0x7ffff7fb7810) at ../sysdeps/unix/sysv/linux/arch-fork.h:49
49      ../sysdeps/unix/sysv/linux/arch-fork.h: No such file or directory.
(gdb) n
53      in ../sysdeps/unix/sysv/linux/arch-fork.h
(gdb) n
__libc_fork () at ../sysdeps/nptl/fork.c:78
78      ../sysdeps/nptl/fork.c: No such file or directory.    # 这一堆信息应该是代表进入子进程前要经过的初始化函数
(gdb) n
83      in ../sysdeps/nptl/fork.c # 这一堆信息应该是代表进入子进程前要经过的初始化函数
(gdb) n
100     in ../sysdeps/nptl/fork.c # 这一堆信息应该是代表进入子进程前要经过的初始化函数
(gdb) n
102     in ../sysdeps/nptl/fork.c # 这一堆信息应该是代表进入子进程前要经过的初始化函数
(gdb) n
113     in ../sysdeps/nptl/fork.c # 这一堆信息应该是代表进入子进程前要经过的初始化函数
(gdb) n
126     in ../sysdeps/nptl/fork.c # 这一堆信息应该是代表进入子进程前要经过的初始化函数
(gdb) n
129     in ../sysdeps/nptl/fork.c # 这一堆信息应该是代表进入子进程前要经过的初始化函数，下次切换进程就没这些信息了
(gdb) n
main () at test.cpp:9
9           if ( pid != 0)
(gdb) n
22              printf("我是子进程:pid=%d.ppid=%d\n", getpid(), getppid());
(gdb) 
```
参考：[GDB调试之多进程/线程](https://blog.csdn.net/Augusdi/article/details/118864353)


# 5.多线程调试

调试多线的常用命令：
```
查看线程: info threads
切换线程: thread 线程id
指定某线程执行某gdb命令: thread apply 线程id cmd
全部的线程执行某adb命令: thread apply all cmd

使用 GDB 调试多线程程序时，默认的调试模式为：一个线程暂停运行，其它线程也随即暂停；一个线程启动运行，其它线程也随即启动。要知道，
这种调试机制确实能帮我们更好地监控各个线程的“一举一动”，但并非适用于所有场景。
一些场景中，我们可能只想让某一特定线程运行，其它线程仍维持暂停状态。要想达到这样的效果，就需要借助 set scheduler-locking 命令。
此命令可以帮我们将其它线程都“锁起来”，使后续执行的命令只对当前线程或者指定线程有效，而对其它线程无效。
set scheduler-locking mode，mode可以为：
off：不锁定线程，任何线程都可以随时执行；
on：锁定线程，只有当前线程或指定线程可以运行；
step：当单步执行某一线程时，其它线程不会执行，同时保证在调试过程中当前线程不会发生改变。但如果该模式下执行 continue、until、finish
命令，则其它线程也会执行，并且如果某一线程执行过程遇到断点，则 GDB 调试器会将该线程作为当前线程。
```
实例：
```
#include <stdio.h>
#include <unistd.h>
#include <pthread.h>
int x = 0, y = 0; // x用于线程一，y用于线程二。
pthread_t pthid1, pthid2;
//第一个线程的主函数
void *pth1_main(void *arg);
//第二个线程的主函数
void *pth2_main(void *arg);
int main()
{
    //创建线程一
    if (pthread_create(&pthid1, NULL, pth1_main, (void *)0) != 0)
    {
        printf("pthread_ create pthid1 failed.\n");
        return -1;
    }
    //创建线程二
    if (pthread_create(&pthid2, NULL, pth2_main, (void *)0) != 0)
    {
        printf("pthread_ create pthid2 failed.\n");
        return -1;
    }
    printf(" 111\n");
    pthread_join(pthid1, NULL);
    printf("222\n");
    pthread_join(pthid2, NULL);
    printf("333\n");
    return 0;
}

//第一个线程的主函数
void *pth1_main(void *arg)
{
    for(x = 0; x < 100; x++)
    {
        printf(" x=%d\n", x);
        sleep(1);
    } 
    pthread_exit(NULL);
}

//第二个线程的主函数
void *pth2_main(void *arg)
{
    for (y = 0; y < 100; y++)
    {
        printf(" y=%d\n", y);
        sleep(1) ;
    } 
    pthread_exit(NULL);
}
```
效果如下:
```
**(gdb) b 13    # 在第13行设置断点（if (pthread_create(&pthid1, NULL, pth1_main, (void *)0) != 0)）
Breakpoint 1 at 0x11f1: file test.cpp, line 13.
(gdb) b 35       # 在第35行设置断点（for(x = 0; x < 100; x++)）
Breakpoint 2 at 0x12c9: file test.cpp, line 35.
(gdb) b 46        # 在第46行设置断点（for (y = 0; y < 100; y++)）
Breakpoint 3 at 0x132c: file test.cpp, line 46.
(gdb) r
Starting program: /home/ubuntu1/projects/c++/restful_api/test/test 
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".

Breakpoint 1, main () at test.cpp:13
13          if (pthread_create(&pthid1, NULL, pth1_main, (void *)0) != 0)
(gdb) n
[New Thread 0x7ffff7d9d700 (LWP 48569)]
[Switching to Thread 0x7ffff7d9d700 (LWP 48569)]

Thread 2 "test" hit Breakpoint 2, pth1_main (arg=0x0) at test.cpp:35
35          for(x = 0; x < 100; x++)             # 处于线程1
(gdb) n
[New Thread 0x7ffff759c700 (LWP 48581)]
 111                                            # 主线程输出111
[Switching to Thread 0x7ffff759c700 (LWP 48581)]

Thread 3 "test" hit Breakpoint 3, pth2_main (arg=0x0) at test.cpp:46
46          for (y = 0; y < 100; y++)          # 主线程开启了线程2，并在线程2的断点处停止
(gdb) n                                        # 调试线程2
 x=0                                          # 默认的调试模式为：一个线程暂停运行，其它线程也随即暂停，即这里每输入一个n，
                                              # 线程2都前进一步，线程1就开始运行。线程2运行停止，线程1也跟着停止。
48              printf(" y=%d\n", y);
(gdb) set scheduler-locking on                 # 设定只有当前线程或指定线程可以运行
(gdb) n                    
 y=0            
49              sleep(1) ;**
```

# 6.运行日志
日志：平时经常使用print来进行代码的调试，日志就相当于将print的内容放入一个文件中，这个文件也叫做日志文件。





参考：[C语言gdb调试之精髓](https://www.bilibili.com/video/BV1ei4y1V758)]]></description></item><item><title>动态链接库的静态加载</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/06/26/16414555.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Sun, 26 Jun 2022 14:13:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/06/26/16414555.html</guid><description><![CDATA[
# 1.静态库和动态库、动态库的显式调用和隐式调用
**静态库：**静态链接库在链接时，编译器会将目标文件和静态库文件组织成一个可执行文件，程序运行时，将全部数据加载到内存。
如果程序体积较大，功能较为复杂，那么加载到内存中的时间就会比较长，最直接的一个例子就是双击打开一个软件，要很久才能看到界面。这是静态链接库的一个弊端。
动态库相比静态库的区别是：静态库是编译时就加载到可执行文件中的，而动态库是在程序运行时完成加载的，所以使用动态库的程序的体积要比使用静态库程序的体积小，并且使用动态库的程序在运行时必须依赖所使用的动态库文件(.so文件)，而使用静态库的程序一旦编译好，就不再需要依赖的静态库文件了(.a文件)。
.dll与.so：windows下动态库的后缀为.dll，linux下动态库的后缀为.so

**动态链接库有两种加载方式：隐式加载和显示加载：**
隐式加载又叫载入时加载，指在主程序载入内存时搜索动态库，并将动态库载入内存。隐式加载也会有静态链接库的问题，如果程序稍大，加载时间就会过长，用户不能接受。
显式加载又叫运行时加载，指主程序在运行过程中需要动态库中的函数时再加载。显式加载是将较大的程序分开加载的，程序运行时只需要将主程序载入内存，软件打开速度快，用户体验好。


# 2.extern "C"的作用
C++程序（或库、目标文件）中，所有非静态（non-static）函数在二进制文件中都是以“符号（symbol）”形式出现的。这些符号都是唯一的字符串，从而把各个函数在程序、库、目标文件中区分开来。在C中，符号名正是函数名，两者完全一样。而C++允许重载（不同的函数有相同的名字但不同的参数，甚至const重载），并且有很多C所没有的特性──比如类、成员函数、异常说明──几乎不可能直接用函数名作符号名。为了解决这个问题，C++采用了所谓的name mangling。它把函数名和一些信息（如参数数量和大小）杂糅在一起，改造成奇形怪状，只有编译器才懂的符号名。例如，被mangle后的foo可能看起来像foo@4%6^，或者，符号名里头甚至不包括“foo”。

其中一个问题是，C++标准并没有定义名字必须如何被mangle，所以每个编译器都按自己的方式来进行name mangling。有些编译器甚至在不同版本间更换mangling算法（尤其是g++ 2.x和3.x）。前文说过，在显示调用动态库中的函数时，需要指明调用的函数名，即使您搞清楚了您的编译器到底怎么进行mangling的，从而知道调用的函数名被C++编译器转换为了什么形式，，但可能仅仅限于您手头的这个编译器而已，而无法在下一版编译器下工作。

extern "C"即可以解决这个问题。用 extern "C"声明的函数将使用函数名作符号名，就像C函数一样。因此，只有非成员函数才能被声明为extern "C"，并且不能被重载。尽管限制多多，extern "C"函数还是非常有用，因为它们可以象C函数一样被dlopen动态加载。冠以extern "C"限定符后，并不意味着函数中无法使用C++代码了，相反，它仍然是一个完全的C++函数，可以使用任何C++特性和各种类型的参数。所以extern "C" 只是告诉编译器编和链接的时候都用c的方式的函数名字，函数里的内容可以为c的代码也可以为c++的。


【使用extern "C"后还能使用C++类吗？？】

# 3.显式调用

建立so1.h、so1.cc、so2.h、so2.cc、test.cc五个文件，内容如下：
```
so1.h：
extern "C" void fcn();

so1.cc：
#include <iostream>
#include "so1.h"
void fcn()
{
    std::cout << "this is fcn in so1" << std::endl;
}


so2.h：
extern "C" void fcn();

so2.cc：
#include <iostream>
#include "so2.h"
void fcn()
{
    std::cout << "this is fcn in so2" << std::endl;
}


test.cc:
#include <iostream>
#include <cstdlib>
#include <dlfcn.h>

using namespace std;

int main(int argc, char **argv)
{
    if (argc != 2)
    {
        cout << "argument error!" << endl;
        exit(1);
    }

    // pointer to function
    typedef void (*pf_t)();

    char *err = NULL;
    // open the lib
    void *handle = dlopen(argv[1], RTLD_NOW);

    if (!handle)
    {
        cout << "load " << argv[1] << "failed! " << dlerror() << endl;
        exit(1);
    }

    // clear error info
    dlerror();

    pf_t pf = (pf_t)dlsym(handle, "fcn");
    err = dlerror();
    if (err)
    {
        cout << "can't find symbol fcn! " << err << endl;
        exit(1);
    }

    // call function by pointer
    pf();

    dlclose(handle);

    return 0;
}
```
将so1.cc和so2.cc编译成动态库，编译命令如下：
```
g++ so1.cc -shared -fPIC -o libso1.so
g++ so2.cc -shared -fPIC -o libso2.so
```
test.cc中使用到了上面生成的动态库，编译命令如下：
```
g++ test.cc -l dl -Wl,-rpath=. -o test
等价于：g++ test.cc  -ldl -Wl,-rpath=. -o test
```
【注】在显式调用方式中，必须加入头文件dlfcn.h，makefile中的链接命令中要加入参数-ldl，否则报错。

运行test:
```
./test libso1.so 
或./test libso2.so 
```
可以看到这里，通过输入不同的参数，调用了不同的共享库中的fcn函数，是一种多态的表现，许多软件的不同插件就是这样实现的。

dlfcn.h中提供的API说明如下：
**1.dlopen**

函数原型：void *dlopen(const char *libname,int flag);
功能描述：dlopen必须在dlerror，dlsym和dlclose之前调用，表示要将库装载到内存，准备使用。如果要装载的库依赖于其它库，必须首先装载依赖库。如果dlopen操作失败，返回NULL值；如果库已经被装载过，则dlopen会返回同样的句柄。

参数中的libname一般是库的全路径，这样dlopen会直接装载该文件；如果只是指定了库名称，在dlopen会按照下面的机制去搜寻：
a.根据环境变量LD_LIBRARY_PATH查找
b.根据/etc/ld.so.cache查找
c.查找依次在/lib和/usr/lib目录查找。

flag参数表示处理未定义函数的方式，可以使用RTLD_LAZY或RTLD_NOW。RTLD_LAZY表示暂时不去处理未定义函数，先把库装载到内存，等用到没定义的函数再说；RTLD_NOW表示马上检查是否存在未定义的函数，若存在，则dlopen以失败告终。

**2.dlerror**

函数原型：char *dlerror(void);
功能描述：dlerror可以获得最近一次dlopen,dlsym或dlclose操作的错误信息，返回NULL表示无错误。dlerror在返回错误信息的同时，也会清除错误信息。

**3.dlsym**

函数原型：void *dlsym(void *handle,const char *symbol);
功能描述：在dlopen之后，库被装载到内存。dlsym可以获得指定函数(symbol)在内存中的位置(指针)。如果找不到指定函数，则dlsym会返回NULL值。但判断函数是否存在最好的方法是使用dlerror函数，

**4.dlclose**

函数原型：int dlclose(void *);
功能描述：将已经装载的库句柄减一，如果句柄减至零，则该库会被卸载。如果存在析构函数，则在dlclose之后，析构函数会被调用。


# 4.隐式调用
隐式调用不需要包含头文件dlfcn.h，只需要包含动态链接库中的头文件，使用动态库中的函数也不需要像显示调用那么复杂。
可以参考：[静态库和动态库的制作](https://www.cnblogs.com/codingbigdog/p/16412416.html)。这个链接中调用动态库的方式就是隐式调用。

根据上面的显式调用和隐式调用的实例，可总结显示和隐式的区别如下：
1、 隐式调用需要调用者写的代码量少，调用起来和使用当前项目下的函数一样直接；而显式调用则要求程序员在调用时，指明要加载的动态库的名称和要调用的函数名称。
2、隐式调用由系统加载完成，对程序员透明；显式调用由程序员在需要使用时自己加载，不再使用时，自己负责卸载。
3、由于显式调用由程序员负责加载和卸载，好比动态申请内存空间，需要时就申请，不用时立即释放，因此显式调用对内存的使用更加合理， 大型项目中应使用显示调用。
4、当动态链接库中只提供函数接口，而该函数没有封装到类里面时，如果使用显式调用的方式，调用方甚至不许要包含动态链接库的头文件（需要调用的函数名是通过dlsym函数的参数指明的），而使用隐式调用时，则调用方必须要加上动态库中的头文件，g++编译时还需要要用参数-I指明包含的头文件的位置。需要注意的是，当动态链接库中的接口函数是作为成员函数封装在类里面时，即使使用显式调用的方式，调用方也必须包含动态库中的相应头文件（详见五、显示调用动态链接中的类成员函数）。
5、显式调用更加灵活，可以模拟多态效果。
6、显式调用的方式，必须加入头文件dlfcn.h，makefile中的链接命令中要加入参数-ldl，需要用dlopen加载库，dlsym取函数符号(函数名应用新定义的)，dlclose卸载库。
7、隐式调用的方式，makefile中的链接命令中要加入参数-l加库名，直接用库里的函数名就可以。


# 5.显式调用动态链接中的类成员函数

显示调用动态链接库的类成员函数，有单独的写法，但比较少用。推荐的写法是为每个要被外部调用的类成员函数设计一个普通的接口函数，在接口函数内部使用类的成员函数。当然这就需要将类设计为单例模式，因为不可能在每个接口函数中都构造一个类的对象。【看不懂，以后再看】

参考：[链接](https://www.cnblogs.com/testlife007/p/10774271.html)
]]></description></item><item><title>运行restful API</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/06/25/16412488.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Sat, 25 Jun 2022 13:41:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/06/25/16412488.html</guid><description><![CDATA[dfd



如何找到http下面的文件进行编译？？]]></description></item><item><title>静态库和动态库的制作</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/06/25/16412416.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Sat, 25 Jun 2022 13:03:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/06/25/16412416.html</guid><description><![CDATA[# 程序
```
// add.h
int add(int i, int j);
 
// add.c
#include "add.h"
 
int add(int i, int j)
{
	return i + j;
}
 
// main.c
#include <stdio.h>
#include <stdlib.h>
#include "add.h"
 
int main(int argc, char *argv[]) 
{
	printf("1 + 2 = %d\n", add(1, 2));
	return 0;
}
```
# 动态库的制作和使用
```
# 编译共享库
gcc add.c -fPIC -shared -o libadd.so  # -fPIC：生成位置无关目标代码，适用于动态连接；
                                      # -shared：生成一个共享库文件；

# 编译和运行
gcc -Wl,-rpath=`pwd` main.c -L. -ladd -o app # pwd代表当前路径
                                             # "-L ."代表链接阶段在当前目录下查找库
                                             # -Wl,-rpath代表运行时，在哪里找库。
./app
输出：
1 + 2 = 3
```
参考：[链接](https://www.cnblogs.com/codingbigdog/p/16320965.html)



# 静态库的制作和使用
```
gcc -c add.c -o libadd.a       # 静态库的制作

静态库的使用：
方法一：
gcc main.c libadd.a -o app   # 直接把调用者源代码和静态库文件名一起编译。
./app

方法二：
gcc -L . -l add main.c -o app   # 采用L参数指定静态库文件的目录，-l参数指定静态库名。
./app
```
参考：[C/C++编译以及静态库和动态库的制作和使用](https://blog.csdn.net/qq_37233070/article/details/120544919)

可见，静态库和动态库都是通过-L和-l指定路径的。
在静态库制作的过程中使用到了gcc -c，我们可以通过[链接](https://blog.csdn.net/qq_42775938/article/details/122346013)明白它的含义。



# 补充
公用函数库的程序文件add.c程序文件是源代码，对任何程序员是可见的，没有安全性可言，但是，在实际开发中，出于技术保密或其它方面考虑，开发者并不希望提供公用函数库的源代码。

C/C++提供了一个可以保证代码安全性的方法，把公共的程序文件编译成库文件，库文件是一种可执行代码的二进制形式，可以与其它的源程序一起编译，也可以被操作系统载入内存执行。

库文件分为静态库与动态库。
区别：
静态库源代码修改后，静态库需要重新编译，程序也要重新编译。
动态库源代码修改后，只需要编译动态库文件即可，程序不需要重新编译。
如果在动态库文件和静态库文件同时存在，优先使用动态库编译。

静态库文件名的命名方式是“libxxx.a”,库名前加”lib”，后缀用”.a”，“xxx”为静态库名。
与静态库类似，前缀相同，为“lib”，后缀变为“.so” “xxx”为动态库名。

我们可以看到在编译的时候需要使用-L和-l指明动态库的位置，运行时需要使用-Wl,-rpath指明动态库的位置。这是因为：
动态库在编译的时候只做语法检查， 并没有被编译进目标代码，当程序执行到动态库中的函数时才调用该函数库里的代码。
动态函数库并没有整合进程序，所以程序的运行环境必须提供动态库路径。优点是，如果所使用的动态库发生更新改变，程序不需要重新编译，所以动态库升级比较方便。

如果在动态库文件和静态库文件同时存在，优先使用动态库编译。
参考：[C/C++编译以及静态库和动态库的制作和使用](https://blog.csdn.net/qq_37233070/article/details/120544919)

# -fPIC选项
通常在linux下用gcc编译动态库时都会加上一个-fPIC选项来生成位置无关代码。但是如果你的静态库可能会被动态库使用，那么静态库编译的时候就也需要-fPIC选项。

原理分析
众所周知，静态库其实是一系列.o文件的打包，将.o文件制作成静态库的过程是不会发生链接的。
所以链接静态库就约等于将静态库解包后的.o文件一个一个全部链接。

-fPIC选项的生效阶段在编译阶段，使用-fPIC选项编译的.o文件会生成位置无关的代码

如果一个动态库需要链接一个静态库，那么就相当于动态库去链接一系列的.o文件，而编译动态库所需的.o文件时一般是推荐使用-fPIC编译选项的。


参考：[链接](https://blog.csdn.net/bjrxyz/article/details/121146434)

具体的-fPIC是什么原理可以参考：[动态库基本原理和使用方法，-fPIC选项的来龙去脉](https://blog.csdn.net/cyz_2014/article/details/108920037)。-fPIC大概的原理就是：编译时构造全局偏移表（Global Offset Table, GOT），运行时通过GOT中存储的偏移值访问指令和数据。
]]></description></item><item><title>crontab 常见 /dev/null 2&gt;&amp;1 详解</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/06/24/16409963.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Fri, 24 Jun 2022 10:55:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/06/24/16409963.html</guid><description><![CDATA[
**大部分在 crontab 计划任务中都会年到未尾带 >/dev/null 2>&1,是什么意思呢？**

\>是重定向
/dev/null 代表空设备文件
1 表示stdout标准输出,系统默认值是1,所以 ">/dev/null" 等同于 "1>/dev/null"
2 表示stderr标准错误
& 表示等同于的意思,2>&1,表示2的输出重定向等同于1

整句的意思就是标准输出重定向到空设备文件,也就是不输出任何信息到终端,标准错误输出重定向等同于标准输出,因为之前标准输出已经重定向到了空设备文件,所以标准错误输出也重定向到空设备文件

运行脚本的时候有些错误不想让它显示，就输出到/dev/null
 

**command > file 2>file 与 command > file 2>&1 有什么区别呢?**

command > file 2>file 的意思是将命令所产生的标准输出信息,和错误的输出信息送到file 中.command > file 2>file 这样的写法,stdout和stderr都直接送到file中, file会被打开两次,这样stdout和stderr会互相覆盖,这样写相当使用了FD1和FD2两个同时去抢占file 的管道.
而command >file 2>&1 这条命令就将stdout直接送向file, stderr 继承了FD1管道后,再被送往file,此时,file 只被打开了一次,也只使用了一个管道FD1,它包括了stdout和stderr的内容.
从IO效率上,前一条命令的效率要比后面一条的命令效率要低,所以在编写shell脚本的时候,较多的时候我们会用command > file 2>&1 这样的写法.

**所以在添加crontab命令时，无论命令是否有输出，最好都加上输出重定向到文件或者/dev/null中。如下**

*/5 * * * * /root/XXXX.sh &>/dev/null 2>&1

/dev/null 代表空设备文件

\> 代表重定向到哪里，例如：echo "123" > /home/123.txt

1 表示stdout标准输出，系统默认值是1，所以">/dev/null"等同于"1>/dev/null"

2 表示stderr标准错误

& 表示等同于的意思，2>&1，表示2的输出重定向等同于1

那么>/dev/null 2>&1的意思就是：

标准输出重定向到空设备文件,也就是不输出任何信息到终端,标准错误输出重定向等同于标准输出,因为之前标准输出已经重定向到了空设备文件,所以标准错误输出也重定向到空设备文件。

 

示例:

每天早上6点 
0 6 * * * echo "Good morning." >> /tmp/test.txt //注意单纯echo，从屏幕上看不到任何输出，因为cron把任何输出都email到root的信箱了。

每两个小时 
0 */2 * * * echo "Have a break now." >> /tmp/test.txt 

好文要顶 关注我 收藏该文  


参考：[链接](https://www.cnblogs.com/gyrgyr/p/11367843.html)]]></description></item><item><title>Python调用C++程序，C++调用python</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/06/13/16372215.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Mon, 13 Jun 2022 12:20:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/06/13/16372215.html</guid><description><![CDATA[# 1.Python调用C++程序

1、编写C/C++实现程序。
2、将C/C++程序编译成动态库。
3、在Python中调用编译生成的库。

请参考：[简单的Python调用C++程序（使用ctypes模块）](https://blog.csdn.net/weixin_40313940/article/details/109515357)

python调用C++程序的其他方法：
boost.python：将c/c++的函数接口转换为Python接口有好几种解决方案，不同于C语言的简单直接，C++因使用了大量的面向对象编程的思想导致转换为Python接口时相对比较复杂，boost.python的目标就是为了简单方便地将C++程序转换成Python的接口。

# 2.C++中使用python程序
参考：[在C++中调用Python](https://www.cnblogs.com/dechinphy/p/cpp-python.html)



## 2.1.hello world

```
// cp.cpp
#include <Python.h>
int main(int argc, char *argv[]) {
  Py_Initialize();
  PyRun_SimpleString("print('hello world')\n");
  Py_Finalize();
  return 0;
}
```
执行命令：
```
g++ -o cpy cp.cpp  -I /usr/include/python3.9/ -l python3.9
```
使用-I（大写地i）指定头文件所在路径
虽然编译器会自动地去目录/usr/lib/查找库文件，但我们还是需要使用-l选项指定具体地库python3.9

【问题：/usr/lib/python3.9中几乎都是.py文件，为什么.py文件可以成为库文件】


## 2.2.调用Python函数string.split() 
在C++中如果我们想分割一个字符串，虽然说也是可以实现的，但是应该没有比Python中执行一个string.split()更加方便快捷的方案了，因此我们测试一个用C++调用Python的split函数的功能。

首先编写一个 pysplit.py文件：
```
# pysplit.py

def sp(string):
    return string.split()
```

cp.cpp中将 pysplit.py当成包进行调用。
```
#include <Python.h>
#include <iostream>
using namespace std;
int main(int argc, char *argv[])
{
  Py_Initialize();
  if (!Py_IsInitialized())
	{
		cout << "Initialize failed!" << endl;
		return 0;
	}
  PyObject* pModule = NULL;
  PyObject* pFunc;
  PyRun_SimpleString("import sys");
  PyRun_SimpleString("sys.path.append('./')");
  pModule = PyImport_ImportModule("pysplit");
  if (pModule == NULL)
	{
		cout << "Module Not Found!" << endl;
	}
  pFunc = PyObject_GetAttrString(pModule, "sp");
  PyObject* args1 = Py_BuildValue("s", "Test String");
  PyObject* args2 = Py_BuildValue("s", " Hello Every One !");

  PyObject* pRet = PyObject_CallFunctionObjArgs(pFunc, args1, args2, NULL); // PyObject_CallFunctionObjArgs(函数,参数1,参数2,……,NULL)
  int size = PyList_Size(pRet);
  cout << "List size is: " << size << endl;
  for(int i=0;i<size;i++)
  {
    PyObject* cRet = PyList_GET_ITEM(pRet, i);
    char* s;
    PyArg_Parse(cRet, "s", &s);
    cout << "The " << i << "th term is: " << s << endl;
  }
  Py_Finalize();
  return 0;
}
```
执行命令：
```
g++ -o cpy cp.cpp -lm -std=c++11 -I/usr/include/python3.9/ -lpython3.9 && ./cpy
```
最后，因为从Python中获取的是一个List格式的数据，因此我们首先需要用PyList_GET_ITEM去逐项提取，然后用PyArg_Parse将提取出来的元素保存到一个C++的char字符串中，执行结果如下：
```
dechin@ubuntu2004:~/projects/gitlab/dechin/$ g++ -o cpy cp.cpp -lm -std=c++11 -I/usr/include/python3.9/ -lpython3.9 && ./cpy
List size is: 6
The 0th term is: Test
The 1th term is: String
The 2th term is: Hello
The 3th term is: Every
The 4th term is: One
The 5th term is: !
```

说明：
1.代码中使用了sys.path.append('./')，这是因为：即使是在相同的路径下，也需要通过Python的sys将当前目录添加到系统路径中，才能够识别到这个模块。




tuple格式和**args有什么关系？？
答：[链接](https://www.cnblogs.com/dechinphy/p/args.html)

PyObject_CallFunctionObjArgs和PyObject_CallObject的区别？
答：[链接](https://stackoverflow.com/questions/60487083/passing-array-tuple-from-python-back-to-c)




## 2.5.python中如果有其他模块时





```
#include <Python.h>
#include <iostream>
using namespace std;
int main(int argc, char *argv[])
{
  Py_Initialize();
  if (!Py_IsInitialized())
	{
		cout << "Initialize failed!" << endl;
		return 0;
	}
  PyObject* pModule = NULL;
  PyObject* pFunc;
  PyRun_SimpleString("import sys");
  PyRun_SimpleString("sys.path.append('./')");
  pModule = PyImport_ImportModule("pyYolov5");
  if (pModule == NULL)
	{
		cout << "Module Not Found!" << endl;
	}
  pFunc = PyObject_GetAttrString(pModule, "run");
  PyObject* args = Py_BuildValue("s", "Test String Hello Every One !");
  PyObject* pRet = PyObject_CallFunctionObjArgs(pFunc, args, NULL);

  Py_Finalize();
  return 0;
}
```













使用PyRun_SimpleString，然后在python中调用python程序，从而传入参数
https://blog.csdn.net/qq_30694087/article/details/113748702
https://blog.csdn.net/sspdfn/article/details/62894607




仿照上面例子，调用yolov5，有什么问题再查，
调用成功，再对python.h进行学习。






使用Python.h调用python程序

如何使用C++执行python文件：
https://blog.csdn.net/dingyanxxx/article/details/46949405

https://zhuanlan.zhihu.com/p/80637788
https://zhuanlan.zhihu.com/p/79896193

https://docs.python.org/3/extending/embedding.html#embedding-python-in-c

https://blog.csdn.net/m0_46656879/article/details/124490820

【问题：/usr/lib/python3.9中几乎都是.py文件，为什么.py文件可以成为库文件】
答:主流的用法是把python作为一种文本形式的链接库，在c/c++程序中调用其中定义的函数。什么叫做文本形式的链接库？？
什么类型的文件可以作为C++链接库？？即可以用于-l后？


是不是还有其他在C++里面调用python程序的办法？？


# 其他

void Py_Initialize(void)
初始化Python解释器，如果初始化失败，继续下面的调用会出现各种错误，可惜的是此函数没有返回值来判断是否初始化成功，如果失败会导致致命错误。

int Py_IsInitialized(void)
检查是否已经进行了初始化，如果返回0，表示没有进行过初始化。

void Py_Finalize()
反初始化Python解释器，包括子解释器，调用此函数同时会释放Python解释器所占用的资源。

int PyRun_SimpleString(const char *command)
实际上是一个宏，执行一段Python代码。所以在PyRun_SimpleString中执行的代码，相当于作用于整个代码【我猜的】。




[python与C/C++相互调用](https://www.jianshu.com/p/335253cd688f)



# 1 官方文档
https://docs.python.org/3.9/c-api/

## 1.1 概述
**1.引入头文件：**
```
#define PY_SSIZE_T_CLEAN
#include <Python.h>
```
Python.h中定义的所有函数都是以Py_开头的。

**2.Python.h所处位置**
在 Unix 上，头文件Python.h位于以下目录：prefix/include/pythonversion/ 和 exec_prefix/include/pythonversion/，其中 prefix 和 exec_prefix 是由向 Python 的 configure 脚本传入的对应形参所定义。在 Windows 上，头文件安装于 prefix/include，其中 prefix 是向安装程序指定的安装目录。

我曾经用过的执行命令：
```
g++ -o test test.cpp  -I xx/anaconda3/envs/yolov5Env/include/python3.9/ -L xx/anaconda3/envs/yolov5Env/lib -l python3.9 -Wl,-rpath=xx/anaconda3/envs/yolov5Env/lib
```

**3.C++与C的API**
C++ 用户应该注意，尽管 API 是完全使用 C 来定义的，但头文件正确地将入口点声明为 extern "C"，因此 API 在 C++ 中使用此 API 不必再做任何特殊处理。


**4.有用的宏**
有用的宏：这一小节就是介绍一些有用的函数。


**5.PyObject*类型指针**
PyObject*类型指针，用于指向python的的任意对象，如整型、字符串、列表、函数等。
通过PyObject*，C++程序可以向python函数传递参数，python程序可以给C++程序返回运算结果。
由于几乎所有Python 对象都存在于堆上：所以您不能声明PyObject类型的自动或静态变量，只能声明 PyObject*类型的指针变量。唯一的例外是type objects；因为这些永远不能被释放，它们通常是静态的PyTypeObject对象【看不懂】。

每一种python中常见的类型都对应一个检测类型的宏，如PyList_Check(a)用于检测a是否为python中的list


python程序和c程序在互传变量的时候，注意引用计数的问题。


变量和引用的生命一样长，就不需要考虑增加引用计数。


PyTuple_SetItem()是设置元组的唯一方法；PySequence_SetItem()和PyObject_SetItem()不用于设置元组，因为元组是不可变的数据类型
使用PyTuple_New()和PyTuple_SetItem()创建python tuple  
使用PyList_New()和PyList_SetItem()创建python list
一般不使用上面两种方法，而使用通用的方法Py_BuildValue()来创建元组和列表。



问题：
类似PyImport_ImportModule这样常用的函数怎么都找不到？？
答：PyImport_ImportModule在工具——》导入模块中。


extern "C"中不能创建类和对象吗？？


PyObject_CallFunctionObjArgs如何传递多个参数？
]]></description></item><item><title>网络编程实践视频笔记--陈硕</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/06/12/16368715.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Sun, 12 Jun 2022 11:46:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/06/12/16368715.html</guid><description><![CDATA[参考：https://blog.csdn.net/weixin_43919932/article/details/121308426

第一节 我都没看懂：https://blog.csdn.net/weixin_43919932/article/details/121611027



### 2.1.2 实现 ttcp 程序
SessionMessage(num=1024,len=8192)  // 客户端告诉服务端，接下来要发送1024个数据，每个数据8192个字节




直接看笔记，不懂的，再去看视频。]]></description></item><item><title>unix环境高级编程</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/06/09/16361038.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Thu, 09 Jun 2022 12:25:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/06/09/16361038.html</guid><description><![CDATA[unix环境高级编程主要讲了各种函数和命令的使用。这些函数我在使用C语言进行网络编程的时候经常看到。完全看一遍这本书，我也记不住，所以现在重点不是看这本书。]]></description></item><item><title>ffmpeg、ffplay和ffprobe基础使用</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/06/08/16357163.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Wed, 08 Jun 2022 12:52:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/06/08/16357163.html</guid><description><![CDATA[# 1.ffmpeg、ffplay和ffprobe基础介绍

ffmpeg:Hyper fast Audio and Video encoder 超快音视频编码器
ffplay:Simple media player 简单媒体播放器
ffprobe:Simple multimedia streams analyzer 简单多媒体流分析器

## 1.1.ffmpeg、ffplay和ffprobe帮助文档


**ffmpeg查看帮助文档：**
```
基本信息：ffmpeg -h
高级信息：ffmpeg -h long
所有信息：ffmpeg -h full
若嫌打印过多： ffmepg -h full > ffmpeg_h_full.log，然后再打开ffmpeg_h_full.log文件查看
```

**ffmpeg命令格式：**
```
ffmpeg [options] [[infile options] -i infile]... {[outfile options] outfile}...
options代表全局选项，[infile options]代表离它们最近的输入文件的选项，可以有很多个[[infile options] -i infile]。[outfile options] outfile同理
```

**ffplay与ffprobe：**
```
ffplay -h  # ffplay命令查看帮助文档
ffplay [options] input_file # 命令格式

ffprobe -h  # ffprobe命令查看帮助文档
ffprobe [OPTIONS] [INPUT_FILE] # 命令格式
```
ffmpeg/ffplay/ffprobe部分参数通用，部分参数不通用，在使用时需要注意。



## 1.2.ffmpeg和ffplay基本命令
### 1.2.1.ffmpeg基本查询命令
![](https://img2022.cnblogs.com/blog/1617829/202206/1617829-20220609161007653-2077244425.png)

一些命令的补充解释：
-devices：查询系统中可用摄像头和音频设备
-bsfs：ffmpeg支持处理比特流的信息，此命令用于查询支持哪些比特流。
-protocols：ffmpeg支持处理网络文件，此命令用于查询支持哪些协议
-filters：比如加水印、去水印
-pix_fmts：查询可用哪些格式存储图片
-sample_fmts：使用多少位来存储一个采样，如8位、16位、 32位（浮点型）
-layouts：如双声道、单声道、立体声（三个声道以上称为立体声）

**查询命令的作用：**
比如我们需要将音频输出成mp3格式，那么我们就需要查询mp3对应的编码器：
```
ffmpeg -encoders |grep mp3   # 查询mp3的编码器
# 输出
A....D libmp3lame           libmp3lame MP3 (MPEG audio layer 3) (codec mp3)

# 通过以下命令输出MP3格式的音频文件
ffmpeg -i test.mp4 -b:a 192k -ar 48000 -ac 2 -acodec libmp3lame -aframes 200 out.mp3
```

**下面对各个命令进行介绍：**

ffmpeg -version
![](https://img2022.cnblogs.com/blog/1617829/202206/1617829-20220609134255163-2004387911.png)
除了显示版本信息以外，还显示了一些其他信息。即：
**不管使用ffmeg的什么命令，都会打印ffmpeg是使用什么编译器建立的、建立时采用的配置和库的版本信息。**


ffmpeg -buildconf
![](https://img2022.cnblogs.com/blog/1617829/202206/1617829-20220609134900624-1567606680.png)

ffmpeg -devices
![](https://img2022.cnblogs.com/blog/1617829/202206/1617829-20220609135728924-171704727.png)
**查询命令：一般都会在最开始，说明各种字母代表的意思，比如这里的D和E**


ffmpeg -codecs
![](https://img2022.cnblogs.com/blog/1617829/202206/1617829-20220609161651105-200625492.png)
I代表I帧的编码器



ffmpeg -pix_fmts
![](https://img2022.cnblogs.com/blog/1617829/202206/1617829-20220609141826473-605206373.png)




### 1.2.2.ffmpeg查询类型所支持的参数

```
语法：ffmepg -h type=name
比如： ffmpeg -h muxer=flv
      ffmpeg -h filter=atempo (atempo调整音频播放速率)
      ffmpeg -h encoder=libx264
```
ffmpeg -h encoder=libx264就是查询使用libx264编码器是可以设置什么参数，结果如下
![](https://img2022.cnblogs.com/blog/1617829/202206/1617829-20220609162046942-796875199.png)



### 1.2.3.ffplay播放控制
使用ffplay播放视频时，可以使用下面按键来操作：
![](https://img2022.cnblogs.com/blog/1617829/202206/1617829-20220609163050961-71478533.png)

说明：
/和*不能用，所以这里划掉了

一个音视频文件中，是可能有多个视频流和多个音频流的，可以使用a和v切换。【多个视频流和多个音频流就是指很多个不同的视频和音频】
c就是切换节目，这样能够保持音视频的同步。如果只切换a或v或t一样，会导致音视频不同步。


### 1.2.4.ffplay命令选项
```
◼ -x width 强制显示宽带。
◼ -y height 强制显示高度。
◼ -video_size size 帧尺寸 设置显示帧存储(WxH格式)，仅适用于类似原始YUV等没有包含帧大小(WxH)的视频。
比如: ffplay -pixel_format yuv420p -video_size 320x240 -framerate 5 yuv420p_320x240.yuv
◼ -pixel_format format 格式设置像素格式。
◼ -fs 以全屏模式启动。
◼ -an 禁用音频（不播放声音）
◼ -vn 禁用视频（不播放视频）
◼ -sn 禁用字幕（不显示字幕）
◼ -ss pos：指定从pos位置开始播放视频，下面是几种典型的pos值：
    55：55秒开始 
    12:03:45：12小时03分钟45秒开始
    23.189：23.189秒开始 
◼ -t duration 设置播放视频/音频长度，时间单位如 -ss选项
```

```
◼ -bytes 按字节进行定位拖动（0=off 1=on -1=auto）。【什么叫做按字节进行拖动？？】
◼ -seek_interval interval 自定义左/右键定位拖动间隔（以秒为单位），默认值为10秒（代码没有看到实现） 
◼ -nodisp 关闭图形化显示窗口，视频将不显示
◼ -noborder 无边框窗口
◼ -volume vol 设置起始音量。音量范围[0 ~100]
◼ -f fmt 强制使用设置的格式进行解析。比如-f s16le。主要针对PCM数据进行解析。
◼ -window_title title 设置窗口标题（默认为输入文件名）
◼ -loop number 设置播放循环次数
    -t 5 -loop 2 ：播放五秒，循环两次
◼ -showmode mode 设置显示模式，可用的模式值：0 显示视频，1 显示音频波形，2 显示音频频谱。缺省为0，如果视频不存在则自动选择2 
◼ -vf filtergraph 设置视频滤镜
◼ -af filtergraph 设置音频滤镜
```
```
◼ -stats 打印多个回放统计信息，包括显示流持续时间，编解码器参数，流中的当前位置，以及音频/视频同步差值。默认情况下处于启用状态，要显式禁用它则需要指定-nostats。。
◼ -fast 非标准化规范的多媒体兼容优化。
◼ -genpts 生成pts。 
◼ -sync type 同步类型 将主时钟设置为audio（type=audio），video（type=video）或external（type=ext），默认是audio为主时钟。
    同步类型有以下几种：
      Audio Master：视频跟随音频的播放速度
      Video Master：音频跟随视频的播放速度
      External Clock Master：音频和视频都跟随外部时钟
◼ -ast audio_stream_specifier 指定音频流索引，比如-ast 3，播放流索引为3的音频流
      -ast：就是有很多个音频流，你可以指定播放哪个音频流 
◼ -vst video_stream_specifier指定视频流索引，比如-vst 4，播放流索引为4的视频流
◼ -sst subtitle_stream_specifier 指定字幕流索引，比如-sst 5，播放流索引为5的字幕流
◼ -autoexit 视频播放完毕后退出
```
-stats默认情况下处于启用状态，打印如下信息：
![](https://img2022.cnblogs.com/blog/1617829/202206/1617829-20220609190657984-1489062171.png)

```
◼ -exitonkeydown 键盘按下任何键退出播放
◼ -exitonmousedown 鼠标按下任何键退出播放
◼ -codec:media_specifier codec_name 强制使用设置的多媒体解码器，media_specifier可用值为a（音频）， v（视频）和s字幕。比如-codec:v h264_qsv 强制视频采用h264_qsv解码
◼ -acodec codec_name 强制使用设置的音频解码器进行音频解码
◼ -vcodec codec_name 强制使用设置的视频解码器进行视频解码
    -codec:v h264 等价于 -vcodec h264
◼ -scodec codec_name 强制使用设置的字幕解码器进行字幕解码
◼ -autorotate 根据文件元数据自动旋转视频。值为0或1 ，默认为1。
◼ -framedrop 如果视频不同步则丢弃视频帧。当主时钟非视频时钟时默认开启。若需禁用则使用 -noframedrop
◼ -infbuf 不限制输入缓冲区大小。尽可能快地从输入中读取尽可能多的数据。播放实时流时默认启用，如果未及时读取数据，则可能会丢弃数据。此选项将不限制缓冲区的大小。若需禁用则使用-noinfbuf
```

更多信息请参考：https://ffmpeg.org/ffplay.html



### 1.2.5.ffplay实例
**播放实例：**
```
◼ 播放本地文件
◼ ffplay -window_title "test time" -ss 2 -t 10 -autoexit test.mp4
◼ ffplay buweishui.mp3
◼ 播放网络流
◼ ffplay -window_title "rtmp stream" 
rtmp://202.69.69.180:443/webcast/bshdlive-pc
◼ 强制解码器
◼ mpeg4解码器：ffplay -vcodec mpeg4 test.mp4
◼ h264解码器：ffplay -vcodec h264 test.mp4 
◼ 禁用音频或视频
◼ 禁用音频：ffplay test.mp4 -an
◼ 禁用视频：ffplay test.mp4 -vn
```
```
◼ 播放YUV数据
◼ ffplay -pixel_format yuv420p -video_size 320x240 -framerate 5 yuv420p_320x240.yuv
◼ 播放RGB数据
◼ ffplay -pixel_format rgb24 -video_size 320x240 -i rgb24_320x240.rgb
◼ ffplay -pixel_format rgb24 -video_size 320x240 -framerate 5 -i rgb24_320x240.rgb
◼ 播放PCM数据
◼ ffplay -ar 48000 -ac 2 -f f32le 48000_2_f32le.pcm
-ar set audio sampling rate (in Hz) (from 0 to INT_MAX) (default 0)
-ac set number of audio channels (from 0 to INT_MAX) (default 0)
```

**ffplay简单过滤器**
```
◼ 视频旋转
ffplay -i test.mp4 -vf transpose=1
◼ 视频反转
ffplay test.mp4 -vf hflip
ffplay test.mp4 -vf vflip
◼ 视频旋转和反转
ffplay test.mp4 -vf hflip,transpose=1
◼ 音频变速播放
ffplay -i test.mp4 -af atempo=2
◼ 视频变速播放
ffplay -i test.mp4 -vf setpts=PTS/2
◼ 音视频同时变速
ffplay -i test.mp4 -vf setpts=PTS/2 -af atempo=2
◼ 更多参考
http://www.ffmpeg.org/ffmpeg-filters.html
```

 



# 2.ffmpeg命令
## 2.1.ffmpeg基本参数

主要参数：
```
◼ -i 设定输入流
◼ -f 设定输出格式(format)
◼ -ss 开始时间
◼ -t 时间长度

实例：
ffmpeg -i test.mp4 -codec copy -ss 10 -t 20 -f f1v out.mp4
```

音频参数：
```
◼ -aframes 设置要输出的音频帧数
◼ -b:a 音频码率
◼ -ar 设定采样率
◼ -ac 设定声音的Channel数 
◼ -acodec 设定声音编解码器，如果用copy表示原始编解码数据必须被拷贝。
◼ -an 不处理音频
◼ -af 音频过滤器

实例：
ffmpeg -i test.mp4 -b:a 192k -ar 48000 -ac 2 -acodec libmp3lame -aframes 200 out2.mp3
```

视频参数：
```
◼ -vframes 设置要输出的视频帧数
◼ -b 设定视频码率
◼ -b:v 视频码率。和-b一样。
◼ -r 设定帧速率
◼ -s 设定画面的宽与高
◼ -vn 不处理视频
◼ -aspect aspect 设置横纵比 4:3 16:9 或 1.3333 1.7777。【和-s有什么区别？？】
◼ -vcodec 设定视频编解码器，如果用copy表示原始编解码数据必须被拷贝。
◼ -vf 视频过滤器

实例：
ffmpeg -i test.mp4 -vframes 300 -b:v 300k -r 30 -s 640x480 -aspect 16:9 -vcodec libx265
```

## 2.2.ffmpeg命令提取音视频数据

```
◼ 保留封装格式
ffmpeg -i test.mp4 -acodec copy -vn audio.mp4
ffmpeg -i test.mp4 -vcodec copy -an video.mp4
◼ 提取视频
保留编码格式：ffmpeg -i test.mp4 -vcodec copy -an test_copy.h264
强制格式：ffmpeg -i test.mp4 -vcodec libx264 -an test.h264
◼ 提取音频
保留编码格式：ffmpeg -i test.mp4 -acodec copy -vn test.aac
强制格式：ffmpeg -i test.mp4 -acodec libmp3lame -vn test.mp3
```

## 2.3.ffmpeg命令提取像素格式

```
◼ 提取YUV
◼ 提取3秒数据，分辨率和源视频一致
ffmpeg -i test_1280x720.mp4 -t 3 -pix_fmt yuv420p yuv420p_orig.yuv  # 命名为test_1280x720.mp4就容易看出是1280x720
ffplay -video_size 1280x720 yuv420p_orig.yuv  # 需要指定正确的-video_size才能播放

◼ 提取3秒数据，分辨率转为320x240
ffmpeg -i test_1280x720.mp4 -t 3 -pix_fmt yuv420p -s 320x240  yuv420p_320x240.yuv


◼ 提取RGB
◼ 提取3秒数据，分辨率转为320x240
ffmpeg -i test.mp4 -t 3 -pix_fmt rgb24 -s 320x240 rgb24_320x240.rgb
◼ RGB和YUV之间的转换
ffmpeg -s 320x240 -pix_fmt yuv420p -i yuv420p_320x240.yuv -pix_fmt rgb24 rgb24_320x240_2.rgb
```

## 2.4.ffmpeg命令提取PCM数据
```
ffmpeg -i buweishui.mp3 -ar 48000 -ac 2 -f s16le 48000_2_s16le.pcm # PCM文件的后缀可以是随意的，最好设为pcm。
ffmpeg -i buweishui.mp3 -ar 48000 -ac 2 -sample_fmt s16 out_s16.wav
ffmpeg -i buweishui.mp3 -ar 48000 -ac 2 -codec:a pcm_s16le out2_s16le.wav # out2_s16le.wav与out_s16.wav完全一致
ffmpeg -i buweishui.mp3 -ar 48000 -ac 2 -f f32le 48000_2_f32le.pcm
ffmpeg -i test.mp4 -t 10 -vn -ar 48000 -ac 2 -f f32le 48000_2_f32le_2.p
```
“-f s16le”中的s16le可以通过下面命令查到：
```
ffmpeg -muxers | grep PCM
```



## 2.5.ffmpeg命令转封装

```
◼ 保持编码格式：
ffmpeg -i test.mp4 -vcodec copy -acodec copy test_copy.ts
ffmpeg -i test.mp4 -codec copy test_copy2.ts #  test.mp4中无字幕时，和上面的命令等价
◼ 改变编码格式：
ffmpeg -i test.mp4 -vcodec libx265 -acodec libmp3lame out_h265_mp3.mkv
◼ 修改帧率：
ffmpeg -i test.mp4 -r 15 -codec copy output.mp4 # 由于修改帧率涉及到编解码，所以使用-codec copy将使得帧率没有变化
ffmpeg -i test.mp4 -r 15 output2.mp4
◼ 修改视频码率：
ffmpeg -i test.mp4 -b 400k output_b.mkv # 由于输出为mkv格式，所以音视频会采用mkv格式默认的编码器，故此时音视频可能会被重新编码
◼ 修改视频码率：
ffmpeg -i test.mp4 -b:v 400k output_bv.mkv # 和上述命令完全等价
【注】修改码率只是说修改到400k附近，不一定能修改到400k



```

```
◼ 修改音频码率：
ffmpeg -i test.mp4 -b:a 192k output_ba.mp4
上述命令也会导致video被重新编码，从而导致视频码率的变化。如果不想重新编码video，需要加上-vcodec copy。修改视频码率的时候，音频的码率也有可能发生变化，此时我们可以利用-acodec copy。
◼ 修改音视频码率：
ffmpeg -i test.mp4 -b:v 400k -b:a 192k output_bva.mp4
◼ 修改视频分辨率：
ffmpeg -i test.mp4 -s 480x270 output_480x270.mp4
◼ 修改音频采样率: 
ffmpeg -i test.mp4 -ar 44100 output_44100hz.mp4
```



## 2.6.ffmpeg命令裁剪和合并视频
```
◼ 找三个不同的视频每个视频截取10秒内容
ffmpeg -i 沙海02.mp4 -ss 00:05:00 -t 10 -codec copy 1.mp4
ffmpeg -i 复仇者联盟3.mp4 -ss 00:05:00 -t 10 -codec copy 2.mp4
ffmpeg -i 红海行动.mp4 -ss 00:05:00 -t 10 -codec copy 3.mp4
由于需要将1.mp4、2.mp4和3.mp4合并起来，如果沙海02.mp4、复仇者联盟3.mp4和红海行动.mp4格式不统一时，
则需要强制统一为 -vcodec libx264 -acodec aac。
◼ 将上述1.mp4/2.mp4/3.mp4转成ts格式
ffmpeg -i 1.mp4 -codec copy -vbsf h264_mp4toannexb 1.ts
ffmpeg -i 2.mp4 -codec copy -vbsf h264_mp4toannexb 2.ts
ffmpeg -i 3.mp4 -codec copy -vbsf h264_mp4toannexb 3.ts
◼ 转成flv格式
ffmpeg -i 1.mp4 -codec copy 1.flv
ffmpeg -i 2.mp4 -codec copy 2.flv
ffmpeg -i 3.mp4 -codec copy 3.flv
分离某些封装格式（例如MP4/FLV/MKV等）中的H.264的时候，需要首先写入
SPS和PPS，否则会导致分离出来的数据没有SPS、PPS而无法播放。H.264码流
的SPS和PPS信息存储在AVCodecContext结构体的extradata中。需要使用ffmpeg
中名称为“h264_mp4toannexb”的bitstream filter处理
```

## 2.7.ffmpeg命令图片和视频转换
```
◼ 截取一张图片
ffmpeg -i test.mp4 -y -f image2 -ss 00:00:02 -vframes 1 -s 640x360 test.jpg
ffmpeg -i test.mp4 -y -f image2 -ss 00:00:02 -vframes 1 -s 640x360 test.bmp
    -i 输入
    -y 覆盖
    -f 格式
    image2 一种格式
    -ss 起始值
    -vframes 1：输出一帧。如果大于1，那么输出加%03d，即test%03d.jpg，即输出的图片按testxxx.jpg进行编号，如test001.jpg 
    -s 格式大小size
◼ 转换视频为图片（每帧一张图):
ffmpeg -i test.mp4 -t 5 -s 640x360 -r 15 frame%03d.jpg 
-t 5：对视频的五秒进行操作，每秒十五帧（-r 15）

◼ 图片转换为视频:
ffmpeg -f image2 -i frame%03d.jpg -r 25 video.mp4

◼ 从视频中生成GIF图片
ffmpeg -i test.mp4 -t 5 -r 1 image1.gif
ffmpeg -i test.mp4 -t 5 -r 25 -s 640x360 image2.gif
◼ 将 GIF 转化为 视频
ffmpeg -f gif -i image2.gif image2.mp4
```





视频学习，学到的东西总是基础的。我们还是需要学会使用官方文档
]]></description></item><item><title>jsoncpp使用</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/06/06/16350049.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Mon, 06 Jun 2022 14:44:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/06/06/16350049.html</guid><description><![CDATA[jsoncpp源码位置：https://github.com/open-source-parsers/jsoncpp

# 1.jsoncpp简介
jsoncpp是一个用来存储键值对的库。
键值对的值可以是双引号包起来的字符串、数、布尔类型、null、对象或者数组
上面所说的大家都很熟悉，只有最后两个是比较特殊的：
对象：这里对象的概念和C++中对象的概念不一样，这里的对象指的是用{}括起来的多个键值对组成的集合。一个对象由花括号{}包起来，每一个键：值之间用逗号, 隔开，如 {“name”: Any, “age”:18}
数组：一个数组由中括号[]包起来，每一个键：值之间用逗号, 隔开，如 [“friend1”: William, “friend2”: Austy]
也就是说对象和数组都是键值对的集合，只是一个用{}，一个用[]。

**jsoncpp中含有三种基础类：Value、Write、Reader。**
1. Json::Value：用于存储键值对
2. Json::Writer
这个类负责将内存中的value对象转换为json文档，输出到文件或者字符串中
它有两种主要的方法：FastWriter、StyledWriter
FastWriter：快速无格式的将value转换成json文档
StyledWriter：有格式的将value转换成json文档
3. Json::Reader
用于读取json文档，或者说是用于将字符串或者文件输入流转换为Json::Value对象

**实用函数**
1. 判断某个键是否存在
bool Json::Value::isMember(const char *key) const;
若存在则返回1，反之为0
2. 得到Value中的所有键
Json::Value::getMemberBames() const;
返回一个string类型的vector
3. 删除某个键
Json::Value::removeMember(const char *key);
返回删除的值或者null







# 2.下载安装jsoncpp
首先下载项目https://github.com/open-source-parsers/jsoncpp，我们需要的文件有include/json/和src/lib_json，将这两个文件夹复制到同一目录下，结构如下：
```
lib_json/
  CMakeLists.txt 【这个文件没用，可以删了】
  json_reader.cpp
  json_tool.h
  json_value.cpp
  json_valueiterator.inl
  json_writer.cpp

json/
  allocator.h
  assertions.h
  config.h
  forwards.h
  json.h
  json_features.h
  reader.h
  value.h
  version.h
  writer.h
```

然后在json/目录下创建json.hpp，并include include/json/下所有头文件，内容如下：
```
#ifndef JSON_HPP_INCLUDED
#define JSON_HPP_INCLUDED

#include "allocator.h"
#include "writer.h"
#include "version.h"
#include "value.h"
#include "reader.h"
#include "json.h"
#include "json_features.h"
#include "forwards.h"
#include "config.h"
#include "assertions.h"

#endif // JSON_HPP_INCLUDED
```
然后我们就可以使用jsoncpp。


在lib_json/目录下创建test.cpp，内容如下：
```
#include <iostream>
#include <fstream>
#include "../json/json.hpp"

#if defined(__GNUC__)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#elif defined(_MSC_VER)
#pragma warning(disable : 4996)
#endif

using namespace std;

int createjson()
{
    Json::Value root;
    Json::Value language;
    Json::Value mail;
    Json::StyledWriter writer;
    // Json::FastWriter writer;

    root["Name"] = "pikashu";
    root["Age"] = 18;

    language[0] = "C++";
    language[1] = "Python";
    root["Language"] = language;

    mail["QQ"] = "789123456@qq.com";
    mail["Google"] = "789123456@gmail.com";
    root["E-mail"] = mail;

    string json_file = writer.write(root);

    ofstream ofs;
    ofs.open("test1.json");
    if (!ofs.is_open())
    {
        cout << "open file error." << endl;
        return -1;
    }
    ofs << json_file;
    ofs.close(); 
    return 0;
}

int readjson()
{
    Json::Reader reader;
    Json::Value root;
    Json::Value language;
    Json::Value mail;

    ifstream ifs;
    ifs.open("test1.json");
    if (!ifs.is_open())
    {
        cout << "open file error." << endl;
        return -1;
    }

    if (!reader.parse(ifs, root))
    {
        cout << "parse error" << endl;
        return -1;
    }

    string Name = root["Name"].asString();
    int Age = root["Age"].asInt();  // jsoncpp中获取int类型数据
    cout << "Name: " << Name << endl;
    cout << "Age: " << Age << endl;

    if (root["language"].isArray())
    {
        Json::Value array_l = root["language"];
        cout << "Language: ";
        for (int i = 0; i < array_l.size(); i++)
        {
            cout << array_l[i] << " ";
        }
        cout << endl;
    }

    cout << "Google: " << root["E-mail"].get("Google", "").asString() << endl;
    cout << "QQ: " << root["E-mail"].get("QQ", "").asString() << endl;

    return 1;
}
int main()
{
    createjson();
    readjson();
    return 0;
}
```
运行命令：
```
g++ json_reader.cpp json_value.cpp json_writer.cpp  test.cpp  -o result
./result
```
结果：
```
Name: pikashu
Age: 18
Google: 789123456@gmail.com
QQ: 789123456@qq.com
```
参考：[JSONCPP安装及学习使用](https://blog.csdn.net/qq_44299067/article/details/121929266)
其他jsoncpp安装方法自行百度。
]]></description></item><item><title>c++ mysql使用</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/06/06/16349594.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Mon, 06 Jun 2022 12:31:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/06/06/16349594.html</guid><description><![CDATA[# 1.安装mysql和启动
本人采用源码方式进行安装，请参考：[链接](https://blog.csdn.net/weixin_42973678/article/details/100107986)

一些说明：
**1.用户组与用户**
```
groupadd mysql # 创建用户组
useradd -g mysql mysql # 创建用户mysql，并将用户mysql指定给用户组mysql。-g指定用户组，后面跟着用户名。
mkdir /usr/local/mysql/data
chown -R mysql /usr/local/mysql # 修改文件和目录的所属用户。-R处理指定目录以及其子目录下的所有文件
chgrp -R mysql /usr/local/mysql # chgrp命令:修改文件和目录的所属组
```

**2.oracle与mysql**
oracle数据库中有多个用户，每个用户多张表
MySQL数据库只有一个用户(root), 有多个数据库,每个数据库下有多张表。【这里的root用户不是指linux下的root用户，而是指mysql中有一个称为root的用户】

**3.启动mysql：**
```
systemctl  restart mysqld # 重启MySQL服务

systemctl  status mysqld  # 查看MySQL服务状态

systemctl stop mysqld  # 停止MySQL服务

systemctl start mysqld # 启动MySQL服务

# 登录MySQL数据库有以下两种方法：
sudo mysql 
# 或
mysql -u root -p
```

# 2.CURD 
## 2.1.数据库CURD 

对数据库进行增(Create)、改(Update) 、查(Retrieve) 、删(Delete)操作。

### 2.1.1.创建数据库
```
CREATE {DATABASE | SCHEMA} [IF NOT EXISTS] db_name
    [create_specification [, create_specification] ...]
```
- IF NOT EXISTS 表示只有数据库不存在的时候才创建，如果存在同名就不再执行该语句
- Create specification是建库的一些选项

下面时创建数据库的一些实例：
```
1)创建一个名称为mydb1的数据库。
create database mydb1;
2)创建一个使用utf-8字符集的mydb2数据库。
create database mydb2 character set utf8;
3)创建一个使用utf-8字符集，并带校对规则的mydb3数据库，校对规则会对存入的数据进行检查。
create database mydb3 character set utf8 collate utf8_general_ci;
```

### 2.1.2.查看数据库
```
show databases; # 显示所有数据库
show create database mydb2;  # 显示创建数据库时使用的语句信息
 “ ` ”（ESC键 下面的按键），表示反引号，默认情况下，反引号括起来的字符串，区分大小写。

show create database mydb1;
注意 ：mysql默认语言集是latin1，每次在创建数据库的时候应指定字符集。Oracle是在安装时，即指定了字符集。
```

### 2.1.3.修改和删除数据库
```
alter database mydb1 character set utf8; # 修改mydb1的字符集为utf8(不能修改数据库名) 

drop database mydb3; # 删除数据库mydb3
```



## 2.2.表的CURD
对表本身进行操作：创建，查看，修改，删除

### 2.2.1.创建表
```
use mydb2; # 在mysql中对表操作前，必须先选择所使用的数据库。
show tables; # 查看表的内容
show create table t1; # 查看创建表的语法。ENGINE=InnoDB 默认指定的存储引擎 innoDB。
```

mysql中的数据类型：

![](https://img2022.cnblogs.com/blog/1617829/202206/1617829-20220606201854083-2026900352.png)

- bit     1位　	可以指定位数，如：bit(3)
- int     2字节 	可以指定最大位数，如：int<4>　最大为4位的整数
- float   2个字节　可以指定最大的位数和最大的小数位数，如：float<5,2> 最大为一个5位的数，小数位最多2位 
- double　4个字节　可以指定最大的位数和最大的小数位数，如：float<6,4> 最大为一个6位的数，小数位最多4位
- char　  必须指定字符数,如char(5) 为不可变字符　即使存储的内容为'ab',也是用5个字符的空间存储这个数据
- varchar　必须指定字符数,如varchar(5) 为可变字符　如果存储的内容为'ab',占用2个字符的空间；如果为'abc',则占用3个字符的空间
- text: 大文本(大字符串)
- blob：二进制大数据　如图片，音频文件，视频文件
- date: 日期　如：'1921-01-02'
- datetime: 日期+时间　如：'1921-01-02 12:23:43'
- timeStamp: 时间戳，自动赋值为当前日期时间

创建一个员工表：
```
create table employee(empno int, ename varchar(20), sal int);
show create table employee;  # 查看创建employee表时使用了什么命令
```

### 2.2.2.查看表
```
show tables; # 查看所有的表
show create table employee; # 查看指定表的创建语句 # 注意，mysql表名称区分大小写, 对列名不区分大小写
desc employee; # 显示指定表的结构：
```
### 2.2.3.修改表
```
更改表名：    rename table employee to worker;
增加一个字段： alter table employee add column height double;  （column关键字在Oracle中，添加则语法错误）
修改一个字段：alter table employee modify column height float;
删除一个字段：alter table employee drop column height;
修改表的字符集:alter table employee character set gbk;
show create table employee; # 从这里可以查看修改表的字符集的结果
```

### 2.2.4.删除表
```
删除employee表:
drop table employee;	 (MySQL中不能使用purge，添加会出现语法错误)
```


## 2.3.表数据的CURD	

### 2.3.1.create数据
```
创建一个员工表，新建employee表并向表中添加一些记录：
create table employee(
id int,
name varchar(20),
sex int,
birthday date,
salary double,
entry_date date,
resume text
);
insert into employee values(1,'张三',1,'1983-04-27',15000,'2012-06-24','一个大牛');
insert into employee(id,name,sex,birthday,salary,entry_date,resume) values(2,'李四',1,'1984-02-22',10000,'2012-07-24','一个中牛');
insert into employee(id,name,sex,birthday,salary,entry_date,resume) values(3,'王五',0,'1985-08-28',7000,'2012-08-24','一个小虾');
```

### 2.3.2	update数据 
```
将所有员工薪水都增加500元。
update employee set salary=salary+500;
将王五的员工薪水修改为10000元，resume改为也是一个中牛
update employee set salary=10000, resume='也是一个中牛' where name='王五';
```

### 2.3.3.delete数据 
```
删除表中姓名为王五的记录。
delete from employee where name='王五';		【注意from不能省略】
删除表中所有记录。
delete from employee; 
使用truncate删除表中记录。
truncate table employee;--无条件 效率高
```

### 2.3.4.Retrieve数据
```
查询员工的年收入：
	select id, name as "名字", salary "月薪", salary*12 年薪  from employee where id >=2;
```




# 3. c语言连接mysql数据库
## 3.1.找到所需的头文件和库文件

找到头文件mysql.h和库文件libmysqlclient.a
1. 找到对应的头文件

   >[root@deng ~]# locate mysql.h
   >**/usr/include/mysql/mysql.h**  <---对应的头文件
   >/usr/share/doc/rsyslog-5.8.10/ommysql.html
   >/usr/share/doc/rsyslog-5.8.10/rsyslog_mysql.html

2. 找到对应的库文件

   >[root@deng ~]# locate libmysqlclient.a
   >**/usr/lib64/mysql/libmysqlclient.a**  # .a文件代表静态库    


## 3.2.编程步骤

1. 通过调用mysql_init()初始化连接处理程序，得到句柄
2. 通过调用mysql_real_connect()连接到服务器。
3. 发出SQL语句并处理其结果。
4. 通过调用mysql_close()，关闭与MySQL服务器的连接。



## 3.3.初始化和连接到MySQL

mysql_init函数

```C
MYSQL *mysql_init(MYSQL *mysql) 
功能:
	分配或初始化与mysql_real_connect()相适应的MYSQL对象。如果mysql是NULL指针，该函数将分配、初始化、并返回新对象。
        否则，将初始化对象，并返回对象的地址。如果mysql_init()分配了新的对象，当调用mysql_close()来关闭连接时。将释放该对象。

参数:
	mysql: 一般填写NULL, 会自动分配 初始化和返回对象

返回值:
	初始化的MYSQL*句柄。如果无足够内存以分配新的对象，返回NULL。
	
	
```



mysql_close函数:

```C
void mysql_close(MYSQL *mysql) 
功能:
	关闭前面打开的连接。如果句柄是由mysql_init()或mysql_connect()自动分配的，mysql_close()还将解除分配由mysql指向的连接句柄
	
参数:
	mysql:  是mysql_init的返回值

返回值:
	无
```



mysql_real_connect函数

```C
MYSQL *mysql_real_connect(MYSQL *mysql, const char *host, const char *user, const char *passwd, 
                        const char *db, unsigned int port, const char *unix_socket, unsigned long client_flag) 

功能:
	mysql_real_connect()尝试与运行在主机上的MySQL数据库引擎建立连接。在你能够执行需要有效MySQL连接句柄结构的任何其他API函数
        之前，mysql_real_connect()必须成功完成。

参数:
	mysql: mysql_init返回值, 初始化好的句柄
	host: 主机名或IP地址
	user: 数据库用户名
	passwd: 数据库对应用户名的密码
	db: 数据库名称
	port: 0表示使用默认的端口
	unix_socket: 一般填写NULL
	client_flag: 通常为0

返回值:
	如果连接成功，返回MYSQL*连接句柄。如果连接失败，返回NULL。对于成功的连接，返回值与第1个参数的值相同。

```



测试代码:

```C
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <mysql/mysql.h>

#define _HOST_ "127.0.0.1"
#define _USER_ "root"
#define _PASSWD_ "123456"
#define _DB_ "scott"

//初始化  关闭
int main(void)
{
    MYSQL *mysql = NULL;

    //1. 初始化一个句柄
    mysql = mysql_init(NULL);
    if (NULL == mysql)
    {
        printf("mysql_init failed...\n"); 
        return 1;
    }
    printf("mysql_init ok....\n");

    
    //2. 连接mysql数据库
    mysql = mysql_real_connect(mysql, _HOST_, _USER_, _PASSWD_, _DB_, 0, NULL, 0); 
    if (NULL == mysql)
    {
        printf("连接mysql数据库失败...\n"); 
    }
    else
    {
        printf("连接mysql数据库成功....\n"); 
    }


    //3. 关闭连接
    mysql_close(mysql);    

    return 0;
}

```

编译方法:
```
gcc testMysql.c -I  /home/xxx/software/mysql_5_7/include/ -L  /home/xxx/software/mysql_5_7/lib/ 
        -l mysqlclient -Wl,-rpath=/home/xxx/software/mysql_5_7/lib/
```
/home/xxx/software/mysql_5_7为mysql的安装路径（我使用的是源码安装的方法）




## 3.4.执行SQL语句(增删改查)

mysql_query函数

```C
int mysql_query(MYSQL *mysql, const char *query) 
功能:
	执行由“Null终结的字符串”查询指向的SQL查询。正常情况下，字符串必须包含1条SQL语句，而且不应为语句添加终结分号（‘;’）或
        “\g”。如果允许多语句执行，字符串可包含多条由分号隔开的语句

参数:
	mysql: 是mysql_real_connect连接成功之后的句柄
	query: 对应的SQL语句
	
返回值:
	如果查询成功，返回0。如果出现错误，返回非0值。 

```
执行插入的代码:

```c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <mysql/mysql.h>

#define _HOST_ "192.168.73.36"
#define _USER_ "root"
#define _PASSWD_ "123456"
#define _DB_ "scott"

#define SIZE 128

//初始化  关闭
int main(void)
{
    int ret = -1;

    MYSQL *mysql = NULL;

    char buf[SIZE];

    //1. 初始化一个句柄
    mysql = mysql_init(NULL);
    if (NULL == mysql)
    {
        printf("mysql_init failed...\n"); 
        return 1;
    }
    printf("mysql_init ok....\n");

    
    //2. 连接mysql数据库
    mysql = mysql_real_connect(mysql, _HOST_, _USER_, _PASSWD_, _DB_, 0, NULL, 0); 
    if (NULL == mysql)
    {
        printf("连接mysql数据库失败...\n"); 
    }
    else
    {
        printf("连接mysql数据库成功....\n"); 
    }

    //3. 执行SQL语句
    memset(buf, 0, SIZE);
    strcpy(buf, "insert into dept values(3, '3name', '3loc')");
    ret = mysql_query(mysql, buf);
    if (0 != ret)
    {
        printf("mysql_query failed....\n"); 
    }
    else
    {
        printf("执行SQL语句ok....\n");
    }


    //4. 关闭连接
    mysql_close(mysql);    

    return 0;
}
```
其他操作自己看手册，或者百度。























# C++链接数据库
C++使用Connector/C++连接数据库
[链接](https://blog.csdn.net/hbtj_1216/article/details/51168596)








学会使用官方提供的文档
]]></description></item><item><title>ffmpeg 文档阅读笔记</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/06/05/16344239.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Sun, 05 Jun 2022 08:19:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/06/05/16344239.html</guid><description><![CDATA[# 1.ffmpeg简介
## 1.1.命令格式
```
ffmpeg [global_options] {[input_file_options] -i input_url} ... {[output_file_options] output_url} ...
```
-i：指定输入。输入可以是视频文件、网络流、音视频设备等。可以使用-i指定任意数量的输入。
输出：命令行上任意不能被解释成选项的东西，都被认为是输出。可以有任意数量的输出。
-map：一条ffmpeg命令中，可能有多个输入和输出。-map指定哪个输入对应哪个输出。如果没有使用-map进行指定，那么会使用默认的方法进行指定

-i后面跟索引，索引值从0开始。2:3代表第三个输入文件的第四个流。【不懂？？】

ffmpeg的每个选项按顺序对输入进行操作，即选项对输入进行操作的结果，送给下一个选项进行操作，故ffmpeg的选项的顺序很重要。全局选项（例如 verbosity level）是个例外，全局选项的位置不重要，但是一般放在最前面。

选项都只应用于最先遇到的文件。

## 1.2.ffmpeg的处理流程
```
 _______              ______________
|       |            |              |
| input |  demuxer   | encoded data |   decoder
| file  | ---------> | packets      | -----+
|_______|            |______________|      |
                                           v
                                       _________
                                      |         |
                                      | decoded |
                                      | frames  |
                                      |_________|
 ________             ______________       |
|        |           |              |      |
| output | <-------- | encoded data | <----+
| file   |   muxer   | packets      |   encoder
|________|           |______________|

```
使用libavformat库读取输入文件，获取到encoded data packets。When there are multiple input files, ffmpeg tries to keep them synchronized by tracking lowest timestamp on any active input stream.【这句英文看不懂】
decoder产生未压缩的帧（(raw video/PCM audio/...），然后可以进行filtering




# 2.Filtering

使用libavfilter库中的filter对decoder产生未压缩的帧进行处理，多个filter形成一个filter graph。filter分为simple和complex


## 2.1.Simple filtergraphs
Simple filtergraphs结构如下：
```
 _________                        ______________
|         |                      |              |
| decoded |                      | encoded data |
| frames  |\                   _ | packets      |
|_________| \                  /||______________|
             \   __________   /
  simple     _\||          | /  encoder
  filtergraph   | filtered |/
                | frames   |
                |__________|
```

通过-vf和-af分别指定视频和音频的filter



## 2.2. Complex filtergraphs
Complex filtergraphs结构如下
```
 _________
|         |
| input 0 |\                    __________
|_________| \                  |          |
             \   _________    /| output 0 |
              \ |         |  / |__________|
 _________     \| complex | /
|         |     |         |/
| input 1 |---->| filter  |\
|_________|     |         | \   __________
               /| graph   |  \ |          |
              / |         |   \| output 1 |
 _________   /  |_________|    |__________|
|         | /
| input 2 |/
|_________|

```
通过-lavfi指定Complex filtergraphs，-lavfi是一个全局选项


# 3.Stream copy

-codec copy 复制原始的编码规则，过程如下：
```
 _______              ______________            ________
|       |            |              |          |        |
| input |  demuxer   | encoded data |  muxer   | output |
| file  | ---------> | packets      | -------> | file   |
|_______|            |______________|          |________|

```
可以看到略过了decode和encode阶段



# Stream selection

-map：应该是用于控制哪个输入映射到哪个输出

-vn / -an / -sn / -dn分别使得视频、音频、字幕和数据流不输出


不采取-map时，自动采取什么样的流选择（从哪个输入映射到哪个输出称为流选择）

流包括视频、音频、字幕和数据（video, audio, subtitle and data streams）

没有-map时，默认采取以下措施：
检查输出格式是否包含video, audio，subtitles

选择视频中最高分辨率的视频
选择通道最多的音频
选择第一个字幕，并返回一个警告
参数相同时，选择索引最低的流
数据流不会被自动选择，需要使用-map指定


当-map被使用的时，输出文件就只包含-map指定的流。filtergraph outputs是个例外，

complex filtergraph output streams with unlabeled pads都会被添加到第一个输出文件中。 This will lead to a fatal error if the stream type is not supported by the output format. In the absence of the map option, the inclusion of these streams leads to the automatic stream selection of their types being skipped. If map options are present, these filtergraph streams are included in addition to the mapped streams.（看不懂）

Complex filtergraph output streams with labeled pads必须被map一次且只能一次


Stream handling独立于流选择，除了下面的字幕描述
Stream handling通过设置选项-codec实现`

stream selection之后，进行Stream handling

没有-codec选项，将使用the output file muxer的默认encoder



An exception exists for subtitles. If a subtitle encoder is specified for an output file, the first subtitle stream found of any type, text or image, will be included. ffmpeg does not validate if the specified encoder can convert the selected stream or if the converted stream is acceptable within the output format. This applies generally as well: when the user sets an encoder manually, the stream selection process cannot check if the encoded stream can be muxed into the output file. If it cannot, ffmpeg will abort and all output files will fail to be processed.（看不懂，为什么都没有实例说明，这他妈时官方文档吗？？？）



```bash
假设输入文件如下：
input file 'A.avi'
      stream 0: video 640x360
      stream 1: audio 2 channels

input file 'B.mp4'
      stream 0: video 1920x1080
      stream 1: audio 2 channels
      stream 2: subtitles (text)
      stream 3: audio 5.1 channels
      stream 4: subtitles (text)

input file 'C.mkv'
      stream 0: video 1280x720
      stream 1: audio 2 channels
      stream 2: subtitles (image)

命令：
ffmpeg -i A.avi -i B.mp4 out1.mkv out2.wav -map 1:a -c:a copy out3.mov

out1.mkv是Matroska container file，可以包含视频、音频和字幕文件。
    For video, it will select stream 0 from B.mp4, which has the highest resolution among all the input video streams.
    For audio, it will select stream 3 from B.mp4, since it has the greatest number of channels.
    For subtitles, it will select stream 2 from B.mp4, which is the first subtitle stream from among A.avi and B.mp4.

out2.wav：accepts only audio streams, so only stream 3 from B.mp4 is selected.
    
out3.mov
    -map 1:a   1代表选择第二个输入文件B.mp4;   a代表选择B.mp4中的所有音频文件。

out1.mkv和out2.wav使用了输出格式默认的编码器
out3.mov使用了copy到的编码器
```
]]></description></item><item><title>ffmpeg安装和基本使用</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/06/02/16339225.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Thu, 02 Jun 2022 14:36:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/06/02/16339225.html</guid><description><![CDATA[# 1.FFmpeg简介

# 1.1.FFMPEG下载编译与安装
直接参考这篇文章[ubuntu20源码编译安装ffmpeg](https://blog.csdn.net/H_Zhang/article/details/123684216)。


## 1.2.ffmpeg库文件的说明
libavformat：用于各种音视频封装格式的生成和解析

libavutil：libavutil库是一个工具库，以辅助多媒体编程。

libavcodec：libavcodec 库提供通用编码/解码框架，并包含用于音频，视频和字幕流的多个解码器和编码器，以及多个比特流滤波器。实现了市面上可见的绝大部分解码器的功能， libavcodec 库被其他各大解码器 ffdshow， Mplayer 等所包含或应用。

libavdevice：提供了一个通用框架，用于从许多常见的多媒体输入/输出设备抓取和渲染，并支持多个输入和输出设备，包括 Video4Linux2，VfW，DShow和ALSA，AUDIO_BEOS，JACK,OSS,1394。

libavresample：对音频进进行重采样

libavfilter：通用的音视频后处理库，亦即音频/视频过滤框架（FileIO、 FPS、 DrawText），提供了宽高比 裁剪 格式化 非格式化 伸缩，及噪音处理等处理操作。

libswresample：原始音频格式转码。执行高度优化的音频重采样，重新矩阵化和样本格式转换操作。该libswresample库进行高度优化的音频采样，rematrixing和采样格式转换操作。

libswscale：（原始视频格式转换） 用于视频场景比例缩放、色彩映射转换；图像颜色空间或格式转换，如 rgb565、rgb888 等与 yuv420 等之间转换。

上面对库文件进行了简单的介绍，具体可参考[ffmpeg自学路(三)ffmpeg各项库说明，及build.sh的shell相关命令说明](https://blog.csdn.net/u014436704/article/details/106763235)





## 1.3.工具集
ffmpeg：该项目提供的一个工具，可用于格式转换、解码或电视卡即时编码等。
ffsever：一个 HTTP 多媒体即时广播串流服务器。
ffplay：是一个简单的播放器，使用 ffmpeg 库解析和解码，通过 SDL 显示。
ffprobe：多媒体侦测   






# 2.FFmpeg处理音视频流程

那电影的实质就是N多张图片的集合。事实上，如果一部影片里面的图片，我们原封不动的全部存起来，空间会很大很大很大，但是如果通过一定的算法（这里不讲相关算 法），把每一张图片压缩（编码_encode）一下，变成帧。再把帧连起来变成流，再把不同的流放到某个容器里面，这就是我们平常看见的电影文件了。

FFmpeg处理音视频流程：
![](https://img2022.cnblogs.com/blog/1617829/202206/1617829-20220603140307930-929200316.png)

输入文件：如mp4、flv
编码数据包：从mp4中提取出来的音频和视频等数据
解码后的数据帧：编码数据包中数据都是压缩过的，所以需要进行解码。然后我们就可以对解码后的数据进行各种各样的处理。处理完之后，重新进行encoder和muxer。

实例：
- 720p视频转480p视频：首先将720p视频解码成数据帧，然后对数据帧进行处理，最后再封装成视频。故需要经过FFmpeg处理音视频的全部流程。
- mp4转flv：首先将mp4文件demuxer成编码数据包，然后直接将编码数据包muxer成flv文件。故不需要经过FFmpeg处理音视频的全部流程。从这个例子可以看出，我们不一定需要经过FFmpeg处理音视频的全部流程。

```
ffmpeg -i test_1920x1080.mp4 -acodec copy -vcodec libx264 -s 1280x720 test_1280x720.flv
```
上述命令在ffmpeg基本流程中：
![](https://img2022.cnblogs.com/blog/1617829/202206/1617829-20220609160604039-446838161.png)

libx264代表采用x264进行视频编码，
copy代表音频直接copy原来的，copy命令代表就没有经过decode和encode，只经历的demuxe和muxe






# 3.ffmpeg常用命令
ffmpeg常用命令可以分为八类：
- 基本信息查询命令
- 录制命令
- 分解/复用命令
- 处理原始数据命令
- 裁剪与合并命令
- 图片/视频互转命令
- 直播相关命令
- 各种滤镜命令




## 3.1.基本信息查询命令

![](https://img2022.cnblogs.com/blog/1617829/202206/1617829-20220609155138232-1447170069.png)

结合FFmpeg处理音视频流程来记上面的命令。
一些命令的补充解释：
-devices：查询系统中可用摄像头和音频设备
-bsfs：ffmpeg支持处理比特流的信息，此命令用于查询支持哪些比特流。
-protocols：ffmpeg支持处理网络文件，此命令用于查询支持哪些协议
-filters：比如加水印、去水印
-pix_fmts：查询可用哪些格式存储图片
-sample_fmts：使用多少位来存储一个采样，如8位、16位、 32位（浮点型）
-layouts：如双声道、单声道、立体声（三个声道以上称为立体声）



## 3.2.录制命令
ffmpeg命令结构：
```
ffmpeg [options] [[infile options] -i infile]... {[outfile options] outfile}...
```


录制屏幕：
```
ffmpeg -video_size 1920x1080 -framerate 25 -f x11grab -i :0.0+0,00 output.mp4
```
-f x11grab：使用桌面录制工具x11grab录制桌面
-video_size：指定分辨率，即将屏幕上的多大一块录制下来
-framerate 25：帧率25，即每秒展示25帧图像。
-i :0.0+0,00 ：-i是用来指定输入设备，带冒号的代表是音频设备（:0.0+0），没有冒号的代表是视频设备（00）。 【本段是我猜的】



## 3.3.分解与复用

分解与复用：不同视频格式的转换、音频和视频的分离，分离出来是mp3、H264等未解码的数据。

```
ffmpeg -i out.mp4 -vcodec copy -acodec copy out.flv
ffmpeg -i out.mp4 -vn -acodec copy out.aac  # 如果没有音频就会出现错误
ffmpeg -i out.mp4 -vcodec copy -an out.h264 # 如果没有视频就会出现错误
```
-vcodec copy：复制原来的视频数据
-acodec copy：复制原来的音频数据
-vn：不需要视频
-an：不需要音频




## 3.4.处理原始数据命令
处理原始数据命令：就是指处理PCM和YUV格式的数据
```
# FFmpeg提取YUV数据
ffmpeg -i input.mp4 -an -c:v rawvideo -pix_fmt yuv420p out.yuv
-c:v rawvideo  ： -c:v代表对视频进行编码；rawvideo代表原始视频
-pix_fmt：指定像素格式 
```
以上编码得到的是视频out.yuv根本无法通过ffplay播放，且ffplay根本没有-s选项
















# 其他
项目的目录：
首先利用git建立版本管理，然后创建以下四个目录：
src：源码
bin：可执行文件
lib：库文件
doc：说明文档










为什么我觉得拿git做版本管理很不好用？？？？]]></description></item><item><title>音视频基础知识</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/06/01/16335745.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Wed, 01 Jun 2022 13:16:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/06/01/16335745.html</guid><description><![CDATA[# 1.视频编码

## 1.1.音视频处理流程
1.封装：将音视频读出来并封装成相应的格式
2.解码：解压
3.重采样：将视频和音频转换成显卡和声卡支持的形式
4.像素格式：视频需要做像素格式的转换

## 1.2.MPEG-4
MPEG-4是一套用于音频、视频信息的压缩编码标准
在MPEG-4标准的Part14中描述了MPEG-4格式，在MPEG-4标准的Part15中描述了AVC格式
MPEG-4使用H264作为压缩算法。


## 1.3.封装格式(也叫容器)

封装格式(也叫容器）就是将已经编码压缩好的视频流、音频流及字幕按照一定的方案放到一个文件中，便于播放软件播放。
一般来说，视频文件的后缀名就是它的封装格式。

封装的格式不一样，后缀名也就不一样。不同的封装格式，应用在不同的场景下，如mp4常用于本地存储，flv常用于网络传输。



常用封装格式:
AVI：压缩标准可任意选择。可以没有压缩，这样会导致文件很大。早期用的比较多。
FLV（直播等）、ts（电视）、ASF：流媒体格式
mp4

H264+AAC封装为FLV或MP4是最为流行的模式。

## 1.4.常用编码格式（压缩算法）
**视频：**
H264 、wmv、XviD：分析前后帧进行运动补偿，从而实现视频的压缩。拖动使用这种压缩方法的视频的进度条的时候，如果停到非关键帧的地方可能会播放失败【我们平常拖动没出问题，是因为播放器已经对这个问题进行了处理。如果我们自己设计播放器的时候，一定要注意这个问题】。
mjpeg：每一帧都是独立的，压缩率比较低。常在摄像机中看到。

**音频：**
acc、MP3、ape、flac、PCM：现在视频中的音频主要使用acc进行编码。acc和MP3是有损压缩，ape和flac是无损压缩，所以ape和flac编码的音频声音质量比较好。PCM是原始音频


因为音频相对视频会比较小，所以音频可以不压缩，但视频一般都需要进行压缩。

常用视频压缩算法：
```
MPEG2	MPEG阵营
H264		MPEG阵营
H265		MPEG阵营
AVS   		中国阵营
VP8    	Google阵营
VP9    	Google阵营
```




## 1.5.封装结构
每一个视频都采取下面这种封装的结构。

![](https://img2022.cnblogs.com/blog/1617829/202206/1617829-20220601203750503-1661202360.png)

不同的封装格式决定了视频帧和音频帧的编码方式。

封装格式(格式头)：mp4、FLV、AVI等。比如mp4中使用box来保存音视频信息(编码和格式、关键帧索引)。FFmpeg可以解码没有格式头的视频文件，FFmpeg会自动进行探测，使用什么方式可解析出帧，就用什么方式。

视频编码帧：视频编码帧中包含压缩的方式，我们可以根据压缩方式进行解码，比如H264一般解码成YUV格式【Y表示灰度（亮度），UV表示色度。黑白电视只传输Y就可以】。我们在将H264转换成YUV格式之后是没有办法显示的，需要将YUV格式的图像转换成RGB才能显示。经过H264——>YUV——>RBG以后得到的图片会比较大。

音频编码帧：这里以aac解码进行说明。
aac解码之后，变成了PCM FLT格式。PCM代表原始音频，FLT代表音频使用float进行保存，使用float保存音频是为了方便编码和解码时候做浮点运算。由于float是四个字节，32位，而一般显卡不支持32位浮点运算（除非显卡超级好），所以需要将PCM FLT格式的音频继续进行转换，转为声卡支持的S16播放（即转成16位）。

视频编码帧解码的开销比音频编码帧解码的开销多很多，以至于音频编码帧解码的开销可以忽略不记。




# 2.图像和音频的存储方式
## 2.1.图像的存储方式
### 2.1.1.RGB与YUV
视频显示的帧都是压缩过的，所以要将帧抽取出来进行显示，就要将帧进行解压。解压出来的图像会比视频中的帧大很多。解压出来的图像可以是下面几种像素格式：RBG、YUV、RGBA。
RGBA：这里的A是透明通道，A我们一般用不到，但是用显卡显示图片的时候，经常要求传入RGBA。
YUV：Y表示灰度（亮度），UV表示色度。我们视频压缩算法都是在YUV图像上进行的。同样存储一个像素点，YUV需要的空间相比RBG更小。

**RBG与YUV的互相转换**
```
// RBG转YUV：
Y = 0.298R + 0.612G + 0.117B;
 
U = -0.168R - 0.330G + 0.498B + 128;
 
V = 0.449R - 0.435G - 0.083B + 128;

// YUV转RBG：
R = Y + 1.4075( V - 128);
 
G = Y - 0.3455( U - 128) - 0.7169( V - 128);
 
B = Y + 1.779( U - 128);
```
libyuv，Google开源的实现各种YUV与RGB间相互转换、旋转、缩放的库。



**3X3RGB图像在内存中的存放方式(连续)：**

![](https://img2022.cnblogs.com/blog/1617829/202206/1617829-20220602095921853-1230503651.png)

注意：为了运算效率，图像的存储可能会采取某些对齐策略。



### 2.1.2.YUV

![](https://img2022.cnblogs.com/blog/1617829/202206/1617829-20220602101703579-1666909601.png)

其中空心圆表示UV（UV是成对出现的），实心圆表示Y。
YUV444：每一个Y都对应一个UV。
YUV422：从图中可以看到YUV和Y间隔出现，这表示每两个亮度共用一个色度。
YUV420：四个Y共用一个UV，这四个Y是上下相邻的四个像素。最常使用的就是YUV420.
YUV420p：这里p是平面的意思，代表Y和UV是分开存放的，比如Y放在一个数组，UV放在一个数组。

YUV格式：有两大类：planar和packed。
- 对于planar的YUV格式，先连续存储所有像素点的Y，紧接着存储所有像素点的U，随后是所有像素点的V。YUV420p属于planar。
- 对于packed的YUV格式，每个像素点的Y,U,V是连续交叉存储的。YUV444、YUV422、YUV420都是属于packed。

![](https://img2022.cnblogs.com/blog/1617829/202206/1617829-20220608144832643-1135271834.png)

除了上面两个大类外，YUV存在多种格式，比如YUV420sp等，不同的YUV格式的数据在存储时的排列顺序是不一样的，在开发的过程中必须非常注意，否则画面会显示不正常。比如花屏，绿屏等现象。

更多介绍请点击:
https://blog.51cto.com/u_7335580/2059670
https://blog.51cto.com/cto521/1944224
https://blog.csdn.net/mandagod/article/details/78605586

计算一张的RGB_888图像的大小，可采用如下方式： 1280×720 * 3 = 2.637 MB，4分钟就达到了15G的容量。 假如是一部90分钟的电影，每秒25帧，则一部电影为 2.637MB90分钟60秒*25FPS= 347.651GB

相较于RGB，我们可以计算一帧为1280×720的视频帧，用YUV420P的格式来表示，其数据量的大小如下：每个像素点需要1.5个YUV来表示，故 1280 * 720 * 1 ＋ 1280 * 720 * 0.5 = 1.318MB 。
如果fps（1秒的视频帧数目）是25，按照一般电影的长度90分钟来计算，那么这部电影用YUV420P的数据格式来表示的话，其数据量的大小就是： 1.318MB * 25fps * 90min * 60s = 173.76GB

故直接将图片存储成视频，那么这样的视频将会是很大，所以一般会按照一定的规则进行压缩。



## 2.2.音频的存储方式

**PCM音频参数：**
- 采样率sample_ rate：采样率越高，采到的数据越多，声音越真实。CD的采样率为44100，一秒采44100次。 
- 通道channels：如左右声道。CD的采样率为44100，两个声道总的采样率为88200
- 样本大小sample_size(采样格式)：一个声音用多少位的格式来存储，有如下两个方式
AV_SAMPLE_FMT_S16：16位
AV_SAMPLE_FMT_FLTP：32位，一般声卡无法播放32位声音需要转换为16位的声音，即进行重采样处理。

AV_SAMPLE_FMT_S16P：这里p是平面的意思，如在双声道中，将两个声道的数据是分开存放的，一个声道存放在一个数组中。




# 3.MP4标准和h264格式的NAL的GOP分析

## 3.1. MP4格式分析
![](https://img2022.cnblogs.com/blog/1617829/202206/1617829-20220602111400350-1703691725.png)



## 3.2. H.264/AVC视频编码标准
**H.264/AVC视频编码标准包括两层：**  
网络抽象层面(NAL)：格式化数据并提供头信息
视频编码层面(VCL)：视频数据的内容


**NAL单元：**
因此我们平时的每帧数据就是一个NAL单元(SPS与PPS除外【SPS与PPS为参数数据，比如分辨率等】)。在实际的H264数据帧中，往往帧前面带有00 00 00 01或0000 01分隔符, 用分隔符来识别数据的开始和结束。一般来说编码器编出的首帧数据为PPS与SPS，接着为I帧。

**GOP**：GOP是一组帧，可以解码出来播放的一组帧。这组帧必然含有关键帧（I帧）。有关键帧似乎才能解码出视频图像，下面是一个GOP：

![](https://img2022.cnblogs.com/blog/1617829/202206/1617829-20220602142138611-1983326405.png)

**I帧**
I帧称为关键帧，B帧和P帧依赖I帧解码出图像。I帧存储着完整的数据，可以单独解码出来完整的图像。
- I帧图像采用帧内编码方式;
- I帧所占数据的信息量比较大;
- I帧图像是周期性出现在图像序列中的，出现频率可由编码器选择;
- I帧是P帧和B帧的参考帧(其质量直接影响到同组中以后各帧的质量);
- I帧是帧组GOP的基础帧(第一帧),在一组中只有一个I帧，且在GOP中处于第一帧
- I帧不需要考虑运动矢量;

**P帧**
P帧根据本帧与前一帧（I帧或P帧）的不同点来压缩本帧数据，同时利用了空间和时间上的相关性。这里的“前一帧”必须是I帧或P帧，如果P帧的前一帧是B帧，则往前找，直到找到I帧或P帧。


**B帧**
B帧参考前一帧和后一帧解码出图像。故GOP的第一个图像必须为I帧，这样就能保证GOP不需要参考其他图像，可以独立解码。如果关键帧丢失，那么关键帧后面的B和P帧将无法正确解码。

播放到B帧时，由于B帧参考前一帧和后一帧解码出图像，所以解码B帧时，不能立刻进行播放，而是将此B帧缓存，在此B帧的下一帧解码成功后，再回过来处理，才能正确地显示此B帧。 









# 4.一些概念
## 4.1.音视频概念

视频码率：kb/s，是指视频文件在单位时间内使用的数据流量，也叫码流率。码率越大，说明单位时间内取样率越大，数据流精度就越高。比如一秒25帧且存储每帧使用了A kb的存储空间，那么视频码率就是25A kb/s，也称25A kbps【ps指的是/s】

视频帧率：fps，通常说一个视频的25帧，指的就是这个视频帧率，即1秒中会显示25帧。帧率越高，给人的视觉就越流畅。

视频分辨率：分辨率就是我们常说的640x480分辨率、1920x1080分辨率，分辨率影响视频图像的大小。


## 4.2.物理概念

声音是由物体的振动产生的，而振动是一个一上一下的过程，那么如何使用数学的方式描述这样一个一上一下的过程？
答：就是通过下面这种曲线表示。一上一下的过程称为一个周期，曲线的高度表示声音的大小，一个周期宽度代表声音的快慢。

![](https://img2022.cnblogs.com/blog/1617829/202206/1617829-20220608151646968-723517335.png)

声音的频率是周期的倒数，它表示的是声音在1秒钟内的周期数，单位是赫兹(Hz)。千赫(kHz),即1000Hz,表示每秒振动1000次。声音按频率可作如下划分:
次声		              	0～20Hz
 人耳能听见的声音 	20Hz～20KHz
 超声					20KHz～1GHz
 特超声					1GHz～10THz 

为什么人听不到次生和超声呢？
答：听不到次声是因为“动的很慢的物体，我们会感觉它没动”。
听不到超声是因为“动的很快的物体，我们也会感觉它没动”。【这是我自己的理解】

## 4.3.数字音频
### 4.3.1.采样频率

PCM脉冲编码调制：PCM(Pulse Code Modulation)，脉冲编码调制。人耳听到的是模拟信号，PCM是把声音从模拟信号转化为数字信号的技术。简单来说，就是不把左图全部存储下来，而是将存储某几个时间点的振幅。
![](https://img2022.cnblogs.com/blog/1617829/202206/1617829-20220608153002736-185713846.png)

根据Nyguist采样定律，要从采样中完全恢复原始信号波形，采样频率必须至少是信号中最高频率的两倍。就是说平均每个周期要采样至少两次。

前面提到人耳能听到的频率范围是[20H~20kHz]，所以采样频率一般为44.1Khz，这样就能保证声音到达20Khz也能被数字化，从而使得经过数字化处理之后，人耳听到的声音质量不会被降低。


### 4.3.2.采样量化

采样量化（采样精度），就是指一个时间点的振幅用几个bit表示，例如8位量化可以表示256个不同值，而CD质量的16位量化可以表示65536个值。

我们可以直观地将振幅理解为声音的大小，如果用比较多的bit表示一个振幅，那么我们可以听到的声音就越丰富。这就像平时我们调节声音大小一样，如果只有那么几个声音可以调整，那么声音就会不丰富。

```
采样频率：每秒钟采样的点的个数。常用的采样频率有：
22000（22kHz）：	无线广播。
44100（44.1kHz）：CD音质。
48000（48kHz）：	数字电视，DVD。
96000（96kHz）：	蓝光，高清DVD。
192000(192kHz):	蓝光，高清DVD。

采样精度（采样深度）：每个“样本点”的大小，
		常用的大小为8bit， 16bit，24bit。

通道数：单声道，双声道，四声道，5.1声道。

```
### 4.3.3.音频里的其他名词
**比特率**：每秒传输的bit数，单位为：bps（Bit Per Second）
没有压缩的音频数据的比特率 = 采样频率 * 采样精度 * 通道数。
通道数:个人理解,就是同时有个几个设备在进行音频的采样,这样对上面的公式更好理解,最少为1,一般通道数越多,音质越好。

**码率：** 压缩后的音频数据的比特率。常见的码率：
96kbps：FM质量
128-160kbps：一般质量音频。
192kbps：CD质量。
256-320Kbps：高质量音频
	
码率越大，压缩效率越低，音质越好，压缩后数据越大。
码率 = 音频文件大小/时长。

**帧**：每次编码的采样单元数，比如MP3通常是1152个采样点作为一个编码单元，AAC通常是1024个采样点作为一个编码单元。

**帧长：**
- 可以指每帧播放持续的时间：每帧持续时间(秒) = 每帧采样点数 / 采样频率（HZ）
	比如：MP3 48k, 1152个采样点,每帧则为 24毫秒
		1152/48000= 0.024 秒 = 24毫秒；
- 也可以指压缩后每帧的数据大小

**非交错模式：**首先记录的是一个周期内所有帧的左声道样本，再记录所有右声道样本
**交错模式：**数字音频信号存储的方式。数据以连续帧的方式存放，即首先记录**帧**1的左声道样本和右声道样本，再开始帧2的记录...










# 5.音视频录制\播放原理
![](https://img2022.cnblogs.com/blog/1617829/202206/1617829-20220608162404514-1517427702.png)



# 6.音频编码原理简介
数字音频压缩编码在保证信号在听觉方面不产生失真的前提下，对音频数据信号进行尽可能大的压缩，降低数据量。数字音频压缩编码采取去除声音信号中冗余成分的方法来实现。所谓冗余成分指的是音频中不能被人耳感知到的信号，它们对确定声音的音色，音调等信息没有任何的帮助。冗余信息：
- 冗余信号包含人耳听觉范围外的音频信号以及被掩蔽掉的音频信号等。例如，人耳所能察觉的声音信号的频率范围为20Hz～20KHz，除此之外的其它频率人耳无法察觉，都可视为冗余信号。
- 此外，根据人耳听觉的生理和心理声学现象，当一个强音信号与一个弱音信号同时存在时，弱音信号将被强音信号所掩蔽而听不见，这样弱音信号就可以视为冗余信号而不用传送。这就是人耳听觉的掩蔽效应，主要表现在**频谱掩蔽效应**和**时域掩蔽效应**。


## 6.1.频谱掩蔽效应

![](https://img2022.cnblogs.com/blog/1617829/202206/1617829-20220608185339344-561360745.png)

上图中的阈值线表示在这条线以下的声音，人是听不到的。当有另外能量较大的声音出现的时候，该声音频率附近的阈值会提高很多，即所谓的掩蔽效应。如上图，虚线代表阈值，当能量较大的声音在0.2kHz附近出现（黑色柱子）时，该声音频率附近的阈值会提高很多（虚线中凸起的实线部分）。

由图中我们可以看出人耳对2KHz～5KHz的声音最敏感，而对频率太低或太高的声音信号都很迟钝，当有一个频率为0.2KHz、强度为60dB的声音出现时，其附近的阈值提高了很多。由图中我们可以看出在0.1KHz以下、1KHz以上的部分,由于离0.2KHz强信号较远，不受0.2KHz强信号影响,阈值不受影响；而在0.1KHz～1KHz范围，由于0.2KHz强音的出现,阈值有较大的提升，人耳在此范围所能感觉到的最小声音强度大幅提升。如果0.1KHz～1KHz范围内的声音信号的强度在被提升的阈值曲线之下，由于它被0.2KHz强音信号所掩蔽，那么此时我们人耳只能听到0.2KHz的强音信号而根本听不见其它弱信号，这些与0.2KHz强音信号同时存在的弱音信号就可视为冗余信号而不必传送。






## 6.2.时域掩蔽效应

![](https://img2022.cnblogs.com/blog/1617829/202206/1617829-20220608190918846-775982788.png)

当强音信号和弱音信号同时出现时，还存在时域掩蔽效应。即两者发生时间很接近的时候，也会发生掩蔽效应。时域掩蔽过程曲线如图所示，分为前掩蔽、同时掩蔽和后掩蔽三部分。

时域掩蔽效应可以分成三种：前掩蔽，同时掩蔽，后掩蔽。前掩蔽是指人耳在听到强信号之前的短暂时间内，已经存在的弱信号会被掩蔽而听不到。同时掩蔽是指当强信号与弱信号同时存在时，弱信号会被强信号所掩蔽而听不到。后掩蔽是指当强信号消失后，需经过较长的一段时间才能重新听见弱信号，称为后掩蔽。这些被掩蔽的弱信号即可视为冗余信号。


## 6.3.音频编解码器选型
OPUS
MP3
AAC
AC3和EAC3 杜比公司的方案 
[详解音频编解码的原理、演进和应用选型等](https://www.jianshu.com/p/6b4c481f4294)

# 7.音视频同步
DTS（Decoding Time Stamp）：即解码时间戳，这个时间戳的意义在于告诉播放器该在什么时候解码这一帧的数据。
PTS（Presentation Time Stamp）：即显示时间戳，这个时间戳用来告诉播放器该在什么时候显示这一帧的数据。  

**音视频同步方式：**
Audio Master：视频跟随音频的播放速度
Video Master：音频跟随视频的播放速度
External Clock Master：音频和视频都跟随外部时钟
  
音视频同步方式：Audio Master > External Clock Master > Video Master，即优先选择Audio Master方式进行音视频同步。 
]]></description></item><item><title>ubuntu遇到 Err:1 http://cn.archive.ubuntu.com/ubuntu bionic InRelease 报错解决</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/05/29/16324800.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Sun, 29 May 2022 12:26:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/05/29/16324800.html</guid><description><![CDATA[```
# 检查ubuntu的版本，这一步很重要，不同版本的ubuntu使用的更新内容有差别.
cat /etc/issue
 Ubuntu 16.04.5 LTS \n \l
sudo cp /etc/apt/sources.list  /etc/apt/sources.list_save

# 换源
sudo vim /etc/apt/sources.list
# 根据Ubuntu版本，将源文件里的内容全部替换为如下内容：
```
16.04 LTS

```
# 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释
deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial main restricted universe multiverse
# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial main restricted universe multiverse
deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-updates main restricted universe multiverse
# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-updates main restricted universe multiverse
deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-backports main restricted universe multiverse
# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-backports main restricted universe multiverse
deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-security main restricted universe multiverse
# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-security main restricted universe multiverse
# 预发布软件源，不建议启用
# deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-proposed main restricted universe multiverse
# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-proposed main restricted universe multiverse
```
18.04 LTS

```
# 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释
deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse
# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse
deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse
# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse
deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse
# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse
deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse
# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse

# 预发布软件源，不建议启用
# deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse
# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse
```



20.04 LTS

```
# 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释
deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiverse
# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiverse
deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted universe multiverse
# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted universe multiverse
deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-backports main restricted universe multiverse
# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-backports main restricted universe multiverse
deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security main restricted universe multiverse
# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security main restricted universe multiverse

# 预发布软件源，不建议启用
# deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-proposed main restricted universe multiverse
# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-proposed main restricted universe multiverse
```

21.04 LTS

```
# 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释
deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ hirsute main restricted universe multiverse
# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ hirsute main restricted universe multiverse
deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ hirsute-updates main restricted universe multiverse
# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ hirsute-updates main restricted universe multiverse
deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ hirsute-backports main restricted universe multiverse
# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ hirsute-backports main restricted universe multiverse
deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ hirsute-security main restricted universe multiverse
# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ hirsute-security main restricted universe multiverse

# 预发布软件源，不建议启用
# deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ hirsute-proposed main restricted universe multiverse
# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ hirsute-proposed main restricted universe multiverse
```

21.10 LTS
```
# 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释
deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ impish main restricted universe multiverse
# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ impish main restricted universe multiverse
deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ impish-updates main restricted universe multiverse
# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ impish-updates main restricted universe multiverse
deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ impish-backports main restricted universe multiverse
# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ impish-backports main restricted universe multiverse
deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ impish-security main restricted universe multiverse
# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ impish-security main restricted universe multiverse

# 预发布软件源，不建议启用
# deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ impish-proposed main restricted universe multiverse
# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ impish-proposed main restricted universe multiverse
```

参考：[链接](https://blog.csdn.net/wlc_1111/article/details/124528341)
[链接2](https://blog.csdn.net/PAN_Andy/article/details/105053890)
]]></description></item><item><title>C++中的#和##</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/05/28/16321773.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Sat, 28 May 2022 12:03:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/05/28/16321773.html</guid><description><![CDATA[\#\#组合出来的字符串代表一个标识符
\#组合出来的字符串就是一个字符串
```
#include <iostream>
#define t(x) hello##x//合并操作符##将出现在其左右的字符序列合并成一个新的标识符 
#define s(y) #y//将传入的参数变为字符串，字符串化

using namespace std;

int main()
{
	int hello1 = 10;
	cout << t(1) << endl;//将hello和1链接形成hello1,hello1是一个变量。输出：10
	cout << s(hello) << endl;//将hello变为字符串。输出：hello
	return 0;
}
```
[参考链接](https://blog.csdn.net/zhang_chou_chou/article/details/80737339)]]></description></item><item><title> multipart/form-data的HTTP消息文本</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/05/28/16321759.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Sat, 28 May 2022 11:53:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/05/28/16321759.html</guid><description><![CDATA[下面是通过post方式发送的请求：
```
POST http://www.example.com HTTP/1.1
Content-Type:multipart/form-data; boundary=----WebKitFormBoundaryyb1zYhTI38xpQxBK

------WebKitFormBoundaryyb1zYhTI38xpQxBK
Content-Disposition: form-data; name="city_id"

111111
------WebKitFormBoundaryyb1zYhTI38xpQxBK
Content-Disposition: form-data; name="company_id"

222222
------WebKitFormBoundaryyb1zYhTI38xpQxBK
Content-Disposition: form-data; name="file"; filename="chrome.png"
Content-Type: image/png

PNG ... content of chrome.png ...
```
第一行是请求行，指明了方法、URI 和 HTTP 版本号；
第二行是消息头（简单起见，只有一个 Content-Type)；
然后空出一行；
接下来就是消息体。可以看到使用 multipart/form-data 时，消息体通过 boundary 来分隔多个字段，被分隔的每个字段都有自己的小头部和小消息体，且也用空行分隔。






参考：[multipart/form-data的HTTP消息文本](https://www.jianshu.com/p/8251fff48a59)]]></description></item><item><title>linux下源码编译安装的一般步骤：安装编译、动态库和环境变量配置</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/05/28/16321101.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Sat, 28 May 2022 08:55:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/05/28/16321101.html</guid><description><![CDATA[# 1.安装

(./configure）–＞ 编译（sudo make） –＞ 安装（sudo make install）。

1.配置：这是编译源代码的第一步，通过 ./configure 命令完成（图形化可以用cmake-gui来配置）。执行此步以便为编译源代码作准备。常用的选项有 --prefix=PREFIX，用以指定程序的安装位置。更多的选项可通过 --help 查询。也有某些程序无需执行此步。
2.编译：一旦配置通过，可即刻使用 make 指令来执行源代码的编译过程。视软件的具体情况而定，编译所需的时间也各有差异，我们所要做的就是耐心等候和静观其变。此步虽然仅下简单的指令，但有时候所遇到的问题却十分复杂。较常碰到的情形是程序编译到中途却无法圆满结束。此时，需要根据出错提示分析以便找到应对之策。
3.安装：如果编译没有问题，那么执行 sudo make install 就可以将程序安装到系统中了。

例子：
```
//0.有时候需要先安装依赖库
//1.解压缩
tar -zxf nagios-4.0.2.tar.gz  
//2.进入目录
cd nagios-4.0.2
//3.配置
./configure --prefix=/usr/local/nagios     
//4.编译
make -j4
//5.安装
make install
```
参考：[链接](https://blog.csdn.net/qq_38455499/article/details/118465821)

# 2.配置
## 2.1.动态库配置
使用--prefix指定安装目录后，运行所需的动态库也会被安装在这个目录下。当程序运行时，linux系统不会去这个目录下查找动态库，那么程序就会由于缺少动态库而无法运行，一般会出现如下错误：error while loading shared libraries。
为了让linux系统找到动态库所在路径，必须做如下操作：
```
在/etc/ld.so.conf中添加动态库所在路径，或在/etc/ld.so.conf.d目录下建立xxxx.conf，然后再在xxxx.conf中添加动态库所在路径【xxxx随便什么都可以】
命令行输入：sudo /sbin/ldconfig
```

参考[链接](https://www.cnblogs.com/codingbigdog/p/16320965.html)

## 2.2.环境变量配置
在ubuntu系统中，经常会遇到修改环境变量的需要，修改的方式有三种，区别在于生效的范围：当前终端、当前用户、所有用户
- 1.在命令行窗口内执行如下命令export PATH=$PATH:<你的要加入的路径>，只对当前终端有效，执行命令后立即生效

- 2.在~目录下修改.bashrc 隐藏文件，添加如下语句 export PATH=<你要加入的路径1>:<你要加入的路径2>: ...... :$PATH，只对当前用户有效，需要重新打开命令行窗口生效。下面是一个实例：
```
sudo vim ~/.bashrc

# 在文件末尾添加两行
export PATH=$PATH:/home/lorien/work/media/ffmpeg/install/bin
export LD_LIBRARY_PATH=/home/lorien/work/media/ffmpeg/install/lib

source ~/.bashrc
```
- 3.在~目录下还有一个.profile隐藏文件，和.bashrc类似，但是该文件在用户登录时候被读取执行，所以需要重启生效。

- 4.在/etc目录下修改profile文件，添加如下语句export PATH=<你要加入的路径>:$PATH，对所有用户有效，需要重启或者执行source /etc/profile命令使得立即生效

下面是一个实例：
```
# 加入全局环境变量路径：
dxb@dxb-virtual-machine:~$ sudo vi /etc/profile
在文件中加入以下内容:
export PATH="/usr/local/ffmpeg/bin:$PATH"  
# PATH="/usr/local/ffmpeg/bin:$PATH"表示在$PATH前添加"/usr/local/ffmpeg/bin:"，然后将整体返回给$PATH

然后保存并运行source /etc/profile
每个新开的终端都需要输入source /etc/profile以后，才能直接运行软件。

重启以后，新开的终端不用运行source /etc/profile，就可以直接运行软件。
```

参考：[链接](https://blog.csdn.net/weixin_40571066/article/details/123257988)
]]></description></item><item><title>linux Ｃ\C++动态库（共享库）、静态库链接</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/05/28/16320965.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Sat, 28 May 2022 08:26:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/05/28/16320965.html</guid><description><![CDATA[首先我们大致看一下以下五个问题:
**1.pkg-config是什么？**
在源代码编译时，pkg-config可用于查询已安装的库的使用接口

**2.动态库（共享库）和静态库的区别是什么？**
区别：1、静态库的扩展名一般为“.a”或“.lib”；动态库的扩展名一般为“.so”或“.dll”。2、静态库在编译时会直接整合到目标程序中，编译成功的可执行文件可独立运行；动态库在编译时不会放到连接的目标程序中，即可执行文件无法单独运行。
可参考这篇[文章](https://blog.csdn.net/m0_61745661/article/details/123597887)，写得很好

**3.linux扩展名没有作用？**
Linux不根据扩展名判断文件类型，而是根据文件的内容来判断。所以扩展名的作用是帮助人来识别文件，对于Linux系统本身来说没有什么用处。
.sh结尾表示是shell脚本文件，但是不以.sh结尾的文件也可以是可执行的shell脚本（比如/etc/init.d中的脚本），因为它们的文件开头都有#!/bin/sh这一行




**4.make进行编译以后不就生成了可执行文件，make install进行了什么操作？**
类 UNIX 系统的软件，有些不需要安装，执行可执行文件就可以直接用了。
有些软件需要将配置文件、资源文件复制到相应的位置才能运行，如动态链接库的软件需要更新动态链接库缓存，否则会因为找不到刚刚编译出来的动态链接库而出错，等等。

**5.linux下源码安装的一般流程**
请参考[链接](https://blog.csdn.net/weixin_42732867/article/details/104789431)




# 1.Linux中pkg-config
## 1.1.pkg-config简介
pkg-config用于指明第三方头文件和库文件的位置。为了让pkg-config可以得到一个库的信息，就要求库的提供者提供一个.pc文件。
如：
``` 
gcc -o test test.c `pkg-config --libs --cflags glib-2.0` #　--cflags一般用于指定头文件，--libs一般用于指定库文件。
```
pkg-config默认会到/usr/lib/pkconfig/目录下去寻找glib-2.0.pc文件。然而假如我们安装了一个库，其生成的.pc文件并不在这个默认目录中的话，pkg-config就找不到了。此时我们需要通过PKG_CONFIG_PATH环境变量来指定pkg-config还应该在哪些地方去寻找.pc文件。

我们可以通过如下命令来设置PKG_CONFIG_PATH环境变量：
```
export PKG_CONFIG_PATH=$PKG_CONFIG_PATH:/usr/local/lib/pkgconfig/
```
这样pkg-config就会在/usr/local/lib/pkgconfig/目录下寻找.pc文件了。
另外还需要注意的是,上述环境变量的设置只对当前的终端窗口有效。为了让其永久生效，我们可以将上述命令写入到/etc/bash.bashrc等文件中，以方便后续使用。



##　1.2.pkg-config与LD_LIBRARY_PATH
pkg-config与LD_LIBRARY_PATH的主要工作阶段：
- pkg-config: 编译时、 链接时
- LD_LIBRARY_PATH: 链接时、 运行时

pkg-config主要是在编译时会用到其来查找对应的头文件、链接库等；而LD_LIBRARY_PATH环境变量则在 链接时 和 运行时 会用到。程序编译出来之后，在程序加载执行时也会通过LD_LIBRARY_PATH环境变量来查询所需要的库文件。




##　1.3.LD_LIBRARY_PATH及ldconfig
下面我们来讲述一下LD_LIBRARY_PATH及ldconfig命令：
库文件在链接（静态库和共享库）和运行（仅限于使用共享库的程序）时被使用，其搜索路径是在系统中进行设置的。一般Linux系统把/lib和/usr/lib这两个目录作为默认的库搜索路径，所以使用这两个目录中的库时不需要进行设置搜索路径即可直接使用。对于处于默认库搜索路径之外的库，需要将库的位置添加到库的搜索路径之中。设置库文件的搜索路径有下列两种方式，可任选其中一种使用：

- 在环境变量LD_LIBRARY_PATH中指明库的搜索路径
- 在/etc/ld.so.conf文件中添加库的搜索路径

将自己可能存放库文件的路径都加入到/etc/ld.so.conf中是明智的选择。添加方法也及其简单，将库文件的绝对路径直接写进/etc/ld.so.conf文件中就OK了，一行一个。比如：
```
/usr/X11R6/lib
/usr/local/lib
/opt/lib
```
我们也可以在/etc/ld.so.conf.d目录下建立xxxx.conf，然后再在xxxx.conf中添加以上内容。可以这样做的原因是：/etc/ld.so.conf文件中通过“include /etc/ld.so.conf.d/*.conf”包含了目录ld.so.conf.d下的所有.conf文件。



需要注意的是：第二种搜索路径的设置方式对于程序链接时的库（包括共享库和静态库）的定位已经足够了。但是对于使用了共享库的程序的执行还是不够的，这是因为为了加快程序执行时对共享库的定位速度，避免使用搜索路径查找共享库的低效率，所以是直接读取库列表文件/etc/ld.so.cache的方式从中进行搜索。/etc/ld.so.cache是一个非文本的数据文件，不能直接编辑，它是根据/etc/ld.so.conf中设置的搜索路径由/sbin/ldconfig命令将这些搜索路径下的共享库文件集中在一起而生成的（ldconfig命令要以root权限执行）。因此为了保证程序执行时对库的定位，在/etc/ld.so.conf中进行了库搜索路径的设置之后，还必须要运行/sbin/ldconfig命令更新/etc/ld.so.cache文件之后才可以。

ldconfig，简单的说，它的作用就是将/etc/ld.so.conf列出的路径下的库文件缓存到/etc/ld.so.cache以供使用。因此当安装完一些库文件（例如刚安装好glib)，或者修改ld.so.conf增加新的库路径之后，需要运行一下/sbin/ldconfig使所有的库文件都被缓存到ld.so.cache中。如果没有这样做，即使库文件明明就在/usr/lib下的，也是不会被使用的，结果在编译过程中报错。

前面已经说明过了，库搜索路径的设置有两种方式：在环境变量 LD_LIBRARY_PATH 中设置以及在 /etc/ld.so.conf 文件中设置。其中，第二种设置方式需要 root 权限，以改变 /etc/ld.so.conf 文件并执行 /sbin/ldconfig 命令。而且，当系统重新启动后，所有的基于 GTK2 的程序在运行时都将使用新安装的 GTK+ 库。不幸的是，由于 GTK+ 版本的改变，这有时会给应用程序带来兼容性的问题，造成某些程序运行不正常。为了避免出现上面的这些情况，在 GTK+ 及其依赖库的安装过程中对于库的搜索路径的设置将采用第一种方式进行。这种设置方式不需要 root 权限，设置也简单：
```
export LD_LIBRARY_PATH=/opt/gtk/lib:$LD_LIBRARY_PATH
echo $LD_LIBRARY_PATH
```

在程序链接时，对于库文件（静态库和共享库）的搜索路径，除了上面的设置方式之外，还可以通过-L参数显示指定。因为用-L设置的路径将被优先搜索，所以在链接的时候通常都会以这种方式直接指定要链接的库的路径。




# 2.Linux下链接库的路径顺序
##  2.1.运行时链接库的搜索顺序
Linux程序在运行时对动态链接库的搜索顺序如下：

1） 在编译目标代码时所传递的动态库搜索路径（注意，这里指的是通过-Wl,rpath=<path1>:<path2>或-R选项传递的运行时动态库搜索路径，而不是通过-L选项传递的）

例如：
```
gcc -Wl,-rpath,/home/arc/test,-rpath,/lib/,-rpath,/usr/lib/,-rpath,/usr/local/lib test.c
或者
gcc -Wl,-rpath=/home/arc/test:/lib/:/usr/lib/:/usr/local/lib test.c
```

2） 环境变量LD_LIBRARY_PATH指定的动态库搜索路径；

3） 配置文件/etc/ld.so.conf中所指定的动态库搜索路径(更改/etc/ld.so.conf之后，一定要执行命令ldconfig，该命令会将/etc/ld.so.conf文件中所有路径下的库载入内存）;

4） 默认的动态库搜索路径/lib；

5） 默认的动态库搜索路径/usr/lib;

## 2.2.编译时与运行时动态库查找的比较
下面是对编译时库的查找与运行时库的查找做一个简单的比较：

1）编译时查找的是静态库或动态库， 而运行时，查找的是动态库；

2）编译时可以用-L指定查找路径，或者用环境变量LIBRARY_PATH， 而运行时可以用-Wl,rpath或者-R选项，或者修改/etc/ld.so.conf，或者设置环境变量LD_LIBRARY_PATH;

3）编译时用的链接器是ld，而运行时用的链接器是/lib/ld-linux.so.2

4）编译时与运行时都会查找默认路径/lib、/usr/lib

5）编译时还有一个默认路径/usr/local/lib，而运行时不会默认查找该路径；

说明： -Wl,rpath选项虽然是在编译时传递的，但是其实是工作在运行时。其本身其实也不算是gcc的一个选项，而是ld的选项，gcc只不过是一个包装器而已。我们可以执行man ld来进一步了解相关信息



# 3.gcc使用-Wl,-rpath
-Wl,-rpath选项的作用就是指定程序运行时的库搜索目录，是一个链接选项，生效于设置的环境变量之前(LD_LIBRARY_PATH)。下面我们通过一个例子来说明：
```
// add.h
int add(int i, int j);
 
// add.c
#include "add.h"
 
int add(int i, int j)
{
	return i + j;
}
 
// main.c
#include <stdio.h>
#include <stdlib.h>
#include "add.h"
 
int main(int argc, char *argv[]) 
{
	printf("1 + 2 = %d\n", add(1, 2));
	return 0;
}
```
add.h和add.c用于生成一个so库，实现了一个简单的加法，main.c中引用共享库计算1 + 2：
```
# 编译共享库
gcc add.c -fPIC -shared -o libadd.so  # -fPIC：生成位置无关目标代码，适用于动态连接；
                                      # -shared：生成一个共享库文件；
# 编译主程序
gcc main.c -L . -ladd -o app  # ladd应该相当于libadd.so的简写
                              # "-L ."代表链接阶段在当前目录下查找库
```
编译好后运行：
```
./app
输出：
./app: error while loading shared libraries: libadd.so: cannot open shared object file: No such file or directory
```
可以看到， libadd.so这个库没有找到。这是因为-L指定的是编译时从哪里找动态库，我们还需要使用-Wl,rpath选项指定运行时从哪个目录下找动态库之后：
```
gcc -Wl,-rpath=`pwd` main.c -L. -ladd -o app # pwd代表当前路径
                                             # "-L ."代表链接阶段在当前目录下查找库
                                             # -Wl,-rpath代表运行时，在哪里找库。
./app
输出：
1 + 2 = 3
```
依赖库的查找路径就找到了，程序能正常运行。

用ldd查看C++程序的依赖库【参考：[用ldd查看C++程序的依赖库](https://blog.csdn.net/csfreebird/article/details/9200469)】：
```
ldd -v  app
输出：
linux-vdso.so.1 (0x00007ffd619b7000)
libadd.so => ./libadd.so (0x00007f9e216ca000)
libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f9e214c7000)
/lib64/ld-linux-x86-64.so.2 (0x00007f9e216d6000)

Version information:
./app:
        libc.so.6 (GLIBC_2.2.5) => /lib/x86_64-linux-gnu/libc.so.6
/lib/x86_64-linux-gnu/libc.so.6:
        ld-linux-x86-64.so.2 (GLIBC_2.3) => /lib64/ld-linux-x86-64.so.2
        ld-linux-x86-64.so.2 (GLIBC_PRIVATE) => /lib64/ld-linux-x86-64.so.2
```

下面我们再来看一下生成的可执行文件app，执行如下命令：
```
readelf app -d
```
输出：
```
Dynamic section at offset 0xe08 contains 26 entries:
  Tag        Type                         Name/Value
 0x0000000000000001 (NEEDED)             Shared library: [libadd.so]
 0x0000000000000001 (NEEDED)             Shared library: [libc.so.6]
 0x000000000000000f (RPATH)              Library rpath: [/root/test]
 0x000000000000000c (INIT)               0x400578
 0x000000000000000d (FINI)               0x400784
 0x0000000000000019 (INIT_ARRAY)         0x600df0
 0x000000000000001b (INIT_ARRAYSZ)       8 (bytes)
 0x000000000000001a (FINI_ARRAY)         0x600df8
 0x000000000000001c (FINI_ARRAYSZ)       8 (bytes)
 0x000000006ffffef5 (GNU_HASH)           0x400298
 0x0000000000000005 (STRTAB)             0x400408
 0x0000000000000006 (SYMTAB)             0x4002d0
 0x000000000000000a (STRSZ)              189 (bytes)
 0x000000000000000b (SYMENT)             24 (bytes)
 0x0000000000000015 (DEBUG)              0x0
 0x0000000000000003 (PLTGOT)             0x601000
 0x0000000000000002 (PLTRELSZ)           96 (bytes)
 0x0000000000000014 (PLTREL)             RELA
 0x0000000000000017 (JMPREL)             0x400518
 0x0000000000000007 (RELA)               0x400500
 0x0000000000000008 (RELASZ)             24 (bytes)
 0x0000000000000009 (RELAENT)            24 (bytes)
 0x000000006ffffffe (VERNEED)            0x4004e0
 0x000000006fffffff (VERNEEDNUM)         1
 0x000000006ffffff0 (VERSYM)             0x4004c6
 0x0000000000000000 (NULL)               0x0
```
可以看到是在编译后的程序中包含了库的搜索路径。

我们还经常见到-Wl,rpath-link
-Wl,rpath-link是设置编译链接时候的顺序，例如app运行依赖libadd.so，但是libadd.so又依赖libadd_ex.so，rpath-link就是指定libadd_ex.so的路径。和-Wl,rpath相比工作的时间不同，一个在链接期间，一个在运行期间。




# 4.gcc编译头文件查找路径
对于#include ""，预处理器首先在当前目录查找，如果没找到，就按系统设置目录列表查找头文件。
对于#include<>，预处理器按系统设置目录列表查找头文件。我们常用 -I添加头文件的查找目录。预处理器的查找顺序为：当前目录——>-I设定目录——>系统设置目录。
您还可以使用 -nostdinc 选项阻止预处理器搜索任何默认系统头目录。当您编译操作系统内核或其他不使用标准 C 库工具或标准 C 库本身的程序时，这很有用。

除此之外，我们还可以通过相应的环境变量来指定头文件的搜索路径：
```
export C_INCLUDE_PATH=XXXX:$C_INCLUDE_PATH
export CPLUS_INCLUDE_PATH=XXX:$CPLUS_INCLUDE_PATH
```
可以将以上代码添加到/etc/profile末尾。


#gcc编译选项
```
-I：编译程序按照-I指定的路进去搜索头文件
-L：指定的路径会被优先搜索
-l：-L用于指定库所在的目录，-l用于指定具体的库。
```
注意：-l event指定的是所有库名称中含有“libevent”字串的库。有时“-l event”也写成“-levent”。

下面是一个编译实例：
```
g++ main.cpp -Wl,-rpath=`../lib`  -L ../lib  -l opencv_core -l opencv_imgproc -l opencv_videoio -l opencv_imgcodecs -l opencv_highgui -I ../include/opencv4 -o app 

-Wl,-rpath：指定运行时在哪里找库
-L：指定库目录
-l：指定具体的库文件。即使有了-L，也需要设置-l
-I：指定了头文件所在的目录
```





from：[链接](https://blog.csdn.net/chen_jianjian/article/details/123890413)
]]></description></item><item><title>WARNING: Retrying (Retry(total=0, connect=None, read=None, redirect=None, status=None)) after connection broken by 'ProxyError('Cannot connect to proxy.', NewConnectionError('&lt;pip._vendor.</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/05/26/16313563.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Thu, 26 May 2022 07:13:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/05/26/16313563.html</guid><description><![CDATA[安装 pip 包报错：
```
WARNING: Retrying (Retry(total=4, connect=None, read=None, redirect=None, status=None)) after connection broken by 'ProxyError('Cannot connect to proxy.', NewConnectionError('<pip._vendor.urllib3.connection.HTTPSConnection object at 0x7fc50528c710>: Failed to establish a new connection: [Errno 111] Connection refused'))': /simple
WARNING: Retrying (Retry(total=3, connect=None, read=None, redirect=None, status=None)) after connection broken by 'ProxyError('Cannot connect to proxy.', NewConnectionError('<pip._vendor.urllib3.connection.HTTPSConnection object at 0x7fc50528c590>: Failed to establish a new connection: [Errno 111] Connection refused'))': /simple
WARNING: Retrying (Retry(total=2, connect=None, read=None, redirect=None, status=None)) after connection broken by 'ProxyError('Cannot connect to proxy.', NewConnectionError('<pip._vendor.urllib3.connection.HTTPSConnection object at 0x7fc50528cd50>: Failed to establish a new connection: [Errno 111] Connection refused'))': /simple
WARNING: Retrying (Retry(total=1, connect=None, read=None, redirect=None, status=None)) after connection broken by 'ProxyError('Cannot connect to proxy.', NewConnectionError('<pip._vendor.urllib3.connection.HTTPSConnection object at 0x7fc50528cbd0>: Failed to establish a new connection: [Errno 111] Connection refused'))': /simple
WARNING: Retrying (Retry(total=0, connect=None, read=None, redirect=None, status=None)) after connection broken by 'ProxyError('Cannot connect to proxy.', NewConnectionError('<pip._vendor.urllib3.connection.HTTPSConnection object at 0x7fc50528cd90>: Failed to establish a new connection: [Errno 111] Connection refused'))': /simple
ERROR: Could not install packages due to an EnvironmentError: HTTPSConnectionPool(host='pypi.doubanio.com', port=443): Max retries exceeded with url: /simple (Caused by ProxyError('Cannot connect to proxy.', NewConnectionError('<pip._vendor.urllib3.connection.HTTPSConnection object at 0x7fc50528ce10>: Failed to establish a new connection: [Errno 111] Connection refused')))
```
代理问题，解决方案
```
unset no_proxy;unset https_proxy
```
[参考连接](https://blog.csdn.net/ao1886/article/details/114283556)
]]></description></item><item><title>C++ opencv使用</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/05/24/16307407.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Tue, 24 May 2022 14:10:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/05/24/16307407.html</guid><description><![CDATA[# 安装
请参考：[C++ opencv安装和使用](https://blog.csdn.net/weixin_44796670/article/details/115900538)

通过以下命令，将opencv安装到指定目录中：
```
cmake -D CMAKE_BUILD_TYPE=Release -D CMAKE_INSTALL_PREFIX=/home/ubuntu1/test_c++/opencv  ..
```
将C++ opencv安装到指定目录下以后，可以看到有四个目录bin、include、lib 和 share,分别包含了可执行文件、头文件、库文件和cmake配置文件。在这里,我们只需用到 include 和 lib 这两个文件夹,
  


为什么在OpenCV 3.x和OpenCV 4.x中都有有一个opencv2文件夹？
基于C的OpenCV是API v1，基于C ++的OpenCV是API v2。库版本现在为3.x或4.x，但它们仍使用相同的基于C ++的API。因此，OpenCV构建仍将其头文件保存在opencv2文件夹中。也就是说opencv2代表此库用于C++。


lib中各个库都代表什么？什么时候需要引入什么库？？？


# 使用

只能保存avi，mp4格式编码方式有点迷


```
// 画框cv::rectangle(图片,左上点,右上点,框的颜色);
cv::rectangle(image, cv::Point(400, 400), cv::Point(450, 450), cv::Scalar(0, 0, 255));
```

opencv读取图片：
```
//main.cpp

#include <opencv2/opencv.hpp>
#include<iostream>

int main(int argc, char const *argv[])
{
    cv::VideoCapture cap;
    cap.open("human.mp4");

    if (!cap.isOpened())
        return 0;


  
    cv::Mat frame;
    while(1) {
        cap >> frame;
        if (frame.empty())
            break;
        cv::imshow("hello", frame);
        cv::waitKey(50);
    }
    cap.release();

    return 0;
}
```
使用g++进行编译：
```
g++ main.cpp -Wl,-rpath=./opencv/lib -L ./opencv/lib  -l opencv_core -l opencv_imgproc -l opencv_videoio -l opencv_imgcodecs -l opencv_highgui -I ./opencv/include/opencv4 -o app 

-Wl,-rpath：运行阶段，在这个目录下查找库文件
-L：编译阶段，在这个目录下查找库文件
-l：-L指向目录，-l指向具体的库。
-I：指向头文件所在目录
命令具体可参考：https://www.cnblogs.com/codingbigdog/p/16320965.html
```
]]></description></item><item><title>程序员的出路</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/05/22/16298756.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Sun, 22 May 2022 11:44:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/05/22/16298756.html</guid><description><![CDATA[熟悉公司赚钱和找客户流程，然后自己创业。【可能累死】
参考：[链接](https://www.zhihu.com/question/493709505/answer/2193640005)

混上公司上层，当上架构师，让自己不可或缺。
让自己技术好，让自己即使被裁也不怕。

转产品经理或者项目经理

若果不想长期走技术路线，可以及早开辟一个副业。用2-3年的时间把副业的收入做到主业的一半，慢慢的切换到副业上。比如我喜欢心理学，我可以考虑一下，恋爱市场的心理需求。


评论区：
1.只要技术够好，这个年代程序员不赚钱谁赚钱，我见过月入百万的项目太多了，但首先你技术要好
2.跑路日本吧，在国内绝逼给优化了
3.43岁的程序员鼓励你一下，要是有其他出路不妨一试，但提醒你出去就回不来了。
4.我觉得30岁的程序员如果沟通能力和业务理解能力都较强，管理、产品经理或者项目经理都可以转，这些岗位互通的地方很多。

最好的赚钱方法是：利用信息不对称，合法地炒作，赚到钱就跑路。


最后：不要被贩卖焦虑了，程序员还是可以感到四十多岁的，等到干不动了，钱应该也赚够了，该养老了。
]]></description></item><item><title>C++ webserver from 黑马程序员 </title><link>http://www.cnblogs.com/codingbigdog/archive/2022/05/20/16293559.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Fri, 20 May 2022 11:42:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/05/20/16293559.html</guid><description><![CDATA[# 1.使用抓包工具Wireshark查看三次握手
常用的抓包工具：
- tcpdump：游双的《高性能网络编程》中常用tcpdump进行抓包
- Wireshark：本黑马程序员课程中使用Wireshark进行抓包。抓包程序不要一直开着，不然内存会爆掉。

我首先在虚拟机中开启两个ubuntu系统，此时这两个系统，相当于在同一个网段下面的两台主机。然后使用Wireshark监听网卡VMware Network Adapter VMnet8。【[虚拟网卡的知识参考](https://www.cnblogs.com/lyh233/p/14592566.html)】

**使用抓包工具Wireshark查看三次握手步骤**
假设两台虚拟主机为A和B，A的IP为192.168.154.129，B的IP为192.168.154.130。
1.在主机A中运行黑马程序员课程中所给的代码02_process_tcp_server.c，具体代码如下：
```
#include <stdio.h>
#include <sys/socket.h>
#include <unistd.h>
#include <signal.h>
#include <sys/wait.h>
#include "wrap.h"
void free_process(int sig)
{
	pid_t pid;
	while(1)
	{
		pid = waitpid(-1,NULL,WNOHANG);
		if(pid <=0 )//小于0 子进程全部退出了 =0没有进程没有退出
		{
			break;
		}
		else
		{
			printf("child pid =%d\n",pid);
		}
	}



}
int main(int argc, char *argv[])
{
	sigset_t set;
	sigemptyset(&set);
	sigaddset(&set,SIGCHLD);
	sigprocmask(SIG_BLOCK,&set,NULL);
	//创建套接字,绑定
	int lfd = tcp4bind(8008,NULL);
	//监
	Listen(lfd,128);
	//提取
	//回射
	struct sockaddr_in cliaddr;
	socklen_t len = sizeof(cliaddr);
	while(1)
	{
		char ip[16]="";
		//提取连接,
		int cfd = Accept(lfd,(struct sockaddr *)&cliaddr,&len);
		printf("new client ip=%s port=%d\n",inet_ntop(AF_INET,&cliaddr.sin_addr.s_addr,ip,16),
				ntohs(cliaddr.sin_port));
		//fork创建子进程
		pid_t pid;
		pid = fork();
		if(pid < 0)
		{
			perror("");
			exit(0);
		}
		else if(pid == 0)//子进程
		{
			//关闭lfd
			close(lfd);
			while(1)
			{
			char buf[1024]="";

			int n = read(cfd,buf,sizeof(buf));
			if(n < 0)
			{
				perror("");
				close(cfd);
				exit(0);
			}
			else if(n == 0)//对方关闭j
			{
				printf("client close\n");
				close(cfd);
				exit(0);
			
			}
			else
			{
				printf("%s\n",buf);
				write(cfd,buf,n);
			//	exit(0);	
			}
			}
		
		}
		else//父进程
		{
			close(cfd);
			//回收
			//注册信号回调
			struct sigaction act;
			act.sa_flags =0;
			act.sa_handler = free_process;
			sigemptyset(&act.sa_mask);
			sigaction(SIGCHLD,&act,NULL);
			sigprocmask(SIG_UNBLOCK,&set,NULL);
		
		}
	}
	//关闭



	return 0;
}
```
编译和运行命令：
```
gcc 02_process_tcp_server.c wrap.c 
./a.out
```
wrap.c代码见[函数封装](https://www.cnblogs.com/codingbigdog/p/16245492.html)

2.开启Wireshark监听网卡VMware Network Adapter VMnet8
3.在主机B运行如下命令：
```
nc 192.168.154.129 8008
hello // 发送hello
hello // 发送hello以后，会收到hello
^C    // ctrl+c断开连接
```

Wireshark中抓到的信息如下：
![](https://img2022.cnblogs.com/blog/1617829/202205/1617829-20220520204042214-1685166316.png)


# 2.HTTP协议
常用的请求方法有GET、HEAD、POST。
无连接：服务器处理完客户的请求，并收到客户的应答后，即断开连接。
无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。
从URL中获取参数：从“？”开始到“#”为止之间的部分为参数部分。允许有多个参数，参数与参数之间用“&”作为分隔符。可以从URL中获取参数，传给后台。

## 2.1.请求消息Request
请求消息Request有下面四个部分：
请求行（request line）、请求头部（header）、空行和请求数据
![](https://img2022.cnblogs.com/blog/1617829/202205/1617829-20220520212604859-650996089.png)

如：
![](https://img2022.cnblogs.com/blog/1617829/202205/1617829-20220520214117141-1352557713.png)
其中\r\n代表空行



## 2.2.响应消息Response
HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。
![](https://img2022.cnblogs.com/blog/1617829/202205/1617829-20220520214410051-631001605.png)
Content-Type是必填的；Content-Length可填可不填,填一定填对。

HTTP协议的具体内容可参考：[链接](https://www.cnblogs.com/ranyonsue/p/5984001.html)



# 3.webserver实现
## 一些API
读取目录下所有文件名
```
// dirent用于存储文件信息
struct dirent {
              ino_t          d_ino;       /* inode number */
              off_t          d_off;       /* not an offset; see NOTES */
              unsigned short d_reclen;    /* length of this record */
              unsigned char  d_type;      /* type of file; not supported
                                              by all filesystem types */
              char           d_name[256]; /* filename */
           };

// scandir 读取目录下的文件
struct dirent **mylist : // 指向指针数组的指针，如果要改变这个在指针的指向就需要使用三级指针
int scandir(const char *dirp, struct dirent ***namelist, // 需要改变mylist指针的指向，所以这里namelist使用三级指针
              int (*filter)(const struct dirent *),
              int (*compar)(const struct dirent **, const struct dirent **));
参数: 
        dirp: 目录的路径名
        namelist:  mylist地址，保存目录下的文件
        filter: 过滤的函数入口地址。用于过滤不需要的文件。不需要过滤时写NULL
        compar : 排序函数入口地址   可以直接使用已经写好的函数alphasort，用于字母排序
返回值: 读取文件的个数

```
## 具体实现代码
在黑马程序员课程中，实现了两个webserver，分别为epoll_web.c和event_wb.c。
具体代码可以在https://gitee.com/baba1980/heima_codes_notes的webserver下中找到，我添加了注释，所以代码直接应该可以看懂。
]]></description></item><item><title>C++ UDP 和unix domain socket，from 黑马程序员</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/05/19/16290593.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Thu, 19 May 2022 14:50:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/05/19/16290593.html</guid><description><![CDATA[#1.UDP和TCP区别
TCP: 传输控制协议   安全可靠  丢包重传   面向连接(电话模型) 
UDP: 用户数据报协议  不安全不可靠 丢包不重传  快 不面向连接(邮件模型)，可在应用层是实现安全可靠和丢包重传等内容


**tcp通信流程:**
服务器: 创建流式套接字 绑定 监听 提取 读写 关闭
客户端: 创建流式套接字 连接 读写 关闭
收发数据:
read或recv（推荐使用recv）:
ssize_t recv(int sockfd, void *buf, size_t len, int flags);//flags==MSG_PEEK时， 读数据但不会删除缓冲区的数据
write或send（推荐使用send）:
ssize_t send(int sockfd, const void *buf, size_t len, int flags);//flags一般填0，flags=1代表发送紧急数据

**udp通信流程：**
服务器: 创建报式套接字 绑定 读写 关闭
客户端: 创建报式套接字 读写  关闭
发数据:
```
ssize_t sendto(int sockfd, const void *buf, size_t len, int flags,
                      const struct sockaddr *dest_addr, socklen_t addrlen);
flags一般写0
dest_addr: 目的地的地址信息
addrlen: 结构体大小
```
收数据:
```
ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags,
                        struct sockaddr *src_addr, socklen_t *addrlen);
flags一般写0
src_addr: 对方的地址信息
addrlen: 结构体大小的地址
```




#　2.UDP通信
创建报式套接字
```
int socket(int domain, int type, int protocol);
参数:
    domain : AF_INET
    type :SOCK_DGRAM
    protocol :0
```
**UDP服务器upd_server.c**
```
#include <stdio.h>
#include <sys/socket.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <string.h>
#include <stdlib.h>
int main(int argc, char *argv[])
{
	//创建套接字
	int fd = socket(AF_INET,SOCK_DGRAM,0);
	//绑定
	struct sockaddr_in myaddr;
	myaddr.sin_family = AF_INET;
	myaddr.sin_port = htons(8888);
	myaddr.sin_addr.s_addr = inet_addr("127.0.0.1"); // inet_addr只用于IPv4，inet_pton可用于IPv4和IPv6
	int ret = bind(fd,(struct sockaddr*)&myaddr,sizeof(myaddr));
	if(ret < 0)
	{
		perror("");
		return 0;
	}
	//读写
	char buf[1500]="";
	struct sockaddr_in cliaddr;
	socklen_t len = sizeof(cliaddr);
	while(1)
	{
		memset(buf,0,sizeof(buf)); // 清空，不然会残留上次收到的数据
		int n = recvfrom(fd,buf,sizeof(buf),0,(struct sockaddr *)&cliaddr,&len);
		if(n < 0)
		{
			perror("");
			break;
		}
		else
		{
			printf("%s\n",buf);
			sendto(fd,buf,n,0,(struct sockaddr *)&cliaddr,len);
		
		}
	}
	//关闭
	close(fd);
	return 0;
}
```
**UDP客户端udp_client.c**
```
#include <stdio.h>
#include <string.h>
#include <sys/socket.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <stdlib.h>
int main(int argc, char *argv[])
{
	//创建套接字
	int fd = socket(AF_INET,SOCK_DGRAM,0);
	//绑定
	struct sockaddr_in myaddr;
	myaddr.sin_family = AF_INET;
	myaddr.sin_port = htons(9000);
	//inet_pton
	myaddr.sin_addr.s_addr = inet_addr("127.0.0.1");
	int ret = bind(fd,(struct sockaddr*)&myaddr,sizeof(myaddr));
	if(ret < 0)
	{
		perror("");
		return 0;
	}
	//读写
	char buf[1500]="";
	struct sockaddr_in cliaddr;
	socklen_t len = sizeof(cliaddr);

	struct sockaddr_in dstaddr;
	dstaddr.sin_family = AF_INET;
	dstaddr.sin_port = htons(8888);
	dstaddr.sin_addr.s_addr = inet_addr("127.0.0.1");
	int n=0;
	while(1)
	{
		n = read(STDIN_FILENO,buf,sizeof(buf));	
		sendto(fd,buf,n,0,(struct sockaddr *)&dstaddr,sizeof(dstaddr));
		memset(buf,0,sizeof(buf));
		 n = recvfrom(fd,buf,sizeof(buf),0,NULL,NULL);
		if(n < 0)
		{
			perror("");
		}
		else{
			printf("%s\n",buf);
		
		}
	}
	//关闭
	close(fd);
	return 0;
}
```
# 3.本地套接字实现进程通信（unix domain socket）
可以直接使用网络套接字实现进程通信，也可以使用本地套接字实现进程通信。

套接字用文件来标识,这个文件在绑定之前是不能存在

本地套接字可用于tcp和udp通信，这里以tcp通信为例。
```
int socket(int domain, int type, int protocol);
参数:
    domain : AF_UNIX
    type :SOCK_STREAM
    protocol : 0


绑定
int bind(int sockfd, const struct sockaddr *addr,
                socklen_t addrlen);
sockfd: 本地套接字
addr:  本地套接字结构体地址sockaddr_un
    struct sockaddr_un {
               sa_family_t sun_family;               /* AF_UNIX */
               char        sun_path[108];            /* pathname *///文件的路径名
               };
addrlen: sockaddr_un大小 


提取
int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
    addr: struct sockaddr_un 结构体地址
```

**本地套接字实现tcp服务器：**
```
#include <stdio.h>
#include <fcntl.h>
#include <stddef.h>
#include <sys/socket.h>
#include <unistd.h>
#include <sys/un.h>
#include <arpa/inet.h>
int main(int argc, char *argv[])
{
	unlink("sock.s"); 	// 套接字用文件来标识,这个文件在绑定之前是不能存在。故先删除sock.s
	//创建unix流式套接
	int lfd = socket(AF_UNIX,SOCK_STREAM,0);
	//绑定
	struct sockaddr_un myaddr;
	myaddr.sun_family = AF_UNIX;
	strcpy(myaddr.sun_path ,"sock.s"); // 不能用myaddr.sun_path = "sock.s"。字符串不能用等号
	int len = offsetof(struct sockaddr_un,sun_path)+strlen(myaddr.sun_path); // offsetof(struct sockaddr_un,sun_path)相当于myaddr.sun_family的大小
	bind(lfd,(struct sockaddr *)&myaddr,len); // 也可以写成bind(lfd,(struct sockaddr *)&myaddr,sizeof(myaddr));
	//监听
	listen(lfd,128);
	
	//提取
	struct sockaddr_un cliaddr;
	socklen_t len_c = sizeof(cliaddr);
	int cfd = accept(lfd,(struct sockaddr*)&cliaddr,&len_c);

	printf("new cilent file = %s\n",cliaddr.sun_path);
	//读写
	char buf[1500]="";
	while(1)
	{
		int n = recv(cfd,buf,sizeof(buf),0);
		if(n <= 0)
		{
			printf("err or client close\n");
			break;
		}
		else
		{
			printf("%s\n",buf);
			send(cfd,buf,n,0);
		
		}
	
	}
	//关闭
	close(cfd);
	close(lfd);
	return 0;
}
```
**本地套接字客户端实现:**
```
#include <stdio.h>
#include <stddef.h>
#include <arpa/inet.h>
#include <sys/un.h>
#include <sys/socket.h>
#include <unistd.h>
#include <string.h>
#include <stdlib.h>
int main(int argc, char *argv[])
{
	unlink("sock.c");
	//创建unix流式套接字
	int cfd = socket(AF_UNIX,SOCK_STREAM,0);
	//如果不绑定,就是隐式绑定
	struct sockaddr_un myaddr;
	myaddr.sun_family = AF_UNIX;
	strcpy(myaddr.sun_path,"sock.c");
	int len = offsetof(struct sockaddr_un,sun_path)+strlen("sock.c");
	if(bind(cfd,(struct sockaddr*)&myaddr,len)< 0)
	{
		perror("");
		return 0;
	}
	//连接
	struct sockaddr_un seraddr;
	seraddr.sun_family = AF_UNIX;
	strcpy(seraddr.sun_path,"sock.s");
	connect(cfd,(struct sockaddr*)&seraddr,sizeof(seraddr));
	//读写
	while(1)
	{
		char buf[1500]="";
		int n = read(STDIN_FILENO,buf,sizeof(buf));
		send(cfd,buf,n,0);
		memset(buf,0,sizeof(buf));
		n = recv(cfd,buf,sizeof(buf),0);
		if(n <=0 )
		{
		
			printf("err or server close\n");
			break;
		
		}
		else
		{
			printf("%s\n",buf);
		
		}
	
	
	}
	//关闭
	close(cfd);
	return 0;
}
```
]]></description></item><item><title>C++ 线程池</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/05/18/16286717.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Wed, 18 May 2022 14:47:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/05/18/16286717.html</guid><description><![CDATA[创建几个线程用于处理任务，这些线程暂时不销毁，从而减少线程创建和销毁所需的时间。
将任务放进任务队列中，线程从任务队列中取任务。
这是生成者和消费者模型，需要考虑互斥与同步的问题。实现所需内容如下：
- 一个锁：用于线程互斥访问任务队列
- 两个条件变量：1.当任务队列满时不能添加任务  2.队列中有任务才能取
- 循环队列：用循环队列实现任务队列

实现所需函数如下
```
pthread_cond_wait：等待条件变量满足后，继续执行下面程序
pthread_cond_signal：随机给某一个等待在条件变量的线程发送信号。
pthread_cond_broadcast：给所有等待在等待条件变量的线程发送信号
```
# 1.**epoll加线程池的实现：**
头文件threadpoolsimple.h：
```
#ifndef _THREADPOOL_H
#define _THREADPOOL_H

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <unistd.h>
#include <pthread.h>
#include "sys/epoll.h"
#include "wrap.h"

typedef struct _PoolTask // 代表一个任务。用一个PoolTask数组构造任务队列
{
    int tasknum;//模拟任务编号
    void *arg;//回调函数参数
    void (*task_func)(void *arg);//任务的回调函数
    int fd;
    int epfd;
    struct epoll_event *evs;

}PoolTask ;

typedef struct _ThreadPool // 线程池
{
    int max_job_num;	//最大任务个数
    int job_num;		//实际任务个数
    PoolTask *tasks;	//任务队列数组的首地址
    int job_push;		//入队位置
    int job_pop;		// 出队位置

    int thr_num;		//线程池内线程个数
    pthread_t *threads;	//线程池内线程数组
    int shutdown;		//是否关闭线程池
    pthread_mutex_t pool_lock;	//线程池的锁
    pthread_cond_t empty_task;//任务队列为空的条件
    pthread_cond_t not_empty_task;//任务队列不为空的条件

}ThreadPool;

void create_threadpool(int thrnum,int maxtasknum);//创建线程池--thrnum  代表线程个数，maxtasknum 最大任务个数
void destroy_threadpool(ThreadPool *pool);//摧毁线程池
//void addtask(ThreadPool *pool);//添加任务到线程池
void addtask(ThreadPool *pool,int fd,struct epoll_event *evs);
void taskRun(void *arg);	//任务回调函数

#endif
```

```
//简易版线程池
#include "threadpoolsimple.h"

ThreadPool *thrPool = NULL;

int beginnum = 1000;

void *thrRun(void *arg)
{
    //printf("begin call %s-----\n",__FUNCTION__);
    ThreadPool *pool = (ThreadPool*)arg;
    int taskpos = 0;//任务位置
    PoolTask *task = (PoolTask *)malloc(sizeof(PoolTask));

    while(1)
	{
        //获取任务，先要尝试加锁
        pthread_mutex_lock(&thrPool->pool_lock);

		//无任务并且线程池不是要摧毁
        while(thrPool->job_num <= 0 && !thrPool->shutdown ) // 当pool->not_empty_task为1时，循环退出，并在下面代码中销毁线程
		{
			//如果没有任务，线程会阻塞
            pthread_cond_wait(&thrPool->not_empty_task,&thrPool->pool_lock);
        }
        
        if(thrPool->job_num)
		{
            //有任务需要处理
            taskpos = (thrPool->job_pop++) % thrPool->max_job_num;  // 从循环队列中取任务
            //printf("task out %d...tasknum===%d tid=%lu\n",taskpos,thrPool->tasks[taskpos].tasknum,pthread_self());
			//为什么要拷贝？避免任务被修改，生产者会添加任务
            memcpy(task,&thrPool->tasks[taskpos],sizeof(PoolTask));
            task->arg = task;
            thrPool->job_num--;
            //task = &thrPool->tasks[taskpos];
            pthread_cond_signal(&thrPool->empty_task);// empty_task加一，代表任务队列空余空间增加一
        }

        if(thrPool->shutdown)
		{
            //代表要摧毁线程池，此时线程退出即可
            //pthread_detach(pthread_self());//临死前分家
            pthread_mutex_unlock(&thrPool->pool_lock);
            free(task);
			pthread_exit(NULL);
        }

        //释放锁
        pthread_mutex_unlock(&thrPool->pool_lock);
        printf("001\n");
        task->task_func(task->arg);//执行回调函数
        printf("002\n");
    }
    
    //printf("end call %s-----\n",__FUNCTION__);
}

//创建线程池
void create_threadpool(int thrnum,int maxtasknum)
{
    printf("begin call %s-----\n",__FUNCTION__);
    thrPool = (ThreadPool*)malloc(sizeof(ThreadPool));

    thrPool->thr_num = thrnum;
    thrPool->max_job_num = maxtasknum;
    thrPool->shutdown = 0;//是否摧毁线程池，1代表摧毁
    thrPool->job_push = 0;//任务队列添加的位置
    thrPool->job_pop = 0;//任务队列出队的位置
    thrPool->job_num = 0;//初始化的任务个数为0

    thrPool->tasks = (PoolTask*)malloc((sizeof(PoolTask)*maxtasknum));//申请最大的任务队列

    //初始化锁和条件变量
    pthread_mutex_init(&thrPool->pool_lock,NULL);
    pthread_cond_init(&thrPool->empty_task,NULL);
    pthread_cond_init(&thrPool->not_empty_task,NULL);

    int i = 0;
    thrPool->threads = (pthread_t *)malloc(sizeof(pthread_t)*thrnum);//申请n个线程id的空间
	
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
    for(i = 0;i < thrnum;i++)
	{
        pthread_create(&thrPool->threads[i],&attr,thrRun,(void*)thrPool);//创建多个线程
    }
    //printf("end call %s-----\n",__FUNCTION__);
}
//摧毁线程池
void destroy_threadpool(ThreadPool *pool)
{
    pool->shutdown = 1;// 标志位设为1 
    pthread_cond_broadcast(&pool->not_empty_task);// 给所有阻塞在pool->not_empty_task上的线程发信号

    int i = 0;
    for(i = 0; i < pool->thr_num ; i++)
	{
        pthread_join(pool->threads[i],NULL);  // 这个代码没有必要
    }

    pthread_cond_destroy(&pool->not_empty_task);
    pthread_cond_destroy(&pool->empty_task);
    pthread_mutex_destroy(&pool->pool_lock);

    free(pool->tasks);
    free(pool->threads);
    free(pool);
}

//添加任务到线程池
void addtask(ThreadPool *pool,int fd,struct epoll_event *evs)
{
    //printf("begin call %s-----\n",__FUNCTION__);
    pthread_mutex_lock(&pool->pool_lock);

	//实际任务总数大于最大任务个数则阻塞等待(等待任务被处理)
    while(pool->max_job_num <= pool->job_num)
	{
        pthread_cond_wait(&pool->empty_task,&pool->pool_lock);
    }

    int taskpos = (pool->job_push++)%pool->max_job_num;
    //printf("add task %d  tasknum===%d\n",taskpos,beginnum);
    pool->tasks[taskpos].tasknum = beginnum++;
    pool->tasks[taskpos].arg = (void*)&pool->tasks[taskpos];
    pool->tasks[taskpos].task_func = taskRun;
    pool->tasks[taskpos].fd = fd;
     pool->tasks[taskpos].evs = evs;
    pool->job_num++;

    pthread_mutex_unlock(&pool->pool_lock);

    pthread_cond_signal(&pool->not_empty_task);// not_empty_task加一，代表任务增加一
    //printf("end call %s-----\n",__FUNCTION__);
}

//任务回调函数
void taskRun(void *arg)
{
    printf("003\n");
    PoolTask *task = (PoolTask*)arg;
     char buf[1024]="";
    int n = Read(task->fd , buf,sizeof(buf));
    if(n == 0 )
        {
         close(task->fd);//关闭cfd
        epoll_ctl(task->epfd,EPOLL_CTL_DEL,task->fd,task->evs);//将cfd上树
            printf("client close\n");
        }
    else if(n> 0)
        {
         printf("%s\n",buf );
         Write(task->fd ,buf,n);

        }
 printf("004\n");
   
}


int main()
{
    create_threadpool(3,20);
    int i = 0;
    //创建套接字,绑定
    int lfd = tcp4bind(8000,NULL);
    //监听
    listen(lfd,128);
    //创建树
    int epfd = epoll_create(1);
    struct epoll_event ev,evs[1024];
    ev.data.fd = lfd;
    ev.events = EPOLLIN;//监听读事件
    //将ev上树
    epoll_ctl(epfd,EPOLL_CTL_ADD,lfd,&ev);
    while(1)
    {
        int nready = epoll_wait(epfd,evs,1024,-1);
        if(nready < 0)
            perr_exit("err");
        else if(nready == 0)
            continue;
        else if(nready > 0 )
        {
            for(int i=0;i<nready;i++)
            {
                if(evs[i].data.fd == lfd && evs[i].events & EPOLLIN)//如果是lfd变化,并且是读事件。这个处理很快，所以就不放进任务队列里面了
                {
                        struct sockaddr_in cliaddr;
                        char buf_ip[16]="";
                        socklen_t len  = sizeof(cliaddr);
                        int cfd = Accept(lfd,(struct sockaddr *)&cliaddr,&len);
                        printf("client ip=%s port=%d\n",inet_ntop(AF_INET,
                        &cliaddr.sin_addr.s_addr,buf_ip,sizeof(buf_ip)),
                        ntohs(cliaddr.sin_port));
                        ev.data.fd = cfd;//cfd上树
                        ev.events = EPOLLIN;//监听读事件
                        epoll_ctl(epfd,EPOLL_CTL_ADD,cfd,&ev);//将cfd上树

                }
                else if(evs[i].events & EPOLLIN)//普通的读事件
                {
                    printf("###########1\n");
                    addtask(thrPool,evs[i].data.fd,&evs[i]);
                     printf("###########2\n");
                    // char buf[1024]="";
                    // int n = Read(evs[i].data.fd , buf,sizeof(buf));
                    // if(n <= 0 )
                    // {
                    //     close(evs[i].data.fd);//关闭cfd
                    //     epoll_ctl(epfd,EPOLL_CTL_DEL,evs[i].data.fd,&evs[i]);//将cfd上树
                    //     printf("client close\n");
                    // }
                    // else
                    // {
                    //     printf("%s\n",buf );
                    //     Write(evs[i].data.fd ,buf,n);

                    // }


                }


            }



        }


    }
    close(lfd);

   
    destroy_threadpool(thrPool);

    return 0;
}
```
# 2.复杂版的线程池实现
头文件threadpool.h：
```
#ifndef __THREADPOOL_H_
#define __THREADPOOL_H_

typedef struct threadpool_t threadpool_t;

/**
 * @function threadpool_create
 * @descCreates a threadpool_t object.
 * @param thr_num  thread num
 * @param max_thr_num  max thread size
 * @param queue_max_size   size of the queue.
 * @return a newly created thread pool or NULL
 */
threadpool_t *threadpool_create(int min_thr_num, int max_thr_num, int queue_max_size);

/**
 * @function threadpool_add
 * @desc add a new task in the queue of a thread pool
 * @param pool     Thread pool to which add the task.
 * @param function Pointer to the function that will perform the task.
 * @param argument Argument to be passed to the function.
 * @return 0 if all goes well,else -1
 */
int threadpool_add(threadpool_t *pool, void*(*function)(void *arg), void *arg);

/**
 * @function threadpool_destroy
 * @desc Stops and destroys a thread pool.
 * @param pool  Thread pool to destroy.
 * @return 0 if destory success else -1
 */
int threadpool_destroy(threadpool_t *pool);

/**
 * @desc get the thread num
 * @pool pool threadpool
 * @return # of the thread
 */
int threadpool_all_threadnum(threadpool_t *pool);

/**
 * desc get the busy thread num
 * @param pool threadpool
 * return # of the busy thread
 */
int threadpool_busy_threadnum(threadpool_t *pool);

#endif

```
```
#include <stdlib.h>
#include <pthread.h>
#include <unistd.h>
#include <assert.h>
#include <stdio.h>
#include <string.h>
#include <signal.h>
#include <errno.h>
#include "threadpool.h"

#define DEFAULT_TIME 10                 /*10s检测一次*/
#define MIN_WAIT_TASK_NUM 10            /*如果queue_size > MIN_WAIT_TASK_NUM 添加新的线程到线程池*/ 
#define DEFAULT_THREAD_VARY 10          /*每次创建和销毁线程的个数*/
#define true 1
#define false 0

// 代表一个任务
typedef struct 
{
    void *(*function)(void *);          /* 函数指针，回调函数 */
    void *arg;                          /* 上面函数的参数 */
} threadpool_task_t;                    /* 各子线程任务结构体 */

/* 描述线程池相关信息 */
struct threadpool_t 
{
    pthread_mutex_t lock;               /* 用于锁任务队列 */    
    pthread_mutex_t thread_counter;     /* 记录忙状态线程个数的锁 -- busy_thr_num */

    pthread_cond_t queue_not_full;      /* 当任务队列满时，添加任务的线程阻塞，等待此条件变量 */
    pthread_cond_t queue_not_empty;     /* 任务队列里不为空时，通知等待任务的线程 */
  
    pthread_t *threads;                 /* 存放线程池中每个线程的tid。数组 */
    pthread_t adjust_tid;               /* 存管理线程tid */
    threadpool_task_t *task_queue;      /* 任务队列(数组首地址) */

    int min_thr_num;                    /* 线程池最小线程数 */
    int max_thr_num;                    /* 线程池最大线程数 */
    int live_thr_num;                   /* 当前存活线程个数 */
    int busy_thr_num;                   /* 忙状态线程个数 */
    int wait_exit_thr_num;              /* 要销毁的线程个数 */

    int queue_front;                    /* task_queue队头下标 */
    int queue_rear;                     /* task_queue队尾下标 */
    int queue_size;                     /* task_queue队中实际任务数 */
    int queue_max_size;                 /* task_queue队列可容纳任务数上限 */

    int shutdown;                       /* 标志位，线程池使用状态，true或false */
};

void *threadpool_thread(void *threadpool);

void *adjust_thread(void *threadpool);

int is_thread_alive(pthread_t tid);
int threadpool_free(threadpool_t *pool);

//threadpool_create(3,100,100);  
threadpool_t *threadpool_create(int min_thr_num, int max_thr_num, int queue_max_size)
{
    int i;
    threadpool_t *pool = NULL;
    do 
	{
        if((pool = (threadpool_t *)malloc(sizeof(threadpool_t))) == NULL) 
		{  
            printf("malloc threadpool fail");
            break;                                      /*跳出do while。相当于使用了go to,直接跳转到下面的位置*/
        }

        pool->min_thr_num = min_thr_num;
        pool->max_thr_num = max_thr_num;
        pool->busy_thr_num = 0;
        pool->live_thr_num = min_thr_num;               /* 活着的线程数 初值=最小线程数 */
        pool->wait_exit_thr_num = 0;
        pool->queue_size = 0;                           /* 有0个任务 */
        pool->queue_max_size = queue_max_size;
        pool->queue_front = 0;
        pool->queue_rear = 0;
        pool->shutdown = false;                         /* 不关闭线程池 */

        /* 根据最大线程上限数， 给工作线程数组开辟空间, 并清零 */
        pool->threads = (pthread_t *)malloc(sizeof(pthread_t)*max_thr_num); 
        if (pool->threads == NULL) 
		{
            printf("malloc threads fail");
            break;
        }
        memset(pool->threads, 0, sizeof(pthread_t)*max_thr_num);

        /* 队列开辟空间 */
        pool->task_queue = (threadpool_task_t *)malloc(sizeof(threadpool_task_t)*queue_max_size);
        if (pool->task_queue == NULL) 
		{
            printf("malloc task_queue fail\n");
            break;
        }

        /* 初始化互斥琐、条件变量 */
        if (pthread_mutex_init(&(pool->lock), NULL) != 0
                || pthread_mutex_init(&(pool->thread_counter), NULL) != 0
                || pthread_cond_init(&(pool->queue_not_empty), NULL) != 0
                || pthread_cond_init(&(pool->queue_not_full), NULL) != 0)
        {
            printf("init the lock or cond fail\n");
            break;
        }

		//启动工作线程
		pthread_attr_t attr;
		pthread_attr_init(&attr);
		pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
        for (i = 0; i < min_thr_num; i++) 
		{
            pthread_create(&(pool->threads[i]), &attr, threadpool_thread, (void *)pool);/*pool指向当前线程池*/
            printf("start thread 0x%x...\n", (unsigned int)pool->threads[i]);
        }

		//创建管理者线程，用于根据任务的多少，动态地增加和减少线程的数量
        pthread_create(&(pool->adjust_tid), &attr, adjust_thread, (void *)pool);

        return pool;

    } while (0);

	/* 前面代码调用失败时,释放poll存储空间 */
    threadpool_free(pool);

    return NULL;
}

/* 向线程池中 添加一个任务 */
//threadpool_add(thp, process, (void*)&num[i]);   /* 向线程池中添加任务 process: 小写---->大写*/

int threadpool_add(threadpool_t *pool, void*(*function)(void *arg), void *arg)
{
    pthread_mutex_lock(&(pool->lock));

    /* ==为真，队列已经满， 调wait阻塞 */
    while ((pool->queue_size == pool->queue_max_size) && (!pool->shutdown)) 
	{
        pthread_cond_wait(&(pool->queue_not_full), &(pool->lock));
    }

    if (pool->shutdown) 
	{
        pthread_cond_broadcast(&(pool->queue_not_empty));
        pthread_mutex_unlock(&(pool->lock));
        return 0;
    }

    /* 清空 工作线程 调用的回调函数 的参数arg */
    if (pool->task_queue[pool->queue_rear].arg != NULL) 
	{
        pool->task_queue[pool->queue_rear].arg = NULL;
    }

    /*添加任务到任务队列里*/
    pool->task_queue[pool->queue_rear].function = function;
    pool->task_queue[pool->queue_rear].arg = arg;
    pool->queue_rear = (pool->queue_rear + 1) % pool->queue_max_size;       /* 队尾指针移动, 模拟环形 */
    pool->queue_size++;

    /*添加完任务后，队列不为空，唤醒线程池中 等待处理任务的线程*/
    pthread_cond_signal(&(pool->queue_not_empty));
    pthread_mutex_unlock(&(pool->lock));

    return 0;
}

/* 线程池中各个工作线程 */
void *threadpool_thread(void *threadpool)
{
    threadpool_t *pool = (threadpool_t *)threadpool;
    threadpool_task_t task;

    while (true) 
	{
        /* Lock must be taken to wait on conditional variable */
        /*刚创建出线程，等待任务队列里有任务，否则阻塞等待任务队列里有任务后再唤醒接收任务*/
        pthread_mutex_lock(&(pool->lock));

        /*queue_size == 0 说明没有任务，调 wait 阻塞在条件变量上, 若有任务，跳过该while*/
        while ((pool->queue_size == 0) && (!pool->shutdown)) 
		{  
            printf("thread 0x%x is waiting\n", (unsigned int)pthread_self());
            pthread_cond_wait(&(pool->queue_not_empty), &(pool->lock));//暂停到这

            /*清除指定数目的空闲线程，如果要结束的线程个数大于0，结束线程*/
            if (pool->wait_exit_thr_num > 0) 
			{
                pool->wait_exit_thr_num--;

                /*如果线程池里线程个数大于最小值时可以结束当前线程*/
                if (pool->live_thr_num > pool->min_thr_num) 
				{
                    printf("thread 0x%x is exiting\n", (unsigned int)pthread_self());
                    pool->live_thr_num--;
                    pthread_mutex_unlock(&(pool->lock));
					//pthread_detach(pthread_self());
                    pthread_exit(NULL);
                }
            }
        }

        /*如果指定了true，要关闭线程池里的每个线程，自行退出处理---销毁线程池*/
        if (pool->shutdown) 
		{
            pthread_mutex_unlock(&(pool->lock));
            printf("thread 0x%x is exiting\n", (unsigned int)pthread_self());
            //pthread_detach(pthread_self());
            pthread_exit(NULL);     /* 线程自行结束 */
        }

        /*从任务队列里获取任务, 是一个出队操作*/
        task.function = pool->task_queue[pool->queue_front].function;
        task.arg = pool->task_queue[pool->queue_front].arg;

        pool->queue_front = (pool->queue_front + 1) % pool->queue_max_size;       /* 出队，模拟环形队列 */
        pool->queue_size--;

        /*通知可以有新的任务添加进来*/
        pthread_cond_broadcast(&(pool->queue_not_full));

        /*任务取出后，立即将 线程池琐 释放*/
        pthread_mutex_unlock(&(pool->lock));

        /*执行任务*/ 
        printf("thread 0x%x start working\n", (unsigned int)pthread_self());
        pthread_mutex_lock(&(pool->thread_counter));                            /*忙状态线程数变量琐*/
        pool->busy_thr_num++;                                                   /*忙状态线程数+1*/
        pthread_mutex_unlock(&(pool->thread_counter));

        (*(task.function))(task.arg);                                           /*执行回调函数任务*/
        //task.function(task.arg);                                              /*执行回调函数任务*/

        /*任务结束处理*/ 
        printf("thread 0x%x end working\n", (unsigned int)pthread_self());
        pthread_mutex_lock(&(pool->thread_counter));
        pool->busy_thr_num--;                                       /*处理掉一个任务，忙状态数线程数-1*/
        pthread_mutex_unlock(&(pool->thread_counter));
    }

    pthread_exit(NULL);
}

/* 管理线程 */
void *adjust_thread(void *threadpool)
{
    int i;
    threadpool_t *pool = (threadpool_t *)threadpool;
    while (!pool->shutdown) 
	{

        sleep(DEFAULT_TIME);                                    /*定时 过一段时间就对线程增加或减少一次*/

        pthread_mutex_lock(&(pool->lock));
        int queue_size = pool->queue_size;                      /* 任务数 */
        int live_thr_num = pool->live_thr_num;                  /* 存活的线程数 */
        pthread_mutex_unlock(&(pool->lock));

        pthread_mutex_lock(&(pool->thread_counter));
        int busy_thr_num = pool->busy_thr_num;                  /* 忙着的线程数 */
        pthread_mutex_unlock(&(pool->thread_counter));

        /* 创建新线程 算法： 任务数大于最小线程池个数（不应该任务数大于不忙的线程时才增加吗？）, 且存活的线程数少于最大线程个数时 如：30>=10 && 40<100*/
        if (queue_size >= MIN_WAIT_TASK_NUM && live_thr_num < pool->max_thr_num) 
		{
            pthread_mutex_lock(&(pool->lock));  
            int add = 0;

            /*一次增加 DEFAULT_THREAD 个线程*/
            for (i = 0; i < pool->max_thr_num && add < DEFAULT_THREAD_VARY
                    && pool->live_thr_num < pool->max_thr_num; i++) 
			{
                if (pool->threads[i] == 0 || !is_thread_alive(pool->threads[i])) // 查找数组pool->threads中可用的位置 
				// pool->threads[i] == 0代表pool->threads[i]没存线程号；
				// !is_thread_alive(pool->threads[i])为真代表存储的线程已死
				{
                    pthread_create(&(pool->threads[i]), NULL, threadpool_thread, (void *)pool);
                    add++;
                    pool->live_thr_num++;
                }
            }

            pthread_mutex_unlock(&(pool->lock));
        }

        /* 销毁多余的空闲线程 算法：忙线程X2 小于 存活的线程数 且 存活的线程数 大于 最小线程数时*/
        if ((busy_thr_num * 2) < live_thr_num  &&  live_thr_num > pool->min_thr_num) 
		{
            /* 一次销毁DEFAULT_THREAD个线程, 隨機10個即可 */
            pthread_mutex_lock(&(pool->lock));
            pool->wait_exit_thr_num = DEFAULT_THREAD_VARY;      /* 要销毁的线程数 设置为10 */
            pthread_mutex_unlock(&(pool->lock));

            for (i = 0; i < DEFAULT_THREAD_VARY; i++) 
			{
                /* 通知处在空闲状态的线程, 他们会自行终止*/
                pthread_cond_signal(&(pool->queue_not_empty));
            }
        }
    }

    return NULL;
}

int threadpool_destroy(threadpool_t *pool)
{
    int i;
    if (pool == NULL) 
	{
        return -1;
    }
    pool->shutdown = true;

    /*先销毁管理线程*/
    //pthread_join(pool->adjust_tid, NULL);

    for (i = 0; i < pool->live_thr_num; i++) 
	{
        /*通知所有的空闲线程*/
        pthread_cond_broadcast(&(pool->queue_not_empty));
    }

    /*for (i = 0; i < pool->live_thr_num; i++) 
	{
        pthread_join(pool->threads[i], NULL);
    }*/

    threadpool_free(pool);

    return 0;
}

int threadpool_free(threadpool_t *pool)
{
    if (pool == NULL) 
	{
        return -1;
    }

    if (pool->task_queue) 
	{
        free(pool->task_queue);
    }

    if (pool->threads) 
	{
        free(pool->threads);
        pthread_mutex_lock(&(pool->lock));
        pthread_mutex_destroy(&(pool->lock));
        pthread_mutex_lock(&(pool->thread_counter));
        pthread_mutex_destroy(&(pool->thread_counter));
        pthread_cond_destroy(&(pool->queue_not_empty));
        pthread_cond_destroy(&(pool->queue_not_full));
    }

    free(pool);
    pool = NULL;

    return 0;
}

int threadpool_all_threadnum(threadpool_t *pool)
{
    int all_threadnum = -1;

    pthread_mutex_lock(&(pool->lock));
    all_threadnum = pool->live_thr_num;
    pthread_mutex_unlock(&(pool->lock));

    return all_threadnum;
}

int threadpool_busy_threadnum(threadpool_t *pool)
{
    int busy_threadnum = -1;

    pthread_mutex_lock(&(pool->thread_counter));
    busy_threadnum = pool->busy_thr_num;
    pthread_mutex_unlock(&(pool->thread_counter));

    return busy_threadnum;
}

int is_thread_alive(pthread_t tid)
{
    int kill_rc = pthread_kill(tid, 0);     //发0号信号，测试线程是否存活
    if (kill_rc == ESRCH) 
	{
        return false;
    }

    return true;
}

/*测试*/ 

#if 1
/* 线程池中的线程，模拟处理业务 */
void *process(void *arg)
{
    printf("thread 0x%x working on task %d\n ",(unsigned int)pthread_self(),*(int *)arg);
    sleep(1);
    printf("task %d is end\n", *(int *)arg);

    return NULL;
}

int main(void)
{
    /*threadpool_t *threadpool_create(int min_thr_num, int max_thr_num, int queue_max_size);*/
    threadpool_t *thp = threadpool_create(3,100,100);   /*创建线程池，池里最小3个线程，最大100，队列最大100*/
    printf("pool inited");

    //int *num = (int *)malloc(sizeof(int)*20);
    int num[20], i;
    for (i = 0; i < 20; i++) 
	{
        num[i]=i;
        printf("add task %d\n",i);
        threadpool_add(thp, process, (void*)&num[i]);   /* 向线程池中添加任务 */
    }

    sleep(10);                                          /* 等子线程完成任务 */
    threadpool_destroy(thp);

    return 0;
}

#endif
```
]]></description></item><item><title>vscode python 环境配置</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/05/17/16282625.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Tue, 17 May 2022 14:09:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/05/17/16282625.html</guid><description><![CDATA[vscode python 环境配置
新建launch.json，内容如下：

```
{
    // 使用 IntelliSense 了解相关属性。 
    // 悬停以查看现有属性的描述。
    // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387
    "version": "0.2.0",
    "configurations": [

        {
            "name": "Python",
            "type": "python",
            "request": "launch",
            "program": "${file}",
             "pythonPath": "C:\\Users\\hetao\\anaconda3\\python.exe",
            "console": "integratedTerminal",
            "args": [
                "--source","human.jpg"
            ],
            "cwd": "${fileDirname}"             // 设置相对路径，在debug时可以切换到当前文件所在的目录
         },
         
    ]
}

```
【注】打开哪个文件，就会运行哪个文件。故运行文件A时，记得要打开文件A，然后再点运行。]]></description></item><item><title>Linux下端口被占用（例如端口3000），关掉端口占用的进程的方法</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/05/17/16282619.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Tue, 17 May 2022 14:06:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/05/17/16282619.html</guid><description><![CDATA[Linux下端口被占用（例如端口3000），关掉端口占用的进程的方法：
```
# 查询进程号
# netstat -tln | grep 8090
sudo lsof -i:8090
# 杀死进程
sudo kill -9 进程号
```]]></description></item><item><title>Label class 79 exceeds nc=79 in /home/zwl/study/ML_DL/yolov5-master/data/cla</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/05/17/16282597.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Tue, 17 May 2022 14:01:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/05/17/16282597.html</guid><description><![CDATA[
错误：
Label class 79 exceeds nc=79 in /home/zwl/study/ML_DL/yolov5-master/data/cla
解决：
txt格式的labels每个种类标的是有序号的，序号从0开始以此递增。
我出现错误的原因是：有79个类，但序号却是从0到21，23到79，缺少了22。
故将序号改为0~79就行了
参考：[此链接的评论区](https://blog.csdn.net/qq_45714906/article/details/120528631)]]></description></item><item><title>组会</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/05/16/16276741.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Mon, 16 May 2022 05:58:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/05/16/16276741.html</guid><description><![CDATA[


检测是否有物体和分类分开进行：互相依赖的，不能分开。
除非说，你检测出人，然后利用得到的人的框，检测这里面有没有救生衣。那还是要有检测人这一项，
检测出物体，是个伪命题，什么是物体。也就说物体必须有明确地指向。即要得到物体的框，就必须要指明物体的类型。







yolov5原理是什么：






问题：
如果你要在八十类上面添加第八十一类。必须考虑：
1.加入第八十一的数据集中，如果图片包含前八十类的，那么就必须把这八十类也框出来，不然就会影响前八十类的检测受到影响。
2.由于要输出八十一类，故需要修改网络结构。故需要将第八十一的数据集和前八十类的数据集都加进去训练。
这就要求我们必须要去检查前八十类的数据集中，如果图片包含第八十一类，就必须要框出来。这个工作量就很大。

解决方法：
1.让第八十一的数据集中只含有一个类，那么第八十一的数据集会过于简单。那么模型就难以预测一个图片中有多个类，因为训练的时候没见过。。
2.coco有八十类。只训练coco的前79类，得到预训练模型，通过预训练模型，增加一类，训练得到80类的模型。
预训练模型跑得需要时间一两天，有时弄错就要重新跑，还没弄完。


问题：
yolov5在八十类的检测中P就0.4多，R就0.6多。故得到这样的模型没有实际的意义。只是为了写论文，刷榜才有用。当类别多了以后，检测出来就不准了。
![](https://user-images.githubusercontent.com/26833433/90222759-949d8800-ddc1-11ea-9fa1-1c97eed2b963.png)

有意义的事，是去识别少量的类。就像临水项目中那样，让检测的准确率高一些（95%以上）


至于用八十类的预训练模型，识别一个类，这就是临时水项目中师兄做的————用预训练模型去实现人员检测，最后达到95%，用了上万的数据集







一百三个轮次以后，概率区域稳定。p:6点多，R：五点多，因为昨晚断电了，忘记截图保存了。
一个用于训练一个类的结果：




# 1200
![](https://img2022.cnblogs.com/blog/1617829/202205/1617829-20220531101954193-1061825470.png)

17个epoch之后模型性能不在提升。反而下降

![](https://img2022.cnblogs.com/blog/1617829/202205/1617829-20220531143113931-2035376920.png)
![](https://img2022.cnblogs.com/blog/1617829/202205/1617829-20220531143257153-646705527.png)


#600

![](https://img2022.cnblogs.com/blog/1617829/202205/1617829-20220531145959997-1829286325.png)

![](https://img2022.cnblogs.com/blog/1617829/202205/1617829-20220531150054621-1786873946.png)

![](https://img2022.cnblogs.com/blog/1617829/202205/1617829-20220531150133106-688146962.png)


# 300   
![](https://img2022.cnblogs.com/blog/1617829/202205/1617829-20220531153152703-1238758818.png)

![](https://img2022.cnblogs.com/blog/1617829/202205/1617829-20220531153210848-160108225.png)

![](https://img2022.cnblogs.com/blog/1617829/202205/1617829-20220531153235899-677496670.png)


# 400
![](https://img2022.cnblogs.com/blog/1617829/202205/1617829-20220531164906867-2056168351.png)

![](https://img2022.cnblogs.com/blog/1617829/202205/1617829-20220531165000918-403547539.png)

![](https://img2022.cnblogs.com/blog/1617829/202205/1617829-20220531165015632-1913259977.png)

超过100个epoch没有提升，就跳出

# 500
![](https://img2022.cnblogs.com/blog/1617829/202205/1617829-20220531193756965-583848355.png)
![](https://img2022.cnblogs.com/blog/1617829/202205/1617829-20220531193905016-491802746.png)

![](https://img2022.cnblogs.com/blog/1617829/202205/1617829-20220531193834294-648608736.png)





不同的类需要的数据量可能不一致？
不可能实验很多个类然后做平均吧，太麻烦了。而且数据集去哪找。可以找到也是个大的工程，
只能说输进去多少，达到多少的准确率。如果你想要更大的准确率，就请多输入点数据。
这就跑个模型，
感觉所有需要跑的人，都可以会跑，，，而且还可以直接改改网络。自己看看想冻结什么网络就冻结什么网络，跑出来效果肯定更好
提供接口供别人轻易地使用？？？
只能说算个大概，





# 只有mask时
## 1200
![](https://img2022.cnblogs.com/blog/1617829/202205/1617829-20220531202938132-1961088668.png)
![](https://img2022.cnblogs.com/blog/1617829/202205/1617829-20220531203444955-1549647547.png)


# 20220606

后端代码的实现流程

视频显示有问题，看ffmpeg、opencv




C++的编译链接问题



  
]]></description></item><item><title>mongoose实现web服务器</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/05/14/16271138.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Sat, 14 May 2022 11:43:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/05/14/16271138.html</guid><description><![CDATA[# 1.简介
Mongoose Web Server是一款易于使用的Web服务器，它可以嵌入到其它应用程序中，为其提供Web接口。
mongoose的代码着实轻量，先看看它的特点：
1. 在整个的实现是使用C语言编写
2. 整个代码也只有一个mongoose.c和mongoose.h两个文件， 从引入第三方的考虑上也着实不多。
3. 实现的功能还是非常多的，从使用的层面上来说功能还是比较全面。只不过不知道是否是为了第三方使用的方便还是怎么地，它的代码只用了两个源文件罢了。诸多的功能也大以宏的开始与结束来区分。
4. 示例非常齐全，所有的功能都有单独的示例。
5.支持夸平台。


# 2.数据结构
## 2.1.mg_mgr

mg_mgr是mongoose中进行事件管理的结构体，事件分为5种类型， 共享同一个回调函数，事件类型通过传参区分。
```
#define MG_EV_POLL 0    /* Sent to each connection on each mg_mgr_poll() call */
#define MG_EV_ACCEPT 1  /* New connection accepted. union socket_address * */
#define MG_EV_CONNECT 2 /* connect() succeeded or failed. int *  */
#define MG_EV_RECV 3    /* Data has been received. int *num_bytes */
#define MG_EV_SEND 4    /* Data has been written to a socket. int *num_bytes */
#define MG_EV_CLOSE 5   /* Connection is closed. NULL */
#define MG_EV_TIMER 6   /* now >= conn->ev_timer_time. double * */
```
完整数据结构如下：
```
/*
 * Mongoose event manager.
 */
struct mg_mgr {
  struct mg_connection *active_connections;
#if MG_ENABLE_HEXDUMP
  const char *hexdump_file; /* Debug hexdump file path */
#endif
#if MG_ENABLE_BROADCAST
  sock_t ctl[2]; /* Socketpair for mg_broadcast() */
#endif
  void *user_data; /* User data */
  int num_ifaces;
  struct mg_iface **ifaces; /* network interfaces */
  const char *nameserver;   /* DNS server to use */
};

#define MG_SOCKET_IFACE_VTABLE \
{ \
mg_socket_if_init, \
mg_socket_if_free, \
mg_socket_if_add_conn, \
mg_socket_if_remove_conn, \
mg_socket_if_poll, \
mg_socket_if_listen_tcp, \
mg_socket_if_listen_udp, \
mg_socket_if_connect_tcp, \
mg_socket_if_connect_udp, \
mg_socket_if_tcp_send, \
mg_socket_if_udp_send, \
mg_socket_if_recved, \
mg_socket_if_create_conn, \
mg_socket_if_destroy_conn, \
mg_socket_if_sock_set, \
mg_socket_if_get_conn_addr, \
}
```
重要成员：
```
active_connections ：当前活动的连接，如果有多个，则以链表形式挂接
ctl：　broadcast 的socket
ifaces：网络相关的接口集合，在linux下默认为socket相关接口 
```


## 2.2. mg_connection
mg_connection是一个具体连接实例 

完整数据结构如下：
```
/*
 * Mongoose connection.
 */
struct mg_connection {
  struct mg_connection *next, *prev; /* mg_mgr::active_connections linkage */
  struct mg_connection *listener;    /* Set only for accept()-ed connections */
  struct mg_mgr *mgr;                /* Pointer to containing manager */

  sock_t sock; /* Socket to the remote peer */
  int err;
  union socket_address sa; /* Remote peer address */
  size_t recv_mbuf_limit;  /* Max size of recv buffer */
  struct mbuf recv_mbuf;   /* Received data */
  struct mbuf send_mbuf;   /* Data scheduled for sending */
  time_t last_io_time;     /* Timestamp of the last socket IO */
  double ev_timer_time;    /* Timestamp of the future MG_EV_TIMER */
#if MG_ENABLE_SSL
  void *ssl_if_data; /* SSL library data. */
#endif
  mg_event_handler_t proto_handler; /* Protocol-specific event handler */
  void *proto_data;                 /* Protocol-specific data */
  void (*proto_data_destructor)(void *proto_data);
  mg_event_handler_t handler; /* Event handler function */
  void *user_data;            /* User-specific data */
  union {
    void *v;
    /*
     * the C standard is fussy about fitting function pointers into
     * void pointers, since some archs might have fat pointers for functions.
     */
    mg_event_handler_t f;
  } priv_1;
  void *priv_2;
  void *mgr_data; /* Implementation-specific event manager's data. */
  struct mg_iface *iface;
  unsigned long flags;
/* Flags set by Mongoose */
#define MG_F_LISTENING (1 << 0)          /* This connection is listening */
#define MG_F_UDP (1 << 1)                /* This connection is UDP */
#define MG_F_RESOLVING (1 << 2)          /* Waiting for async resolver */
#define MG_F_CONNECTING (1 << 3)         /* connect() call in progress */
#define MG_F_SSL (1 << 4)                /* SSL is enabled on the connection */
#define MG_F_SSL_HANDSHAKE_DONE (1 << 5) /* SSL hanshake has completed */
#define MG_F_WANT_READ (1 << 6)          /* SSL specific */
#define MG_F_WANT_WRITE (1 << 7)         /* SSL specific */
#define MG_F_IS_WEBSOCKET (1 << 8)       /* Websocket specific */

/* Flags that are settable by user */
#define MG_F_SEND_AND_CLOSE (1 << 10)       /* Push remaining data and close  */
#define MG_F_CLOSE_IMMEDIATELY (1 << 11)    /* Disconnect */
#define MG_F_WEBSOCKET_NO_DEFRAG (1 << 12)  /* Websocket specific */
#define MG_F_DELETE_CHUNK (1 << 13)         /* HTTP specific */
#define MG_F_ENABLE_BROADCAST (1 << 14)     /* Allow broadcast address usage */
#define MG_F_TUN_DO_NOT_RECONNECT (1 << 15) /* Don't reconnect tunnel */

#define MG_F_USER_1 (1 << 20) /* Flags left for application */
#define MG_F_USER_2 (1 << 21)
#define MG_F_USER_3 (1 << 22)
#define MG_F_USER_4 (1 << 23)
#define MG_F_USER_5 (1 << 24)
#define MG_F_USER_6 (1 << 25)
};
```
结构体重要成员：
```
next、prev：  下、上一个连接
mgr：对应的事件管理
sock： 对应的socket
sa： socket的地址
recv_mbuf、send_mbuf ： 发送和接受的buffer
proto_handler、handler： 协议的回调函数和事件回调函数
```



## 2.3.实现方式

整个流程其实很简单，可分为以下三步

1.mg_mgr_init：先对mgr进行初始化，主要是将相关的socket接口函数集合赋值给mgr.ifaces

2.mg_bind：该步骤主要为一个mg_connection申请内存，并将事件回调函数ev_handler注册到该连接里，并且初始化若干个（由网卡数量决定）http端口的socket进行监听

3.mg_mgr_poll：该函数调用mongoose中提供的poll接口：mg_socket_if_poll。在该函数中，对所有初始化的socket进行select操作,在退出select的阻塞后，根据read_fd_set, write_fd_set, err_fd_set 进行判断，将退出阻塞的socket分类，然后进行分类处理。


# 3.使用 mongoose 实现简单的封装

在https://github.com/cesanta/mongoose中下载mongoose.c和mongoose.h两个文件

HttpService .h 的实现：
```
#pragma once
 
/*
Http服务
*/
 
 
#ifdef _WIN32
#include <winsock2.h>
#include <stdio.h>
#pragma comment(lib,"ws2_32.lib")
#endif
 
#include "mongoose.h"
 
class HttpService {
  public:
    bool start(const char *port);
  private:
    static void mgEvHandler(struct mg_connection *nc, int ev, void *p);
    static void mgSendBody(struct mg_connection *nc, const char *content); //发送body信息
    static void mgSendFile(struct mg_connection *nc, struct http_message *hm, const char* filePath);
    static struct mg_serve_http_opts s_http_server_opts;
};
```
HttpService .cpp 的实现：
```
  
#include "HttpService.h"
 
struct mg_serve_http_opts HttpService::s_http_server_opts;
 
//请求事件处理
void HttpService::mgEvHandler(struct mg_connection *nc, int ev, void *p) { // 形参好像固定是这三种类型
    //处理request
    if (ev == MG_EV_HTTP_REQUEST) {
        struct http_message *msg = (struct http_message *)p;
 
        //body内容
        char* body = new char[msg->body.len + 1];
        memset(body, 0, msg->body.len + 1);
        memcpy(body, msg->body.p, msg->body.len);
 
        //uri内容
        char* uri = new char[msg->uri.len + 1];
        memset(uri, 0, msg->uri.len + 1);
        memcpy(uri, msg->uri.p, msg->uri.len);
 
        //返回body信息
        mgSendBody(nc, "body content");
 
        //返回下载文件
        //mgSendFile("相对于s_http_server_opts.document_root的文件路径");
 
        delete uri;
        delete body;
    }
}
 
//发送body信息
void HttpService::mgSendBody(struct mg_connection *nc, const char *content) {
    mg_send_head(nc, 200, strlen(content), "Content-Type: text/plain\r\nConnection: close");
    mg_send(nc, content, strlen(content));
    nc->flags |= MG_F_SEND_AND_CLOSE;
}
 
//发送文件，文件的位置是相对于s_http_server_opts.document_root的路径
void HttpService::mgSendFile(struct mg_connection *nc, struct http_message *hm, const char* filePath) {
    mg_http_serve_file(nc, hm, filePath, mg_mk_str("text/plain"), mg_mk_str(""));
}
 
//初始化并启动
bool HttpService::start(const char *port) {
    struct mg_mgr mgr;
    struct mg_connection *nc;
 
    mg_mgr_init(&mgr, NULL);
    printf("Starting web server on port %s\n", port);
    nc = mg_bind(&mgr, port, mgEvHandler);
    if (nc == NULL) {
        printf("Failed to create listener\n");
        return false;
    }
 
    // Set up HTTP server parameters
    mg_set_protocol_http_websocket(nc);
    s_http_server_opts.document_root = ".";  //文件相对路径 Serve current directory
    s_http_server_opts.enable_directory_listing = "yes";
 
    for (;;) {
        mg_mgr_poll(&mgr, 1000); //1s轮训一次
    }
    mg_mgr_free(&mgr);
 
    return true;
}

int main(){
	HttpService server;
	server.start("8090");
	return 0;
}
```

运行命令：
```
g++ mongoose.c HttpService.cpp -lpthread -o server
```
HttpService.cpp调用mongoose.c中的函数，即C++中调用c，不知道为什么，可以直接进行编译，不过要加上-lpthread就行










参考：[mongoose(WEB服务器) 简单走读](https://www.cnblogs.com/luo-ruida/p/7732287.html)

[利用mongoose实现http服务](https://blog.csdn.net/houxian1103/article/details/113765217)
[C语言和C++的混合编译](http://c.biancheng.net/view/7494.html)]]></description></item><item><title>vue基础</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/05/12/16264808.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Thu, 12 May 2022 14:50:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/05/12/16264808.html</guid><description><![CDATA[# 1.安装和运行
**1.安装node.js**
node.js下载链接：https://nodejs.org/en/download/
安装node.js以后，npm就默认被安装了
查看是否安装成功
```
node -v
npm -v
```

**2.安装cnpm**
npm国内速度太慢，下载cnpm来用：
```
npm install -g cnpm --registry=https://registry.npm.taobao.org
```
这个过程不用管warning

利用cnpm -v看是否安装成功

**3.安装vue cli**
```
cnpm install -g @vue/cli
vue -V    # 检查是否安装成功
```
```
vue create serv  # 创建项目serv    
cd serv
npm run serve    # 运行项目
```

一些插件的安装：[链接](https://blog.csdn.net/seimeii/article/details/121115540)。使用cnpm安装更快。

**3.vscode中安装eslint**
在vscode中安装eslint:https://www.cnblogs.com/sheseido/p/12357144.html
记得安装完了要重启。
每一次ctrl+s保存后，都会自动格式化

# 2.
HTML DOM 定义了访问和操作 HTML 文档的标准方法。
DOM 以树结构表达 HTML 文档。
![](https://img2022.cnblogs.com/blog/1617829/202205/1617829-20220513101551679-1440404150.png)



CDN：导入远程的在线js文件


# 3.vue语法
参考：[菜鸟教程](https://www.runoob.com/vue3/vue3-intro.html)

在HTML文件中引入 vue.global.js 文件来测试学习。

```
Vue.createApp(HelloVueApp).mount('#hello-vue')   # 将组件HelloVueApp挂载到id为DOM 元素
```














鱼皮的介绍的一些网站，用于制作网站：https://www.bilibili.com/video/BV1CM4y137kF

vue就是一个单纯的前端，没有什么后端的操作吗？？如果是的话，那我直接找一个写好的前端来用，不更省事？？
]]></description></item><item><title>makefile使用</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/05/12/16262239.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Thu, 12 May 2022 06:06:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/05/12/16262239.html</guid><description><![CDATA[# 1.Makefile
## 1.1.Makefile简介
makefile用于编译整个项目.
一个工程中的源文件不计其数，其按类型、功能、模块分别放在若干个目录中，makefile定义了一系列的规则来指定，哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为 makefile就像一个Shell脚本一样，其中也可以执行操作系统的命令。

Makefile带来的好处就是——“自动化编译”，一旦写好，只需要一个make命令，整个工程完全自动编译，极大的提高了软件开发的效率。make是一个命令工具，是一个解释makefile中指令的命令工具，一般来说，大多数的IDE都有这个命令，比如：Delphi的make，Visual C++的nmake，Linux下GNU的make。可见，makefile都成为了一种在工程方面的编译方法。

make主要解决两个问题：
1) 大量代码的关系维护
大项目中源代码比较多，手工维护、编译时间长而且编译命令复杂，难以记忆及维护
把代码维护命令及编译命令写在makefile文件中，然后再用make工具解析此文件自动执行相应命令，可实现代码的合理编译
2) 减少重复编译时间
n 在改动其中一个文件的时候，能判断哪些文件被修改过，可以只对该文件进行重新编译，然后重新链接所有的目标文件，节省编译时间

Makefile文件命名规则：makefile和Makefile都可以，推荐使用Makefile。

make工具的安装：sudo apt install make

## 1.2.make与cmake
不同平台有自己的make标准。如果软件想跨平台，必须要保证能够在不同平台编译。而如果使用上面的 Make 工具，就得为每一种标准写一次 Makefile ，这将是一件让人抓狂的工作。
CMake就是针对上面问题所设计的工具：它首先允许开发者编写一种平台无关的 CMakeList.txt 文件来定制整个编译流程，然后再根据目标用户的平台进一步生成所需的本地化 Makefile 和工程文件，如 Unix 的 Makefile 或 Windows 的 Visual Studio 工程。从而做到“Write once, run everywhere”。


[参考](https://blog.csdn.net/qq_28038207/article/details/80791694)


# 2.Makefile语法规则
## 2.1.一条规则
一条规则：
```
目标：依赖文件列表
<Tab>命令列表
```

Makefile基本规则三要素：
1）目标：
通常是要产生的文件名称，目标可以是可执行文件或其它obj文件，也可是一个动作的名称
2）依赖文件：
- 用来输入从而产生目标的文件
- 一个目标通常有几个依赖文件（可以没有）

3）命令：
- make执行的动作，一个规则可以含几个命令（可以没有）
- 有多个命令时，每个命令占一行
 
示例代码：
```
test:
  echo "hello world"
```
依赖文件可以没有；
echo前面要Tab一下;
```
all:test1  test2
  echo "hello all"

test1:
  echo "hello test1"

test2:
  echo "hello test2"
```
test依赖test1和test2，然后通过test下面代码就可以获取到test1和test2。
依赖test1和test2用空格隔开。
执行命令：make -f 1.mk 
执行结果：
```
echo "hello test1"
hello test1
echo "hello test2"
hello test2
echo "hello all"
hello all
```
还可以执行：
make test1 -f 1.mk   # 执行其他目标
make test1 test2 -f 1.mk  # 执行多个目标


## 2.2.make命令格式
make是一个命令工具，它解释Makefile 中的指令（应该说是规则）。

make命令格式：
make [ -f file ][ options ][ targets ]

**1.[ -f file ]**
make默认在工作目录中寻找名为GNUmakefile、makefile、Makefile的文件作为makefile输入文件
-f 可以指定以上名字以外的文件作为makefile输入文件

**2.[ options ]**

-v： 显示make工具的版本信息
-w： 显示开始处理makefile时所在的工作目录和显示结束makefile文件的处理时所在的工作路径
-C dir：读取目录dir下的makefile文件，如make -C 7makefile/ -f. 1.mk：读取7makefile目录下的1.mk文件
-n：只打印要执行的命令但不执行
-s：执行但不显示执行的命令

**3.[ targets ]**

若使用make命令时没有指定目标，则make工具默认会实现makefile文件内的第一个目标，然后退出
指定了make工具要实现的目标，目标可以是一个或多个（多个目标间用空格隔开）。


## 2.3.Makefile示例
测试程序： test.c add.c sub.c mul.c div.c

**1.最简单的Makefile**
Makefile文件如下：
```
test:test.c add.c sub.c mul.c div.c
    gcc test.c add.c sub.c mul.c div.c -o test
```
在Makefile所在目录下输入，make即可执行Makefile。
缺点：效率低，修改一个文件，所有文件会被全部编译

**2.第二个版本Makefile**
Makefile文件如下：
```
test:test.o add.o sub.o mul.o div.o
    gcc test.o add.o sub.o mul.o div.o -o test
​
test.o:test.c
    gcc -c test.c
add.o:add.c
    gcc -c add.c
sub.o:sub.c
    gcc -c sub.c
mul.o:mul.c
    gcc -c mul.c
div.o:div.c
    gcc -c div.c
```
如果修改add.c文件，那么make命令只会重新编译add.c文件，其他文件不会重新编译。


## 2.4.Makefile中的变量

在Makefile中使用变量有点类似于C语言中的宏定义，使用该变量相当于内容替换，使用变量可以使Makefile易于维护,修改内容变得简单变量定义及使用。

### 2.4.1.自定义变量

1）定义变量方法：
变量名=变量值

2）引用变量：
$(变量名)或${变量名}
 
3）makefile的变量名：
- makefile变量名可以以数字开头
- 变量是大小写敏感的
- 变量一般都在makefile的头部定义
- 变量几乎可在makefile的任何地方使用
 

示例：

```
#变量
OBJS=add.o sub.o mul.o div.o test.o
TARGET=test
​
$(TARGET):$(OBJS)
    gcc $(OBJS) -o $(TARGET) 
​
add.o:add.c
    gcc -c add.c -o add.o
​
sub.o:sub.c
    gcc -c sub.c -o sub.o
​
mul.o:mul.c
    gcc -c mul.c -o mul.o
​
div.o:div.c
    gcc -c div.c -o div.o
​
test.o:test.c
    gcc -c test.c -o test.o
​
clean:
    rm -rf $(OBJS) $(TARGET)

```
除了使用用户自定义变量，makefile中也提供了一些变量（变量名大写）供用户直接使用，我们可以直接对其进行赋值。
> CC = gcc  # 选择gcc作为编译器
CPPFLAGS : C预处理的选项 如:CPPFLAGS = -I
CFLAGS: C编译器的选项 如CFLAGS = -Wall -g -c
LDFLAGS : 链接器选项，如LDFLAGS = -L -l

上述代码运行：make clean # 实现清理工作


### 2.4.2.自动变量
- $@: 表示规则中的目标
- $<: 表示规则中的第一个依赖
- $^: 表示规则中的所有依赖, 组成一个列表, 以空格隔开,如果这个列表中有重复的项则消除重复项。

注意：自动变量只能在规则的命令中使用

参考示例：
```
#变量
OBJS=add.o sub.o mul.o div.o test.o add.o
TARGET=test
CC=gcc
​
#$@: 表示目标。“眼睛代表目标”
#$<: 表示第一个依赖
#$^: 表示所有的依赖。“一把伞撑起了所有”代表所有依赖
​
$(TARGET):$(OBJS)    # 这里不能使用$^，因为自动变量只能在规则的命令中使用
    $(CC) $^ -o $@   # 等价于#$(CC) $(OBJS) -o $(TARGET) 
    echo $@
    echo $<
    echo $^
​
add.o:add.c
    $(CC) -c $< -o $@ 
​
sub.o:sub.c
    $(CC) -c $< -o $@ 
​
mul.o:mul.c
    $(CC) -c $< -o $@ 
​
div.o:div.c
    $(CC) -c $< -o $@ 
​
test.o:test.c
    $(CC) -c $< -o $@
​
clean:
    rm -rf $(OBJS) $(TARGET)
```


### 2.4.3.模式规则
模式规则示例:
```
%.o:%.c
```
Makefile第三个版本：
```
OBJS=test.o add.o sub.o mul.o div.o
TARGET=test
$(TARGET):$(OBJS)
    gcc $(OBJS) -o $(TARGET) 

%.o:%.c               ​# 模式匹配所有的.o都依赖对应的.c
    gcc -c $< -o $@   # 将所有的.c生成对应的.o
```

# 3.Makefile中的函数
```
makefile中的函数有很多，在这里给大家介绍两个最常用的。

wildcard – 查找指定目录下的指定类型的文件
src = $(wildcard *.c) //找到当前目录下所有后缀为.c的文件,赋值给src

patsubst – 匹配替换
obj = $(patsubst %.c,%.o, $(src)) //把src变量里所有后缀为.c的文件替换成.o
```
在makefile中所有的函数都是有返回值的。

Makefile第四个版本：
```
SRC=$(wildcard *.c)
OBJS=$(patsubst %.c, %.o, $(SRC))
TARGET=test
$(TARGET):$(OBJS)
    gcc $(OBJS) -o $(TARGET) 
​
%.o:%.c
    gcc -c $< -o $@
```


# 4.Makefile中的伪目标
clean用途: 清除编译生成的中间.o文件和最终目标文件
make clean 如果当前目录下有同名clean文件，则不执行clean对应的命令，解决方案：

伪目标声明: .PHONY:clean
声明目标为伪目标之后，makefile将不会该判断目标是否存在或者该目标是否需要更新，而是直接执行Makefile中的clean命令


**clean命令中的特殊符号：**
- “-”此条命令出错，make也会继续执行后续的命令。如:“-rm main.o”
- “@”不显示命令本身,只显示结果。如:“@echo clean done”
 
Makefile第五个版本：
```
SRC=$(wildcard *.c)
OBJS=$(patsubst %.c, %.o, $(SRC))
TARGET=test
$(TARGET):$(OBJS)
    gcc $(OBJS) -o $(TARGET) 
​
%.o:%.c
    @gcc -c $< -o $@  # 最前面加了一个"@"，代表只执行不显示执行命令
.PHONY:clean
clean:
    -rm -rf $(OBJS) $(TARGET) # 最前面加了一个"-"，代表此条命令出错，make也会继续执行后续的命令
```

总结： 一条规则，两个函数，三个变量。



# 5.Makefile工作原理
**1.生成目标**
若想生成目标, 检查规则中的依赖条件是否存在,如不存在,则寻找是否有规则用来生成该依赖文件
![](https://img2022.cnblogs.com/blog/1617829/202205/1617829-20220512191937952-1478668155.png)

比如：
```
test:test.o add.o sub.o mul.o div.o
    gcc test.o add.o sub.o mul.o div.o -o test
​
test.o:test.c
    gcc -c test.c
add.o:add.c
    gcc -c add.c
sub.o:sub.c
    gcc -c sub.c
mul.o:mul.c
    gcc -c mul.c
div.o:div.c
    gcc -c div.c
```
上述代码，目标test依赖test.o，但是目录下没有test.o文件，此时就在Makefile中寻找是否有目标为test.o的规则，最后通过规则生成test.o。
先在目录下查找test.o，如果没有找到，再去查找是否有生成test.o的规则。
**2.更新目标**
检查规则中的目标是否需要更新，必须先检查它的所有依赖,依赖中有任一个被更新,则目标必须更新
![](https://img2022.cnblogs.com/blog/1617829/202205/1617829-20220512192631759-2011245100.png)

from 黑马程序员笔记





# 6.其他

## 6.1.“=”与“:=”
**“=”：**make会将整个makefile展开后，再决定变量的值。也就是说，变量的值将会是整个makefile中最后被指定的值。看例子：
```
x = foo
y = $(x) bar
x = xyz
```
在上例中，y的值将会是 xyz bar ，而不是 foo bar 。


**“:=”：**表示变量的值决定于它在makefile中的位置，而不是整个makefile展开后的最终值。
```
x := foo
y := $(x) bar
x := xyz
```
在上例中，y的值将会是 foo bar ，而不是 xyz bar 了。

参考：[Makefile 中:= ?= += =的区别](https://www.cnblogs.com/wanqieddy/archive/2011/09/21/2184257.html)

##6.2.ifeq、ifneq、ifdef和ifndef（条件判断）

ifeq 和 ifneq：判断两个参数是否相等



注意：条件语句只能用于控制 make 实际执行的 Makefile 文件部分，不能控制规则的 shell 命令执行的过程。
上面这句是什么意思？

参考：[Makefile ifeq、ifneq、ifdef和ifndef（条件判断）](http://c.biancheng.net/view/7068.html)



## 6.5 .PHONY的作用
**.PHONY的作用一：不产生目标文件**
.PHONY是一个伪目标，Makefile中将.PHONY放在一个目标前就是指明这个目标是伪文件目标。其作用就是防止在Makefile中定义的执行命令的目标和工作目录下的实际文件出现名字冲突。例子如下：
```
clean :
  rm *.o temp
```
上述Makefile文件在第一次执行make clean以后会产生clean文件，导致第二次运行make clean失败。
```
.PHONY : clean
clean :
  rm *.o temp
```
上述Makefile文件在第一次执行make clean以后不会产生clean文件，不会导致第二次运行make clean失败。


**.PHONY的作用二：编译多个文件**
```
all : prog1 prog2 prog3
.PHONY : all
prog1 : prog1.o utils.o
  cc -o prog1 prog1.o utils.o
prog2 : prog2.o
  cc -o prog2 prog2.o
prog3 : prog3.o sort.o utils.o
  cc -o prog3 prog3.o sort.o utils.o
```
上述Makefile文件设置了伪目标all，执行Makefile不会生成all文件，但是all的依赖文件prog1、prog2和prog3会被生成。
这样我们就使用Makefile文件编译生成了三个可执行文件——prog1、prog2和prog3。



参考：[如何用一个makefile编译多个目标](https://blog.csdn.net/a815064247/article/details/79442567)



## 6.4.一个makefile示例
makefile的示例学习。本代码摘录于具体项目，有完整的注释，直接看代码学习即可。
```
cc        := g++
name      := pro
workdir   := workspace
srcdir    := src
objdir    := objs
stdcpp    := c++11
syslib    := /home/xd2/.local/lib/python3.6/site-packages/trtpy/lib
cpp_pkg   := /home/zwl/software


cpp_srcs := $(shell find src -name "*.cpp") # 查找src目录下所有.cpp文件，返回字串，示例：src/1.cpp src/2.cpp src/3.cpp
cpp_objs := $(cpp_srcs:.cpp=.o)				# 将cpp_srcs中的.cpp后缀改为.o后缀，返回字串，示例:src/1.o src/2.o src/3.o
cpp_objs := $(cpp_objs:src/%=objs/%)		# 将src/改为objs
cpp_mk   := $(cpp_objs:.o=.mk)				# makefile (mk)文件

c_srcs := $(shell find src -name "*.c")
c_objs := $(c_srcs:.c=.co)
c_objs := $(c_objs:src/%=objs/%)
c_mk   := $(c_objs:.co=.cmk)




include_paths := src              \
	$(cpp_pkg)/opencv4.2/include/opencv4 \
	/home/zwl/software/anaconda3/envs/yolov5Env/include/python3.9


library_paths := $(syslib) $(cpp_pkg)/opencv4.2/lib /home/zwl/software/anaconda3/envs/yolov5Env/lib


# link_librarys := opencv_core opencv_imgproc opencv_videoio  opencv_imgcodecs opencv_highgui \
			stdc++ dl
link_librarys := stdc++ dl python3.9			# 动态库的动态链接需要dl，否则报错。

paths := $(foreach item,$(library_paths),-Wl,-rpath=$(item)) 	 # 循环将$(library_paths)中的单词取出来放进item，然后执行表达式-Wl,-rpath=$(item)
																 # 返回的结果为-Wl,-rpath=item1 -Wl,-rpath=item2 -Wl,-rpath=item3等
																 # -Wl,-rpath=指定运行时链接到的库
include_paths := $(foreach item,$(include_paths),-I$(item))		 # 编译程序按照-I指定的路径进去搜索头文件
library_paths := $(foreach item,$(library_paths),-L$(item))		 # -L指定的路径会被优先搜索
link_librarys := $(foreach item,$(link_librarys),-l$(item))		 # -L用于指定库所在的目录，-l用于指定具体的库

# 如果是其他显卡，请修改-gencode=arch=compute_75,code=sm_75为对应显卡的能力
# 显卡对应的号码参考这里：https://developer.nvidia.com/zh-cn/cuda-gpus#compute
# 如果是 jetson nano，提示找不到-m64指令，请删掉 -m64选项。不影响结果
cpp_compile_flags := -std=c++11 -fPIC -m64 -g -fopenmp -w -O0 # The -m64 option sets int to 32bits and long and pointer to 64 bits and generates code for AMD’s x86-64 architecture.  
															  # 如果想用调试器执行一个可执行文件， 在用gcc编译时必须加上-g选项
															  # -fopenmp：开启多线程支持
															  # -w：关闭编译时的警告，编译后不显示任何warning，因为有时在编译之后编译器会显示一些例如数据转换之类的警告，这些警告是我们平时可以忽略的。
															  # -O0：最少的优化，产生最多代码调试信息
link_flags        := -pthread -fopenmp -Wl,-rpath='$$ORIGIN'  # '$$ORIGIN'表示当前路径，'pwd'也表示当前路径

cpp_compile_flags += $(include_paths) 	# +=用于添加单词
link_flags 		  += $(library_paths) $(link_librarys) $(paths)

ifneq ($(MAKECMDGOALS), clean) # make clean时，不起作用
-include $(cpp_mk) $(c_mk)     # 忽略当前此行命令执行时候所遇到的错误。比如删除一个不存在的文件等，那么也不要管，继续执行make。
							   # include命令可以用来引入其他makefile文件。-include代表不引入这些makefile文件
endif

pro    : workspace/pro
workspace/pro : $(c_objs) $(cpp_objs)
	@echo Link $@
	@mkdir -p $(dir $@)	# dir取出$@的目录部分。mkdir -p 确保目录名称存在，不存在的就建一个
	@g++ $^ -o $@ $(link_flags) 

objs/%.o : src/%.cpp		# .o文件就是静态库文件
	@echo Compile CXX $<
	@mkdir -p $(dir $@)
	@g++ -c $< -o $@ $(cpp_compile_flags) $(link_flags)

objs/%.co : src/%.c
	@echo Compile C $<
	@mkdir -p $(dir $@)
	@g++ -c $< -o $@ $(cpp_compile_flags)

objs/%.mk : src/%.cpp
	@echo Compile depends CXX $<
	@mkdir -p $(dir $@)
	@g++ -M $< -MF $@ -MT $(@:.mk=.o) $(cpp_compile_flags)           		
# -M输出$<依赖哪些头文件。-MF将-M输出的内容放入$@中
# g++ -M main.cpp -MF main.mk：mian.mk中存储的是main.o的依赖。
# -MT重新定义目标对象名,比如将上面的目标mian.o改为hello.o。默认的目标对象名和源文件相同
# g++ -M main.cpp -MF main.mk -MT hello.o
# 由于默认的目标对象名和源文件相同，故-MT $(@:.mk=.o)可以去掉
# $(@:.mk=.o)将$@中的每个.mk结尾字串的后缀改变为.o结尾的后缀


objs/%.cmk : src/%.c   # linux下后缀名一般不起作用，怎么方便怎么取
	@echo Compile depends C $<
	@mkdir -p $(dir $@)
	@g++ -M $< -MF $@ -MT $(@:.cmk=.o) $(cpp_compile_flags)   
	

run : workspace/pro
	@cd workspace && ./pro

debug :
	@echo $(includes)

clean :
	@rm -rf objs workspace/pro build

.PHONY : clean run debug

```






 
]]></description></item><item><title>源码查看</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/05/11/16258345.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Wed, 11 May 2022 08:00:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/05/11/16258345.html</guid><description><![CDATA[
源码阅读：https://github.com/shouxieai/tensorRT_Pro/tree/main/restful_server

# 组会
想要实现检测视频流，而不是检测一张一张图片


# 整体流程
使用mongoose网络库作为底层的数据收发。
yolov5推理器放在一个类中进行实现。只要在写controller子类的时候，添加一个推理器对象就可以了。
controller的作用


整体的流程是创建controller和server，将链接和处理函数的对应关系放在controller中，然后将controller加入到server中。
初始化server：
- 绑定用于处理request和close的函数。
- 开启一个线程搁那循环，用于监听用户的请求。
- 开启num_threads个线程。每个线程用于处理一个连接（会话）。（为啥不用epoll，是因为mongoose内部已经用来poll了吗？）。线程的处理函数都是worker_thread_proc，worker_thread_proc不断监听队列job_中的会话。

当一个请求到来的时候，
1.会调用HttpServerImpl::on_http_event函数处理请求。
2.在HttpServerImpl::on_http_event中首先创建一个新的会话A，然后对请求进行解析，将请求中的请求方法、url、body等东西提取出来，放进会话A的request结构体中。最后将会话A放进会话队列jobs_中。
3.线程worker_thread_proc监听到jobs_存在会话时，会取出会话中的url，并调用此url对应的处理函数。





# 任务和问题
1.服务器用C++写，算法使用python进行实现，如何在C++中调用python写的算法？
答：1.在C++中调用python脚本
2.用C++写算法。
3.在C++调用python的函数。python中设计一个接口函数，C++中调用接口函数从而实现对算法的调用。


2.习惯每日对git的使用


3.将检测结果放入数据库中。将图片post到后台，后台进行检测，将输出的结果存储到相应的目录下，将此图片的路径存储在数据库中。
保存所有检测图片，保证图片命令不重复。


4.输入图片的格式有所限制——自动判断图片类型


5.配合石中西修改json

6.只能保存图片后检测图片——直接提供视频流检测接口。

7.controller类是个父类。如果通过子类继承，进行实现各种控制器，为什么要怎么设计，具体是如何设计的？？

8.给石中西和张鑫玉提供相同的接口才行。

9.只能收mp4文件、返回avi文件：前端判断一下是什么类型，然后发送给我不就行了。


10.mongoose源码阅读：[mongoose的详细说明](https://github.com/cesanta/mongoose/tree/master/docs)
jsoncpp使用、jsoncpp源码阅读
libevent源码阅读
freecplus源码学习：https://freecplus.net/9ebb8276265b404488a3415be224ed85.html，可不看。。

11.登录功能：
登录以后，通过cookie判断是否为正确用户？
用户密码正确，则启动检测并返回结果。

12.上传大文件——实现在线训练功能
![](https://img2022.cnblogs.com/blog/1617829/202206/1617829-20220614152445159-952359619.png)


13.根据师兄发的流程图进行学习


14.vim和vscode结合使用

15.bug: 接收的东西不对时，session->request.body.substr(i1)中的i1就会发生下标越界。


16.放不同模型上去，让人感觉有很多功能。

17.学会修改网络，成为基本的调参侠。

18.口罩检测性能还不是很好

# 小知识
**什么是前后端分离？**
答：我觉得就是前后端只使用json格式的数据进行交互

前后端交互方式
前端占用一个端口运行前端界面，
后端占用一个端口运行后端，等待前端调用相应接口，

为什么github中jsoncpp是个项目，而https://github.com/shouxieai/tensorRT_Pro/tree/main/restful_server
中jsoncpp只包含了json.cpp和json.hpp？？
答：项目restful_server的作者将jsoncpp中的多个.cpp文件都拷贝到了json.cpp中，将jsoncpp中的多个.h文件都拷贝到了json.h中，这可以通过json.cpp和json.h的注释中看出来。








post发送文件的格式
服务器端：首先通过Content-Type获取body的编码方式，然后根据编码方式解析出body中的文件。post传输视频时，Content-Type为application/octet-stream，application/octet-stream格式如下


浏览器：
在某些下载文件的场景中，服务端可能会返回文件流，并在返回头中带上Content-Type:application/octet-stream，告知浏览器这是一个字节流，浏览器处理字节流的默认方式就是下载。Content-Type为application/octet-stream时，一般会配合另一个响应头Content-Disposition，该响应头指示回复的内容该以何种形式展示，是以内联的形式（即网页或者页面的一部分），还是以附件的形式下载并保存到本地。
[响应头Content-Type与Content-Disposition的区别](https://blog.csdn.net/LKJgdut/article/details/104249679)

在客户端，Get方式在通过URL提交数据，数据在URL中可以看到；POST方式，数据放置在HTML HEADER内提交。



rtp c++ 网络视频传输
[C++实现RTSP/RTP服务器](https://blog.csdn.net/longruic/article/details/115817371)
码流是一帧一帧的图片数据，所以传输的时候也是一帧帧来传输的，因此这里就会涉及到各种类型的帧处理了
传过来是字节，如何从字节中获取图片，如何将图片组合成视频，视频的编码是什么







https://blog.csdn.net/yaojiawan/article/details/90260155   restbed -C++ restfull 架构的应用


弄好之后，在vscode命令行下输入：”code .“，就可以用vscode打开当前目录
规范代码快捷键:vscode: shift+alt+F，或者安装某个插件以后，就可以通过ctrl+s进行规范

ctrl+点击：跳转到函数的定义，或在函数定义处使用可查看函数在哪些地方使用了


bind：将已有的变量绑定给函数的形参，并将这个函数作为返回值返回。如果有形参不需要绑定已有变量，就使用占位符进行占位，等到实际调用函数的时候再传入实参。
参考：[链接](https://blog.csdn.net/u013654125/article/details/100140328)
[链接2](https://www.cnblogs.com/yunyuanfeng/p/15032506.html)


typedef int (*func)()  // 定义一种类型func。func声明的变量用于指向返回值为int且形参为空的函数。
所以typedef int (*func)()可以用于实现多态，即同一个函数调用语句，会由于指向函数的不同，而产生不同的效果（多态）
C++11中使用function来代替上述内容
[链接1](https://blog.csdn.net/baoendemao/article/details/41209697)
[链接2](https://zhuanlan.zhihu.com/p/161356621)


vscode的python的launch.json文件配置实例：
```
{
    // 使用 IntelliSense 了解相关属性。 
    // 悬停以查看现有属性的描述。
    // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387
    "version": "0.2.0",
    "configurations": [

        {
            "name": "Python",
            "type": "python",
            "request": "launch",
            "program": "${file}",
            "console": "integratedTerminal",
            // "args": [
            //     "--source","human.jpg"
            // ],
                    
            "args":[

                "--data", "maskDatasets.yaml", 
                // "--cfg", "yolov5s.yaml", 
                "--weights" ,"weights/yolov5s.pt",
                "--batch-size","64",
                "--img","640",
                "--epochs","300",
                
            ],
            "cwd": "${fileDirname}"             // 设置相对路径，在debug时可以切换到当前文件所在的目录
         },
         
    ]
}
```
]]></description></item><item><title>vscode使用</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/05/11/16256860.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Wed, 11 May 2022 02:22:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/05/11/16256860.html</guid><description><![CDATA[
学会使用vscode编程c++、python，学会vscode和vim一样——“机会不碰鼠标”


[【c++】VSCode配置 c++ 环境（小白教程）](https://blog.csdn.net/Zhouzi_heng/article/details/115014059)
[vscode ssh远程连接服务器 无法跳转函数定义](https://blog.csdn.net/qq_41381865/article/details/116120074)

[VSCode 返回上一个光标 (上一个浏览位置)](https://blog.csdn.net/M_N_N/article/details/84581840)


# 添加C++库文件
参考：[链接](https://www.cnblogs.com/dechinphy/p/cpp-python.html)
原文件：
```
{
    "configurations": [
        {
            "name": "Linux",
            "includePath": [
                "${workspaceFolder}/**"
            ],
            "defines": [],
            "compilerPath": "/usr/bin/gcc",
            "cStandard": "gnu17",
            "cppStandard": "c++11",
            "intelliSenseMode": "linux-gcc-x64"
        }
    ],
    "version": 4
}
```
在includePath中添加头文件路径：
```
{
    "configurations": [
        {
            "name": "Linux",
            "includePath": [
                "${workspaceFolder}/**",
                "/usr/include/python3.9/",
                "/usr/lib/python3.9/",
                "/usr/include/python3.9/cpython/"
            ],
            "defines": [],
            "compilerPath": "/usr/bin/gcc",
            "cStandard": "gnu17",
            "cppStandard": "c++11",
            "intelliSenseMode": "linux-gcc-x64"
        }
    ],
    "version": 4
}
```
]]></description></item><item><title>多路IO select poll epoll</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/05/10/16255825.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Tue, 10 May 2022 14:51:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/05/10/16255825.html</guid><description><![CDATA[#1.高并发服务器实现方法
1.阻塞等待：进程开启线程去服务客户，每个线程服务一个客户，阻塞等待客户发送消息——消耗资源
2.非阻塞忙轮询：进程循环询问客户，问它上面是否有消息，有消息就进行处理。——消耗cpu
3.多路IO转接(多路IO复用): **内核**监听多个文件描述符的属性(**读写缓冲区**)变化。如果某个文件描述符的读缓冲区变化了,这个时候就是可以读了,将这个事件告知应用层
三种多路IO
- select：windwos中常用，select可跨平台
- poll：很少用
- epoll：linux中常用 

# 2.select函数
```
#include <sys/select.h>
 /* According to earlier standards */
#include <sys/time.h>
#include <sys/types.h>
#include <unistd.h>

int select(int nfds, fd_set *readfds, fd_set *writefds,
           fd_set *exceptfds, struct timeval *timeout);
功能: 监听多个文件描述符的属性变化(读,写,异常)
在集合中进行增删改查等操作:
       void FD_CLR(int fd, fd_set *set);
       int  FD_ISSET(int fd, fd_set *set);
       void FD_SET(int fd, fd_set *set);
       void FD_ZERO(fd_set *set);
参数:
    nfds  : 最大文件描述符+1。监听0~nfds的文件描述符
    readfds : 需要监听的读的文件描述符存放集合。事件：数据到达了读缓冲区，需要读出来了，触发读事件
    writefds :需要监听的写的文件描述符存放集合。事件：写缓存区满了，当写缓冲区有空余时，就触发可写事件。常设为NULL
    exceptfds : 需要监听的异常的文件描述符存放集合。常设为NULL
    timeout: 多长时间监听一次   固定的时间    NULL：永久监听
        struct timeval {
               long    tv_sec;         /* seconds */ 秒
               long    tv_usec;        /* microseconds */微妙
           };

返回值: 返回的是变化的文件描述符的个数
注意: 变化的文件描述符会存在监听的集合（readfds、writefds和exceptfds）中,未变化的文件描述符会从集合中删除
```

示例代码：
```
#include <stdio.h>
#include <sys/select.h>
#include <sys/types.h>
#include <unistd.h>
#include "wrap.h"
#include <sys/time.h>
#define PORT 8888
int main(int argc, char *argv[])
{
	//创建套接字,绑定
	int lfd = tcp4bind(PORT,NULL);
	//监听
	Listen(lfd,128);
	int maxfd = lfd;//最大的文件描述符
	fd_set oldset,rset;
	FD_ZERO(&oldset);
	FD_ZERO(&rset);
	//将lfd添加到oldset集合中
	FD_SET(lfd,&oldset);
	while(1)
	{	
		rset = oldset;//将oldset赋值给需要监听的集合rset
		
		int n = select(maxfd+1,&rset,NULL,NULL,NULL);
		if(n < 0)
		{
			perror("");
			break;
		}
		else if(n == 0)
		{
			continue;//如果没有变化,重新监听
		}
		else//监听到了文件描述符的变化
		{
			//lfd变化 代表有新的连接到来
			if( FD_ISSET(lfd,&rset))  // 变化的文件描述符都放在了rset集合中，如果lfd在rset中，就说明lfd变化了
			{
				struct sockaddr_in cliaddr;
				socklen_t len =sizeof(cliaddr);
				char ip[16]="";
				//提取新的连接
				int cfd = Accept(lfd,(struct sockaddr*)&cliaddr,&len);
				printf("new client ip=%s port=%d\n",inet_ntop(AF_INET,&cliaddr.sin_addr.s_addr,ip,16),
						ntohs(cliaddr.sin_port));
				//将cfd添加至oldset集合中,以下次监听
				FD_SET(cfd,&oldset);
				//更新maxfd
				if(cfd > maxfd)
					maxfd = cfd;
				//如果只有lfd变化,直接continue
				if(--n == 0)
					continue;

			}


			//cfd  遍历lfd之后的文件描述符是否在rset集合中,如果在则cfd变化
			for(int i = lfd+1;i<=maxfd;i++) // 假设现在 4-1023个文件描述符需要监听,但是5-1000这些文件描述符关闭了
                                                        // 本代码对于这种情况，还是遍历了4-1023
			{
				//如果i文件描述符在rset集合中
				if(FD_ISSET(i,&rset)) 
				{
					char buf[1500]=""; // 因为网络中的最大传输单元为1500
					int ret = Read(i,buf,sizeof(buf));
					if(ret < 0)//出错,将cfd关闭,从oldset中删除cfd
					{
						perror("");
						close(i);
						FD_CLR(i,&oldset);
					}
					else if(ret == 0) // 客户关闭了连接
					{
						printf("client close\n");
						close(i);
						FD_CLR(i,&oldset);
						
					}
					else
					{
						printf("%s\n",buf);
						Write(i,buf,ret);
					
					}
				
				}
				
			
			}
			
		
		}

		
	
	}

	return 0;
}
```

select优点: 跨平台
select缺点:
- 文件描述符数量限制在1024以下，需要修改内核的FD_SETSIZE参数，然后重新编译内核，才能修改1024
- 只是返回变化的文件描述符的个数,具体哪个那个变化需要遍历。当有大量的客户请求了连接但只有少量客户与服务器进行交互（即监听的文件描述符个数多，但是变化的文件描述符少），这种情况下，我们还是需要遍历全部的文件描述符才能找到变化的文件描述符。也就是说大量并发,少了活跃,select效率低。
- select对多个文件描述符进行监听是在内核中进行的，所以每次都需要将需要监听的文件描述集合由应用层符拷贝到内核

假设现在 4-1023个文件描述符需要监听,但是5-1000这些文件描述符关闭了?——本代码修改后，可以解决。解决如下：
```
//进阶版select，通过数组防止遍历1024个描述符
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <arpa/inet.h>
#include <ctype.h>

#include "wrap.h"

#define SERV_PORT 8888

int main(int argc, char *argv[])
{
    int i, j, n, maxi;

    int nready, client[FD_SETSIZE];                 /* 自定义数组client, 防止遍历1024个文件描述符  FD_SETSIZE默认为1024 */
    int maxfd, listenfd, connfd, sockfd;
    char buf[BUFSIZ], str[INET_ADDRSTRLEN];         /* #define INET_ADDRSTRLEN 16 */
    struct sockaddr_in clie_addr, serv_addr;
    socklen_t clie_addr_len;
    fd_set rset, allset;                            /* rset 读事件文件描述符集合 allset用来暂存 */

    listenfd = Socket(AF_INET, SOCK_STREAM, 0);
    //端口复用
    int opt = 1;
    setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));


    bzero(&serv_addr, sizeof(serv_addr));
    serv_addr.sin_family= AF_INET;
    serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);
    serv_addr.sin_port= htons(SERV_PORT);


    Bind(listenfd, (struct sockaddr *)&serv_addr, sizeof(serv_addr));
    Listen(listenfd, 128);

    maxfd = listenfd;                                           /* 起初 listenfd 即为最大文件描述符 */

    maxi = -1;                                                  /* 将来用作client[]的下标, 初始值指向0个元素之前下标位置 */
    for (i = 0; i < FD_SETSIZE; i++)
        client[i] = -1;                                         /* 用-1初始化client[] */

    FD_ZERO(&allset);
    FD_SET(listenfd, &allset);                                  /* 构造select监控文件描述符集 */

    while (1) {   
        rset = allset;                                          /* 每次循环时都从新设置select监控信号集 */

        nready = select(maxfd+1, &rset, NULL, NULL, NULL);      //2  1--lfd  1--connfd
        if (nready < 0)
            perr_exit("select error");

        if (FD_ISSET(listenfd, &rset)) {                        /* 说明有新的客户端链接请求 */

            clie_addr_len = sizeof(clie_addr);
            connfd = Accept(listenfd, (struct sockaddr *)&clie_addr, &clie_addr_len);       /* Accept 不会阻塞 */
            printf("received from %s at PORT %d\n",
                    inet_ntop(AF_INET, &clie_addr.sin_addr, str, sizeof(str)),
                    ntohs(clie_addr.sin_port));

            for (i = 0; i < FD_SETSIZE; i++)
                if (client[i] < 0) {                            /* 找client[]中没有使用的位置 */
                    client[i] = connfd;                         /* 保存accept返回的文件描述符到client[]里 */
                    break;
                }

            if (i == FD_SETSIZE) {                              /* 达到select能监控的文件个数上限 1024 */
                fputs("too many clients\n", stderr);
                exit(1);
            }

            FD_SET(connfd, &allset);                            /* 向监控文件描述符集合allset添加新的文件描述符connfd */

            if (connfd > maxfd)
                maxfd = connfd;                                 /* select第一个参数需要 */

            if (i > maxi)
                maxi = i;                                       /* 保证maxi存的总是client[]最后一个元素下标 */

            if (--nready == 0)
                continue;
        } 

        for (i = 0; i <= maxi; i++) {                               /* 检测哪个clients 有数据就绪 */

            if ((sockfd = client[i]) < 0)
                continue;//数组内的文件描述符如果被释放有可能变成-1
            if (FD_ISSET(sockfd, &rset)) {

                if ((n = Read(sockfd, buf, sizeof(buf))) == 0) {    /* 当client关闭链接时,服务器端也关闭对应链接 */
                    Close(sockfd);
                    FD_CLR(sockfd, &allset);                        /* 解除select对此文件描述符的监控 */
                    client[i] = -1;
                } else if (n > 0) {
                    for (j = 0; j < n; j++)
                        buf[j] = toupper(buf[j]);    // 转化维大写的
                    Write(sockfd, buf, n);
                    Write(STDOUT_FILENO, buf, n);
                }
                if (--nready == 0)
                    break;                                          /* 跳出for, 但还在while中 */
            }
        }
    }

    Close(listenfd);

    return 0;
}
```
虽然本代码还是需要遍历，但是效率提高了一些。


# 3.poll
```
#include <poll.h>
int poll(struct pollfd *fds, nfds_t nfds, int timeout);
功能: 监听多个文件描述符的属性变化
参数:
    fds : 监听的数组的首元素地址
    nfds: 数组有效元素的最大下标+1
    timeout : 超时时间 -1是永久监听 >=0 限时等待

数组元素:
            struct pollfd {
               int   fd;         /* file descriptor */ 需要监听的文件描述符
               short events;     /* requested events */需要监听文件描述符什么事件  EPOLLIN 读事件   EPOLLOUT写事件，其他事件可以通过man poll查看
               short revents;    /* returned events */ 返回监听到的事件    EPOLLIN 读事件   EPOLLOUT写事
           };
```
poll相对与sellect的优缺点
优点:
- 没有文件描述符1024的限制
- 请求和返回是分离的【select中，readfds表示监听的事件集，而且将返回的有读事件的文件描述符也放在readfds中，这就叫做请求和返回是不分离的】

缺点和select一样:
- 只是返回变化的文件描述符的个数,具体哪个那个变化需要遍历。当有大量的客户请求了连接但只有少量客户与服务器进行交互（即监听的文件描述符个数多，但是变化的文件描述符少），这种情况下，我们还是需要遍历全部的文件描述符才能找到变化的文件描述符。也就是说大量并发,少了活跃,poll效率低。
- poll对多个文件描述符进行监听是在内核中进行的，所以每次都需要将需要监听的文件描述集合由应用层符拷贝到内核


poll相对于select没有最大1024文件描述符限制，大小限制。但poll其实也是有最大文件描述符限制，如下：
```
ulimit -a                  # 查看最多打开多少个文件（open files）
ulimit -n 2048             # 将最多打开文件个数修改成2048
cat /proc/sys/fs/file-max  # ulimit -n最大可修改的量
```

示例代码：
```
#include <stdio.h>
#include <stdlib.h>
#include<netinet/in.h>
#include<poll.h>
#include<errno.h>
#include <unistd.h>
#include <string.h>
#include <arpa/inet.h>
#include <ctype.h>

#include "wrap.h"

#define MAXLINE 80
#define SERV_PORT 8000
#define OPEN_MAX 1024


int main(int argc, char *argv[])
{
	int i, j, maxi, listenfd, connfd, sockfd;
	int nready;   // 接收poll返回值，记录满足监听事件的fd个数
	ssize_t n;

	char buf[MAXLINE],str[INET_ADDRSTRLEN];
	socklen_t clilen;

	struct pollfd client[OPEN_MAX] ;//定义pol1的数组
	struct sockaddr_in cliaddr,servaddr;

	listenfd = Socket(AF_INET, SOCK_STREAM, 0);
	int opt = 1;
	setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR,&opt, sizeof(opt));//设置端口复用

	bzero(&servaddr, sizeof(servaddr));
	servaddr.sin_family = AF_INET;
	servaddr.sin_addr.s_addr = htonl(INADDR_ANY);
	servaddr.sin_port = htons(SERV_PORT);

	Bind(listenfd, (struct sockaddr *) &servaddr, sizeof(servaddr));
	Listen(listenfd,128);

	client[0].fd = listenfd;   /*要监听的第一一个文件描述符存入client[0]*/
	client[0].events = POLLIN; /* listenfd监听普通读事件*/
	for (i = 1; i < OPEN_MAX; i++)
		client[i].fd = -1;				// 用-1初始化client[]里剩下元素 0也是文件描述符,
	maxi = 0;                            /* client[]数组有效元素中最大元素下标*/




	for (;;) { // 等价与while循环 
		nready = poll(client, maxi + 1, -1); /* 阻塞监听是否有客户端链接请求*/
		if (client[0].revents & POLLIN) {      // listenfd有 读事件就绪。这里用&，而不用==
			clilen = sizeof(cliaddr);
			connfd = Accept(listenfd, (struct sockaddr *) &cliaddr, &clilen);
			printf("received from %s at PORT %d\n",
				inet_ntop(AF_INET, &cliaddr.sin_addr, str, sizeof(str)),
				ntohs(cliaddr.sin_port));
			for (i = 1; i < OPEN_MAX; i++)
				if (client[i].fd < 0) {
					client[i].fd = connfd;  // 找到client []中空闲的位置,存放accept返回的connfd
					break;
				}
			if (i == OPEN_MAX)  /*达到了最大客户端数*/
				perr_exit("too many clients");

			client[i].events = POLLIN;  /*设置刚刚返回的connfd, 监控读事件*/
			if (i > maxi)
				maxi = i;             /*更新client[]中最大元素下标*/
			if (--nready <= 0)
				continue;            /*没有更多就绪事件时,继续回到po11阻塞*/
		}
		for (i = 1; i <= maxi; i++) {

			if ((sockfd = client[i].fd) < 0)
				continue;				//找到第一-个大于0的

			if (client[i].revents & POLLIN) {
				if ((n = Read(sockfd, buf, MAXLINE)) < 0) {
					if (errno == ECONNRESET) { /* 收到RST标志，代表对方想要关闭连接*/
						printf("client[%d] aborted connection\n", i);
						Close(sockfd);
						client[i].fd = -1;    // poll中不监控该文件描述符,直接置为-1即可，不用像se
					}
					else
						perr_exit("read error");
				}
				else if (n == 0) {   /*说明客户端先关闭链接*/
					printf("client[%d] closed connection\n",i);
					Close(sockfd);
					client[i].fd = -1;
				}
				else {
					for (j = 0; j < n; j++)
						buf[j] = toupper(buf[j]);
					Writen(sockfd, buf, n);
				}
				if (--nready <= 0)
					break;
			}
		}
	}
				
	return 0;

}
```


# 4.epoll
## 4.1.epoll API
1.创建一棵红黑树
2.将需要监听的文件描述符放入树中（上树）
3.通过操作树来实现监听

```
// 创建红黑树
#include <sys/epoll.h>
int epoll_create(int size);
参数:
    size :  监听的文件描述符的上限,  2.6版本之后写1即可（因为不够的时候，它会自动扩展）
返回:  返回树的句柄（就相当于返回一棵树）
```

```
// 上树  下树 修改节点
#include <sys/epoll.h>
int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);
参数:
    epfd : 树的句柄
    op : EPOLL_CTL_ADD 上树   EPOLL_CTL_DEL 下树 EPOLL_CTL_MOD 修改
    fd : 上树或修改或下树的文件描述符
    event : 上树的节点，event里面包含文件描述符和文件描述符需要监听的事件。这不就和fd重复了？
            答：虽然按道理传个event就行，但它就要求你传fd和event，那你就老老实实传啊。
           typedef union epoll_data { // 共用体，一般只使用共用体中的一个数据。
               void        *ptr;
               int          fd;  // 经常使用这个
               uint32_t     u32;
               uint64_t     u64;
           } epoll_data_t;

           struct epoll_event {
               uint32_t     events;      /* Epoll events */  需要监听的事件
               epoll_data_t data;        /* User data variable */ 需要监听的文件描述符，经常只使用fd就行
           };

示例：将cfd上树
int epfd =  epoll_create(1);
struct epoll_event ev;
ev.data.fd = cfd;
ev.events = EPOLLIN;
epoll_ctl(epfd, EPOLL_CTL_ADD,cfd, &ev);
```

```
//监听
#include <sys/epoll.h>
int epoll_wait(int epfd, struct epoll_event *events,
               int maxevents, int timeout);
功能: 监听树上文件描述符的变化
参数：
    epfd : 树
    events : 接收变化的节点的数组的首地址
    maxevents :  数组元素的个数
    timeout : -1 永久监听  大于等于0 限时等待
返回值: 返回的是变化的文件描述符个数

```

优点：
- 和poll一样，没有文件描述符1024的限制，但是还是有上限的。见poll中说明
- 以后每次监听都不要在此将需要监听的文庙描述符拷贝到内核
- 返回的是己经变化的文件描述符,不需要遍历树

## 4.2.示例代码：
**1.父进程监听子进程是否向管道中发送数据。**
```
#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <sys/epoll.h>
int main(int argc, char *argv[])
{
	int fd[2];
	pipe(fd);    // fd中保存管道的读端和写端
	//创建子进程
	pid_t pid;
	pid = fork();
	if(pid < 0)
		perror("");
	else if(pid == 0) // 为子进程
	{
		close(fd[0]);  // 子进程的读端没有用，故关掉
		char buf[5];
		char ch='a';
		while(1)
		{
			sleep(3); // 每隔三秒写一次数据
			memset(buf,ch++,sizeof(buf));
			write(fd[1],buf,5); // 子进程向管道的写端写数据
		}

	}
	else
	{
		close(fd[1]);
		//创建树
		int epfd = epoll_create(1);
		struct epoll_event ev,evs[1];
		ev.data.fd = fd[0];
		ev.events = EPOLLIN;  // 读事件：有数据来了，就触发读事件
		epoll_ctl(epfd,EPOLL_CTL_ADD,fd[0],&ev);  //上树
		//监听
		while(1)
		{
			int n = epoll_wait(epfd,evs,1,-1);
			if(n == 1)
			{
				char buf[128]="";
				int ret  = read(fd[0],buf,sizeof(buf));
				if(ret <= 0)
				{
					close(fd[0]);
					epoll_ctl(epfd,EPOLL_CTL_DEL,fd[0],&ev);
					break;
				}
				else
				{
					printf("%s\n",buf);
				}
			
			}
		
		
		}

	
	
	}


	return 0;
}

```

**2.epoll实现服务器**
```
#include <stdio.h>
#include <fcntl.h>
#include "wrap.h"
#include <sys/epoll.h>
int main(int argc, char *argv[])
{
	//创建套接字 绑定
	int lfd = tcp4bind(8000,NULL);
	//监听
	Listen(lfd,128);
	//创建树
	int epfd = epoll_create(1);
	//将lfd上树
	struct epoll_event ev,evs[1024];
	ev.data.fd = lfd;
	ev.events = EPOLLIN; // 读事件，即有连接到达lfd了，需要我们去读。不设置为边沿触发，使用默认的水平触发
	epoll_ctl(epfd,EPOLL_CTL_ADD,lfd,&ev);
	//while监听
	while(1)
	{
		int nready = epoll_wait(epfd,evs,1024,-1);//监听
		printf("epoll wait _________________\n");
		if(nready <0)
		{
			perror("");
			break;
		}
		else if( nready == 0)
		{
			continue;
		}
		else//有文件描述符变化
		{
			for(int i=0;i<nready;i++)
			{
				//判断lfd变化,并且是读事件变化
				if(evs[i].data.fd == lfd && evs[i].events & EPOLLIN)
				{
					struct sockaddr_in cliaddr;
					char ip[16]="";
					socklen_t len = sizeof(cliaddr);
					int cfd = Accept(lfd,(struct sockaddr *)&cliaddr,&len);//提取新的连接

					printf("new client ip=%s port =%d\n",inet_ntop(AF_INET,&cliaddr.sin_addr.s_addr,ip,16)
							,ntohs(cliaddr.sin_port));
					//设置cfd为非阻塞
					int flags = fcntl(cfd,F_GETFL);//获取的cfd的标志位
					flags |= O_NONBLOCK;
					fcntl(cfd,F_SETFL,flags);
					//将cfd上树
					ev.data.fd =cfd;  // 前面将ev中的内容上树完成之后，ev就没什么用，所以这里可以重复使用ev 
					ev.events =EPOLLIN | EPOLLET;  // EPOLLIN表示读事件。EPOLLET设置为边沿触发，不设置的话，默认为水平触发
					epoll_ctl(epfd,EPOLL_CTL_ADD,cfd,&ev);
				
				}
				else if( evs[i].events & EPOLLIN)//cfd变化 ,而且是读事件变化
				{
					while(1) // 循环读取读缓冲区，直到读缓冲区没有数据为止。从而实现epoll边沿模式下可以一次将数据读走
					{
						char buf[4]="";
						// 如果读一个缓冲区,缓冲区没有数据,如果是带阻塞,就阻塞等待。
                                                // 如果是非阻塞,返回值等于-1,并且会将errno 值设置为EAGAIN
						int n = read(evs[i].data.fd,buf,sizeof(buf)); // 由于前面cfd被设为了非阻塞，所以如果读缓冲区中没有数据，这里也不会阻塞，而是返回-1 并将errno 值设置为EAGAIN
						if(n < 0)//出错,cfd下树
						{
							//如果缓冲区读干净了,这个时候应该跳出while(1)循环,继续监听
							if(errno == EAGAIN)
							{
								break;
							
							}
							//普通错误  
							perror("");
							close(evs[i].data.fd);//将cfd关闭
							epoll_ctl(epfd,EPOLL_CTL_DEL,evs[i].data.fd,&evs[i]);
							break;
						}
						else if(n == 0)//客户端关闭 ,
							{
								printf("client close\n");
								close(evs[i].data.fd);//将cfd关闭
								epoll_ctl(epfd,EPOLL_CTL_DEL,evs[i].data.fd,&evs[i]);//下树
								break;
							}
						else
						{
							// printf("%s\n",buf);  // 由于buf的末尾没有'\0'，所以打印会出错
							write(STDOUT_FILENO,buf,4);  // 用于代替printf("%s\n",buf); 
							write(evs[i].data.fd,buf,n);
							

						}
					}

				}
			
			
			}
		
		}
	
	
	}
	
	return 0;
}
```

## 4.3.epoll的工作方式
**1.监听读缓冲区的变化：**
水平触发（LT）:只要读缓冲区有数据就会触发epo11_ wait
边沿触发（ET）:接收到数据来一次, epo11_ wait只触发一次。这就要求必须一次性将数据都读走。
**2.监听写缓冲区的变化:**
水平触发:只要可以写，就会触发。（这会导致一直触发，所以一般不用）
边沿触发:数据从有到无,就会触发

因为设置为水平触发,只要缓存区有数据epoll_wait就会被触发，这样调用的次数就会比较多。而epoll_wait是一个系统调用,应该尽量少调用。
所以尽量使用边沿触发,边沿出触发数据来一次只触发一次,这个时候要求一次性将数据读完。“epoll实现服务器”的代码就使用了边沿触发，并一次性将数据读完。

工作中使用：边沿触发+非阻塞 

## 4.4.epoll反应堆
本小节看懂就行，不需要会写。
epoll反应堆：将文件描述符、事件和回调函数封装在一起。当事件发生时，自动调用回调函数。
使用结构体进行封装。

**一个简单的epoll反应堆：**
```
//反应堆简单版
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <fcntl.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <sys/epoll.h>
#include "wrap.h"

#define _BUF_LEN_  1024
#define _EVENT_SIZE_ 1024

//全局epoll树的根
int gepfd = 0;

//事件驱动结构体
typedef struct xx_event{
    int fd;
    int events;
    void (*call_back)(int fd,int events,void *arg);
    void *arg;
    char buf[1024];
    int buflen;
    int epfd;
}xevent;

xevent myevents[_EVENT_SIZE_+1]; // 全局变量默认初始化为零

void readData(int fd,int events,void *arg);

//添加事件
//eventadd(lfd,EPOLLIN,initAccept,&myevents[_EVENT_SIZE_-1],&myevents[_EVENT_SIZE_-1]);
void eventadd(int fd,int events,void (*call_back)(int ,int ,void *),void *arg,xevent *ev)
{
    ev->fd = fd;
    ev->events = events;
    //ev->arg = arg;//代表结构体自己,可以通过arg得到结构体的所有信息
    ev->call_back = call_back;

    struct epoll_event epv;
    epv.events = events;
    epv.data.ptr = ev; //核心思想
    epoll_ctl(gepfd,EPOLL_CTL_ADD,fd,&epv);//上树
}

//修改事件
//eventset(fd,EPOLLOUT,senddata,arg,ev);
void eventset(int fd,int events,void (*call_back)(int ,int ,void *),void *arg,xevent *ev)
{
    ev->fd = fd;
    ev->events = events;
    //ev->arg = arg;
    ev->call_back = call_back;

    struct epoll_event epv;
    epv.events = events;
    epv.data.ptr = ev;
    epoll_ctl(gepfd,EPOLL_CTL_MOD,fd,&epv);//修改
}

//删除事件
void eventdel(xevent *ev,int fd,int events)
{
	printf("begin call %s\n",__FUNCTION__);

    ev->fd = 0;
    ev->events = 0;
    ev->call_back = NULL;
    memset(ev->buf,0x00,sizeof(ev->buf));
    ev->buflen = 0;

    struct epoll_event epv;
    epv.data.ptr = NULL;
    epv.events = events;
    epoll_ctl(gepfd,EPOLL_CTL_DEL,fd,&epv);//下树
}

//发送数据
void senddata(int fd,int events,void *arg)
{
    printf("begin call %s\n",__FUNCTION__);

    xevent *ev = arg;
    Write(fd,ev->buf,ev->buflen);
    eventset(fd,EPOLLIN,readData,arg,ev);
}

//读数据
void readData(int fd,int events,void *arg)
{
    printf("begin call %s\n",__FUNCTION__);
    xevent *ev = arg;

    ev->buflen = Read(fd,ev->buf,sizeof(ev->buf)); // 读完数据，并没有直接将数据发送回去。而是监听fd是否可写（可发送）后，再进行发送
    if(ev->buflen>0) //读到数据
	{	
		//void eventset(int fd,int events,void (*call_back)(int ,int ,void *),void *arg,xevent *ev)
        eventset(fd,EPOLLOUT,senddata,arg,ev); // 修改fd，使其监听写事件。一旦可写就将收到的数据发送回去
											   // senddata中，修改fd，使其重新监听读事件。

    }
	else if(ev->buflen==0) //对方关闭连接
	{
        Close(fd);
        eventdel(ev,fd,EPOLLIN);
    }

}
//新连接处理
void initAccept(int fd,int events,void *arg)
{
    printf("begin call %s,gepfd =%d\n",__FUNCTION__,gepfd);//__FUNCTION__ 函数名

    int i;
    struct sockaddr_in addr;
    socklen_t len = sizeof(addr);
    int cfd = Accept(fd,(struct sockaddr*)&addr,&len);//是否会阻塞？
	
	//查找myevents数组中可用的位置
    for(i = 0 ; i < _EVENT_SIZE_; i ++)
	{
        if(myevents[i].fd==0)
		{
            break;
        }
    }

    //设置读事件
    eventadd(cfd,EPOLLIN,readData,&myevents[i],&myevents[i]);
}

// epoll反应堆的使用
int main(int argc,char *argv[])
{
	//创建socket
    int lfd = Socket(AF_INET,SOCK_STREAM,0);

    //端口复用
    int opt = 1;
    setsockopt(lfd,SOL_SOCKET,SO_REUSEADDR,&opt,sizeof(opt));

	//绑定
    struct sockaddr_in servaddr;
    servaddr.sin_family = AF_INET;
    servaddr.sin_port = htons(8888);
    servaddr.sin_addr.s_addr = htonl(INADDR_ANY);
    Bind(lfd,(struct sockaddr*)&servaddr,sizeof(servaddr));
    
	//监听
    Listen(lfd,128);

	//创建epoll树根节点
    gepfd = epoll_create(1024); 
    printf("gepfd === %d\n",gepfd);

    struct epoll_event events[1024]; // 用保存哪些事件发生了

    // 初始化数据myevents[_EVENT_SIZE_]，并将描述符lfd上树
    eventadd(lfd,EPOLLIN,initAccept,&myevents[_EVENT_SIZE_],&myevents[_EVENT_SIZE_]);
    //void eventadd(int fd,int events,void (*call_back)(int ,int ,void *),void *arg,xevent *ev)

    while(1)
	{
        int nready = epoll_wait(gepfd,events,1024,-1); // 同时监听树上的所有节点，包括节点lfd和cfd
		if(nready<0) //调用epoll_wait失败
		{
			perr_exit("epoll_wait error");
			
		}
        else if(nready>0) //调用epoll_wait成功,返回有事件发生的文件描述符的个数
		{
            int i = 0;
            for(i=0;i<nready; i++)
			{
                xevent *xe = events[i].data.ptr;//取ptr指向结构体地址
                printf("fd=%d\n",xe->fd);

                if(xe->events & events[i].events) // 监听的事件和发生的事件一致时。这个其实写不写都无所谓
				{
                    xe->call_back(xe->fd,xe->events,xe);//调用事件对应的回调
                }
            }
        }
    }

	//关闭监听文件描述符
	Close(lfd);

    return 0;
}

```

**一个较复杂的epoll反应堆（可以不看，看懂上面那个简单的反应堆就可以了）：**
```
/*
 * epoll基于非阻塞I/O事件驱动
 */
#include <stdio.h>
#include <sys/socket.h>
#include <sys/epoll.h>
#include <arpa/inet.h>
#include <fcntl.h>
#include <unistd.h>
#include <errno.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>

#define MAX_EVENTS  1024                                    //监听上限数
#define BUFLEN      4096
#define SERV_PORT   8080

void recvdata(int fd, int events, void *arg);
void senddata(int fd, int events, void *arg);

/* 描述就绪文件描述符相关信息 */

struct myevent_s {
    int fd;                                                 //要监听的文件描述符
    int events;                                             //对应的监听事件
    void *arg;                                              //泛型参数
    void (*call_back)(int fd, int events, void *arg);       //回调函数
    int status;                                             //是否在监听:1->在红黑树上(监听), 0->不在(不监听)
    char buf[BUFLEN];
    int len;
    long last_active;                                       //记录每次加入红黑树的时间。如果是不活跃的，就会被剔除掉
};

int g_efd;                                                  //全局变量, 保存epoll_create返回的文件描述符
struct myevent_s g_events[MAX_EVENTS+1];                    //自定义结构体类型数组. +1-->listen fd


/*将结构体 myevent_s 成员变量 初始化*/

void eventset(struct myevent_s *ev, int fd, void (*call_back)(int, int, void *), void *arg)
{
    ev->fd = fd;
    ev->call_back = call_back;
    ev->events = 0;
    ev->arg = arg;
    ev->status = 0;
    //memset(ev->buf, 0, sizeof(ev->buf));
    //ev->len = 0;
    ev->last_active = time(NULL);    //调用eventset函数的时间

    return;
}

/* 向 epoll监听的红黑树 添加一个 文件描述符 */

void eventadd(int efd, int events, struct myevent_s *ev)
{
    struct epoll_event epv = {0, {0}};
    int op;
    epv.data.ptr = ev;
    epv.events = ev->events = events;       //EPOLLIN 或 EPOLLOUT

    if (ev->status == 1) {                                          //已经在红黑树 g_efd 里
        op = EPOLL_CTL_MOD;                                         //修改其属性
    } else {                                //不在红黑树里
        op = EPOLL_CTL_ADD;                 //将其加入红黑树 g_efd, 并将status置1
        ev->status = 1;
    }

    if (epoll_ctl(efd, op, ev->fd, &epv) < 0)                       //实际添加/修改
        printf("event add failed [fd=%d], events[%d]\n", ev->fd, events);
    else
        printf("event add OK [fd=%d], op=%d, events[%0X]\n", ev->fd, op, events);

    return ;
}

/* 从epoll 监听的 红黑树中删除一个 文件描述符*/

void eventdel(int efd, struct myevent_s *ev)
{
    struct epoll_event epv = {0, {0}};

    if (ev->status != 1)                                        //不在红黑树上
        return ;

    epv.data.ptr = ev;
    ev->status = 0;                                             //修改状态
    epoll_ctl(efd, EPOLL_CTL_DEL, ev->fd, &epv);                //从红黑树 efd 上将 ev->fd 摘除

    return ;
}

/*  当有文件描述符就绪, epoll返回, 调用该函数 与客户端建立链接 */
// 回调函数 - 监听的文件描述符发送读事件时被调用
void acceptconn(int lfd, int events, void *arg)
{
    struct sockaddr_in cin;
    socklen_t len = sizeof(cin);
    int cfd, i;

    if ((cfd = accept(lfd, (struct sockaddr *)&cin, &len)) == -1) {
        if (errno != EAGAIN && errno != EINTR) {
            /* 暂时不做出错处理 */
        }
        printf("%s: accept, %s\n", __func__, strerror(errno));
        return ;
    }

    do {
        for (i = 0; i < MAX_EVENTS; i++)                                //从全局数组g_events中找一个空闲元素
            if (g_events[i].status == 0)                                //类似于select中找值为-1的元素
                break;                                                  //跳出 for

        if (i == MAX_EVENTS) {
            printf("%s: max connect limit[%d]\n", __func__, MAX_EVENTS);
            break;                                                      //跳出do while(0) 不执行后续代码
        }

        int flag = 0;
        if ((flag = fcntl(cfd, F_SETFL, O_NONBLOCK)) < 0) {             //将cfd也设置为非阻塞
            printf("%s: fcntl nonblocking failed, %s\n", __func__, strerror(errno));
            break;
        }

        /* 给cfd设置一个 myevent_s 结构体, 回调函数 设置为 recvdata */

        eventset(&g_events[i], cfd, recvdata, &g_events[i]);
        eventadd(g_efd, EPOLLIN, &g_events[i]);                         //将cfd添加到红黑树g_efd中,监听读事件

    } while(0);

    printf("new connect [%s:%d][time:%ld], pos[%d]\n", 
            inet_ntoa(cin.sin_addr), ntohs(cin.sin_port), g_events[i].last_active, i);
    return ;
}

// 回调函数 - 通信的文件描述符发生读事件时候被调用
void recvdata(int fd, int events, void *arg)
{
    struct myevent_s *ev = (struct myevent_s *)arg;
    int len;

    len = recv(fd, ev->buf, sizeof(ev->buf), 0);            //读文件描述符, 数据存入myevent_s成员buf中

    eventdel(g_efd, ev);        //将该节点从红黑树上摘除

    if (len > 0) {

        ev->len = len;
        ev->buf[len] = '\0';                                //手动添加字符串结束标记
        printf("C[%d]:%s\n", fd, ev->buf);

        eventset(ev, fd, senddata, ev);                     //设置该 fd 对应的回调函数为 senddata
        eventadd(g_efd, EPOLLOUT, ev);                      //将fd加入红黑树g_efd中,监听其写事件

    } else if (len == 0) {
        close(ev->fd);
        /* ev-g_events 地址相减得到偏移元素位置 */
        printf("[fd=%d] pos[%ld], closed\n", fd, ev-g_events);
    } else {
        close(ev->fd);
        printf("recv[fd=%d] error[%d]:%s\n", fd, errno, strerror(errno));
    }

    return;
}

// 回调函数 - 通信的文件描述符发生写事件时候被调用
void senddata(int fd, int events, void *arg)
{
    struct myevent_s *ev = (struct myevent_s *)arg;
    int len;

    len = send(fd, ev->buf, ev->len, 0);                    //直接将数据 回写给客户端。未作处理
    /*
    printf("fd=%d\tev->buf=%s\ttev->len=%d\n", fd, ev->buf, ev->len);
    printf("send len = %d\n", len);
    */

    if (len > 0) {

        printf("send[fd=%d], [%d]%s\n", fd, len, ev->buf);
        eventdel(g_efd, ev);                                //从红黑树g_efd中移除
        eventset(ev, fd, recvdata, ev);                     //将该fd的 回调函数改为 recvdata
        eventadd(g_efd, EPOLLIN, ev);                       //从新添加到红黑树上， 设为监听读事件

    } else {
        close(ev->fd);                                      //关闭链接
        eventdel(g_efd, ev);                                //从红黑树g_efd中移除
        printf("send[fd=%d] error %s\n", fd, strerror(errno));
    }

    return ;
}

/*创建 socket, 初始化lfd */

void initlistensocket(int efd, short port)
{
    int lfd = socket(AF_INET, SOCK_STREAM, 0);
    fcntl(lfd, F_SETFL, O_NONBLOCK);                                            //将socket设为非阻塞

    /* void eventset(struct myevent_s *ev, int fd, void (*call_back)(int, int, void *), void *arg);  */
    eventset(&g_events[MAX_EVENTS], lfd, acceptconn, &g_events[MAX_EVENTS]);

    /* void eventadd(int efd, int events, struct myevent_s *ev) */
    eventadd(efd, EPOLLIN, &g_events[MAX_EVENTS]);

    struct sockaddr_in sin;
	memset(&sin, 0, sizeof(sin));                                               //bzero(&sin, sizeof(sin))
	sin.sin_family = AF_INET;
	sin.sin_addr.s_addr = INADDR_ANY;
	sin.sin_port = htons(port);

	bind(lfd, (struct sockaddr *)&sin, sizeof(sin));

	listen(lfd, 20);

    return ;
}

int main(int argc, char *argv[])
{
    unsigned short port = SERV_PORT;

    if (argc == 2)
        port = atoi(argv[1]);                           //使用用户指定端口.如未指定,用默认端口

    g_efd = epoll_create(MAX_EVENTS+1);                 //创建红黑树,返回给全局 g_efd 
    if (g_efd <= 0)
        printf("create efd in %s err %s\n", __func__, strerror(errno));

    initlistensocket(g_efd, port);                      //初始化监听socket

    struct epoll_event events[MAX_EVENTS+1];            //保存已经满足就绪事件的文件描述符数组
	printf("server running:port[%d]\n", port);

    int checkpos = 0, i;
    while (1) {
		
        /* 超时验证，每次测试100个链接，不测试listenfd 当客户端60秒内没有和服务器通信，则关闭此客户端链接。不是重点不用看。 */
        long now = time(NULL);                          //当前时间
        for (i = 0; i < 100; i++, checkpos++) {         //一次循环检测100个。 使用checkpos控制检测对象
            if (checkpos == MAX_EVENTS)
                checkpos = 0;
            if (g_events[checkpos].status != 1)         //不在红黑树 g_efd 上
                continue;

            long duration = now - g_events[checkpos].last_active;       //客户端不活跃的世间

            if (duration >= 60) {
                close(g_events[checkpos].fd);                           //关闭与该客户端链接
                printf("[fd=%d] timeout\n", g_events[checkpos].fd);
                eventdel(g_efd, &g_events[checkpos]);                   //将该客户端 从红黑树 g_efd移除
            }
        }


        /*监听红黑树g_efd, 将满足的事件的文件描述符加至events数组中, 1秒没有事件满足, 返回 0*/
        int nfd = epoll_wait(g_efd, events, MAX_EVENTS+1, 1000);
        if (nfd < 0) {
            printf("epoll_wait error, exit\n");
            break;
        }

        for (i = 0; i < nfd; i++) {
            /*使用自定义结构体myevent_s类型指针, 接收 联合体data的void *ptr成员*/
            struct myevent_s *ev = (struct myevent_s *)events[i].data.ptr;  

            if ((events[i].events & EPOLLIN) && (ev->events & EPOLLIN)) {           //读就绪事件
                ev->call_back(ev->fd, events[i].events, ev->arg);
            }
            if ((events[i].events & EPOLLOUT) && (ev->events & EPOLLOUT)) {         //写就绪事件
                ev->call_back(ev->fd, events[i].events, ev->arg);
            }
        }
    }

    /* 退出前释放所有资源 */
    return 0;
}
```
]]></description></item><item><title>libevent</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/05/09/16251389.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Mon, 09 May 2022 14:40:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/05/09/16251389.html</guid><description><![CDATA[# 1.libevent安装
**1.下载：**在https://libevent.org/中找到安装包并下载
**2.解压：**tar -zxvf libevent-2.1.11-stable.tar.gz

**3.配置安装路径**
```
cd libevent-2.1.11-stable 
./configure --prefix=/usr  # 执行configure ,检测环境生成makefile
```
如果不设置prefix，则默认为**/usr/local/lib**，这里建议如上设置。
如果提示错误：
```
configure: error: openssl is a must but can not be found. You should add the directory containing `openssl.pc' to the `PKG_CONFIG_PATH' environment variable, or set `CFLAGS' and `LDFLAGS' directly for openssl, or use `--disable-openssl' to disable support for openssl encryption
```
一般为openssl库的缘故，需要安装openssl，一般ubuntu自带openssl，这里需要openssl-devel，要注意的是在ubuntu中需要使用sudo apt-get install libssl-dev来安装而不是sudo apt-get install openssl-devel。
然后重新执行：
./configure --prefix=/usr
**4.编译和安装**
```
sudo make
sudo make install
```
由于前面使用--prefix=/usr指定了安装路径
故安装后：
- 库的路径: /usr/lib
- 头文件目录: /usr/include

**编译时需要指定库名  -levent**
-levent相当于libevent的简写，指明本程序编译时需要库libevent。（这里应该是静态链接）

测试代码domo.c：
```
#include <event.h>
#include <stdio.h>

int main()
{
    char ** methods = event_get_supported_methods();//获取libevent后端支持的方法
    int i =0;
    for(i = 0;methods[i] != NULL ;i++)
    {
        printf("%s\n",methods[i]);
    }
    struct event_base * base = event_base_new();
    printf("当前使用的方法：%s\n",event_base_get_method(base));
    return 0;
}
```
执行gcc demo.c -o demo -levent进行编译


参考：[libevent安装教程](https://blog.csdn.net/superhoner/article/details/112001995)




# 2.libevent API
**1.创建和释放根节点**
创建event_base根节点
```
struct event_base *event_base_new(void);
```
返回值值就是event_base根节点地址

释放根节点
```
void event_base_free(struct event_base *);
```
**2.循环监听**
循环监听:
```
int event_base_dispatch(struct event_base *base);
```
相当于 while(1){epoll_wait}循环监听。【epoll用于监听多个文件描述符上的事件。epoll_wait函数获取就绪事件】
退出循环监听:
```
int event_base_loopexit(struct event_base *base, const struct timeval *tv); //等待固定时间之后退出
int event_base_loopbreak(struct event_base *base);//立即退出
```

**3.libevent事件触发流程**
![](https://img2022.cnblogs.com/blog/1617829/202205/1617829-20220510101602527-1064024598.png)

流程:1.创建事件监听节点 2. 添加文件描述符进行循环监听


**4.构建节点用于上树（即将文件描述符、监听事件和回调函数包装成一个特定的结构event，这个结构称为一个节点）**
```
struct event *event_new(struct event_base *base, evutil_socket_t fd, short events, event_callback_fn cb, void *arg);
参数:
base: event_base根节点
fd: 上树的文件描述符
events: 监听的事件
   #define  EV_TIMEOUT         0x01   //超时事件
   #define  EV_READ                  0x02 //读事件
   #define  EV_WRITE                0x04  //写事件
   #define  EV_SIGNAL              0x08     //信号事件
   #define  EV_PERSIST              0x10   //周期性触发,起到循环监听的作用
   #define  EV_ET      
cb: 回调函数
   typedef void (*event_callback_fn)(evutil_socket_t fd, short events, void *arg);
arg: 传给回调函数的参数
返回值: 初始化好的节点的地址
```

**5.节点上树和下树**
上树：
```
int event_add(struct event *ev, const struct timeval *timeout);

ev: 上树节点的地址
timeout: NULL：永久监听  固定时间：限时等待
```

下树:
```
int event_del(struct event *ev);
ev: 下树节点的地址
```

# 3.使用libevent编写tcp服务器流程

示例代码01_event_tcp_server.c：
```
#include <stdio.h>
#include "wrap.h"  
#include <event.h>

void cfdcb(int cfd,short event,void *arg)
{
	char buf[1500]="";
	
	int n = Read(cfd,buf,sizeof(buf));
	if(n <= 0)
	{
		perror("err or close\n");
		//event_del();//下树。这里下树，是有问题的
	
	}
	else
	{
		printf("%s\n",buf);
		Write(cfd,buf,n);
	
	}

}
void lfdcb(int lfd,short event,void *arg)
{
	struct event_base *base = (struct event_base *)arg; 
	//提取新的cfd
	int cfd = Accept(lfd,NULL,NULL);
	//将cfd上树
	struct event *ev = event_new(base,cfd,EV_READ | EV_PERSIST,cfdcb,NULL);//初始化上树节点
	event_add(ev,NULL);
	
}
int main(int argc, char *argv[])
{
	//创建套接字
	//绑定
	int lfd = tcp4bind(8000,NULL);
	//监听
	Listen(lfd,128);
	//创建event_base根节点
	struct event_base * base = event_base_new();
	//构建节点用于上树，即将文件描述符、监听事件和回调函数包装成一个特定的结构event。
	struct event *ev = event_new(base,lfd,EV_READ | EV_PERSIST,lfdcb,base);
	//上树
	event_add(ev,NULL);
	//循环监听（阻塞了）
	event_base_dispatch(base);//阻塞
	//收尾
	close(lfd);
	event_base_free(base);
	return 0;
}
```
编译命令：gcc 01_event_tcp_server.c -o 01_event_tcp_server.c -levent
本代码的下树是有问题的，需要看视频解决，我懒得看，以后再补充

# 4.bufferevent事件 
普通的event事件：文件描述符   事件(底层缓冲区的读事件或者写事件) 触发    回调
bufferevent事件： 应用层有两个缓冲区（读/写缓冲区），每个缓冲区对应一个回调函数，此外还有一个事件的回调函数，总共3个回调函数。

![](https://img2022.cnblogs.com/blog/1617829/202205/1617829-20220511230236886-905309846.png)





## 4.1.bufferevent事件的API
**1.创建新的节点**
```
struct bufferevent *bufferevent_socket_new(struct event_base *base, evutil_socket_t fd, int options);

参数: 
    base  : event_base 根节点
    fd: 要初始化上树的文件描述符
    options : 
           BEV_OPT_CLOSE_ON_FREE   -- 释放bufferevent自动关闭底层接口   
           BEV_OPT_THREADSAFE      -- 使bufferevent能够在多线程下是安全的    
返回值:
   新建节点的地址
```

**2.设置回调函数并进行上树**

使用bufferevent_setcb就可以设置回调函数并进行上树
```
void bufferevent_setcb(struct bufferevent *bufev,
    bufferevent_data_cb readcb, 
    bufferevent_data_cb writecb,
    bufferevent_event_cb eventcb, void *cbarg);


参数:
    bufev : 新建的节点的地址
    readcb : 读回调
    writecb : 写回调
    eventcb : 异常回调
    cbarg: 传给回调函数的参数
```
bufferevent_setcb设置节点对应文件描述符事件触发的回调并进行上树。

回调函数长下面这样：
```
typedef void (*bufferevent_data_cb)(struct bufferevent *bev, void *ctx);             // 读写回调
typedef void (*bufferevent_event_cb)(struct bufferevent *bev, short what, void *ctx);// 事件回调

What代表对应的事件:
    BEV_EVENT_EOF, 对方关闭连接
    BEV_EVENT_ERROR，出错
    BEV_EVENT_TIMEOUT,超时
    BEV_EVENT_CONNECTED 建立连接成功
```

bufferevent_setcb自动监听三个事件（读、写和异常），下面函数用于设置是否在发生某个事件（读、写和异常）的时候触发回调函数
int bufferevent_enable(struct bufferevent *bufev, short event);//EV_READ  EV_WRITE,异常事件也被当成EV_READ
int bufferevent_disable(struct bufferevent *bufev, short event);//EV_READ  EV_WRITE,异常事件也被当成EV_READ



**3.发送数据**
```
int bufferevent_write(struct bufferevent *bufev, const void *data, size_t size);
bufferevent_write是将data的数据写到bufferevent的写缓冲区。写进应用层的写缓冲区，而不是写进内核的写缓冲区。如果内核的写缓冲区有空间，那么应用层的写缓冲区里的内容会进一步放到内核的写缓冲区，从而触发写事件。
```

**4.接收数据**
```
size_t bufferevent_read(struct bufferevent *bufev, void *data, size_t size);
bufferevent_read 是将bufferevent的读缓冲区数据读到data中，同时将读到的数据从bufferevent的读缓冲清除。
```

更详细的bufferevent说明，请见黑马程序员课程发的doc文件。 

## 4.2.连接侦听器
连接侦听器用于创建套接字、绑定、监听和提取
```
struct evconnlistener *evconnlistener_new_bind(struct event_base *base,
        evconnlistener_cb cb, 
        void *ptr, unsigned flags, int backlog,
        const struct sockaddr *sa, int socklen);

参数: 
    base : base根节点
    cb : 通过accept得到套接字以后调用的回调函数 
    ptr : 传给回调的参数
    flags : 
         LEV_OPT_LEAVE_SOCKETS_BLOCKING   文件描述符为阻塞的
         LEV_OPT_CLOSE_ON_FREE            关闭时自动释放
         LEV_OPT_REUSEABLE                端口复用
         LEV_OPT_THREADSAFE               分配锁，线程安全
         flags经常写为LEV_OPT_CLOSE_ON_FREE|LEV_OPT_REUSEABLE
    backlog : -1
    sa : 绑定的地址信息
    socklen : sa的大小
    
返回值: 连接侦听器的地址
```


cb的原型如下：
```
typedef void (*evconnlistener_cb)(struct evconnlistener *evl, evutil_socket_t fd, struct sockaddr *cliaddr, int socklen, void *ptr);
参数:
    evl :  链接侦听器的地址
    fd :  cfd
    cliaddr: 客户端的地址信息
    ptr:  evconnlistener_new_bind传过来的参数
```
 


## 4.3.创建套接字 连接服务器
```
struct bufferevent *bufferevent_socket_new(struct event_base *base,-1, int options);
int bufferevent_socket_connect(struct bufferevent *bev, struct sockaddr *serv, int socklen);
    bev: 新建的节点
    serv: 服务器的地址信息
    socklen: serv长度
```

## 4.4.bufferevent实现tcp服务器
helloworld.c:
```
/*
  This exmple program provides a trivial server program that listens for TCP
  connections on port 9995.  When they arrive, it writes a short message to
  each client connection, and closes each connection once it is flushed.

  Where possible, it exits cleanly in response to a SIGINT (ctrl-c).
*/


#include <string.h>
#include <errno.h>
#include <stdio.h>
#include <signal.h>
#ifndef WIN32
#include <netinet/in.h>
# ifdef _XOPEN_SOURCE_EXTENDED
#  include <arpa/inet.h>
# endif
#include <sys/socket.h>
#endif

#include <event2/bufferevent.h>
#include <event2/buffer.h>
#include <event2/listener.h>
#include <event2/util.h>
#include <event2/event.h>

static const char MESSAGE[] = "Hello, World!\n";

static const int PORT = 9995;

static void conn_readcb(struct bufferevent *bev, void *user_data);
static void listener_cb(struct evconnlistener *, evutil_socket_t,
    			struct sockaddr *, int socklen, void *);
static void conn_writecb(struct bufferevent *, void *);
static void conn_eventcb(struct bufferevent *, short, void *);
static void signal_cb(evutil_socket_t, short, void *);

int main(int argc, char **argv)
{
	struct event_base *base;
	struct evconnlistener *listener;
	struct event *signal_event;

	struct sockaddr_in sin;
#ifdef WIN3 // 配置一些环境
	WSADATA wsa_data;
	WSAStartup(0x0201, &wsa_data);
#endif

	base = event_base_new();//创建event_base根节点
	if (!base) {
		fprintf(stderr, "Could not initialize libevent!\n");
		return 1;
	}

	memset(&sin, 0, sizeof(sin)); // 这里已经将IP设为0.0.0.0
	sin.sin_family = AF_INET;
	sin.sin_port = htons(PORT);

	//创建链接侦听器
	listener = evconnlistener_new_bind(base, listener_cb, (void *)base,
	    			LEV_OPT_REUSEABLE|LEV_OPT_CLOSE_ON_FREE, -1,
	    			(struct sockaddr*)&sin,
	    			sizeof(sin));

	if (!listener) {
		fprintf(stderr, "Could not create a listener!\n");
		return 1;
	}

	//创建信号触发的节点。evsignal_new就是event_new，定义如下：#define evsignal_new(b, x，cb,arg) event_new((b),(x)+EV_SIGNAL | EV_PERSIST,(cb),(arg)) 
	signal_event = evsignal_new(base, SIGINT, signal_cb, (void *)base); // event_new构建节点用于上树
	//将信号节点上树
	if (!signal_event || event_add(signal_event, NULL)<0) { // event_add用于上树
		fprintf(stderr, "Could not create/add a signal event!\n");
		return 1;
	}

	event_base_dispatch(base);//循环监听

	evconnlistener_free(listener);//释放链接侦听器
	event_free(signal_event);//释放信号节点
	event_base_free(base);//释放event_base根节点

	printf("done\n");
	return 0;
}

static void
listener_cb(struct evconnlistener *listener, evutil_socket_t fd,
    struct sockaddr *sa, int socklen, void *user_data)
{
	struct event_base *base = user_data;
	struct bufferevent *bev;

	//将fd上树
	//新建一个buffervent节点
	bev = bufferevent_socket_new(base, fd, BEV_OPT_CLOSE_ON_FREE);
	if (!bev) {
		fprintf(stderr, "Error constructing bufferevent!");
		event_base_loopbreak(base);
		return;
	}
	//设置回调
	bufferevent_setcb(bev, conn_readcb, conn_writecb, conn_eventcb, NULL);
	bufferevent_enable(bev, EV_WRITE | EV_READ);//设置读写事件使能
	//bufferevent_disable(bev, EV_READ);//设置读事件非使能

	bufferevent_write(bev, MESSAGE, strlen(MESSAGE));//给cfd发送消息 helloworld
}
static void conn_readcb(struct bufferevent *bev, void *user_data)
{
	char buf[1500]="";
	int n = bufferevent_read(bev,buf,sizeof(buf));
	printf("%s\n",buf);
	bufferevent_write(bev, buf,n);//给cfd发送消息 



}

static void
conn_writecb(struct bufferevent *bev, void *user_data)
{
	struct evbuffer *output = bufferevent_get_output(bev);//获取缓冲区类型
	if (evbuffer_get_length(output) == 0) {   // 判断应用缓冲区的数据是否都写入了内核缓冲区
		
	//	printf("flushed answer\n");
	//	bufferevent_free(bev);//释放节点 自动关闭
	}
}

static void
conn_eventcb(struct bufferevent *bev, short events, void *user_data)
{
	if (events & BEV_EVENT_EOF) {
		printf("Connection closed.\n");
	} else if (events & BEV_EVENT_ERROR) {
		printf("Got an error on the connection: %s\n",
		    strerror(errno));/*XXX win32*/
	}
	/* None of the other events can happen here, since we haven't enabled
	 * timeouts */
	bufferevent_free(bev);
}

static void
signal_cb(evutil_socket_t sig, short events, void *user_data)
{
	struct event_base *base = user_data;
	struct timeval delay = { 2, 0 };

	printf("Caught an interrupt signal; exiting cleanly in two seconds.\n");

	event_base_loopexit(base, &delay);//退出循环监听
}
```
编译运行：
```
gcc hello-world.c -o hello-world -levent
./hello-world 
```
开启另一个终端，输入：
```
nc 127.1 9995  #127.1代表127.0.0.1
```

## 4.5.bufferevent实现tcp客户端
**客户端创建套接字,连接服务器的API：**
```
struct bufferevent *bufferevent_socket_new(struct event_base *base,-1, int options); // 创建新节点。这里fd填-1，在bufferevent_socket_connect中会实现套接字的创建。
int bufferevent_socket_connect(struct bufferevent *bev, struct sockaddr *serv, int socklen);
    bev: 新建的节点
    serv: 服务器的地址信息
    sockle  n: serv长度
```

bufferevent实现tcp客户端bufferevent_client.c：
```
//bufferevent建立客户端的过程
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <errno.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <event.h>
#include <event2/bufferevent.h>
#include <event2/buffer.h>
#include <event2/util.h>

int tcp_connect_server(const char* server_ip, int port);
void cmd_msg_cb(int fd, short events, void* arg);
void server_msg_cb(struct bufferevent* bev, void* arg);
void event_cb(struct bufferevent *bev, short event, void *arg);
//./a.out  192.168.1.1  9995
int main(int argc, char** argv)
{
    if( argc < 3 )
    {
        //两个参数依次是服务器端的IP地址、端口号
        printf("please input 2 parameter\n");
        return -1;
    }
    //创建根节点
    struct event_base *base = event_base_new();
    //创建并且初始化buffer缓冲区
    struct bufferevent* bev = bufferevent_socket_new(base, -1,
                                                     BEV_OPT_CLOSE_ON_FREE);

    //监听终端输入事件 设置标准输入的监控,设置回调是 cmd_msg_cb 
    struct event* ev_cmd = event_new(base, STDIN_FILENO,
                                     EV_READ | EV_PERSIST,
                                     cmd_msg_cb, (void*)bev);
    // 上面相当于创建了两个节点bev和ev_cmd，等待上树

	printf("001\n");
    //上树 开始监听标准输入的读事件
    event_add(ev_cmd, NULL);
    
    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr) );
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(atoi(argv[2]));
    //将ip地址转换为网络字节序
    inet_aton(argv[1], &server_addr.sin_addr);

    //连接到 服务器ip地址和端口 初始化了 socket文件描述符 socket+connect 
    bufferevent_socket_connect(bev, (struct sockaddr *)&server_addr,
                               sizeof(server_addr));
    //设置buffer的回调函数并上树。 主要设置了读回调 server_msg_cb ,传入参数是标准输入的读事件
    bufferevent_setcb(bev, server_msg_cb, NULL, event_cb, (void*)ev_cmd);
    bufferevent_enable(bev, EV_READ | EV_PERSIST);
	printf("002\n");

    event_base_dispatch(base);//循环等待
    event_free(ev_cmd);
    bufferevent_free(bev);
    event_base_free(base);
    printf("finished \n");
    return 0;
}
//终端输入回调
void cmd_msg_cb(int fd, short events, void* arg)
{
    char msg[1024];

    int ret = read(fd, msg, sizeof(msg));
    if( ret < 0 )
    {
        perror("read fail ");
        exit(1);
    }
    //得到bufferevent指针,目的是为了写到bufferevent的写缓冲区
    struct bufferevent* bev = (struct bufferevent*)arg;

    //把终端的消息发送给服务器端
    bufferevent_write(bev, msg, ret);
}

void server_msg_cb(struct bufferevent* bev, void* arg)
{
	
	printf("001\n");
    char msg[1024];

    size_t len = bufferevent_read(bev, msg, sizeof(msg));
    msg[len] = '\0';
	printf("002\n");

    printf("recv %s from server\n", msg);
}

void event_cb(struct bufferevent *bev, short event, void *arg)
{

    if (event & BEV_EVENT_EOF)
        printf("connection closed\n");
    else if (event & BEV_EVENT_ERROR)
        printf("some other error\n");
    else if( event & BEV_EVENT_CONNECTED)
    {
        printf("the client has connected to server\n");
        return ;
    }


    //这将自动close套接字和free读写缓冲区
   bufferevent_free(bev);
    //释放event事件 监控读终端
  struct event *ev = (struct event*)arg;
    event_free(ev);
	exit(0);
}
```
首先运行bufferevent实现tcp服务器，然后再运行bufferevent实现tcp客户端
]]></description></item><item><title>C++ Restful API 框架库</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/05/09/16249503.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Mon, 09 May 2022 07:49:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/05/09/16249503.html</guid><description><![CDATA[规范见：[链接1](https://www.cnblogs.com/bigsai/p/14099154.html)
[链接2](https://restfulapi.cn/)

![](https://img2022.cnblogs.com/blog/1617829/202205/1617829-20220509154417976-1246343575.png)

表格中第二列和第三列是性能指标，第四列体现易用性。从表中，我们可以很容易发现，巨硬（微软）开源的Restful库的性能最差，甚至不如PHP语言实现的，这简直是对C++的侮辱啊！其中性能最好的库——pistache，性能大约是PHP版本的2.17倍，不过易用性跟PHP差了很多：PHP仅仅用14行就可以写出一个Restful接口，而C++需要大约40行。

从上面的评测，我们可以看到不论是性能还是易用性方面，pistache在所有C++实现的Restful库中表现最为出色。


参考：[链接](https://www.jianshu.com/p/38c3ce4dfbb3)



https://jishuin.proginn.com/p/763bfbd2f0ca]]></description></item><item><title>C++ 信号</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/05/08/16246557.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Sun, 08 May 2022 11:36:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/05/08/16246557.html</guid><description><![CDATA[#1.信号的概念

信号是 Linux 进程间通信的最古老的方式。信号是软件中断，它是在软件层次上对中断机制的一种模拟，是一种异步通信的方式 。信号可以导致一个正在运行的进程被另一个正在运行的异步进程中断，转而处理某一个突发事件。
“中断”在我们生活中经常遇到，譬如，我正在房间里打游戏，突然送快递的来了，把正在玩游戏的我给“中断”了，我去签收快递( 处理中断 )，处理完成后，再继续玩我的游戏。
这里我们学习的“信号”就是属于这么一种“中断”。我们在终端上敲“Ctrl+c”，就产生一个“中断”，相当于产生一个信号，接着就会处理这么一个“中断任务”（默认的处理方式为中断当前进程）。
中断：先停下本进程，去处理信号。
异步：不知道信号什么时候来

内核进程可以利用它来通知用户空间进程发生了哪些系统事件。


## 1.1信号的编号(了解)
1）信号编号：
Unix早期版本就提供了信号机制，但不可靠，信号可能丢失。Berkeley 和 AT&T都对信号模型做了更改，增加了可靠信号机制。但彼此不兼容。POSIX.1对可靠信号例程进行了标准化。

Linux 可使用命令：kill -l（"l" 为字母），查看相应的信号和对应的编号。
不存在编号为0的信号。其中1-31号信号称之为常规信号（也叫普通信号或标准信号），34-64称之为实时信号，驱动编程与硬件相关。名字上区别不大。而前32个名字各不相同。

2） Linux常规信号一览表 :
| 编号    | 信号                  | 对应事件                                                                 | 默认动作          |
| ----- | ------------------- | -------------------------------------------------------------------- | ------------- |
| 1     | SIGHUP              | 用户退出shell时，由该shell启动的所有进程将收到这个信号。由于默认动作时终止进程，所以当终端被关闭以后，终端里面的后台\前台进程都会被终止                                     | 终止进程          |
| 2     | **SIGINT**              | 当用户按下了<Ctrl+C>组合键时，用户终端向正在运行中的由该终端启动的程序发出此信号                         | 终止进程          |
| 3     | **SIGQUIT**             | 用户按下<ctrl+\>组合键时产生该信号，用户终端向正在运行中的由该终端启动的程序发出些信号                      | 终止进程          |
| 4     | SIGILL              | CPU检测到某进程执行了非法指令：c语言中可内嵌汇编语言，此时如果你写了一个非法的指令，就会发出SIGILL信号                                                     | 终止进程并产生core文件 |
| 5     | SIGTRAP             | 该信号由断点指令或其他 trap指令产生                                                 | 终止进程并产生core文件 |
| 6     | SIGABRT             | 调用abort函数时产生该信号                                                      | 终止进程并产生core文件 |
| 7     | SIGBUS              | 非法访问内存地址，包括内存对齐出错                                                    | 终止进程并产生core文件 |
| 8     | SIGFPE              | 在发生致命的运算错误时发出。不仅包括浮点运算错误，还包括溢出及除数为0等所有的算法错误                          | 终止进程并产生core文件 |
| 9     | SIGKILL             | 无条件终止进程。本信号不能被忽略，用于处理和阻塞                                               | 终止进程，可以杀死任何进程 |
| 10    | SIGUSE1             | 用户定义的信号。即程序员可以在程序中定义并使用该信号                                           | 终止进程          |
| 11    | **SIGSEGV**             | 指示进程进行了无效内存访问(段错误)                                                   | 终止进程并产生core文件 |
| 12    | SIGUSR2             | 另外一个用户自定义信号，程序员可以在程序中定义并使用该信号                                        | 终止进程          |
| 13    | **SIGPIPE**             | Broken pipe向一个没有读端的管道写数据                                             | 终止进程          |
| 14    | SIGALRM             | 定时器超时，超时的时间 由系统调用alarm设置                                             | 终止进程          |
| 15    | SIGTERM             | 程序结束信号，与SIGKILL不同的是，该信号可以被阻塞和终止。通常用来要示程序正常退出。执行shell命令Kill时，缺省产生这个信号 | 终止进程          |
| 16    | SIGSTKFLT           | Linux早期版本出现的信号，现仍保留向后兼容                                              | 终止进程          |
| 17    | **SIGCHLD**             | 子进程结束时，父进程会收到这个信号。由于默认忽略这个信号，所以当子进程退出，而父进程未对子进程进行清理，就会出现”僵尸子进程“。                                                    | 忽略这个信号        |
| 18    | SIGCONT             | 如果进程已停止，则使其继续运行                                                      | 继续/忽略         |
| 19    | SIGSTOP             | 停止进程的执行。信号不能被忽略，处理和阻塞                                                | 为终止进程         |
| 20    | SIGTSTP             | 停止终端交互进程的运行。按下<ctrl+z>组合键时发出这个信号                                     | 暂停进程          |
| 21    | SIGTTIN             | 后台进程读终端控制台                                                           | 暂停进程          |
| 22    | SIGTTOU             | 该信号类似于SIGTTIN，在后台进程要向终端输出数据时发生                                       | 暂停进程          |
| 23    | SIGURG              | 套接字上有紧急数据时，向当前正在运行的进程发出些信号，报告有紧急数据到达。如网络带外数据到达                       | 忽略该信号         |
| 24    | SIGXCPU             | 进程执行时间超过了分配给该进程的CPU时间 ，系统产生该信号并发送给该进程                                | 终止进程          |
| 25    | SIGXFSZ             | 超过文件的最大长度设置                                                          | 终止进程          |
| 26    | SIGVTALRM           | 虚拟时钟超时时产生该信号。类似于SIGALRM，但是该信号只计算该进程占用CPU的使用时间                        | 终止进程          |
| 27    | SGIPROF             | 类似于SIGVTALRM，它不公包括该进程占用CPU时间还包括执行系统调用时间                              | 终止进程          |
| 28    | SIGWINCH            | 窗口变化大小时发出                                                            | 忽略该信号         |
| 29    | SIGIO               | 此信号向进程指示发出了一个异步IO事件                                                  | 忽略该信号         |
| 30    | SIGPWR              | 关机                                                                   | 终止进程          |
| 31    | SIGSYS              | 无效的系统调用                                                              | 终止进程并产生core文件 |
| 34~64 | SIGRTMIN ～ SIGRTMAX | LINUX的实时信号，它们没有固定的含义（可以由用户自定义）                                       | 终止进程          |

加粗的为重要的。
通过自定义信号处理函数，可以修改信号的默认动作。




## 1.2.信号四要素
每个信号必备4要素，分别是：

1）编号 2）名称 3）事件 4）默认处理动作

可通过man 7 signal查看帮助文档获取：
![](https://img2022.cnblogs.com/blog/1617829/202205/1617829-20220508203954849-228479650.png)
在标准信号中，有一些信号是有三个“Value”，第一个值通常对alpha和sparc架构有效，中间值针对x86、arm和其他架构，最后一个应用于mips架构。一个‘-’表示在对应架构上尚未定义该信号。故要让程序具有系统可移植性，最好使用信号的名称而不是编号。

不同的操作系统定义了不同的系统信号。因此有些信号出现在Unix系统内，也出现在Linux中，而有的信号出现在FreeBSD或Mac OS中却没有出现在Linux下。这里我们只研究Linux系统中的信号。

Action为默认动作：
Term：终止进程
Ign： 忽略信号 (默认即时对该种信号忽略操作)
Core：终止进程，生成Core文件。(查验死亡原因，用于gdb调试)
Stop：停止（暂停）进程
Cont：继续运行进程
注意通过man 7 signal命令查看帮助文档，其中可看到 : The signals SIGKILL and SIGSTOP cannot be caught, blocked, or ignored.

这里特别强调了9) SIGKILL 和19) SIGSTOP信号，不允许忽略和捕捉，只能执行默认动作。甚至不能将其设置为阻塞。

另外需清楚，只有每个信号所对应的事件发生了，该信号才会被递送(但不一定递达，有可能丢失)，不应乱发信号！！

 

## 1.3.信号的状态

**1） 产生**

a) 当用户按某些终端键时，将产生信号。

终端上按“Ctrl+c”组合键通常产生中断信号 SIGINT

终端上按“Ctrl+\”键通常产生中断信号 SIGQUIT

终端上按“Ctrl+z”键通常产生中断信号 SIGSTOP 等。

b) 硬件异常将产生信号。

除数为 0，无效的内存访问等。这些情况通常由硬件检测到，并通知内核，然后内核产生适当的信号发送给相应的进程。

c) 软件异常将产生信号。

当检测到某种软件条件已发生(如：定时器alarm)，并将其通知有关进程时，产生信号。

d) 调用系统函数(如：kill、raise、abort)将发送信号。

注意：接收信号进程和发送信号进程的所有者必须相同，或发送信号进程的所有者必须是超级用户。

e) 运行 kill /killall命令将发送信号。

此程序实际上是使用 kill 函数来发送信号。也常用此命令终止一个失控的后台进程。

 

**2) 未决状态**：没有被处理，处理函数未被调用

**3) 递达状态**：信号被处理了，处理函数已被调用




## 1.4.阻塞信号集和未决信号集
信号的实现手段导致信号有很强的延时性，但对于用户来说，时间非常短，不易察觉。
Linux内核的进程控制块PCB是一个结构体，task_struct, 除了包含进程id，状态，工作目录，用户id，组id，文件描述符表，还包含了信号相关的信息，主要指阻塞信号集和未决信号集。

阻塞信号集(信号屏蔽字)：将某些信号加入集合，对他们设置屏蔽。当屏蔽x信号后，收到的信号x将不会被处理，直到解除屏蔽以后才会被处理。

未决信号集：
- 信号产生，未决信号集中描述该信号的位立刻翻转为1，表示信号处于未决状态。当信号被处理对应位翻转回为0。这一时刻往往非常短暂。
- 信号产生后由于某些原因(主要是阻塞)不能抵达。这类信号的集合称之为未决信号集。

这两个信号集都是内核使用位图机制来实现的。但操作系统不允许我们直接对其进行位操作。而需自定义另外一个集合，借助信号集操作函数来对PCB中的这两个信号集进行修改。
![](https://img2022.cnblogs.com/blog/1617829/202205/1617829-20220509134516989-1501924538.png)

每一个PCB中都有阻塞信号集和未决信号集
### 1.4.1.自定义信号集函数
为了方便对多个信号进行处理，一个用户进程常常需要对多个信号做出处理，在 Linux 系统中引入了信号集（信号的集合）。

这个信号集有点类似于我们的 QQ 群，一个个的信号相当于 QQ 群里的一个个好友。

信号集是一个能表示多个信号的数据类型，sigset_t set，set即一个信号集。既然是一个集合，就需要对集合进行添加/删除等操作。

相关函数说明如下：
```
#include <signal.h>  
​
int sigemptyset(sigset_t *set);       //将set集合置空
int sigfillset(sigset_t *set)；          //将所有信号加入set集合
int sigaddset(sigset_t *set, int signo);  //将signo信号加入到set集合
int sigdelset(sigset_t *set, int signo);   //从set集合中移除signo信号
int sigismember(const sigset_t *set, int signo); //判断信号是否存在
```
除sigismember外，其余操作函数中的set均为传出参数。sigset_t类型的本质是位图。但不应该直接使用位操作，而应该使用上述函数，保证跨系统操作有效。
示例程序:
```
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <signal.h>

int main()
{
    sigset_t set;   // 定义一个信号集变量
    int ret = 0;
​
    sigemptyset(&set); // 清空信号集的内容
​
    // 判断 SIGINT 是否在信号集 set 里
    // 在返回 1， 不在返回 0
    ret = sigismember(&set, SIGINT);
    if (ret == 0)
    {
        printf("SIGINT is not a member of set \nret = %d\n", ret);
    }
​
    sigaddset(&set, SIGINT); // 把 SIGINT 添加到信号集 set
    sigaddset(&set, SIGQUIT);// 把 SIGQUIT 添加到信号集 set
​
    // 判断 SIGINT 是否在信号集 set 里
    // 在返回 1， 不在返回 0
    ret = sigismember(&set, SIGINT);
    if (ret == 1)
    {
        printf("SIGINT is a member of set \nret = %d\n", ret);
    }
​
    sigdelset(&set, SIGQUIT); // 把 SIGQUIT 从信号集 set 移除
​
    // 判断 SIGQUIT 是否在信号集 set 里
    // 在返回 1， 不在返回 0
    ret = sigismember(&set, SIGQUIT);
    if (ret == 0)
    {
        printf("SIGQUIT is not a member of set \nret = %d\n", ret);
    }
​
    return 0;
}
```

### 1.4.2.sigprocmask函数
信号阻塞集也称信号屏蔽集、信号掩码。每个进程都有一个阻塞集，创建子进程时子进程将继承父进程的阻塞集。信号阻塞集用来描述哪些信号递送到该进程的时候被阻塞（在信号发生时记住它，直到进程准备好时再将信号通知进程）。

所谓阻塞并不是禁止传送信号, 而是将传送的信号阻塞。若将被阻塞的信号从信号阻塞集中删除，进程将会收到相应的信号。【注】若发送同一个信号多次，但由于这个信号被阻塞而无法传送，当将被阻塞的信号从信号阻塞集中删除后，进程只处理一次这个信号（即使它发了很多次）

我们可以通过 sigprocmask() 修改当前的信号掩码来改变信号的阻塞情况。
```
#include <signal.h>

int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);
功能：
    检查或修改信号阻塞集，根据 how 指定的方法对进程的阻塞集合进行修改，新的信号阻塞集由 set 指定，而原先的信号阻塞集合由 oldset 保存。
​
参数：
    how : 信号阻塞集合的修改方法，有 3 种情况：
        SIG_BLOCK：向信号阻塞集合中添加 set 信号集，新的信号掩码是set和旧信号掩码的并集。相当于 mask = mask|set。
        SIG_UNBLOCK：从信号阻塞集合中删除 set 信号集，从当前信号掩码中去除 set 中的信号。相当于 mask = mask & ~ set。
        SIG_SETMASK：将信号阻塞集合设为 set 信号集，相当于原来信号阻塞集的内容清空，然后按照 set 中的信号重新设置信号阻塞集。相当于mask = set。
    set : 要操作的信号集地址。
        若 set 为 NULL，则不改变信号阻塞集合，函数只把当前信号阻塞集合保存到 oldset 中。
    oldset : 保存原先信号阻塞集地址
​
返回值：
    成功：0，
    失败：-1，失败时错误代码只可能是 EINVAL，表示参数 how 不合法。
```
示例程序：
```
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <signal.h>

// 信号处理函数
void signal_handler(int signo)
{
	if (signo == SIGINT)
	{
		printf("recv SIGINT\n");
	}
	else if (signo == SIGQUIT)
	{
		printf("recv SIGQUIT\n");
	}
}

int main()
{	
	int ret;
	sigset_t set, oldset;
	printf("wait for SIGINT OR SIGQUIT\n");

	/* SIGINT: Ctrl+c ; SIGQUIT: Ctrl+\ */
	// 信号注册函数
	signal(SIGINT, signal_handler);
	signal(SIGQUIT, signal_handler);


	printf("按下任意键阻塞信号2\n");
	getchar();

	sigemptyset(&oldset);
	sigemptyset(&set);
	sigaddset(&set, SIGINT);

	//设置屏蔽编号为2的信号
	ret = sigprocmask(SIG_BLOCK, &set, &oldset);
	if (-1 == ret){
		perror("sigprocmaSk");
		return 1;
	}
	printf("设置屏蔽编号为2的信号成功....\n");

	printf("按下任意键解除编号为2的信号的阻塞...\n");
	getchar();
	//将信号屏蔽集设置为原来的集合
	ret = sigprocmask(SIG_SETMASK, &oldset, NULL);
	if (-1 == ret) {
		perror("sigp rocmask");
	}
	return 1;
}

```
![](https://img2022.cnblogs.com/blog/1617829/202205/1617829-20220509142950419-1123283785.png)
在被阻塞期间我们发送了八个SIGINT信号，但是在阻塞解除时，进程只调用了一次信号处理函数


### 1.4.3.sigpending函数


```
#include <signal.h>
​
int sigpending(sigset_t *set);
功能：读取当前进程的未决信号集
参数：
    set：未决信号集
返回值：
    成功：0
    失败：-1
```
示例程序:
```
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <signal.h>
#include <unistd.h>
int main()
{
	// 自定义信号集
	sigset_t myset, old;
	sigemptyset(&myset);// 清空　－》　０

	// 添加要阻塞的信号
	sigaddset(&myset, SIGINT);
	sigaddset(&myset, SIGQUIT);
	sigaddset(&myset, SIGKILL);

	// 自定义信号集设置到内核中的阻塞信号集
	sigprocmask(SIG_BLOCK, &myset, &old);

	sigset_t pend;
	int i = 0;
	while (1)
	{
		// 读内核中的未决信号集的状态
		sigpending(&pend);
		for (int i = 1; i < 32; ++i)
		{
			if (sigismember(&pend, i))
			{
				printf("1");
			}
			else if (sigismember(&pend, i) == 0)
			{
				printf("0");
			}
		}
		printf("\n");
		sleep(1);
		i++;

		// 10s之后解除阻塞
		if (i > 10)
		{
			// sigprocmask(SIG_UNBLOCK, &myset, NULL);
			sigprocmask(SIG_SETMASK, &old, NULL);
		}
	}

	return 0;
}
```







# 2.信号产生函数

## 2.1.kill函数
和kill命令的使用类似
```
#include <sys/types.h>
#include <signal.h>
​
int kill(pid_t pid, int sig);
功能：给指定进程发送指定信号
​
参数：
    pid : 取值有 4 种情况 （和waitpid函数的参数pid一样）:
        pid > 0:  将信号传送给进程 ID 为pid的进程。
        pid = 0 :  将信号传送给当前进程所在进程组中的所有进程。
        pid = -1 : 将信号传送给系统内所有的进程。
        pid < -1 : 将信号传给指定进程组的所有进程。这个进程组号等于 pid 的绝对值。
    sig : 信号的编号，这里可以填数字编号，也可以填信号的宏定义，可以通过命令 kill - l("l" 为字母)进行相应查看。不推荐直接使用数字，应使用宏名，因为不同操作系统信号编号可能不同，但名称一致。
​
返回值：
    成功：0
    失败：-1
```
super用户(root)可以发送信号给任意用户，普通用户是不能向系统用户发送信号的。

kill -9 (root用户的pid) 是不可以的。同样，普通用户也不能向其他普通用户发送信号，终止其进程。 只能向自己创建的进程发送信号。

普通用户基本规则是：发送者实际或有效用户ID == 接收者实际或有效用户ID

程序示例:
```
#include <stdio.h>
#include <stdlib.h> 
#include <string.h>
#include <sys/types.h>
#include <signal.h>
#include <unistd.h>

int main()
{
    pid_t pid = fork();
    if (pid == 0)
    {//子进程
        int i = 0;
        for (i = 0; i<5; i++)
        {
            printf("in son process\n");
            sleep(1);
        }
    }
    else
    {//父进程
        printf("in father process\n");
        sleep(2);
        printf("kill sub process now \n");
        kill(pid, SIGINT);
    }
​
    return 0;
}
```

## 2.2.raise函数
```
#include <signal.h>
​
int raise(int sig);
功能：给当前进程发送指定信号(自己给自己发)，等价于 kill(getpid(), sig)
参数：
    sig：信号编号
返回值：
    成功：0
    失败：非0值
```

## 2.3.abort函数
```
#include <stdlib.h>
​
void abort(void);
功能：给自己发送异常终止信号 6) SIGABRT，并产生core文件，等价于kill(getpid(), SIGABRT);
​
参数：无
​
返回值：无
```
好的编程习惯：
```
写if(4 == i)
而不写
if(i == 4),
因为当我们写错成if(4 = i)时，会报错。
```


## 2.4.alarm函数(闹钟)
alarm函数是非阻塞的
```
#include <unistd.h>
​
unsigned int alarm(unsigned int seconds);
功能：
    设置定时器(闹钟)。在指定seconds后，内核会给当前进程发送14）SIGALRM信号。进程收到该信号，默认动作终止。每个进程都有且只有唯一的一个定时器。
    取消定时器alarm(0)，返回旧闹钟余下秒数。
参数：
    seconds：指定的时间，以秒为单位
返回值：
    返回0或剩余的秒数
```

定时，与进程状态无关(自然定时法)！就绪、运行、挂起(阻塞、暂停)、终止、僵尸……无论进程处于何种状态，alarm都计时（因为alarm是由内核进行运行的）。

测试程序:

```
int main()
{
    int seconds = 0;
​
    seconds = alarm(5);
    printf("seconds = %d\n", seconds);
​
    sleep(2);
    seconds = alarm(5); // 没有超时的闹钟被新的闹钟给覆盖了
    printf("seconds = %d\n", seconds);  // seconds输出为3，因为seconds是上一次闹钟剩余的时间
​
    while (1);
    return 0;
}
```

## 2.5.setitimer函数（定时器）
```
#include <sys/time.h>
​
int setitimer(int which,  const struct itimerval *new_value, struct itimerval *old_value);
功能：
    设置定时器(闹钟)。 可代替alarm函数。精度微秒us，可以实现周期定时。
参数：
    which：指定定时方式
        a) 自然定时：ITIMER_REAL,计算自然时间。返回14）SIGALRM
        b) 虚拟空间计时(用户空间)：ITIMER_VIRTUAL,只计算进程占用cpu的时间。返回26）SIGVTALRM  
        c) 运行时计时(用户 + 内核)：ITIMER_PROF,计算占用cpu及执行系统调用的时间。返回27）SIGPROF
    new_value：struct itimerval, 负责设定timeout时间
        struct itimerval {
            struct timerval it_interval; // 闹钟触发周期，每个多久触发一次
            struct timerval it_value;    // 闹钟触发时间，第一次执行function所延迟的秒数
        };
        struct timeval {
            long tv_sec;            // 秒
            long tv_usec;           // 微秒
        }
        itimerval.it_value： 设定第一次执行function所延迟的秒数 
        itimerval.it_interval：  设定以后每几秒执行function
​
    old_value： 存放旧的timeout值，一般指定为NULL
返回值：
    成功：0
    失败：-1
```
示例程序：
```
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/time.h>

void myfunc(int sig)
{
    printf("hello\n");
}
​
int main()
{
    struct itimerval new_value;
​
    //定时周期
    new_value.it_interval.tv_sec = 1;
    new_value.it_interval.tv_usec = 0;
​
    //第一次触发的时间：延迟两秒触发
    new_value.it_value.tv_sec = 2;
    new_value.it_value.tv_usec = 0;
​
    signal(SIGALRM, myfunc); //信号处理
    setitimer(ITIMER_REAL, &new_value, NULL); //定时器设置
​
    while (1);
​
    return 0;
}
​
```
\#include\<sys/xxx.h\>是Linux系统中的系统头文件，这些头文件下面的函数A，都可以通过man A来查看A的用法

# 3.信号捕捉
信号捕捉内核实现信号捕捉过程：
![](https://img2022.cnblogs.com/blog/1617829/202205/1617829-20220509134108341-56449946.png)
【注】SIGKILL 和 SIGSTOP 不能更改信号的处理方式，因为它们向用户提供了一种使进程终止的可靠方法。

 

## signal函数
```
#include <signal.h>
​
typedef void(*sighandler_t)(int);
sighandler_t signal(int signum, sighandler_t handler);
功能：
    注册信号处理函数（不可用于 SIGKILL、SIGSTOP 信号），即确定收到信号后处理函数的入口地址。此函数不会阻塞。
​
参数：
    signum：信号的编号，这里可以填数字编号，也可以填信号的宏定义(最好使用宏)，可以通过命令 kill - l("l" 为字母)进行相应查看。
    handler : handler存储的是函数的起始地址，取值有 3 种情况：
          SIG_IGN：忽略该信号
          SIG_DFL：执行系统默认动作
          信号处理函数名：自定义信号处理函数，如：func。SIGKILL 和 SIGSTOP 不能更改信号的处理方式，因为它们向用户提供了一种使进程终止的可靠方法。
          回调函数的定义如下：
            void func(int signo)
            {
                // signo 为触发的信号，为 signal() 第一个参数的值
            }
​
返回值：
    成功：第一次返回 NULL，下一次返回此信号上一次注册的信号处理函数的地址。如果需要使用此返回值，必须在前面先声明此函数指针的类型。
    失败：返回 SIG_ERR
```
该函数由ANSI定义，由于历史原因在不同版本的Unix和不同版本的Linux中可能有不同的行为。因此应该尽量避免使用它，取而代之使用sigaction函数。

示例程序:

```
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <signal.h>

// 信号处理函数
void signal_handler(int signo)
{
    if (signo == SIGINT)
    {
        printf("recv SIGINT\n");
    }
    else if (signo == SIGQUIT)
    {
        printf("recv SIGQUIT\n");
    }
}

int main()
{
    printf("wait for SIGINT OR SIGQUIT\n");
    
    /* SIGINT: Ctrl+c ; SIGQUIT: Ctrl+\ */
    // 信号注册函数
    signal(SIGINT, signal_handler);
    signal(SIGQUIT, signal_handler);
    
    while (1); //不让程序结束

    return 0;
}
```
 
]]></description></item><item><title>C++进程控制</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/05/08/16245627.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Sun, 08 May 2022 06:59:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/05/08/16245627.html</guid><description><![CDATA[# 进程相关的命令
## ps
进程是一个具有一定独立功能的程序，它是操作系统动态执行的基本单元。
ps命令可以查看进程的详细状况，常用选项(选项可以不加“-”，不加时输出结果更详细)如下：
| 选项   | 含义                   |
| ---- | -------------------- |
| -a   | 显示终端上的所有进程，包括其他用户的进程 |
| -u   | 显示进程的详细状态            |
| -x   | 显示没有控制终端的进程          |
| -w   | 显示加宽，以便显示更多的信息       |
| -r   | 只显示正在运行的进程           |

ps aux与ps ef等价
ps -a结果如下：
![](https://img2022.cnblogs.com/blog/1617829/202205/1617829-20220508150536215-860536992.png)
其中TTY代表终端，直接在终端中输入tty可显示终端名称：
![](https://img2022.cnblogs.com/blog/1617829/202205/1617829-20220508150605140-1301104498.png)

ps命令常用于查找进程PID，以便于杀死进程。

## top
top命令用来动态显示运行中的进程。top命令能够在运行后，在指定的时间间隔更新显示信息。可以在使用top命令时加上-d 来指定显示信息更新的时间间隔。

在top命令执行后，可以按下按键得到对显示的结果进行排序：

| 按键   | 含义                 |
| ---- | ------------------ |
| M    | 根据内存使用量来排序         |
| P    | 根据CPU占有率来排序        |
| T    | 根据进程运行时间的长短来排序     |
| U    | 可以根据后面输入的用户名来筛选进程  |
| K    | 可以根据后面输入的PID来杀死进程。 |
| q    | 退出                 |
| h    | 获得帮助               |

知道有top这个东西就可以，没必要记后面的参数。

## kill
kill命令：使用某个信号来处理进程，需要配合 ps 使用。
使用格式：
kill [-signal] pid
-signal默认为-15
其中信号-9为绝对终止，可以处理一般信号无法终止的进程（即有些进程不能直接杀死，这时候我们需要加一个参数“ -9 ”，“ -9 ” 代表强制结束）。
查询可用的信号量：kill -l

杀死进程的流程：
```
ps aux| grep name  # 找到名字为name的进程的进程号
kill number        # 通过进程号杀死进程
```
killall -9 name  # 杀死名字为name的所有进程（可能有很多个同名的进程）



# 进程退出和子进程的清理
## 进程退出(exit() 和_exit())
```
#include <stdlib.h>
void exit(int status);
​
#include <unistd.h>
void _exit(int status);
功能：
    结束调用此函数的进程。
参数：
    status：返回给父进程的参数（低 8 位有效），至于这个参数是多少根据需要来填写。
返回值：
    无
```
exit() 和_exit() 函数功能和用法是一样的，无非时所包含的头文件不一样，还有的区别就是：_exit()属于标准库函数，exit()属于系统调用函数。
![](https://img2022.cnblogs.com/blog/1617829/202205/1617829-20220508152450512-898654668.png)
举例如下：
```
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
//结束进程
int main(void)
{
	printf("hello world"); // 要输出"hello world"，就必须刷新I/O缓冲区
	
	//exit(0); // 等价于return 0;,会输出"hello world"
	
	//_ exit(0);  // 直接退出不做任何时候清理，不会输出"hello world"。等价于_Exit(0);
	
	return 0;
}

```
## 等待子进程退出并清理子进程（wait() 和 waitpid()）
在每个进程退出的时候，内核释放该进程所有的资源、包括打开的文件、占用的内存等。但是仍然为其保留一定的信息，这些信息主要主要指进程控制块PCB的信息（包括进程号、退出状态、运行时间等）。

父进程可以通过调用wait或waitpid得到它的退出状态同时彻底清除掉这个进程。
wait() 和 waitpid() 函数的功能一样，区别在于，wait() 函数会阻塞，waitpid() 可以设置不阻塞，waitpid() 还可以指定等待哪个子进程结束。

注意：一次wait或waitpid调用只能清理一个子进程，清理多个子进程应使用循环。

### wait函数
函数说明：
```
#include <sys/types.h>
#include <sys/wait.h>
​
pid_t wait(int *status);
功能：
    等待任意一个子进程结束，如果任意一个子进程结束了，此函数会回收该子进程的资源。
参数：
    status : 进程退出时的状态信息。
返回值：
    成功：已经结束子进程的进程号
    失败： -1
```
调用 wait() 函数的进程会挂起（阻塞），直到它的一个子进程退出或收到一个不能被忽视的信号时才被唤醒（相当于继续往下执行）。

若调用进程没有子进程，该函数立即返回；若它的子进程已经结束，该函数同样会立即返回，并且会回收那个早已结束进程的资源。
所以，wait()函数的主要功能为回收已经结束子进程的资源。

如果参数 status 的值不是 NULL，wait() 就会把子进程退出时的状态取出并存入其中，这是一个整数值（int），指出了子进程是正常退出还是被非正常结束的。

这个退出信息在一个 int 中包含了多个字段，直接使用这个值是没有意义的，我们需要用宏定义取出其中的每个字段。
**宏函数可分为如下三组：**
1\) WIFEXITED(status)：为非0 → 进程正常结束

WEXITSTATUS(status)：如WIFEXITED(status)为真，则可使用WEXITSTATUS(status)获取进程退出状态 (exit的参数)

2\) WIFSIGNALED(status)：为非0 → 进程异常终止

WTERMSIG(status)：如WIFSIGNALED(status)为真，则可使用WTERMSIG(status)取得使进程终止的那个信号的编号。

3\) WIFSTOPPED(status):为非0 → 进程处于暂停状态

WSTOPSIG(status):如WIFSTOPPED(status)为真，则可使用WSTOPSIG(status)取得使进程暂停的那个信号的编号。

WIFCONTINUED(status):为真 → 进程暂停后已经继续运行

举例如下：
 
```
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>
//等待子进程退出
int main(void)
{
	int status = 0;
	int i = 0;
	int ret = -1;
	pid_t pid = -1;

	//创建子进程
	pid = fork();
	if (-1 == pid)
	{
		perror("fork");
		return 1;
	}
	if (0 == pid)
	{
		for (i = 0; i < 15; i++)
		{
			printf("child process %d do thing %d\n", getpid(),i + 1);
			sleep(1);
			//子进程终止
		}

		exit(10);
	}
	//父进程执行
	printf("父进程等待子进程退出，回收其资源\n");
	ret = wait(&status); // 父进程等待子进程退出，回收其资源
	if (-1 == ret)
	{
		perror("wait");
		return 1;
	}

	printf("父进程回收了子进程资源...\n");


	//属于正常退出
	if (WIFEXITED(status))
	{       
		printf("子进程退出状态码: %d\n", WEXITSTATUS(status));
	}
	else if (WIFSIGNALED(status))
	{
                // 通过kill pid或kill -9 pid杀死进程pid
		printf("子进程被信号%d杀死了... \n", WTERMSIG(status));
	}
	else if (WIFSTOPPED(status))
	{
                // 通过kill -19 pid挂起进程，通过kill -18 pid继续运行进程
                // 通过kill -l可查看-18和-19的含义
		printf("子进程被信号%d暂停...\n", WSTOPSIG(status));
	}

	return 0;
}
```

### waitpid函数
waitpid() 可以设置不阻塞，waitpid() 还可以指定等待哪个子进程结束。
函数说明：
```
#include <sys/types.h>
#include <sys/wait.h>
​
pid_t waitpid(pid_t pid, int *status, int options);
功能：
    等待子进程终止，如果子进程终止了，此函数会回收子进程的资源。
​
参数：
    pid : 参数 pid 的值有以下几种类型：
      pid > 0  等待进程 ID 等于 pid 的子进程。
      pid = 0  等待同一个进程组中的任何子进程，如果子进程已经加入了别的进程组，waitpid 不会等待它。
      pid = -1 等待任一子进程，此时 waitpid 和 wait 作用一样。
      pid < -1 等待指定进程组中的任何子进程，这个进程组的 ID 等于 pid 的绝对值。
​
    status : 进程退出时的状态信息。和 wait() 用法一样。
​
    options : options 提供了一些额外的选项来控制 waitpid()。
            0：同 wait()，阻塞父进程，等待子进程退出。
            WNOHANG：没有任何已经结束的子进程，则立即返回。
            WUNTRACED：如果子进程暂停了则此函数马上返回，并且不予以理会子进程的结束状态。（由于涉及到一些跟踪调试方面的知识，加之极少用到）
                 
返回值：
    waitpid() 的返回值比 wait() 稍微复杂一些，一共有 3 种情况：
        1) 当正常返回的时候，waitpid() 返回收集到的已经回收子进程的进程号；
        2) 如果设置了选项 WNOHANG，而调用中 waitpid() 发现没有已退出的子进程可等待，则返回 0；
        3) 如果调用中出错，则返回-1，这时 errno 会被设置成相应的值以指示错误所在，如：当 pid 所对应的子进程不存在，或此进程存在，但不是调用进程的子进程，waitpid() 就会出错返回，这时 errno 被设置为 ECHILD；

 ```

父进程还没运行到wait()或waitpid()，子进程就结束了。接下来父进程运行到wait()或waitpid()时，就会对这个已结束的子进程进行清理，而不是跳过这个已结束的子进程。
]]></description></item><item><title>网络编程常用函数的封装 from 黑马程序员</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/05/08/16245492.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Sun, 08 May 2022 06:03:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/05/08/16245492.html</guid><description><![CDATA[

# 1.socket通信函数的封装
```
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <errno.h>
#include <string.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <strings.h>

void perr_exit(const char *s)
{
	perror(s);
	exit(-1);
}

int Accept(int fd, struct sockaddr *sa, socklen_t *salenptr)
{
	int n;

again:
	if ((n = accept(fd, sa, salenptr)) < 0) {
		if ((errno == ECONNABORTED) || (errno == EINTR))//如果是被信号中断和软件层次中断,不能退出
			goto again;
		else
			perr_exit("accept error");
	}
	return n;
}

int Bind(int fd, const struct sockaddr *sa, socklen_t salen)
{
    int n;

	if ((n = bind(fd, sa, salen)) < 0)
		perr_exit("bind error");

    return n;
}

int Connect(int fd, const struct sockaddr *sa, socklen_t salen)
{
    int n;

	if ((n = connect(fd, sa, salen)) < 0)
		perr_exit("connect error");

    return n;
}

int Listen(int fd, int backlog)
{
    int n;

	if ((n = listen(fd, backlog)) < 0)
		perr_exit("listen error");

    return n;
}

int Socket(int family, int type, int protocol)
{
	int n;

	if ((n = socket(family, type, protocol)) < 0)
		perr_exit("socket error");

	return n;
}
```
问题：为什么信号中断时，就不能终止读取？
由于没有东西可以读时，就会阻塞在那里，但是却由于信号过来了，本进程要中断阻塞状态去处理别的事件。这时候此阻塞状态就会被打断。
所以我们应该让进程处理完中断信号后，继续处于待读数据的阻塞状态。

# 2.黏包
黏包：接收到两个数据包，但是不清楚从哪开始是一个数据包，从哪开始是另一个数据包。
黏包解决方法：
- 约定好，一次发送固定的字节数
- 数据的结尾加一个标记
- 头部加上数据的大小


要实现上述功能，就有必要实现读取固定字节大小的函数，如下所示：
```
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <errno.h>
#include <string.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <strings.h>


// 从fd中读取nbytes个字节，并用ptr指向
ssize_t Read(int fd, void *ptr, size_t nbytes)
{
	ssize_t n;

again:
	if ( (n = read(fd, ptr, nbytes)) == -1) {
		if (errno == EINTR)//如果是被信号中断,不应该退出
			goto again;
		else
			return -1;
	}
	return n;
}

// 向fd中写入nbytes个字节，并用ptr指向带写入数据
ssize_t Write(int fd, const void *ptr, size_t nbytes)
{
	ssize_t n;

again:
	if ( (n = write(fd, ptr, nbytes)) == -1) {
		if (errno == EINTR)
			goto again;
		else
			return -1;
	}
	return n;
}

int Close(int fd)
{
    int n;
	if ((n = close(fd)) == -1)
		perr_exit("close error");

    return n;
}

/*应该读取固定的字节数数据*/
ssize_t Readn(int fd, void *vptr, size_t n)
{
	size_t  nleft;              //usigned int 剩余未读取的字节数
	ssize_t nread;              //int 实际读到的字节数
	char   *ptr;

	ptr = vptr;                // 当前读取的位置
	nleft = n;

	while (nleft > 0) {
		if ((nread = read(fd, ptr, nleft)) < 0) {
			if (errno == EINTR)
				nread = 0;
			else
				return -1;
		} else if (nread == 0)
			break;

		nleft -= nread;
		ptr += nread;
	}
	return n - nleft;
}

/*:固定的字节数数据*/
ssize_t Writen(int fd, const void *vptr, size_t n)
{
	size_t nleft;
	ssize_t nwritten;
	const char *ptr;

	ptr = vptr;
	nleft = n;
	while (nleft > 0) {
		if ( (nwritten = write(fd, ptr, nleft)) <= 0) {
			if (nwritten < 0 && errno == EINTR)
				nwritten = 0;
			else
				return -1;
		}

		nleft -= nwritten;
		ptr += nwritten;
	}
	return n;
}

static ssize_t my_read(int fd, char *ptr)
{
	static int read_cnt;    // 静态的变量初始化为零
	static char *read_ptr;
	static char read_buf[100]; // 一次行读一百个字节，但每次只返回一个字节

	if (read_cnt <= 0) {
again:
		if ( (read_cnt = read(fd, read_buf, sizeof(read_buf))) < 0) {
			if (errno == EINTR)
				goto again;
			return -1;
		} else if (read_cnt == 0) // 当read_cnt为零时，说明fd中无数据，只有一个头部——这说明客户端发送了关闭报文
			return 0;
		read_ptr = read_buf;
	}
	read_cnt--;
	*ptr = *read_ptr++;

	return 1;
}

// 读取一行，即遇到\n就结束
ssize_t Readline(int fd, void *vptr, size_t maxlen) // 读到的数据存储在vptr中
{
	ssize_t n, rc;
	char    c, *ptr;

	ptr = vptr;
	for (n = 1; n < maxlen; n++) {
		if ( (rc = my_read(fd, &c)) == 1) {
			*ptr++ = c;
			if (c  == '\n')
				break;
		} else if (rc == 0) {
			*ptr = 0; 
			return n - 1;
		} else
			return -1;
	}
	*ptr  = 0; // 最后加上个0

	return n;
}
```
# 3.完整代码
头文件wrap.h
```
#ifndef __WRAP_H_
#define __WRAP_H_
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <errno.h>
#include <string.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <strings.h>

void perr_exit(const char *s);
int Accept(int fd, struct sockaddr *sa, socklen_t *salenptr);
int Bind(int fd, const struct sockaddr *sa, socklen_t salen);
int Connect(int fd, const struct sockaddr *sa, socklen_t salen);
int Listen(int fd, int backlog);
int Socket(int family, int type, int protocol);
ssize_t Read(int fd, void *ptr, size_t nbytes);
ssize_t Write(int fd, const void *ptr, size_t nbytes);
int Close(int fd);
ssize_t Readn(int fd, void *vptr, size_t n);
ssize_t Writen(int fd, const void *vptr, size_t n);
ssize_t my_read(int fd, char *ptr);
ssize_t Readline(int fd, void *vptr, size_t maxlen);
int tcp4bind(short port,const char *IP);
#endif
```
wrap.c
```
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <errno.h>
#include <string.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <strings.h>

void perr_exit(const char *s)
{
	perror(s);
	exit(-1);
}

int Accept(int fd, struct sockaddr *sa, socklen_t *salenptr)
{
	int n;

again:
	if ((n = accept(fd, sa, salenptr)) < 0) {
		if ((errno == ECONNABORTED) || (errno == EINTR))//如果是被信号中断和软件层次中断,不能退出
			goto again;
		else
			perr_exit("accept error");
	}
	return n;
}

int Bind(int fd, const struct sockaddr *sa, socklen_t salen)
{
    int n;

	if ((n = bind(fd, sa, salen)) < 0)
		perr_exit("bind error");

    return n;
}

int Connect(int fd, const struct sockaddr *sa, socklen_t salen)
{
    int n;

	if ((n = connect(fd, sa, salen)) < 0)
		perr_exit("connect error");

    return n;
}

int Listen(int fd, int backlog)
{
    int n;

	if ((n = listen(fd, backlog)) < 0)
		perr_exit("listen error");

    return n;
}

int Socket(int family, int type, int protocol)
{
	int n;

	if ((n = socket(family, type, protocol)) < 0)
		perr_exit("socket error");

	return n;
}

ssize_t Read(int fd, void *ptr, size_t nbytes)
{
	ssize_t n;

again:
	if ( (n = read(fd, ptr, nbytes)) == -1) {
		if (errno == EINTR)//如果是被信号中断,不应该退出
			goto again;
		else
			return -1;
	}
	return n;
}

ssize_t Write(int fd, const void *ptr, size_t nbytes)
{
	ssize_t n;

again:
	if ( (n = write(fd, ptr, nbytes)) == -1) {
		if (errno == EINTR)
			goto again;
		else
			return -1;
	}
	return n;
}

int Close(int fd)
{
    int n;
	if ((n = close(fd)) == -1)
		perr_exit("close error");

    return n;
}

/*参三: 应该读取固定的字节数数据*/
ssize_t Readn(int fd, void *vptr, size_t n)
{
	size_t  nleft;              //usigned int 剩余未读取的字节数
	ssize_t nread;              //int 实际读到的字节数
	char   *ptr;

	ptr = vptr;
	nleft = n;

	while (nleft > 0) {
		if ((nread = read(fd, ptr, nleft)) < 0) {
			if (errno == EINTR)
				nread = 0;
			else
				return -1;
		} else if (nread == 0)
			break;

		nleft -= nread;
		ptr += nread;
	}
	return n - nleft;
}
/*:固定的字节数数据*/
ssize_t Writen(int fd, const void *vptr, size_t n)
{
	size_t nleft;
	ssize_t nwritten;
	const char *ptr;

	ptr = vptr;
	nleft = n;
	while (nleft > 0) {
		if ( (nwritten = write(fd, ptr, nleft)) <= 0) {
			if (nwritten < 0 && errno == EINTR)
				nwritten = 0;
			else
				return -1;
		}

		nleft -= nwritten;
		ptr += nwritten;
	}
	return n;
}

static ssize_t my_read(int fd, char *ptr)
{
	static int read_cnt;    // 静态的变量初始化为零
	static char *read_ptr;
	static char read_buf[100]; // 一次行读一百个字节，但每次只返回一个字节

	if (read_cnt <= 0) {
again:
		if ( (read_cnt = read(fd, read_buf, sizeof(read_buf))) < 0) {
			if (errno == EINTR)
				goto again;
			return -1;
		} else if (read_cnt == 0) // 当read_cnt为零时，说明fd中无数据，只有一个头部——这说明客户端发送了关闭报文
			return 0;
		read_ptr = read_buf;
	}
	read_cnt--;
	*ptr = *read_ptr++;

	return 1;
}

// 读取一行，即遇到\n就结束
ssize_t Readline(int fd, void *vptr, size_t maxlen) // 读到的数据存储在vptr中
{
	ssize_t n, rc;
	char    c, *ptr;

	ptr = vptr;
	for (n = 1; n < maxlen; n++) {
		if ( (rc = my_read(fd, &c)) == 1) {
			*ptr++ = c;
			if (c  == '\n')
				break;
		} else if (rc == 0) {
			*ptr = 0; 
			return n - 1;
		} else
			return -1;
	}
	*ptr  = 0; // 最后加上个0

	return n;
}

int tcp4bind(short port,const char *IP)
{
    struct sockaddr_in serv_addr;
    int lfd = Socket(AF_INET,SOCK_STREAM,0);
    bzero(&serv_addr,sizeof(serv_addr));
    if(IP == NULL){
        //如果这样使用 0.0.0.0,任意ip将可以连接
        serv_addr.sin_addr.s_addr = INADDR_ANY;
    }else{
        if(inet_pton(AF_INET,IP,&serv_addr.sin_addr.s_addr) <= 0){
            perror(IP);//转换失败
            exit(1);
        }
    }
    serv_addr.sin_family = AF_INET;
    serv_addr.sin_port   = htons(port);
   // int opt = 1;
	//setsockopt(lfd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

    Bind(lfd,(struct sockaddr *)&serv_addr,sizeof(serv_addr));
    return lfd;
}
```
]]></description></item><item><title>多进程实现并发服务器</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/05/08/16245477.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Sun, 08 May 2022 05:59:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/05/08/16245477.html</guid><description><![CDATA[多进程实现并发服务器流程:
创建套接字lfd
绑定
监听
while(1)
{
    提取连接，使用cfd与客户端进行通信
    fork创建子进程，这时子进程就复制了一份lfd和cfd吗？？
    在子进程中,关闭lfd,服务客户端
    在父进程关闭cfd,回收子进程的资源
}
关闭
根据具体代码修改上面流程。。。。。

子进程退出时，会给父进程发送SIGCHLD信号，此时父进程就可以回收子进程的资源
]]></description></item><item><title>Linux fcntl函数详解</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/05/07/16244318.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Sat, 07 May 2022 14:10:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/05/07/16244318.html</guid><description><![CDATA[fcntl系统调用是控制文件描述符属性的通用POSIX(POSIX是一种通用的规范)方法。
```
//头文件：
#include <unistd.h>    
#include <fcntl.h>

//定义函数：
int fcntl(int fd, int cmd);
int fcntl(int fd, int cmd, long arg);
int fcntl(int fd, int cmd, struct flock * lock);
```
fd：文件描述符
cmd：对fd的操作

# cmd选项

参考：[链接1](http://c.biancheng.net/cpp/html/233.html)
[链接2](https://www.cnblogs.com/xuyh/p/3273082.html)
还没参考，这两写呢.........


close-on-exec, 从字面意思即可理解为：如果对描述符设置了FD_CLOEXEC，在使用execl调用执行的程序里，此描述符将在子进程中会被自动关闭，不能使用了。




# execl函数
```
#include <unistd.h>
#include <fcntl.h>
#include <stdio.h>
#include <sys/types.h>
#include <string.h>

int main(int argc, char *argv[])
{
    // execl函数
    // int execl(const char *pathname, const char *arg, ...

    //  pathname: 要执行的文件的路径（推荐使用绝对路径）
    //  接下来的参数代表执行该文件时传递过去的argv[0], argv[1], ..., 最后一个参数必须用空指针(NULL)作结束.
    //  argv[0]是程序名称，argv[1],...为程序后面所需要跟着的参数

    if (fork() > 0)
    {
        printf("I'm parent process: pid: %d\n", getpid());
        sleep(1);
    }
    else
    {
        // 当前是子进程
        // execl("/mnt/c/Users/x/Pictures/code/lesson14/2", "2", NULL);

        execl("/bin/ps", "ps", "a", "u", "x", NULL);

        printf("I'm child process: %d", getpid());
    }
    for (int i = 0; i < 3; i++)
    {
        printf("i=%d, pid: %d\n", i, getpid());
    }
}

```
这个函数是没有返回值的，因为从调用该函数开始，用户区就被调用的二进制程序给替换掉了，已经不再受我们控制
可以看到在程序运行时，printf("I'm child process: %d", getpid())并没有执行


参考：[链接1](https://blog.csdn.net/ma_de_hao_mei_le/article/details/122952159)
[链接2](http://c.biancheng.net/cpp/html/271.html)]]></description></item><item><title>游双 第九章 I/O复用</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/05/07/16244095.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Sat, 07 May 2022 12:45:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/05/07/16244095.html</guid><description><![CDATA[# 1.select处理带外数据
Linux下实现I/O复用的系统调用主要有select、poll和epoll
select系统调用：在一段指定时间内，监听用户感兴趣的文件描述符上的可读、可写和异常等事件
socket上接收到普通数据和带外数据都将使select返回，但socket处于不同的就绪状态：前者处于可读状态，后者处于异常状态。代码清单9-1描述了select是如何同时处理二者的。
```
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <assert.h>
#include <stdio.h>
#include <unistd.h>
#include <errno.h>
#include <string.h>
#include <fcntl.h>
#include <stdlib.h>

int main(int argc, char* argv[])
{
	if (argc <= 2)
	{
		printf("usage: %s ip_address port_number\n", basename(argv[0]));
		return 1;
	}
	const char* ip = argv[1];
	int port = atoi(argv[2]);
	printf("ip is %s and port is %d\n", ip, port);

	int ret = 0;
	struct sockaddr_in address;
	bzero(&address, sizeof(address));
	address.sin_family = AF_INET;
	inet_pton(AF_INET, ip, &address.sin_addr);
	address.sin_port = htons(port);

	int listenfd = socket(PF_INET, SOCK_STREAM, 0);
	assert(listenfd >= 0);

	ret = bind(listenfd, (struct sockaddr*)&address, sizeof(address));
	assert(ret != -1);

	ret = listen(listenfd, 5);
	assert(ret != -1);

	struct sockaddr_in client_address;
	socklen_t client_addrlength = sizeof(client_address);
	int connfd = accept(listenfd, (struct sockaddr*)&client_address, &client_addrlength);
	if (connfd < 0)
	{
		printf("errno is: %d\n", errno);
		close(listenfd);
	}

	char remote_addr[INET_ADDRSTRLEN];
	printf("connected with ip: %s and port: %d\n", inet_ntop(AF_INET, &client_address.sin_addr, remote_addr, INET_ADDRSTRLEN), ntohs(client_address.sin_port));

	char buf[1024];
	fd_set read_fds;
	fd_set exception_fds;

	// 每次调用select前都要重新在read_fds和exception_fds中设置文件描述符connfd，
	// 因为事件发生之后，文件描述符集合将被内核修改
	FD_ZERO(&read_fds);  // 清除fdset的所有位
	FD_ZERO(&exception_fds);

	int nReuseAddr = 1;
	setsockopt(connfd, SOL_SOCKET, SO_OOBINLINE, &nReuseAddr, sizeof(nReuseAddr));
	while (1)
	{
		memset(buf, '\0', sizeof(buf));
		FD_SET(connfd, &read_fds);
		FD_SET(connfd, &exception_fds);

		ret = select(connfd + 1, &read_fds, NULL, &exception_fds, NULL);
		printf("select one\n");
		if (ret < 0)
		{
			printf("selection failure\n");
			break;
		}

		// 对于可读事件，采用普通的recv函数读取数据
		if (FD_ISSET(connfd, &read_fds))
		{
			ret = recv(connfd, buf, sizeof(buf) - 1, 0);
			if (ret <= 0)
			{
				break;
			}
			printf("get %d bytes of normal data: %s\n", ret, buf);
		}

		// 对于异常事件，采用带MSG_OOB标志的recv函数读取带外数据
		else if (FD_ISSET(connfd, &exception_fds))
		{
			ret = recv(connfd, buf, sizeof(buf) - 1, MSG_OOB);
			if (ret <= 0)
			{
				break;
			}
			printf("get %d bytes of oob data: %s\n", ret, buf);
		}

	}

	close(connfd);
	close(listenfd);
	return 0;
}
```
采用书中代码清单5-6（即[链接](https://www.cnblogs.com/codingbigdog/p/16243321.html)第五节的）来发送外带数据，为什么无法进入else if (FD_ISSET(connfd, &exception_fds))中



# 2. LT和ET模式
这段代码没看懂。。。
```
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <assert.h>
#include <stdio.h>
#include <unistd.h>
#include <errno.h>
#include <string.h>
#include <fcntl.h>
#include <stdlib.h>
#include <sys/epoll.h>
#include <pthread.h>

#define MAX_EVENT_NUMBER 1024
#define BUFFER_SIZE 10

// 将文件描述符设置成非阻塞的
int setnonblocking(int fd)
{
	int old_option = fcntl(fd, F_GETFL); //fcntl()用来操作文件描述词的一些特性.。
										 // F_GETFL 取得文件描述词状态旗标, 此旗标为open()的参数flags.常见的flags为只读只写等
	int new_option = old_option | O_NONBLOCK; // 设置成非阻塞的
	fcntl(fd, F_SETFL, new_option);		 // F_SETFL 设置文件描述词状态旗标, 参数arg 为新旗标, 但只允许O_APPEND、
										// O_NONBLOCK 和O_ASYNC 位的改变, 其他位的改变将不受影响
	return old_option;
}

// 将文件描述符fd上的EPOLLIN注册到epollfd指示的epoll内核事件表中，参数enable_et指定是否对fd启用ET模式
void addfd(int epollfd, int fd, bool enable_et)
{
	epoll_event event;
	event.data.fd = fd;
	event.events = EPOLLIN;
	if (enable_et)
	{
		event.events |= EPOLLET;
	}
	epoll_ctl(epollfd, EPOLL_CTL_ADD, fd, &event);
	setnonblocking(fd);
}

// LT模式的工作流程
void lt(epoll_event* events, int number, int epollfd, int listenfd)
{
	char buf[BUFFER_SIZE];
	for (int i = 0; i < number; i++)
	{
		int sockfd = events[i].data.fd;
		if (sockfd == listenfd)
		{
			struct sockaddr_in client_address;
			socklen_t client_addrlength = sizeof(client_address);
			int connfd = accept(listenfd, (struct sockaddr*)&client_address, &client_addrlength);
			addfd(epollfd, connfd, false);   // 对connfd禁用ET模式
		}
		else if (events[i].events & EPOLLIN)
		{
		// 只要socket读缓存中还有未读出的数据，这段代码就被触发
			printf("event trigger once\n");
			memset(buf, '\0', BUFFER_SIZE);
			int ret = recv(sockfd, buf, BUFFER_SIZE - 1, 0);
			if (ret <= 0)
			{
				close(sockfd);
				continue;
			}
			printf("get %d bytes of content: %s\n", ret, buf);
		}
		else
		{
			printf("something else happened \n");
		}
	}
}

// ET模式的工作流程
void et(epoll_event* events, int number, int epollfd, int listenfd)
{
	char buf[BUFFER_SIZE];
	for (int i = 0; i < number; i++)
	{
		int sockfd = events[i].data.fd;
		if (sockfd == listenfd)
		{
			struct sockaddr_in client_address;
			socklen_t client_addrlength = sizeof(client_address);
			int connfd = accept(listenfd, (struct sockaddr*)&client_address, &client_addrlength);
			addfd(epollfd, connfd, true);
		}
		else if (events[i].events & EPOLLIN)
		{
			printf("event trigger once\n");
			while (1)
			{
				memset(buf, '\0', BUFFER_SIZE);
				int ret = recv(sockfd, buf, BUFFER_SIZE - 1, 0);
				if (ret < 0)
				{
					if ((errno == EAGAIN) || (errno == EWOULDBLOCK))
					{
						printf("read later\n");
						break;
					}
					close(sockfd);
					break;
				}
				else if (ret == 0)
				{
					close(sockfd);
				}
				else
				{
					printf("get %d bytes of content: %s\n", ret, buf);
				}
			}
		}
		else
		{
			printf("something else happened \n");
		}
	}
}

int main(int argc, char* argv[])
{
	if (argc <= 2)
	{
		printf("usage: %s ip_address port_number\n", basename(argv[0]));
		return 1;
	}
	const char* ip = argv[1];
	int port = atoi(argv[2]);

	int ret = 0;
	struct sockaddr_in address;
	bzero(&address, sizeof(address));
	address.sin_family = AF_INET;
	inet_pton(AF_INET, ip, &address.sin_addr);
	address.sin_port = htons(port);

	int listenfd = socket(PF_INET, SOCK_STREAM, 0);
	assert(listenfd >= 0);

	ret = bind(listenfd, (struct sockaddr*)&address, sizeof(address));
	assert(ret != -1);

	ret = listen(listenfd, 5);
	assert(ret != -1);

	epoll_event events[MAX_EVENT_NUMBER];
	int epollfd = epoll_create(5);
	assert(epollfd != -1);
	addfd(epollfd, listenfd, true);

	while (1)
	{
		int ret = epoll_wait(epollfd, events, MAX_EVENT_NUMBER, -1);
		if (ret < 0)
		{
			printf("epoll failure\n");
			break;
		}

		lt(events, ret, epollfd, listenfd);
		//et( events, ret, epollfd, listenfd );
	}

	close(listenfd);
	return 0;
}
```
]]></description></item><item><title>有四篇在简书上还没复制过来。。。。</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/05/07/16243378.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Sat, 07 May 2022 09:20:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/05/07/16243378.html</guid><description><![CDATA[222]]></description></item><item><title>游双的 第6、7、8章</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/05/07/16243326.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Sat, 07 May 2022 09:13:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/05/07/16243326.html</guid><description><![CDATA[第6章 高级I/O函数 && 第7章 Linux服务器程序规范 && 第8章 高性能服务器程序框架
# 1.使用printf发送数据（使用dup将标准IO重定向到socket）
使用printf发送数据
```
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <assert.h>
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <errno.h>
#include <string.h>

int main( int argc, char* argv[] )
{
    if( argc <= 2 )
    {
        printf( "usage: %s ip_address port_number\n", basename( argv[0] ) );
        return 1;
    }
    const char* ip = argv[1];
    int port = atoi( argv[2] );

    struct sockaddr_in address;
    bzero( &address, sizeof( address ) );
    address.sin_family = AF_INET;
    inet_pton( AF_INET, ip, &address.sin_addr );
    address.sin_port = htons( port );

    int sock = socket( PF_INET, SOCK_STREAM, 0 );
    assert( sock >= 0 );

    int ret = bind( sock, ( struct sockaddr* )&address, sizeof( address ) );
    assert( ret != -1 );

    ret = listen( sock, 5 );
    assert( ret != -1 );

    struct sockaddr_in client;
    socklen_t client_addrlength = sizeof( client );
    int connfd = accept( sock, ( struct sockaddr* )&client, &client_addrlength );
    
    if ( connfd < 0 )
    {
        printf( "errno is: %d\n", errno );
    }
    else
    {
        close( STDOUT_FILENO );
        dup( connfd );
        printf( "abcd\n" );
        close( connfd );
    }

    close( sock );
    return 0;
}
```
接收的数据
```
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <assert.h>
#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>

#define BUF_SIZE 1024

int main( int argc, char* argv[] )
{
    if( argc <= 2 )
    {
        printf( "usage: %s ip_address port_number\n", basename( argv[0] ) );
        return 1;
    }
    const char* ip = argv[1];
    int port = atoi( argv[2] );

    struct sockaddr_in server_address;
    bzero( &server_address, sizeof( server_address ) );
    server_address.sin_family = AF_INET;
    inet_pton( AF_INET, ip, &server_address.sin_addr );
    server_address.sin_port = htons( port );

    int sockfd = socket( PF_INET, SOCK_STREAM, 0 );
    assert( sockfd >= 0 ); //如果表达式为假，那么就打印错误并终止程序。assert一般用于调试，可以添加#define NDEBUG 来禁用assert调用
    
    if (  connect( sockfd, ( struct sockaddr* )&server_address,sizeof( server_address ) ) < 0 )
    {
        printf( "connection failed\n" );
    }
    else
    {
        char buffer[ BUF_SIZE ];

        memset( buffer, '\0', BUF_SIZE ); 	// 用来给某一块内存空间进行赋值的
        int ret = recv( sockfd, buffer, BUF_SIZE-1, 0 );
        printf( "got %d bytes of normal data '%s'\n", ret, buffer );
    }

    close( sockfd );
    return 0;
}
```
# 2.readv函数（分散读）和writev函数（集中写）
writev函数将多块分散的内存数据一并写入文件描述符中，在本代码中就是使用writev发送两个字符数组。
```
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <assert.h>
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <errno.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <fcntl.h>
#include<sys/uio.h>

#define BUFFER_SIZE 1024
/*定义两种HTTP状态码和状态信息*/
static const char* status_line[2] = { "200 OK", "500 Internal server error" };

int main( int argc, char* argv[] )
{
    if( argc <= 3 )
    {
        printf( "usage: %s ip_address port_number filename\n", basename( argv[0] ) );
        return 1;
    }
    const char* ip = argv[1];
    int port = atoi( argv[2] );
    const char* file_name = argv[3]; /*将目标文件作为程序的第三个参数传入*/

    struct sockaddr_in address;
    bzero( &address, sizeof( address ) );
    address.sin_family = AF_INET;
    inet_pton( AF_INET, ip, &address.sin_addr );
    address.sin_port = htons( port );

    int sock = socket( PF_INET, SOCK_STREAM, 0 );
    assert( sock >= 0 );

    int ret = bind( sock, ( struct sockaddr* )&address, sizeof( address ) );
    assert( ret != -1 );

    ret = listen( sock, 5 ); // 
    assert( ret != -1 );

    struct sockaddr_in client;
    socklen_t client_addrlength = sizeof( client );
    int connfd = accept( sock, ( struct sockaddr* )&client, &client_addrlength );
    if ( connfd < 0 )
    {
        printf( "errno is: %d\n", errno );
    }
    else
    {
        char header_buf[ BUFFER_SIZE ]; /*用于保存HTTP应答的状态行、头部字段和一个空行的缓存区*/
        memset( header_buf, '\0', BUFFER_SIZE );
        char* file_buf; /*用于存放目标文件内容的应用程序缓存*/
        struct stat file_stat; /*用于获取目标文件的属性，比如是否为目录，文件大小等*/
        			// struct stat这个结构体是用来描述一个linux系统文件系统中的文件属性的结构
        bool valid = true;	/*记录目标文件是否是有效文件*/
        int len = 0;		/*缓存区header_buf目前已经使用了多少字节的空间*/
        if( stat( file_name, &file_stat ) < 0 ) /*目标文件不存在*/ // stat()函数获取file_name文件的属性结构
        {
            valid = false;
        }
        else // 将文件存入一个字符数组中
        {
            if( S_ISDIR( file_stat.st_mode ) ) /*目标文件是一个目录*/
            {
                valid = false;
            }
            else if( file_stat.st_mode & S_IROTH ) /*当前用户有读取目标文件的权限*/
            {
            	/*动态分配缓存区file_buf，并指定其大小为目标文件的大小file_stat.st_size
加1，然后将目标文件读入缓存区file_buf中*/
                int fd = open( file_name, O_RDONLY );
                file_buf = new char [ file_stat.st_size + 1 ];
                memset( file_buf, '\0', file_stat.st_size + 1 );
                if ( read( fd, file_buf, file_stat.st_size ) < 0 ) //将fd指向的文件，存入file_buf中。
                {
                    valid = false;
                }
            }
            else
            {
                valid = false;
            }
        }
        
        if( valid )
        {
  /*下面这部分内容将HTTP应答的状态行、“Content-Length”头部字段和一个空行依次加入header_buf中*/
            ret = snprintf( header_buf, BUFFER_SIZE-1, "%s %s\r\n", "HTTP/1.1", status_line[0] ); //  snprintf将字符串"%s %s\r\n"存入header_buf字符数组中。
            len += ret;
            ret = snprintf( header_buf + len, BUFFER_SIZE-1-len, 
                             "Content-Length: %ld\r\n", file_stat.st_size );
            len += ret;
            ret = snprintf( header_buf + len, BUFFER_SIZE-1-len, "%s", "\r\n" );
          /*利用writev将header_buf和file_buf的内容一并写出*/
            struct iovec iv[2];
            iv[ 0 ].iov_base = header_buf;
            iv[ 0 ].iov_len = strlen( header_buf );
            iv[ 1 ].iov_base = file_buf;
            iv[ 1 ].iov_len = file_stat.st_size;
            ret = writev( connfd, iv, 2 );
        }
        else
        {
            ret = snprintf( header_buf, BUFFER_SIZE-1, "%s %s\r\n", "HTTP/1.1", status_line[1] );
            len += ret;
            ret = snprintf( header_buf + len, BUFFER_SIZE-1-len, "%s", "\r\n" );
            send( connfd, header_buf, strlen( header_buf ), 0 );
        }
        close( connfd );
        delete [] file_buf;
    }

    close( sock );
    return 0;
}
```
Kongming20上输入：./6-2testwritev.out 192.168.154.130 12345 6-2testwritev.cpp
ernest-laptop上输入：telnet 192.168.154.130 12345，ernest-laptop就可以获取到6-2testwritev.cpp的内容
# 3.用sendfile函数传输文件
sendfile函数在两个文件描述符之间直接传递数据（完全在内核中操作），从而避免了内核缓冲区和用户缓冲区之间的数据拷贝，效率很高，这被称为零拷贝。
```
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <assert.h>
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <errno.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/sendfile.h>

int main( int argc, char* argv[] )
{
    if( argc <= 3 )
    {
        printf( "usage: %s ip_address port_number filename\n", basename( argv[0] ) );
        return 1;
    }
    const char* ip = argv[1];
    int port = atoi( argv[2] );
    const char* file_name = argv[3];

    int filefd = open( file_name, O_RDONLY );
    assert( filefd > 0 );
    struct stat stat_buf;
    fstat( filefd, &stat_buf );

    struct sockaddr_in address;
    bzero( &address, sizeof( address ) );
    address.sin_family = AF_INET;
    inet_pton( AF_INET, ip, &address.sin_addr );
    address.sin_port = htons( port );

    int sock = socket( PF_INET, SOCK_STREAM, 0 );
    assert( sock >= 0 );

    int ret = bind( sock, ( struct sockaddr* )&address, sizeof( address ) );
    assert( ret != -1 );

    ret = listen( sock, 5 );
    assert( ret != -1 );

    struct sockaddr_in client;
    socklen_t client_addrlength = sizeof( client );
    int connfd = accept( sock, ( struct sockaddr* )&client, &client_addrlength );
    if ( connfd < 0 )
    {
        printf( "errno is: %d\n", errno );
    }
    else
    {
        sendfile( connfd, filefd, NULL, stat_buf.st_size );
        close( connfd );
    }

    close( sock );
    return 0;
}
```
使用1中的接收数据的代码，即可接收到数据 

# 4.使用splice函数实现的回射服务器
splice函数用于在两个文件描述符之间移动数据，也是零拷贝操作。
```
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <assert.h>
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <errno.h>
#include <string.h>
#include <fcntl.h>

int main( int argc, char* argv[] )
{
    if( argc <= 2 )
    {
        printf( "usage: %s ip_address port_number\n", basename( argv[0] ) );
        return 1;
    }
    const char* ip = argv[1];
    int port = atoi( argv[2] );

    struct sockaddr_in address;
    bzero( &address, sizeof( address ) );
    address.sin_family = AF_INET;
    inet_pton( AF_INET, ip, &address.sin_addr );
    address.sin_port = htons( port );

    int sock = socket( PF_INET, SOCK_STREAM, 0 );
    assert( sock >= 0 );

    int ret = bind( sock, ( struct sockaddr* )&address, sizeof( address ) );
    assert( ret != -1 );

    ret = listen( sock, 5 );
    assert( ret != -1 );

    struct sockaddr_in client;
    socklen_t client_addrlength = sizeof( client );
    int connfd = accept( sock, ( struct sockaddr* )&client, &client_addrlength );
    if ( connfd < 0 )
    {
        printf( "errno is: %d\n", errno );
    }
    else
    {
        int pipefd[2];
        assert( ret != -1 );
        ret = pipe( pipefd ); /*创建管道*/
        /*将connfd上流入的客户数据定向到管道中*/
        ret = splice( connfd, NULL, pipefd[1], NULL, 32768, SPLICE_F_MORE | SPLICE_F_MOVE ); 
        assert( ret != -1 );
        /*将管道的输出定向到connfd客户连接文件描述符*/
        ret = splice( pipefd[0], NULL, connfd, NULL, 32768, SPLICE_F_MORE | SPLICE_F_MOVE );
        assert( ret != -1 );
        close( connfd );
    }

    close( sock );
    return 0;
}
```
Kongming20上输入：./6-4testsplice.out 192.168.154.130 12345
ernest-laptop上输入：telnet 192.168.154.130 12345,然后随便输入一串字符，就可以得到相同字符的返回
# 5.tee函数同时输出数据到终端和文件的程序
tee函数在两个管道文件描述符之间复制数据，也是零拷贝操作。它不消耗数据，因此源文件描述符上的数据仍然可以用于后续的读操作
```
#include <assert.h>
#include <stdio.h>
#include <unistd.h>
#include <errno.h>
#include <string.h>
#include <fcntl.h>

int main( int argc, char* argv[] )
{
	if ( argc != 2 )
	{
		printf( "usage: %s <file>\n", argv[0] );
		return 1;
	}
	int filefd = open( argv[1], O_CREAT | O_WRONLY | O_TRUNC, 0666 );
	assert( filefd > 0 );

	int pipefd_stdout[2];
        int ret = pipe( pipefd_stdout );
	assert( ret != -1 );

	int pipefd_file[2];
        ret = pipe( pipefd_file );
	assert( ret != -1 );

	//close( STDIN_FILENO );
	// dup2( pipefd_stdout[1], STDIN_FILENO );
	//write( pipefd_stdout[1], "abc\n", 4 );
	/*将标准输入内容输入管道pipefd_stdout*/
	ret = splice( STDIN_FILENO, NULL, pipefd_stdout[1], NULL, 32768, SPLICE_F_MORE | SPLICE_F_MOVE );
	assert( ret != -1 );
	/*将管道pipefd_stdout的输出复制到管道pipefd_file的输入端*/
	ret = tee( pipefd_stdout[0], pipefd_file[1], 32768, SPLICE_F_NONBLOCK ); 
	assert( ret != -1 );
	/*将管道pipefd_file的输出定向到文件描述符filefd上，从而将标准输入的内容写入文件*/
	ret = splice( pipefd_file[0], NULL, filefd, NULL, 32768, SPLICE_F_MORE | SPLICE_F_MOVE );
	assert( ret != -1 );
	/*将管道pipefd_stdout的输出定向到标准输出，其内容和写入文件的内容完全一致*/
	ret = splice( pipefd_stdout[0], NULL, STDOUT_FILENO, NULL, 32768, SPLICE_F_MORE | SPLICE_F_MOVE );
	assert( ret != -1 );

	close( filefd );
        close( pipefd_stdout[0] );
        close( pipefd_stdout[1] );
        close( pipefd_file[0] );
        close( pipefd_file[1] );
	return 0;
}
```
本程序数据的流向如下：
首先STDIN_FILENO里的内容被放进管道pipefd_stdout中，此时STDIN_FILENO里的内容就没了，无法再读STDIN_FILENO来获取相同的内容。
然后为了让数据保留在管道pipefd_stdout中以便后续使用，故使用了tee函数将管道pipefd_stdout中的数据复制到管道pipefd_file，再将数据从管道pipefd_file传到 filefd。为什么不直接将管道pipefd_stdout的数据复制到 filefd？答：因为tee只能在两个管道之间复制数据，而filefd不是管道。
最后将保留再管道pipefd_stdout中的数据传到 STDOUT_FILENO

# 6.切换root用户为形参指定用户
```
// 切换root用户为形参指定用户
static bool switch_to_user( uid_t user_id, gid_t gp_id ) // 形参为目标用户ID，为目标组ID
{
    if ( ( user_id == 0 ) && ( gp_id == 0 ) ) // 两个都等于零，代表是root用户
    {
        return false;
    }

    gid_t gid = getgid();
    uid_t uid = getuid();
    if ( ( ( gid != 0 ) || ( uid != 0 ) ) && ( ( gid != gp_id ) || ( uid != user_id ) ) ) // 当前用户如果是root或者目标用户时，就不进入if中。保证当前用户只能是root和目标用户
    {
        return false;
    }
	
    /*由于前面保证了当前用户只能是root和目标用户.如果不是root，则已经是目标用户*/
    if ( uid != 0 ) 
    {
        return true;
    }

    if ( ( setgid( gp_id ) < 0 ) || ( setuid( user_id ) < 0 ) )
    {
        return false;
    }

    return true;
}
```
# 7.守护进程的编写
```
bool daemonize()
{
    /*创建子进程，关闭父进程，这样可以使程序在后台运行*/
    pid_t pid = fork();
    if ( pid < 0 )
    {
        return false;
    }
    else if ( pid > 0 )
    {
        exit( 0 );
    }
    
    /*设置文件权限掩码。当进程创建新文件（使用open(const char*pathname,int flags,mode_t mode)系统调用）时，文件的权限将是mode＆0777*/
    umask( 0 );

    /*创建新的会话，设置本进程为进程组的首领*/
    pid_t sid = setsid();
    if ( sid < 0 )
    {
        return false;
    }

    /*切换工作目录*/
    if ( ( chdir( "/" ) ) < 0 )
    {
        /* Log the failure */
        return false;
    }
    
    /*关闭标准输入设备、标准输出设备和标准错误输出设备*/
    close( STDIN_FILENO );
    close( STDOUT_FILENO );
    close( STDERR_FILENO );
    
    /*关闭其他已经打开的文件描述符，代码省略*/
    /*将标准输入、标准输出和标准错误输出都定向到/dev/null文件*/
    open( "/dev/null", O_RDONLY );
    open( "/dev/null", O_RDWR );
    open( "/dev/null", O_RDWR );
    return true;
}
```
# 8.有限状态机

分析HTTP请求行和头部字段并返回不同的字符串：
本代码HTTP请求的一行（包括请求行和头部字段）为行，每一行都有一对回车(\r)换行(\n)符。
HTTP格式可参考：[HTTP协议格式详解](https://www.jianshu.com/p/8fe93a14754c)。其中Http请求消息结构如下：
![](https://img2022.cnblogs.com/blog/1617829/202205/1617829-20220507171406077-1887215386.png)


```
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
#include <string.h>
#include <fcntl.h>

#define BUFFER_SIZE 4096 /*读缓冲区大小*/
// 主状态机的两种可能状态，分别表示：当前正在分析请求行，当前正在分析头部字段
enum CHECK_STATE { CHECK_STATE_REQUESTLINE = 0, CHECK_STATE_HEADER, CHECK_STATE_CONTENT };
// 从状态机的三种可能状态，即行的读取状态，分别表示：读取到一个完整的行、行出错和行数据尚且不完整
enum LINE_STATUS { LINE_OK = 0, LINE_BAD, LINE_OPEN };
// 服务器处理HTTP请求的结果：
// NO_REQUEST表示请求不完整，需要继续读取客户数据；
// GET_REQUEST表示获得了一个完整的客户请求；
// BAD_REQUEST表示客户请求有语法错误；
// FORBIDDEN_REQUEST表示客户对资源没有足够的访问权限；
// INTERNAL_ERROR表示服务器内部错误；
// CLOSED_CONNECTION表示客户端已经关闭连接了
enum HTTP_CODE { NO_REQUEST, GET_REQUEST, BAD_REQUEST, FORBIDDEN_REQUEST, INTERNAL_ERROR, CLOSED_CONNECTION };
// 为了简化问题，我们没有给客户端发送一个完整的HTTP应答报文，而只是根据服务器的处理结果发送如下成功或失败信息
static const char* szret[] = { "I get a correct result\n", "Something wrong\n" };

// 从状态机:解析一行，得出是否从状态机的状态。
// 从状态机的三种可能状态，即行的读取状态，分别表示：读取到一个完整的行、行出错和行数据尚且不完整
LINE_STATUS parse_line(char* buffer, int& checked_index, int& read_index)
{
	char temp;
	// checked_index指向buffer（应用程序的读缓冲区）中当前正在分析的字节，
	// read_index指向buffer中客户数据的尾部的下一字节。
	// buffer中第0～checked_index字节都已分析完毕，第checked_index～(read_index-1)字节由下面的循环挨
	// 个分析
	for (; checked_index < read_index; ++checked_index)
	{
		// 获得当前要分析的字节
		temp = buffer[checked_index];
		// 如果当前的字节是“\r”，即回车符，则说明可能读取到一个完整的行
		if (temp == '\r')
		{
			// 如果“\r”字符碰巧是目前buffer中的最后一个数据，那么这次分析没有读取到一个完整的行，\r后面应
			// 该还有一个\n，返回LINE_OPEN以表示还需要继续读取客户数据才能进一步分析
			if ((checked_index + 1) == read_index)
			{
				return LINE_OPEN;
			}
			// 如果下一个字符是“\n”，则说明我们成功读取到一个完整的行
			else if (buffer[checked_index + 1] == '\n')
			{
				buffer[checked_index++] = '\0';  // 将\r置为\0
				buffer[checked_index++] = '\0';  //  将\n置为\0
				return LINE_OK;
			}
			// 否则的话，说明客户发送的HTTP请求存在语法问题
			return LINE_BAD;
		}
		// 如果当前的字节是“\n”，即换行符，则也说明可能读取到一个完整的行
		else if (temp == '\n')
		{
			if ((checked_index > 1) && buffer[checked_index - 1] == '\r')
			{
				buffer[checked_index - 1] = '\0';
				buffer[checked_index++] = '\0';
				return LINE_OK;
			}
			return LINE_BAD;
		}
	}
	// 如果所有内容都分析完毕也没遇到“\r”字符，则返回LINE_OPEN，
	// 表示还需要继续读取客户数据才能进一步分析
	return LINE_OPEN;
}

// 分析请求行
HTTP_CODE parse_requestline(char* szTemp, CHECK_STATE& checkstate)
{
	// 如果请求行中没有空格“\t”字符，则HTTP请求必有问题
	char* szURL = strpbrk(szTemp, " \t"); // 返回char指针，指向szTemp中为\t的字符的位置
	if (!szURL)
	{
		return BAD_REQUEST;
	}
	*szURL++ = '\0'; // 将空格置零，然后指针指向下一个字符

	char* szMethod = szTemp;
	if (strcasecmp(szMethod, "GET") == 0)
	{
		printf("The request method is GET\n"); // 仅支持GET方法
	}
	else
	{
		return BAD_REQUEST;
	}

	szURL += strspn(szURL, " \t");   // szURL所指位置为下一个空格。strspn( szURL, " \t" )表示在szURL中找到\t的下标。
	char* szVersion = strpbrk(szURL, " \t");
	if (!szVersion)
	{
		return BAD_REQUEST;
	}
	*szVersion++ = '\0';
	szVersion += strspn(szVersion, " \t");
	if (strcasecmp(szVersion, "HTTP/1.1") != 0)
	{
		return BAD_REQUEST;
	}

	if (strncasecmp(szURL, "http://", 7) == 0)
	{
		szURL += 7;
		szURL = strchr(szURL, '/');    // 检索第一次出现'/'的位置
	}

	if (!szURL || szURL[0] != '/')
	{
		return BAD_REQUEST;
	}

	//URLDecode( szURL );
	printf("The request URL is: %s\n", szURL);
	checkstate = CHECK_STATE_HEADER;
	return NO_REQUEST;
}

// 分析头部字段
HTTP_CODE parse_headers(char* szTemp)
{
	// 遇到一个空行，说明我们得到了一个正确的HTTP请求
	if (szTemp[0] == '\0') // 因为parse_line()将空行（回车换行）都弄成了\0
	{
		return GET_REQUEST;
	}
	else if (strncasecmp(szTemp, "Host:", 5) == 0)   // 处理“HOST”头部字段
	{
		szTemp += 5;    // 跳到Host:之后
		szTemp += strspn(szTemp, " \t");
		printf("the request host is: %s\n", szTemp);
	}
	else // 其他头部字段都不处理
	{
		printf("I can not handle this header\n");
	}

	return NO_REQUEST;
}

// 分析HTTP请求的入口函数
HTTP_CODE parse_content(char* buffer, int& checked_index, CHECK_STATE& checkstate, int& read_index, int& start_line)
{
	LINE_STATUS linestatus = LINE_OK;   // 记录当前行的读取状态
	HTTP_CODE retcode = NO_REQUEST;   // 记录HTTP请求的处理结果
	while ((linestatus = parse_line(buffer, checked_index, read_index)) == LINE_OK) // 主状态机，用于从buffer中取出所有完整的行
	{
		char* szTemp = buffer + start_line;	// start_line是行在buffer中的起始位置
		start_line = checked_index;			// 记录下一行的起始位置
		switch (checkstate)					// checkstate记录主状态机当前的状态
		{
		case CHECK_STATE_REQUESTLINE:		// 第一个状态，分析请求行
		{
			retcode = parse_requestline(szTemp, checkstate);
			if (retcode == BAD_REQUEST)
			{
				return BAD_REQUEST;
			}
			break;
		}
		case CHECK_STATE_HEADER:			// 第二个状态，分析头部字段
		{
			retcode = parse_headers(szTemp);
			if (retcode == BAD_REQUEST)
			{
				return BAD_REQUEST;
			}
			else if (retcode == GET_REQUEST)
			{
				return GET_REQUEST;
			}
			break;
		}
		default:
		{
			return INTERNAL_ERROR;
		}
		}
	}
	if (linestatus == LINE_OPEN)	// 若没有读取到一个完整的行，则表示还需要继续读取客户数据才能进一步分析
	{
		return NO_REQUEST;
	}
	else
	{
		return BAD_REQUEST;
	}
}

int main(int argc, char* argv[])
{
	if (argc <= 2)
	{
		printf("usage: %s ip_address port_number\n", basename(argv[0]));
		return 1;
	}
	const char* ip = argv[1];
	int port = atoi(argv[2]);

	struct sockaddr_in address;
	bzero(&address, sizeof(address));
	address.sin_family = AF_INET;
	inet_pton(AF_INET, ip, &address.sin_addr);
	address.sin_port = htons(port);

	int listenfd = socket(PF_INET, SOCK_STREAM, 0);
	assert(listenfd >= 0);

	int ret = bind(listenfd, (struct sockaddr*)&address, sizeof(address));
	assert(ret != -1);

	ret = listen(listenfd, 5);
	assert(ret != -1);

	struct sockaddr_in client_address;
	socklen_t client_addrlength = sizeof(client_address);
	int fd = accept(listenfd, (struct sockaddr*)&client_address, &client_addrlength);
	if (fd < 0)
	{
		printf("errno is: %d\n", errno);
	}
	else
	{
		char buffer[BUFFER_SIZE];
		memset(buffer, '\0', BUFFER_SIZE);
		int data_read = 0;
		int read_index = 0;
		int checked_index = 0;
		int start_line = 0;
		CHECK_STATE checkstate = CHECK_STATE_REQUESTLINE;
		while (1)
		{
			data_read = recv(fd, buffer + read_index, BUFFER_SIZE - read_index, 0);
			if (data_read == -1)
			{
				printf("reading failed\n");
				break;
			}
			else if (data_read == 0)
			{
				printf("remote client has closed the connection\n");
				break;
			}

			read_index += data_read;
			HTTP_CODE result = parse_content(buffer, checked_index, checkstate, read_index, start_line);
			if (result == NO_REQUEST)
			{
				continue;
			}
			else if (result == GET_REQUEST)
			{
				send(fd, szret[0], strlen(szret[0]), 0);
				break;
			}
			else
			{
				send(fd, szret[1], strlen(szret[1]), 0);
				break;
			}
		}
		close(fd);
	}

	close(listenfd);
	return 0;
}
```
我们前面学习的都是发字符串操作，这就是最有用的操作。网络传输中多数的数据都是以字符串进行传输的，然后再对字符串的内容进行解析得到不同的结果。如图片链接会解析成具体的图片。]]></description></item><item><title>第5章 Linux网络编程基础API</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/05/07/16243321.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Sat, 07 May 2022 09:12:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/05/07/16243321.html</guid><description><![CDATA[其结合《Linux高性能服务器编程 by 游双》进行阅读。
#1.判断机器字节序
```
#include <stdio.h>
void byteorder()
{
	union 
	{
		short value;                            // short占 2 字节
		char union_bytes[ sizeof( short ) ];   // sizeof返回一个对象或者类型所占的内存字节数。char占一个字节
	} test;
	test.value = 0x0102;        // 十六进制，每两位占一个字节
	if (  ( test.union_bytes[ 0 ] == 1 ) && ( test.union_bytes[ 1 ] == 2 ) ) // union_bytes[ 0 ]为低地址，01为高位，故为大端模式
	{
		printf( "big endian\n" );
	}
	else if ( ( test.union_bytes[ 0 ] == 2 ) && ( test.union_bytes[ 1 ] == 1 ) )
	{
		printf( "little endian\n" );
	}
	else
	{
		printf( "unknown...\n" );
	}
}
```
共同体Union和结构体类似。结构体和共用体的区别在于：结构体的各个成员会占用不同的内存，互相之间没有影响；而共用体的所有成员共用同一段内存，修改一个成员会影响其余所有成员。
由于value和union_bytes共用一块内存，所以对value的赋值后，union_bytes访问的就是赋值后的那一部分内存
# 2.点分十进制字符串与网络字节序整数的互相转换
```
#include<iostream>
#include<arpa/inet.h>
using namespace std;
int main(){
    cout<<inet_addr("192.168.2.125")<<endl; // 输出2097326272
    struct in_addr network;
    network.s_addr=2097326272;
    cout<<inet_ntoa(network)<<endl; // 输出192.168.2.125
    return 0; 
}
```
inet_addr函数将用点分十进制字符串表示的IPv4地址转化为用网络字节序整数表示的IPv4地址。它失败时返回INADDR_NONE。
inet_ntoa函数将用网络字节序整数表示的IPv4地址转化为用点分十进制字符串表示的IPv4地址
# 3.服务器开启监听
任务：backlog参数对listen系统调用的影响
```
#include＜sys/socket.h＞
int listen(int sockfd,int backlog);
```
监听队列的长度如果超过backlog，服务器将不受理新的客户连接，客户端也将收到ECONNREFUSED错误信息
```
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <signal.h>
#include <unistd.h>
#include <stdlib.h>
#include <assert.h>
#include <stdio.h>
#include <string.h>

static bool stop = false;
/*SIGTERM信号的处理函数，触发时结束主程序中的循环*/
static void handle_term( int sig )
{
    stop = true;
}

int main( int argc, char* argv[] )
{
    signal( SIGTERM, handle_term );

    if( argc <= 3 )
    {
        printf( "usage: %s ip_address port_number backlog\n", basename( argv[0] ) );
        return 1;
    }
    const char* ip = argv[1];
    int port = atoi( argv[2] );	// 将字符串转换成int
    int backlog = atoi( argv[3] );

    int sock = socket( PF_INET, SOCK_STREAM, 0 );
    assert( sock >= 0 );
    /*创建一个IPv4 socket地址*/
    struct sockaddr_in address;
    bzero( &address, sizeof( address ) ); // 将内存前sizeof(address)个字节清零
    address.sin_family = AF_INET;
    inet_pton( AF_INET, ip, &address.sin_addr ); // 需要将IP转化成网络字节序
    address.sin_port = htons( port );

    int ret = bind( sock, ( struct sockaddr* )&address, sizeof( address ) );
    assert( ret != -1 );
    /*循环等待连接，直到有SIGTERM信号将它中断*/
    ret = listen( sock, backlog );
    assert( ret != -1 );

    while ( ! stop )
    {
        sleep( 1 );
    }

    close( sock );
    return 0;
}
```
argc代表数组argv的元素个数，为int类型。argv的第一个元素argv[0]是可执行程序名称，并且包含程序所在的完整路径。argv的除第一个元素外的其他元素为传入的参数。
argc至少为1，即argv数组至少包含程序名。
netstat -nt|grep 12345 :netstat -nt可查看所有tcp连接信息，包括端口接收和发送的信息的数量、连接双方的地址以及连接所处的状态。grep 12345代表查阅有包含12345的行。
#４.接收连接
```
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <assert.h>
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <errno.h>
#include <string.h>

int main( int argc, char* argv[] )
{
    if( argc <= 2 )
    {
        printf( "usage: %s ip_address port_number\n", basename( argv[0] ) );
        return 1;
    }
    const char* ip = argv[1];
    int port = atoi( argv[2] );

    struct sockaddr_in address;
    bzero( &address, sizeof( address ) );
    address.sin_family = AF_INET;
    inet_pton( AF_INET, ip, &address.sin_addr );
    address.sin_port = htons( port );

    int sock = socket( PF_INET, SOCK_STREAM, 0 );
    assert( sock >= 0 );

    int ret = bind( sock, ( struct sockaddr* )&address, sizeof( address ) );
    assert( ret != -1 );

    ret = listen( sock, 5 );
    assert( ret != -1 );

    struct sockaddr_in client;
    socklen_t client_addrlength = sizeof( client );
    int connfd = accept( sock, ( struct sockaddr* )&client, &client_addrlength );
    if ( connfd < 0 )
    {
        printf( "errno is: %d\n", errno );
    }
    else
    {
        char remote[INET_ADDRSTRLEN ];
        printf( "connected with ip: %s and port: %d\n", 
            inet_ntop( AF_INET, &client.sin_addr, remote, INET_ADDRSTRLEN ), ntohs( client.sin_port ) );
        close( connfd );
    }

    close( sock );
    return 0;
}
```
# 5.发送和接收带外数据
发送带外数据
```
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <assert.h>
#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <stdlib.h>

int main( int argc, char* argv[] )
{
    if( argc <= 2 )
    {
        printf( "usage: %s ip_address port_number\n", basename( argv[0] ) );
        return 1;
    }
    const char* ip = argv[1];
    int port = atoi( argv[2] );

    struct sockaddr_in server_address;
    bzero( &server_address, sizeof( server_address ) );
    server_address.sin_family = AF_INET;
    inet_pton( AF_INET, ip, &server_address.sin_addr );
    server_address.sin_port = htons( port );

    int sockfd = socket( PF_INET, SOCK_STREAM, 0 );
    assert( sockfd >= 0 ); //如果表达式为假，那么就打印错误并终止程序。assert一般用于调试，可以添加#define NDEBUG 来禁用assert调用
    if ( connect( sockfd, ( struct sockaddr* )&server_address, sizeof( server_address ) ) < 0 )
    {
        printf( "connection failed\n" );
    }
    else
    {
        printf( "send oob data out\n" );
        const char* oob_data = "abc";
        const char* normal_data = "123";
        send( sockfd, normal_data, strlen( normal_data ), 0 );
        send( sockfd, oob_data, strlen( oob_data ), MSG_OOB );
        send( sockfd, normal_data, strlen( normal_data ), 0 );
    }

    close( sockfd );
    return 0;
}
```
接收带外数据
```
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <assert.h>
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <errno.h>
#include <string.h>

#define BUF_SIZE 1024

int main( int argc, char* argv[] )
{
    if( argc <= 2 )
    {
        printf( "usage: %s ip_address port_number\n", basename( argv[0] ) );
        return 1;
    }
    const char* ip = argv[1];
    int port = atoi( argv[2] );

    struct sockaddr_in address;
    bzero( &address, sizeof( address ) );
    address.sin_family = AF_INET;
    inet_pton( AF_INET, ip, &address.sin_addr );
    address.sin_port = htons( port );

    int sock = socket( PF_INET, SOCK_STREAM, 0 );
    assert( sock >= 0 );

    int ret = bind( sock, ( struct sockaddr* )&address, sizeof( address ) );
    assert( ret != -1 );

    ret = listen( sock, 5 );
    assert( ret != -1 );

    struct sockaddr_in client;
    socklen_t client_addrlength = sizeof( client );
    int connfd = accept( sock, ( struct sockaddr* )&client, &client_addrlength );
    if ( connfd < 0 )
    {
        printf( "errno is: %d\n", errno );
    }
    else
    {
        char buffer[ BUF_SIZE ];

        memset( buffer, '\0', BUF_SIZE ); 	// 用来给某一块内存空间进行赋值的
        ret = recv( connfd, buffer, BUF_SIZE-1, 0 );
        printf( "got %d bytes of normal data '%s'\n", ret, buffer );

        memset( buffer, '\0', BUF_SIZE );
        ret = recv( connfd, buffer, BUF_SIZE-1, MSG_OOB );
        printf( "got %d bytes of oob data '%s'\n", ret, buffer );

        memset( buffer, '\0', BUF_SIZE );
        ret = recv( connfd, buffer, BUF_SIZE-1, 0 );
        printf( "got %d bytes of normal data '%s'\n", ret, buffer );

        close( connfd );
    }

    close( sock );
    return 0;
}
```
# 6.TIME_WAIT状态立即被重用
使sock处于TIME_WAIT状态，与之绑定的socket地址也可以立即被重用
```
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <assert.h>
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <errno.h>
#include <string.h>

int main( int argc, char* argv[] )
{
    if( argc <= 2 )
    {
        printf( "usage: %s ip_address port_number\n", basename( argv[0] ) );
        return 1;
    }
    const char* ip = argv[1];
    int port = atoi( argv[2] );

    int sock = socket( PF_INET, SOCK_STREAM, 0 );
    assert( sock >= 0 );
    int reuse = 1;
    setsockopt( sock, SOL_SOCKET, SO_REUSEADDR, &reuse, sizeof( reuse ) );

    struct sockaddr_in address;
    bzero( &address, sizeof( address ) );
    address.sin_family = AF_INET;
    inet_pton( AF_INET, ip, &address.sin_addr );
    address.sin_port = htons( port );
    int ret = bind( sock, ( struct sockaddr* )&address, sizeof( address ) );
    assert( ret != -1 );

    ret = listen( sock, 5 );
    assert( ret != -1 );

    struct sockaddr_in client;
    socklen_t client_addrlength = sizeof( client );
    int connfd = accept( sock, ( struct sockaddr* )&client, &client_addrlength );
    if ( connfd < 0 )
    {
        printf( "errno is: %d\n", errno );
    }
    else
    {
        char remote[INET_ADDRSTRLEN ];
        printf( "connected with ip: %s and port: %d\n", 
            inet_ntop( AF_INET, &client.sin_addr, remote, INET_ADDRSTRLEN ), ntohs( client.sin_port ) );
        close( connfd );
    }

    close( sock );
    return 0;
}
```
# 7.tcpdump
tcpdump是命令行形式的抓包工具。可以用wireshark 读取tcpdump 生成的pcap文件，用wireshark的图形化界面分析tcpdump 结果数据。
可参考：[tcpdump详解](https://www.cnblogs.com/111testing/p/13620931.html)
# 8.设置发送和接收缓冲区大小
设置发送缓冲区大小
```
#include <sys/socket.h>
#include <arpa/inet.h>
#include <assert.h>
#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <stdlib.h>

#define BUFFER_SIZE 512

int main( int argc, char* argv[] )
{
    if( argc <= 3 )
    {
        printf( "usage: %s ip_address port_number send_bufer_size\n", basename( argv[0] ) );
        return 1;
    }
    const char* ip = argv[1];
    int port = atoi( argv[2] );

    struct sockaddr_in server_address;
    bzero( &server_address, sizeof( server_address ) );
    server_address.sin_family = AF_INET;
    inet_pton( AF_INET, ip, &server_address.sin_addr );
    server_address.sin_port = htons( port );

    int sock = socket( PF_INET, SOCK_STREAM, 0 );
    assert( sock >= 0 );

    int sendbuf = atoi( argv[3] );
    int len = sizeof( sendbuf );
    /*先设置TCP发送缓冲区的大小，然后立即读取之*/
    setsockopt( sock, SOL_SOCKET, SO_SNDBUF, &sendbuf, sizeof( sendbuf ) );
    getsockopt( sock, SOL_SOCKET, SO_SNDBUF, &sendbuf, ( socklen_t* )&len );
    printf( "the tcp send buffer size after setting is %d\n", sendbuf );

    if ( connect( sock, ( struct sockaddr* )&server_address, sizeof( server_address ) ) != -1 )
    {
        char buffer[ BUFFER_SIZE ];
        memset( buffer, 'a', BUFFER_SIZE );
        send( sock, buffer, BUFFER_SIZE, 0 );
    }

    close( sock );
    return 0;
}
```
设置接受缓存区大小
```
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <assert.h>
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <errno.h>
#include <string.h>

#define BUFFER_SIZE 1024

int main( int argc, char* argv[] )
{
    if( argc <= 3 )
    {
        printf( "usage: %s ip_address port_number receive_buffer_size\n", basename( argv[0] ) );
        return 1;
    }
    const char* ip = argv[1];
    int port = atoi( argv[2] );

    struct sockaddr_in address;
    bzero( &address, sizeof( address ) );
    address.sin_family = AF_INET;
    inet_pton( AF_INET, ip, &address.sin_addr );
    address.sin_port = htons( port );

    int sock = socket( PF_INET, SOCK_STREAM, 0 );
    assert( sock >= 0 );
    int recvbuf = atoi( argv[3] );
    int len = sizeof( recvbuf );
    setsockopt( sock, SOL_SOCKET, SO_RCVBUF, &recvbuf, sizeof( recvbuf ) );
    getsockopt( sock, SOL_SOCKET, SO_RCVBUF, &recvbuf, ( socklen_t* )&len );
    printf( "the receive buffer size after settting is %d\n", recvbuf );

    int ret = bind( sock, ( struct sockaddr* )&address, sizeof( address ) );
    assert( ret != -1 );

    ret = listen( sock, 5 );
    assert( ret != -1 );

    struct sockaddr_in client;
    socklen_t client_addrlength = sizeof( client );
    int connfd = accept( sock, ( struct sockaddr* )&client, &client_addrlength );
    if ( connfd < 0 )
    {
        printf( "errno is: %d\n", errno );
    }
    else
    {
        char buffer[ BUFFER_SIZE ];
        memset( buffer, '\0', BUFFER_SIZE );
        while( recv( connfd, buffer, BUFFER_SIZE-1, 0 ) > 0 ){}
        close( connfd );
    }

    close( sock );
    return 0;
}
```
# 9.通过主机名字获取IP和端口
```
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h>
#include <stdio.h>
#include <unistd.h>
#include <assert.h>

int main( int argc, char *argv[] )
{
	assert( argc == 2 );
	char *host = argv[1];
	
	/*获取目标主机地址信息*/
	struct hostent* hostinfo = gethostbyname( host ); // 从hostinfo可获取IP
	assert( hostinfo );
	/*获取daytime服务信息*/
	struct servent* servinfo = getservbyname( "daytime", "tcp" );  // 从servinfo可获取端口号
	assert( servinfo );
	printf( "daytime port is %d\n", ntohs( servinfo->s_port ) );

	struct sockaddr_in address;
	address.sin_family = AF_INET;
	address.sin_port = servinfo->s_port;
	/*注意下面的代码，因为h_addr_list本身是使用网络字节序的地址列表，所以使用其
	中的IP地址时，无须对目标IP地址转换字节序*/
	address.sin_addr = *( struct in_addr* )*hostinfo->h_addr_list;

	int sockfd = socket( AF_INET, SOCK_STREAM, 0 );
	int result = connect( sockfd, (struct sockaddr* )&address, sizeof( address ) );
	assert( result != -1 );

	char buffer[128];
	result = read( sockfd, buffer, sizeof( buffer ) );
	assert( result > 0 );
	buffer[ result ] = '\0';
	printf( "the day tiem is: %s", buffer );
	close( sockfd );
    return 0;
}
```
]]></description></item><item><title>灵感</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/05/07/16243312.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Sat, 07 May 2022 09:11:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/05/07/16243312.html</guid><description><![CDATA[现在小样本学习都是将特征提取和实现小样本分类分成了两个步骤，这似乎是不对的。


大物体和小物体的区别不就在于像素点的不同，
如果将大物体中的像素点按照一定规则抽取一部分，不就成了小物体。而这个规则可以利用神经网络进行学习。]]></description></item><item><title>pytorch的使用</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/05/07/16243310.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Sat, 07 May 2022 09:10:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/05/07/16243310.html</guid><description><![CDATA[# 1.将数据放入GPU进行计算
```
device = torch.device("cuda:0" if torch.cuda.is_available() else "cpu")  # 选择设备
net = AlexNet(num_classes=5, init_weights=True)
net.to(device)      # 将次此模型指定在ＧＰＵ上运行
# 训练的时候需要将每个batch的图像和和标签都指定到GPU上，如：
outputs = net(images.to(device))
loss = loss_function(outputs, labels.to(device))
# 预测时也需要将每个batch的图像和和标签都指定到GPU上，如：
outputs = net(val_images.to(device))
predict_y = torch.max(outputs, dim=1)[1]
acc += torch.eq(predict_y, val_labels.to(device)).sum().item()
```

# 2. transforms对图像进行变换
```
from torchvision import transforms
data_transform = transforms.Compose([transforms.RandomResizedCrop(224),   
                                     transforms.RandomHorizontalFlip(),
                                     transforms.ToTensor(),
                                     transforms.Normalize((0.5, 0.5, 0.5), (0.5, 0.5, 0.5))]),
```
transforms.Compose()将多个变换进行打包。transforms中有各种各样用于变换的类。

# 3.torch.utils.data.DataLoader加载图片和对图片进行变换
torch.utils.data.DataLoader如下：
```
nw = min([os.cpu_count(), batch_size if batch_size > 1 else 0, 8])  # 使用多线程加载数据。在debug时，一般需要置为0
train_loader = torch.utils.data.DataLoader(dataset=train_dataset,
                                               batch_size=batch_size,         # batch_size代表一次同时喂入的数据
                                               shuffle=True,                         # shuffle=True:打乱数据
                                               num_workers=nw)                 #  num_workers=nw多线程来读数据                                                                               
```
dataset是Map-style datasets和Iterable-style datasets：
**1.Map-style datasets：**
Map-style型的类需要包含\_\_getitem\_\_(self,i)和\_\_len\_\_(self)两个函数。
_\_getitem\_\_(self,i)代表对dataset[i]返回东西的定义。这里要求dataset[i]必须返回图像和标签，即return img,target。Map-style型的类的定义，举例如下：
```
import torch
from PIL import Image
import json
import numpy as np
import torchvision.transforms as transforms
import os
identity = lambda x:x # 传入参数x，return x
class SimpleDataset:
    def __init__(self, data_file, transform, target_transform=identity): # 这都可以是自定义的
        with open(data_file, 'r') as f:
            self.meta = json.load(f)
        self.transform = transform
        self.target_transform = target_transform


    def __getitem__(self,i): #
        image_path = os.path.join(self.meta['image_names'][i])
        # print(image_path)
        img = Image.open(image_path).convert('RGB')
        img = self.transform(img)
        target = self.target_transform(self.meta['image_labels'][i])
        return img, target

    def __len__(self):
        return len(self.meta['image_names'])
```
还有一个常用的包torchvision.datasets.ImageFolder用于导入数据：
```
train_dataset = datasets.ImageFolder(root=os.path.join(image_path, "train"),        # datasets.ImageFolder加载数据集要求目录为类别名
                                         transform=data_transform)
train_dataset.class_to_idx:返回一个字典，key为类名，value为类对应的数字标签
```
ImageFolder返回的是Map-style datasets
从以上可以看出图像的加载和变换一般都是在类的\_\_getitem\_\_中进行的。而\_\_getitem\_\_是通过下标访问数据时（如a[0]）被调用的。
**2.Iterable-style datasets**
暂时没有遇到过，请参加官网[链接](https://pytorch.org/docs/stable/data.html)

# 4.训练网络
## 4.1 一般训练过程
传统的训练函数，一个batch是这么训练的：
```
for i,(images,target) in enumerate(train_loader):
    # 1. input output
    images = images.cuda(non_blocking=True)
    target = torch.from_numpy(np.array(target)).float().cuda(non_blocking=True)
    outputs = model(images)
    loss = criterion(outputs,target)

    # 2. backward
    optimizer.zero_grad()   # reset gradient
    loss.backward()
    optimizer.step()            
```
1.获取loss：输入图像和标签，通过infer计算得到预测值，计算损失函数；
2.optimizer.zero_grad() 清空过往梯度；
3.loss.backward() 反向传播，计算当前梯度；
4.optimizer.step() 根据梯度更新网络参数
## 4.2 变相提高batch的方法
简单的说就是进来一个batch的数据，计算一次梯度，更新一次网络，使用梯度累加是这么写的：
```
for i,(images,target) in enumerate(train_loader):
    # 1. input output
    images = images.cuda(non_blocking=True)
    target = torch.from_numpy(np.array(target)).float().cuda(non_blocking=True)
    outputs = model(images)
    loss = criterion(outputs,target)

    # 2.1 loss regularization
    loss = loss/accumulation_steps   
    # 2.2 back propagation
    loss.backward()
    # 3. update parameters of net
    if((i+1)%accumulation_steps)==0:
        # optimizer the net
        optimizer.step()        # update parameters of net
        optimizer.zero_grad()   # reset gradient
```
1.获取loss：输入图像和标签，通过infer计算得到预测值，计算损失函数；
2.loss.backward() 反向传播，计算当前梯度；
3.多次循环步骤1-2，不清空梯度，使梯度累加在已有梯度上；
4.梯度累加了一定次数后，先optimizer.step() 根据累计的梯度更新网络参数，然后optimizer.zero_grad() 清空过往梯度，为下一波梯度累加做准备；
总结来说：梯度累加就是，每次获取1个batch的数据，计算1次梯度，梯度不清空，不断累加，累加一定次数后，根据累加的梯度更新网络参数，然后清空梯度，进行下一次循环。

一定条件下，batchsize越大训练效果越好，梯度累加则实现了batchsize的变相扩大，如果accumulation_steps为8，则batchsize '变相' 扩大了8倍，是我们这种乞丐实验室解决显存受限的一个不错的trick，使用时需要注意，学习率也要适当放大。
更新1：关于BN是否有影响，之前有人是这么说的：
 As far as I know, batch norm statistics get updated on each forward pass, so no problem if you don't do .backward() every time. 

BN的估算是在forward阶段就已经完成的，并不冲突，只是accumulation_steps=8和真实的batchsize放大八倍相比，效果自然是差一些，毕竟八倍Batchsize的BN估算出来的均值和方差肯定更精准一些。
参考：[链接](https://cloud.tencent.com/developer/article/1700045)
## 4.3 训练的进度条
```
# train_loader是通过torch.utils.data.DataLoader得到的数据
train_bar = tqdm(train_loader)              # tqdm模块是python进度条库．train_bar中的元素每被取出一个进度条就前进一点，当所有元素被取出以后进度条就满了
for step, data in enumerate(train_bar):     # 列表中的每个元素都变成(序号，元素)
    images, labels = data
    optimizer.zero_grad()
    outputs = net(images.to(device))
    loss = loss_function(outputs, labels.to(device))
    loss.backward()
    optimizer.step()

    # print statistics
    running_loss += loss.item()

    train_bar.desc = "train epoch[{}/{}] loss:{:.3f}".format(epoch + 1,
                                                             epochs,
                                                             loss)          # 设置进度条前面的显示的信息
```
## 4.4 关于with torch.no_grad():
在使用pytorch时，并不是所有的操作都需要进行计算图的生成（计算过程的构建，以便梯度反向传播等操作）。而对于tensor的计算操作，默认是要进行计算图的构建的，在这种情况下，可以使用 with torch.no_grad():，强制之后的内容不进行计算图构建。

# 5.卷积
nn.Conv2d(3, 48, kernel_size=11, stride=4, padding=2) 
代表输入的channel为3，输出的channel为48。卷积核为11x11。
其中padding可为int或tuple。padding=2：在周围补两圈零，padding=(1,2)：代表在上下各补一行零，左右两侧各补两列零。还有可以利用nn.ZeroPad2d()补零（自己google）
# 6.模型保存
## 6.1 保存模型的方法
```
# 保存整个模型
torch.save(net, path) # 这样保存可能会保存到确切的目录，导致模型在别的地方不能被加载

# 保存模型参数（推荐）
state_dict = net.state_dict()
torch.save(state_dict , path)
```
torch.save(列表，路径)可以用于保存任何列表，如：
```
import torch
torch.save([1,{"a":1,"b":2},"dsdsds"],'./cache/test.pkl')
```

## 6.2 保存断点继续训练
保存断点
```
checkpoint = {
        "net": model.state_dict(),
        'optimizer':optimizer.state_dict(),
        "epoch": epoch
    }
if not os.path.isdir("./models/checkpoint"):
    os.mkdir("./models/checkpoint")
    torch.save(checkpoint, './models/checkpoint/ckpt_best_%s.pth' %(str(epoch)))
```
将网络训练过程中的网络的权重，优化器的权重保存，以及epoch 保存，便于继续训练恢复
在训练过程中，可以根据自己的需要，每多少代，或者多少epoch保存一次网络参数，便于恢复，提高程序的鲁棒性。

从模型的断点继续训练：
```
start_epoch = -1
 
if RESUME:
    path_checkpoint = "./models/checkpoint/ckpt_best_1.pth"  # 断点路径
    checkpoint = torch.load(path_checkpoint)  # 加载断点
 
    model.load_state_dict(checkpoint['net'])  # 加载模型可学习参数
 
    optimizer.load_state_dict(checkpoint['optimizer'])  # 加载优化器参数
    start_epoch = checkpoint['epoch']  # 设置开始的epoch

for epoch in  range(start_epoch + 1 ,EPOCH):
    # print('EPOCH:',epoch)
    for step, (b_img,b_label) in enumerate(train_loader):
        train_output = model(b_img)
        loss = loss_func(train_output,b_label)
        # losses.append(loss)
        optimizer.zero_grad()
        loss.backward()
        optimizer.step()
```
参考：[链接](https://blog.csdn.net/weixin_35698091/article/details/112429883)
[链接](https://blog.csdn.net/LXYTSOS/article/details/90639524)
## 6.3 模型的可复现性
```
import torch
import random
import numpy as np
 
def set_random_seed(seed = 10,deterministic=False,benchmark=False):
    random.seed(seed)
    np.random(seed)
    torch.manual_seed(seed)
    torch.cuda.manual_seed_all(seed)
    if deterministic:
        torch.backends.cudnn.deterministic = True
    if benchmark:
        torch.backends.cudnn.benchmark = True
```
torch.backends.cudnn.deterministic = True和torch.backends.cudnn.benchmark = True使得每次卷积计算采用的是相同的策略。
设置 torch.backends.cudnn.benchmark=True 将会让程序在开始时花费一点额外时间，为整个网络的每个卷积层搜索最适合它的卷积实现算法，进而实现网络的加速。适用场景是网络结构固定（不是动态变化的），网络的输入形状（包括 batch size，图片大小，输入的通道）是不变的，其实也就是一般情况下都比较适用。反之，如果卷积层的设置一直变化，将会导致程序不停地做优化，反而会耗费更多的时间。
参考：[链接](https://blog.csdn.net/qq_36791000/article/details/121786560)

可变学习率：参考——[链接](https://blog.csdn.net/weixin_35698091/article/details/112429883)
# 7.损失函数
## 7.1.nn.CrossEntropyLoss()
```
torch.nn.CrossEntropyLoss(weight=None, size_average=None, ignore_index=- 100, reduce=None, reduction='mean', label_smoothing=0.0)
```
首先输入预测值和真实值。预测值的size为(minibatch,C)和真实值的size为(minibatch)。这里的C是类别数。
对于一个样本x的损失函数的计算如下：

![](https://img2022.cnblogs.com/blog/1617829/202205/1617829-20220507170914097-414099133.png)


x[class]真实类对应的预测概率。
损失函数中也有权重weight参数设置，若设置权重，则公式为：
![](https://img2022.cnblogs.com/blog/1617829/202205/1617829-20220507170859325-2125068636.png)

当数据不平衡的时候，weight经常被使用。weight是一个1D得tensor，所以weight[class]是一个数。数据不平衡一般指的是存在一些类的样本数很少。如果类class的样本数少一些，那么weight[class]在weight中就会设置的比较大一些。
具体可参见：[链接](https://blog.csdn.net/geter_CS/article/details/84857220)
[链接](https://zhuanlan.zhihu.com/p/159477597)：可知交叉熵就通过求最大化似然估计得到的
官方[链接](https://pytorch.org/docs/stable/generated/torch.nn.CrossEntropyLoss.html)

#其他
1.assert和format的使用
```
 assert os.path.exists(image_path), "{} path does not exist.".format(image_path)
```
2.dict.items以及for的简便使用
```
cla_dict = dict((val, key) for key, val in flower_list.items())  # flower_list为一个字典
```
3.numpy与torch
numpy中有的函数，torch几乎都有对应的函数。所以如果需要对torch数组进行某种操作A时，可以百度numpy操作A。如搜索“numpy判断数组相同”比搜索“torch判断数组相同”，更容易得到想要的结果。]]></description></item><item><title>colab使用</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/05/07/16243295.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Sat, 07 May 2022 09:08:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/05/07/16243295.html</guid><description><![CDATA[基础使用参见[链接](https://blog.csdn.net/qq_36890370/article/details/106160805#commentBox)
注：创建了一个Untitled0.ipynb并装载成功以后，我们就可以在其中输入linux下的命令来运行我们的程序了，命令的前面要加!，这和使用juypter notebook是一样。

友情提醒：如果需要购买Google drive内存的朋友，在网页上好像是不能用国内的银行卡支付的，本人在这个问题上困扰了很久，最后解决的方法是本人在手机上下载了一个Google云端硬盘App,然后利用苹果APP Store绑定的银行卡就可以用国内的银行卡支付啦。
### 想到什么补充什么系列
Google Colab也有一些比较坑的地方，如下：
1.挂载只有12个小时，也就是说12小时之后你就需要重现挂载一次，所以就需要我们在进行模型训练的时候记得要加上checkpoint，不然你如果训练的模型超过12小时，Google断开挂载你就白白浪费12小时啦。
2.每次使用都需要重新配置你上次自己安装的环境，默认环境当然就不用啦。还有就是CUDA和Cudnn不需要重新配置（亲测），我也不知道为什么...欢迎指正。然后给大家安利一个方法，就是独立出一个页面把你要配的环境的代码都写在该页面下，下次打开只需要运行所有单元格就可以再开一个页面来跑你需要跑的程序啦。
3.模型在训练的过程中 有可能会出现连接中断需要重新连接的情况，不要怕点击重新连接就行，如果经常出现推荐给大家一个脚本神器按键精灵，人不在电脑边上只需要F10启动脚本左键点击功能。
4.如果电脑自动关机了，或者是自动更新什么的，只要时间不是很长，你只需要重启，恢复网页还是可以继续训练的，比较训练是挂载在Google上，但是时间久了也就要重新训练了。
5.如果是断网了也只需要联网点击重新连接即可，同上如果断网太久也就只能重新训练了
参考：(链接)[https://zhuanlan.zhihu.com/p/54389036]]]></description></item><item><title>我的计划</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/05/07/16243284.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Sat, 07 May 2022 09:06:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/05/07/16243284.html</guid><description><![CDATA[ # 英语计划
**目标**：听说读写能力、过六级口语和六级
英语适合碎片化的持续学习，不能一下吃成一个胖子

**计划**：
口语：我连最简单的对话都无法完成，故练习各个场景下的常见对话。
背新概念英语第一册，并做相应的笔记[]()
最好每天背五节课以上，并且多听。
**时间：**
早上刚来时，背至少一句。
每次休息时，拿一句来背一背。
休息完毕后，每天拿一篇六级阅读来读读。

#  专业计划
问题：每次可能遇到面试，自己感觉都没有可以拿得出来的东西
**专业知识**：游双、陈硕、复习C++（目标：面试不怕）：每天一早上
**刷leetcode**：中午十一点二十以后、下午五点以后、晚上十点以后
1.从易到难，刷到中等难度基本足以
2.按照数据结构类型来刷，比如一个时间段，只刷链表题，待刷得差不多的时候，接下来再刷二叉树的题

整理华挑所学
微表情检测系统
论文复现与修改（few-shot and zero-shot）：除早上以外的时间。

严格按照番茄时间来学，会比较轻松
早睡早起
## C++
1.学过的东西，很容易就忘。那就因为没有练习，可以通过运行敲代码、做项目、写博客的方式，来加深记忆。
2.举代码例子，来说明知识点。

# 其他
1.严格按番茄计划，可能会学得比较轻松一些。

# 如果再一个星期我就需要找工作，我该怎么办
学游双、看面试的C++题目、刷leetcode

# 自律
1.将自律培养成习惯
2.接收自律失败的自己并改正，只要你行走在路上就是进步。（好的情绪是自律的关键）
方法：
3.如果觉得做这个习惯很困难，那就告诉你自己只坚持先做一点点，做完一点点，看能不能再坚持做一点点，以此类推。
4.完成一个番茄，就在便利贴上打一个勾，让自己的努力可见。
5.冥想：安静坐好，专注呼吸。有利于抵御诱惑。
6.散散步、睡觉、调整放慢呼吸。
只有3和4是现在直接能做的。]]></description></item><item><title>C++工作要求</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/05/07/16243289.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Sat, 07 May 2022 09:06:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/05/07/16243289.html</guid><description><![CDATA[C++基础（最重要）
熟悉linux，熟悉多线程，熟悉常用数据结构和算法，
熟悉网络通信机制，TCP/HTTP/SOCKET等常用协议

附加：
图像方向：
5、图像开发基础，有OpenCV/OpenGL开发经验为佳；
6、底层硬件CPU/GPU加速开发经验优先；
7、有端上CV/CG/AR/ML系统设计开发经验：Lens/SparkAR/MediaPipe/游戏引擎/推理引擎优先

浏览器引擎（Lynx 自渲染引擎）方向：
2. 精通 C++ 研发技术，熟悉 Android / iOS 技术栈；
3. 熟悉计算机图形学及渲染管线相关知识；熟悉 2D 图形库（Skia）或 3D 渲染技术（OpenGL/Vulkan/Metal）者优先
4. 熟悉 Chromium / Flutter 等内核渲染层技术原理者优先；拥有React Native / Weex 或浏览器内核研发经验者优先
3. 熟练掌握C++，精通C++语言基础特性，熟悉C++11/14语法特性；熟悉标准库、Boost及常用C++库；对使用C++进行进/线程间通信、网络通信、内存管理等平台级开发知识有较好掌握；熟练使用C++常用编译及调试工具等。C++开发经验3年以上者为佳；
4. 熟悉移动端（Android或iOS）跨平台开发技术，熟悉Weex / ReactNative等框架实现原理；熟悉Flutter引擎实现原理优先；
5. 熟悉浏览器引擎技术（Chrome，Blink，Servo等），熟悉现代浏览器的DOM构建、管理及表示、渲染架构、CSS实现、排版布局等核心技术优先；
6. 熟悉计算机图形学相关知识，了解OpenGL / Vulkan / Metal 开发的优先，有音视频多媒体处理经验的优先；

其他1：
4.有微软MFC、COM经验者优先；

其他2：
5、熟悉docker、k8s虚拟化环境下的开发、调试、部署及问题排查

其他3：
2、精通C++；有大中型项目Linux后台开发经验(熟悉GDB调试优先)；
4、熟悉Oracle/DB2/MySQL等关系数据库管理、开发，1年以上数据库应用经验；熟悉Redis、FastDB等内存数据库的使用和开发；


qt开发：
2.熟悉MFC/C++软件，
3.熟练掌握SqlServer、Access、Sqlite等相关数据库；
4.熟悉QT软件开发或者LINUX系统开发优先考虑；
5.熟练掌握TCPIP、UDP等网络开发技术；
6.熟悉GPIB、USB、RS232、PXI接口的优先考虑；
7.具有测试自动化开发、ATE系统开发经验的优先考虑。
8.熟练使用Labview软件的优先考虑；


安全方向：
2、熟悉Win程序开发，包括：QT常规界面，多线程、虚拟内存、Hook等技术；
4、有逆向分析或Windows安全产品开发经验的优先。、

网络编程：
5.精通面向对象设计方法和设计模式，逻辑能力佳，熟悉UML设计工具；
6.熟悉TCP/IP、HTTP、WebSocket等协议，熟悉ONVIF、GB28181、SNMP等协议的优先；
7.熟练掌握至少一种数据库pg、Oracle、MySQL,有数据库优化经历者优先；

其他4:
4. 熟悉Linux平台基本使用/常用命令/shell脚本；


其他5：
3.熟悉Redis/HBase/MongoDB/ElasticSearch/Spark/Flink/Faiss/Annoy等，具有任一框架优化经验者更佳；
4.具有底层基础库优化经验者优先，包括但不限于JVM、CPU/GPU、OpenBLAS/MKL等；
5.具有分布式机器学习算法开发经验者优先。



算法：工作内容1、研发前沿计算机视觉, 图像处理, 深度学习算法；2、结合深度学习技术研发计算成像，计算摄影，传感器信号处理等相关产品3、在相关行业进行算法优化与落地。职位要求1、计算机,电子,信息工程等相关专业本科或以上学历, 希望有机器学习,计算机视觉,图像/信号处理相关背景；2、熟悉主流计算机视觉，图像处理算法；3、熟练使用C/C++, python等编程语言, 有编程竞赛获奖经历者优先；4、熟练使用pytorch，tensorflow，caffe等深度学习训练框架；5、有OpenCL，Neon，Hexagon DSP，Cadence DSP等移动端系统优化经验者优先；6、有手机行业, 传感器行业或摄像头行业技术研发类岗位从业经验者优先。]]></description></item><item><title>临时存</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/05/07/16243279.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Sat, 07 May 2022 09:05:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/05/07/16243279.html</guid><description><![CDATA[# 元学习
https://zhuanlan.zhihu.com/p/136975128
李宏毅元学习


# Cosine Normalization: Using Cosine Similarity Instead of Dot Product in Neural Networks
激活函数的输入是前一层的输出和权重的点积。由于点积没有大小限制，所以方差可能太大。而大的方差会对输入的分布比较敏感，这会导致泛化性变差和减慢训练速度。
我们提出了 cosine normalization， cosine normalization使用cosine similarity 或 centered cosine similarity来代替点积。
# Dynamic Few-Shot Visual Learning without Forgetting
在不忘记以前所学类的基础上学会识别更多的类，
To achieve that goal we propose (a) to extend an object recognition system withan attention based few-shot classification weight generator,and (b) to redesign the classifier of a ConvNet model as the cosine similarity function between feature representations
and classification weight vectors. ]]></description></item><item><title>numpy使用</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/05/07/16243270.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Sat, 07 May 2022 09:03:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/05/07/16243270.html</guid><description><![CDATA[# numpy分片中常见的错误：
```
a = np.array([[1,2,3,4],])
a = np.array([[1,2,3,4],[1,2,3,4],[1,2,3,4],[1,2,3,4],[1,2,3,4]])
a[1:3][1:3]    # 代表得到b=a[1:3]，然后再取b[1:3]
Out[5]: array([[1, 2, 3, 4]])
a[1:3,1:3] 
Out[6]: 
array([[2, 3],
       [2, 3]])
```
```
a = np.array([[1,2,3,4],[1,2,3,4],[1,2,3,4],[1,2,3,4],[1,2,3,4]])
a[[1,3],[1,3]]
Out[12]: array([2, 4])
```
结果不是array([[2, 3],
                        [2,3]])]]></description></item><item><title>背新概念第一册</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/05/07/16243262.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Sat, 07 May 2022 09:02:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/05/07/16243262.html</guid><description><![CDATA[1~19.
Is this your shirt
whose shirt is that
get ……back
here is/this is 
what is your job?
what nationality are you?
Catch!
come upstairs and see it
it is **the same color**
**is there**  a problem?
Your passports,please 
what is the matter?
all right=ok，如 are you ok = are you all right?
here you are
2，]]></description></item><item><title>栈、链表</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/05/07/16243256.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Sat, 07 May 2022 09:01:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/05/07/16243256.html</guid><description><![CDATA[# 1.栈
```
// 栈的使用
stack<int> inStack;     // 定义
inStack.top();              // 取栈顶元素
inStack.push(1)          // 元素进栈
inStack.pop();            // 栈顶元素出栈
inStack.empty();        // 判断栈是否为空。为空时，返回true
INT_MAX                  // int类型的最大值。直接可使用，无需引入头文件。如果不能直接使用，则引入头文件#include <limits.h>
INT_MIN
::min(a,b)                         // 取a和b中的较小值。::min代表使用的是类外的函数min。min来自#include <algorithm>
```
##1.1. [用两个栈实现队列](https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/)
思路：
- 进队：元素进入栈inStack
- 出栈：元素从outStack出栈。outStack为空时，将inStack里的元素全部出栈到outStack中，然后元素再从outStack出栈。
```
class CQueue {
private:
    stack<int> inStack, outStack;

    void in2out() {
        while (!inStack.empty()) {
            outStack.push(inStack.top());
            inStack.pop();
        }
    }

public:
    CQueue() {}

    void appendTail(int value) {
        inStack.push(value);
    }

    int deleteHead() {
        if (outStack.empty()) {
            if (inStack.empty()) {
                return -1;
            }
            in2out();
        }
        int value = outStack.top();
        outStack.pop();
        return value;
    }
};
```
##1.2. [包含min函数的栈](https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/)
题目：定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。
思路：每一次stack的入栈，min_stack都会入栈此刻stack中最小的元素，这样使得stack和min_stack大小始终一样大。当stack中的最小元素出栈时，min_stack中的最小元素也会恰好出栈。
```
class MinStack {
    stack<int> x_stack;
    stack<int> min_stack;
public:
    MinStack() {
        min_stack.push(INT_MAX);
    }
    
    void push(int x) {
        x_stack.push(x);
        min_stack.push(::min(min_stack.top(), x));   // ::min代表使用的是类外的函数min。min来自#include <algorithm>
    }
    
    void pop() {
        x_stack.pop();
        min_stack.pop();
    }
    
    int top() {
        return x_stack.top();
    }
    
    int min() {
        return min_stack.top();
    }
};
```
# 2.链表
```
// vector（动态数组）的使用
void push_back(const T& x):向量尾部增加一个元素X
void pop_back():删除向量中最后一个元素
```
题目：输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。
思路：从链头开始进行进栈，然后出栈即可
```
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    vector<int> reversePrint(ListNode* head) {
        /* 根据返回值定义存储结果的变量 */
        vector<int> result;
        /* 因为要反向输出值所以先把数据放入栈立里面然后在拿出来 */
        stack<int> st;
        ListNode* cur = head;
        /* 将数据压入栈 */
        while(cur != NULL) {
            st.push(cur->val);
            cur = cur->next;
        }
        /* 将栈中的数据弹出 利用栈的性质可以反向输出结果 */
        while(!st.empty()) {
            result.push_back(st.top());
            st.pop();
        }
        return result;

    }
};
```

















































From leetcode]]></description></item><item><title>C++ 虚基类、 多继承的构造和析构顺序</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/05/07/16243249.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Sat, 07 May 2022 09:00:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/05/07/16243249.html</guid><description><![CDATA[多继承：子类有两个或两个以上的父类。
多继承的构造函数调用顺序：基类的构造函数，成员对象的构造函数，子类的构造函数。析构函数与此顺序相反


虚基类中的构造和析构顺序]]></description></item><item><title>C++ 拷贝构造函数</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/05/07/16243235.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Sat, 07 May 2022 08:59:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/05/07/16243235.html</guid><description><![CDATA[#1.简介
拷贝构造函数（一种特殊的构造函数）：用一个对象初始化一个新建立的对象。默认拷贝构造函数的功能是把传入的对象的每个数据成员的值依次复制到新建立的对象中。
拷贝构造函数在三种情况下被调用：1）用于用一个对象初始化另一个对象 2）对象作为实参传递给形参 3）作为函数的返回值。举例如下：
```
#include<iostream>
using namespace std;

class Clock {
private:
	int H, M, S;
public:
	Clock(int h = 0, int m = 0, int s = 0) {	// 构造函数 
		H = h, M = m, S = s;
		cout << "constructor:" << H << ":" << M << ":" << S << endl;
	}

	~Clock() {
		cout<<"destructor:" << H << ":" << M << ":" << S << endl;
	}

	// 拷贝构造函数
	Clock(Clock &p) { // 由于一般不修改p，所以Clock(Clock &p)一般写为Clock(const Clock &p)
		H = p.H;
		M = p.M;
		S = p.S;
		cout << "copy constructor,before call:" << H << ":" << M << ":" << S << endl;
	}
};

Clock fun(Clock c) {
	return c;
}

int main() {
	Clock c1(8, 0, 0); // 调用构造函数
	Clock c2(9, 0, 0); // 调用构造函数
	Clock c3(c2); // 等价于Clock c3 =c2;，这里调用拷贝构造函数
	fun(c2); // c2作为实参传入时，调用一次拷贝构造函数。返回Clock对象时，又调用一次拷贝构造函数

	Clock c4;
	c4 = c2;	// c2和c4都是已存在的对象。此时不调用拷贝构造函数

	return 0;
}
```
结果如下：
```
constructor:8:0:0           // Clock c1(8, 0, 0); 输出
constructor:9:0:0           // Clock c2(9, 0, 0);输出
copy constructor,before call:9:0:0      // Clock c3(c2); 输出
copy constructor,before call:9:0:0      // c2作为实参传入fun(c2)时，调用一次拷贝构造函数。
copy constructor,before call:9:0:0      // fun(c2)返回Clock对象时，又调用一次拷贝构造函数
destructor:9:0:0
destructor:9:0:0
constructor:0:0:0          //  Clock c4;输出
```
额外说明：当对象作为函数的返回值时需要调用拷贝构造函数，此时C++将从堆中动态建立一个临时对象，将函数返回的对象复制给该临时对象，并把该临时对象的地址存储到寄存器里，从而由该临时对象完成函数返回值的传递。

# 2.深拷贝构造函数
深拷贝构造函数：默认拷贝构造函数是将一个对象的所有数据成员的值，复制给另一个对象的所有数据成员。但是当数据成员中存在指针时，默认拷贝构造函数只会拷贝地址到另一个对象。这就会导致两个不同的指针指向同一个地址，两个对象中的指针指向同一个内存空间，可能会导致内存的多次释放。
这个时候就需要重写拷贝构造函数来开辟新的内存空间，从而让两个不同的指针指向的地址不同且不同地址中存储的数据是相同的。举例如下：
```
#include <iostream>
using namespace std;

class test {
public:
	char* Str;

	test(const char* str) {
		int a = strlen(str);//改为sizeof就是错的
		Str = new char[a + 1];
	
		strcpy_s(Str, a+1,str); 
	}
	~test() {
		delete[] Str;
		Str = nullptr;
	}
};



int main() {
	test t1("aaaaaaa1"); // 
	test t2(t1);		//  t2.Str指向的地址和t1.Str指向的地址是一样的。

	return 0;
}
```
test t2(t1);使用默认拷贝构造函数，t2.Str指向的地址和t1.Str指向的地址是一样的，假设都指向地址A。那么对象t1和t2都会调用析构函数来释放地址A上的空间，这就会导致重复释放同一个空间，从而导致错误。
重写拷贝构造函数，修改代码为：
```
#include <iostream>
using namespace std;

class test {
public:
	char* Str;

	test(const char* str) {
		int a = strlen(str);//改为sizeof就是错的
		Str = new char[a + 1];
	
		strcpy_s(Str, a+1,str); 
	}
	~test() {
		delete[] Str;
		Str = nullptr;
	}
	test(const test &p) {
		int a = strlen(p.Str);//改为sizeof就是错的
		Str = new char[a + 1];

		strcpy_s(Str, a + 1, p.Str);
	}

	
};

int main() {
	test t1("aaaaaaa1"); // 
	test t2(t1);		// t2,Str指向的地址和t1.Str指向的地址是一样的。

	return 0;
}
```]]></description></item><item><title>C++　友元、虚基类、多态、虚函数</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/05/07/16243244.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Sat, 07 May 2022 08:59:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/05/07/16243244.html</guid><description><![CDATA[本文对友元、虚基类、多态和虚函数四个看起来高大上的概念进行介绍。

# 1.友元
友元：让其他函数（类外函数或者其他类的成员函数）可以访问对象的private和protect类型成员
## 1.1.友元函数
友元函数：在类内定义或声明的一个函数为友元，友元函数中创建的对象可以访问private和protect类型的数据成员。【注】友元函数不属于这个类中的成员函数，而是一个普通的类外函数或者其他类的成员函数。下面举两个实例进行说明：
友元函数为普通的类外函数：
```
#include <iostream>
#include <string>

class A {
private:
	int a;
	void printFun() {
		std::cout << a;
	}
public:
	A() {
		a = 1;
	}
	friend void accessPrivate(A b);  
};
void accessPrivate(A b) {
	b.printFun();
}

int main()
{
	A b = A();
	accessPrivate(b);
}
```
友元函数friend void accessPrivate(A b) 声明在类的任何位置都是可以的，即使声明在private下也可以。不过习惯将友元函数声明在类的最后面。

友元函数为其他类的成员函数：
```
#include <iostream>
#include <string>

class A;

class B {
public:
	void accessPrivate(A A1);  // 使用A，所以前面必须有A的声明
};

class A {
private:
	int a;
	void printFun() {
		std::cout << a;
	}
public:
	A() {
		a = 1;
	}
	friend void B::accessPrivate(A b); 
};

// 由于函数accessPrivate中调用了类A的printFun()函数，
// 所以必须等到类A的函数printFun()声明或定义完成后，
// 函数accessPrivate才能具体进行定义。
void B::accessPrivate(A A1) {  
	A1.printFun();
}


int main()
{
	B B1 = B();
	A A1 = A();
	B1.accessPrivate(A1);
}

```
## 1.2.友元类
友元类：将A声明为B的友元类，那么A的任意成员函数中创建的B类对象b，b都可以访问private和protect类型的数据成员。
``` 
#include <iostream>
#include <string>

class B;

class A {
private:
	int a;
	void printFun() {
		std::cout << a;
	}
public:
	A() {
		a = 1;
	}
	friend class B; 
};

class B {
public:
	void accessPrivate(A A1) {
		A1.printFun();
	}
};

int main()
{
	B B1 = B();
	A A1 = A();
	B1.accessPrivate(A1);
}
```
# 2.二义性问题
## 2.1.间接二义性问题（由虚基类解决）
间接二义性：首先我们知道子类继承父类中成员是将成员复制一份。当B和C都继承了A，然后D又继承了B和C。如果A中有成员a，那么D中就有两个名字相同的a。
虚基类：虚基类就是让当B和C都“虚”继承了A，如果D又继承了B和C。如果A中有成员a，那么D只有一个a。
举例如下：
```
#include<iostream>
using namespace std;

class base {
public:
	base() {
		a = 5; 
		cout << "base=" << a << endl;
	}

protected:
	int a;
};

class base1 :virtual public base {
public:
	base1() { 
		a += 10;
		cout << "base1=" << a << endl;
	}
};

class base2 :virtual public base {
public:
	base2() { 
		a += 20; 
		cout << "base2=" << a << endl; 
	}
};

class derived :public base1, public base2 {
public:
	derived() {
		cout << "derived a =" << a << endl; 
	}
};

int  main()
{
	derived obj;
	return 0;
}
```


## 2.2.多继承的二义性问题

多继承：子类有两个或两个以上的父类。
 二义性问题：多个基类中拥有同名的成员A，子类调用A时编译器无法确定调用的是哪个A。
二义性解决：
1）利用类的作用域分辨符。如Car::show()代表调用了类Car的函数show。
2）派生类中重定义此函数。
 3）将部分基类中的A改名。

# 3.多态
##3.1.多态
多态：假设B和C都继承于基类A，则B和C的对象都可以用基类的对象的指针a进行指向。当a调用方法x时，由于B和C类的方法x的实现是不一样，同样使用a->x得到的效果是不同。多态指的就是：使用相同的代码a->x，却可以根据a具体指向的对象而实现出不同的效果，这个不同的效果就是多态。
举例：
```
#include <iostream> 
using namespace std;

class Shape {
protected:
	int width, height;
public:
	Shape(int a = 0, int b = 0)
	{
		width = a;
		height = b;
	}
	int area()
	{
		cout << "Parent class area :" << endl;
		return 0;
	}
};
class Rectangle : public Shape {
public:
	Rectangle(int a = 0, int b = 0) :Shape(a, b) { }
	int area()
	{
		cout << "Rectangle class area :" << width * height << endl;
		return (width * height);
	}
};
class Triangle : public Shape {
public:
	Triangle(int a = 0, int b = 0) :Shape(a, b) { }
	int area()
	{
		cout << "Triangle class area :" << width * height / 2 << endl;
		return (width * height / 2);
	}
};
// 程序的主函数
int main()
{
	Shape *shape;
	Rectangle rec(10, 7);
	Triangle  tri(10, 5);

	// 存储矩形的地址
	shape = &rec;
	// 调用矩形的求面积函数 area
	shape->area();

	// 存储三角形的地址
	shape = &tri;
	// 调用三角形的求面积函数 area
	shape->area();

	return 0;
}
```
当上面的代码被编译和执行时，它会产生下列结果：
```
Parent class area :
Parent class area :
```
这就说明了shape->area()只调用了基类Shape中的area函数。
导致错误输出的原因是，调用函数 area() 被编译器设置为基类中的版本，这就是所谓的静态多态，或静态链接 - 函数调用在程序执行前就准备好了。有时候这也被称为早绑定，因为 area() 函数在程序编译期间就已经设置好了。
但现在，让我们对程序稍作修改，在 Shape 类中，area() 的声明前放置关键字 virtual，如下所示：
```
#include <iostream> 
using namespace std;

class Shape {
protected:
	int width, height;
public:
	Shape(int a = 0, int b = 0)
	{
		width = a;
		height = b;
	}
	virtual int area()
	{
		cout << "Parent class area :" << endl;
		return 0;
	}
};
class Rectangle : public Shape {
public:
	Rectangle(int a = 0, int b = 0) :Shape(a, b) { }
	int area()
	{
		cout << "Rectangle class area :" << width * height << endl;
		return (width * height);
	}
};
class Triangle : public Shape {
public:
	Triangle(int a = 0, int b = 0) :Shape(a, b) { }
	int area()
	{
		cout << "Triangle class area :" << width * height / 2 << endl;
		return (width * height / 2);
	}
};
// 程序的主函数
int main()
{
	Shape *shape;
	Rectangle rec(10, 7);
	Triangle  tri(10, 5);

	// 存储矩形的地址
	shape = &rec;
	// 调用矩形的求面积函数 area
	shape->area();

	// 存储三角形的地址
	shape = &tri;
	// 调用三角形的求面积函数 area
	shape->area();

	return 0;
}
```
修改后，当编译和执行前面的实例代码时，它会产生以下结果：
```
Rectangle class area :70
Triangle class area :25
```
此时，编译器看的是指针的内容，而不是它的类型。因此，由于 tri 和 rec 类的对象的地址存储在 *shape 中，所以会调用各自的 area() 函数。
#3.2.虚函数
虚函数是在基类中使用关键字 virtual 声明的函数。在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链接到该函数。我们想要的是在程序中任意点可以根据所调用的对象类型来选择调用的函数，这种操作被称为动态链接，或后期绑定。
**纯虚函数：**
您可能想要在基类中定义虚函数，以便在派生类中重新定义该函数更好地适用于对象，但是您在基类中又不能对虚函数给出有意义的实现，这个时候就会用到纯虚函数。
我们可以把基类中的虚函数 area() 改写如下：
```
class Shape {
   protected:
      int width, height;
   public:
      Shape( int a=0, int b=0)
      {
         width = a;
         height = b;
      }
      // pure virtual function
      virtual int area() = 0;
};
```
= 0 告诉编译器，函数没有主体，上面的虚函数是纯虚函数。


[菜鸟教程](https://www.runoob.com/cplusplus/cpp-polymorphism.html)还有七篇笔记没看，我先去睡觉，以后再看。。。。。。

参考：[菜鸟教程](https://www.runoob.com/cplusplus/cpp-polymorphism.html)
C++语言程序设计教程 第3版  沈显君 
]]></description></item><item><title>C++操作符重载</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/05/07/16243232.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Sat, 07 May 2022 08:58:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/05/07/16243232.html</guid><description><![CDATA[操作符重载：定义用操作符来操作对象时所产生的效果，如定义用加号来操作对象时所产生的效果（加法的重载）：
```
#include <iostream>
using namespace std;

class complex
{
public:
	complex(double a, double b);
	complex operator+(const complex & A)const;

	void display()const;
private:
	double real;   //复数的实部
	double imag;   //复数的虚部
};


complex::complex(double a, double b)
{
	real = a;
	imag = b;
}

//打印复数
void complex::display()const
{
	cout << real << " + " << imag << " i ";
}

//重载加法操作符
complex complex::operator+(const complex & A)const
{
	complex B(0,0);
	B.real = real + A.real;
	B.imag = imag + A.imag;
	return B;
}


int main()
{
	complex c1(4.3, -5.8);
	complex c2(8.4, 6.7);
	complex c3(0,0);

	//复数的加法
	c3 = c1 + c2;
	cout << "c1 + c2 = ";
	c3.display();
	cout << endl;

	return 0;
}
```]]></description></item><item><title>C++ inline</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/05/07/16243219.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Sat, 07 May 2022 08:57:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/05/07/16243219.html</guid><description><![CDATA[## 1.1.函数与inline
将函数替换成函数中具体的表达式，从而防止使用太多的函数而导致栈溢出。【栈空间就是指放置程序的局部数据（也就是函数内数据）的内存空间】
```
#include <stdio.h>
 
inline const char *num_check(int v)
{
    return (v % 2 > 0) ? "奇" : "偶";
}
 
int main(void)
{
    int i;
    for (i = 0; i < 100; i++)
        printf("%02d   %s\n", i, num_check(i));
    return 0;
}
```
内部任何调用 num_check(i)的地方都换成了 (v % 2 > 0) ? "奇" : "偶"，这样就避免了频繁调用函数对栈内存重复开辟所带来的消耗。

【注】
- inline 函数体内的代码一般是**简单**的，不能包含复杂的结构控制语句例如 while、switch，并且不能内联函数本身不能是直接递归函数（即，自己内部还调用自己的函数）。仅当函数体内包含常量开销O(1)的简单语句才使用inline关键字修饰成员函数
- inline 函数仅仅是一个**对编译器的建议**，如果编译器认为该函数过长，通常是O(n)级以上的消耗，编译器会忽略该请求。
- inline的问题：1.如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。2.另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。

使用inline的原因：1.防止栈溢出 2.函数切换时间相对于函数执行时间太大。

## 1.2.类中的成员函数与inline
定义在类中的成员函数默认都是内联的，如果在类定义时就在类内给出函数定义，那当然最好。如果在类中未给出成员函数定义，而又想内联该函数的话，那在类外要加上 inline，否则就认为不是内联的。
```
// 头文件
class A
{
    public:
    void Foo(int x, int y);
}
 
// 定义文件
inline void A::Foo(int x, int y){}
```
 值得注意的是： 如果在类体外定义inline函数，则必须将类定义和成员函数的定义都放在同一个头文件中(或者写在同一个源文件中)，否则编译时无法进行置换(将函数代码的拷贝嵌入到函数调用点)。 但是这样做，不利于类的接口与类的实现分离，不利于信息隐蔽。虽然程序的执行效率提高了，但从软件工程质量的角度来看，这样做并不是好的办法。只有在类外定义的成员函数规模很小而调用频率较高时，才将此成员函数指定为内置函数。
【[C++ 中的 inline 用法](https://www.runoob.com/w3cnote/cpp-inline-usage.html)中为什么说类中声明函数，类外使用内联函数，是比较好的编程习惯？这不是脱裤子放屁吗？直接在类中定义不就行了？】
【”定义在类中的成员函数默认都是内联的“这句话是什么意思？】

参考：[C++ 中的 inline 用法](https://www.runoob.com/w3cnote/cpp-inline-usage.html)
]]></description></item><item><title>C++　模板</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/05/07/16243223.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Sat, 07 May 2022 08:57:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/05/07/16243223.html</guid><description><![CDATA[#　1.模板
模版分为：类模版、函数模版、成员模板。
## 1.1.类模板
用一个实例进行说明：
```
template<typename T>	// 类模板，
class complex{
private:
    T re, im;	// 模板
    friend complex& __doap1 (complex *ths, const complex& r); 	// 友元函数

public:
    complex(T r = 0, T i = 0) : re(r), im(i){}	// 默认参数、初始化列表
    complex& operate+=(const complex&);	// 重载运算符
    T real() const { return re; }		// 成员函数-常函数
    T imag() const { return im; }
};

int main(){
    complex<double> c1(1.1, 2.2);
    complex<int> c2(3, 4);
}
```
在类complex的定义前，加一个template<typename T>：代表数据类型T是在声明对象的时候指定的，如complex<double> c1(1.1, 2.2);指定了T为double类型。
注：template<typename T>有时也写成template<class T>，它们是一样的，只是早期一般使用template<class T>。


## 1.2. 函数模板
用一个实例进行说明：
```
#include <iostream>

// 函数模板
template<class T>
inline T& min(T& a,  T& b) {
	return b < a ? b : a;	// 运算符< 可被重载
}

class stone {
	private:
		int _w, _h, _weight;
	public:
		stone(int w, int h, int we) : _w(w), _h(h), _weight(we) {}
		// 重载运算符<
		bool operator <(const stone& rhs) {
			return this->_weight < rhs._weight;
		}

		int getWeight() {
			return _weight;
		}
};

int main() {
	stone r1(2, 3,5), r2(3, 3,1);
	// 调用模板函数min，类型推导
	// 类型推导T为stone类型，进一步调用stone::operator<()
	stone r3 = min(r1, r2);
	std::cout << r3.getWeight();

	return 0;
}
```
注：函数模板使用时，不必显式指定具体的泛型类型。编译器会对函数模板进行实参推导/类型推导（argument deduction）。类模板使用时，需显式指定具体的泛型类型。


## 1.3.成员模版
成员模板：类模板中的成员函数也为模板。举例如下：
```
template <typename T>
 
class A {
public:
  template <typename U>
  void assign(const D<U>& u)
  {
    v = u.getvalue();
  }
  
  T getvalue()
  {
    return v;
  }
private:
  T v;
}
```
【注】成员模板不能是virtual

模板构造函数：一种特殊的成员模板
```
#include <iostream>

template <typename T>
class A
{
public:
	template <typename U>
	A(const U& a) {
		std::cout << "template constructor" << std::endl;
	}

	A(const A& a) {
		std::cout << "copy constructor" << std::endl;
	}
	A() {
		std::cout << "default constructor" << std::endl;
	}
};

int main() {
	A<int> i; // default constructor
	A<int> ii(i); // implicitly generated copy constructor
	A<double> d(i); // template constructor

	std::cin.get();
	return 0;
}
```
结果为：
```
default constructor
copy constructor
template constructor
```
由于ii和i的类型是一样的，所以调用类A<int>的拷贝构造函数A(const A& a) 对ii进行初始化。
由于d和i的类型是不一样的，所以调用A<double>的模板构造函数 A(const U& a) 来对d进行初始化。其中U的类型为A<int>。这就相当于A<double> d(i)就实现了用类A<int>初始化类A<double>，也就是说实现了隐式的类型转换。
”ii和i的类型是一样时，调用类A<int>的拷贝构造函数对ii进行初始化“，这就说明了A<int> ii(i)没有调用模板构造函数 A(const U& a) ，而是调用了拷贝构造函数A(const A& a)。也就是说模板构造函数 A(const U& a)没有覆盖掉拷贝构造函数A(const A& a)的作用。

参考：[链接1](https://blog.csdn.net/luoshabugui/article/details/104619151)
]]></description></item><item><title>W3Cschool:C++ Web 编程</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/05/07/16243212.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Sat, 07 May 2022 08:55:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/05/07/16243212.html</guid><description><![CDATA[# 1.CGI简介
##　1.1.简介和环境配置
公共网关接口（CGI），是一套标准，定义了信息是如何在 Web 服务器和客户端脚本之间进行交换的。CGI 程序包括网络通信的客户端和服务器。CGI 程序可以用 Python、PERL、Shell、C 或 C++ 等进行编写。
Apache（音译为阿帕奇）是世界使用排名第一的Web服务器软件

参考[CGI环境配置（Ubuntu）](https://www.cnblogs.com/paopaolx/p/14275964.html)，进行CGI环境配置。如果出现问题，建议重头再试来一遍。
C++的可执行文件放在/var/www/html/cgi-bin/目录下。除了C++的可执行文件外，/var/www/html/cgi-bin/目录下还可以存放各种各样的脚本程序。
## 1.2.第一个 CGI 程序：
在/var/www/html/cgi-bin/目录创建helloworld.cpp为文件，文件内容如下：
```
#include <iostream>
using namespace std;
 
int main ()
{
    
   cout << "Content-type:text/html\r\n\r\n";    cout << "<html>\n";
   cout << "<head>\n";
   cout << "<title>Hello World - 第一个 CGI 程序</title>\n";
   cout << "</head>\n";
   cout << "<body>\n";
   cout << "<h2>Hello World! 这是我的第一个 CGI 程序</h2>\n";
   cout << "</body>\n";
   cout << "</html>\n";
   
   return 0;
}
```
编译helloworld.cpp，并给可执行文件helloworld.cgi赋予相关权限：
```
gcc helloworld.cpp -o helloworld.cgi
chmod 755 helloworld.cgi
```

## 1.3.HTTP 头信息：
![](https://img2022.cnblogs.com/blog/1617829/202205/1617829-20220507165352832-1019616633.png)


## 1.4.CGI 环境变量
![](https://img2022.cnblogs.com/blog/1617829/202205/1617829-20220507165407514-205275549.png)

所有的 CGI 程序都可以访问下列的环境变量。这些变量在编写 CGI 程序时扮演了非常重要的角色。


# 2.C++ CGI 库的使用
## 2.1.安装 CGI 库
这个cgicc库，似乎是个几百年前的库，感觉现在学，没有什么意义。







参考：[C++ Web 编程](https://www.w3cschool.cn/cpp/cpp-web-programming.html)·]]></description></item><item><title>STL的总结</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/05/07/16243199.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Sat, 07 May 2022 08:53:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/05/07/16243199.html</guid><description><![CDATA[请先看[这个](https://www.jianshu.com/p/29359030ef03)，然后再看本文
# 0.简介

容器的概念：容器就是类模板，此类模板是用来生成不同数据类型下的数据结构，如生成int型栈、char型栈等。容器是个类肯定包含对数据结构的操作，如进栈、出栈、获取栈中元素个数等。
容器一般都在命名空间std中，所以在#include<容器名>后， 一般还需要写using namespace std;


# 1.容器中一般都拥有的函数
容器中一般拥有以下的函数：
以下函数的具体使用直接参考[官方](http://www.cplusplus.com/reference/stl/)提供的代码实例，就可以很容易使用。
iterators：指向第一个元素和最后一个元素的 iterator，如begin、end、rbegin、rend等
size：元素个数、empty：是否为空
max_size： 容器的成员函数max_size()取得 STL容器的capacity属性，表示STL在发生realloc前能允许的最大元素数，也可以理解为预分配的内存空间。 例如一个vector<int> v的capacity为5，当插入第6个元素时，vector会realloc，vector内部数据会复制到另外一个内存区域。
front和back：返回第一个元素和最后一个元素
pop_front和pop_back：弹出第一个或最后一个元素
erase：擦除对应位置上的元素
swap：将两个对象的值进行交换
resize：通过删除后面的元素和增加零（或增加指定元素），来使对象中的元素变为指定大小
clear：清空对象
insert：在迭代器指向的位置插入元素
splice：将一个对象A中的连续的多个元素插入到另一个对象B中，此时这些元素在A中被删除。
remove：移除特定值的元素、remove_if移除满足条件的元素
unique：移除重复元素，或移除满足条件的元素
reverse：翻转元素顺序
merge：拼接已经排序好的两个对象时，输出的还是排序好的对象。拼接的两个对象其中有一或两个未排序好，则直接将两个对象拼接在一起。可以按指定条件拼接两个对象。
sort：将元素进行排序。除了容器本身带有的sort函数，我们还可以使用全局的::sort来实现排序。但是如果容器自带sort，使用自带的最好；如果容器没有自带sort，再使用全局的::sort。
assign：用于给容器分配元素，相当于初始化对象。
#　2.list
list（双向链表）：每个元素均有指针指向前一个元素和下一个元素（快速 插入或删除）。list 容器中的元素可以分散存储在内存空间里，而不是必须存储在一整块连续的内存空间中。不可通过[]访问元素（快速查找）。可使用push_back、pop_back、push_front、pop_front
```
#include <iostream>
#include <list>
using namespace std;
int main()
{	
	// 初始化list
	//std::list<double> values;  //创建空的 list 容器
	std::list<double> values(10, 5); // 创建了一个包含 10 个元素并且值都为 5 个 values 容器。

	//拷贝普通数组，创建list容器
	//int a[] = { 1,2,3,4,5 };
	//std::list<int> values(a, a + 5);

	//拷贝其它类型的容器，创建 list 容器
	//std::array<int, 5>arr{ 11,12,13,14,15 };
	//std::list<int>values(arr.begin() + 2, arr.end());//拷贝arr容器中的{13,14,15}

	//向容器中添加元素
	values.push_back(3.1);  // 也可使用push_front()在双向链表的前面添加元素
	values.push_back(2.2);
	cout << "values size：" << values.size() << endl;
	//对容器中的元素进行排序
	values.sort();
	//使用迭代器顺序输出list容器中的元素（不知道为什么这个才是顺序输出）
	for (std::list<double>::iterator it = values.end(); it != values.begin();) {
		std::cout << *(--it) << " ";
	}
	cout << std::endl;
	//使用迭代器倒序输出list容器中的元素
	for (std::list<double>::iterator it = values.begin(); it != values.end();++it) {
		std::cout << *it << " ";
	}
	return 0;
}
```


list是双向链表，那指向上一元素和下一个元素的指针是什么？？答：似乎没有提供这样的指针，只能使用迭代器进行访问。也就是说list是双向链表是指它的存储的采用的是双向链表的方式，从而让list 容器中的元素可以分散存储在内存空间里.
参考：[C++ list（STL list）容器完全攻略（超级详细）](http://c.biancheng.net/view/6892.html)
[c++官方STL手册](http://www.cplusplus.com/reference/stl/)

# 3.stack
stack和queue是不允许使用迭代器iterator，因为这会破坏栈和队列访问元素的特性。
```
// 栈的使用
stack<int> inStack;     // 定义
inStack.top();              // 取栈顶元素
inStack.push(1)          // 元素进栈
inStack.pop();            // 栈顶元素出栈
inStack.empty();        // 判断栈是否为空。为空时，返回true
```
# 4.vector
```
// vector（动态数组）的使用
void push_back(const T& x):向量尾部增加一个元素X
void pop_back():删除向量中最后一个元素
```
vector不可使用push_front和pop_front
![](https://img2022.cnblogs.com/blog/1617829/202205/1617829-20220507165055942-864464924.png)


# 5.deque（双端队列）
给vector分配的总空间都是2的整数倍。当扩充vector类型的数据时，如果发现空间不够，就会将数据搬移到一个更大的空间中去。新的空间大小是旧的空间的小的$2^n$倍（根据扩充的数据多少，选择最小的n）。在使用vector类型数据的时候，每次空间不够都需要将空间进行翻倍，这就会导致分配的空间可能有冗余，即有些空间没有被用。
deque（双端队列）：与vector类似，这里的双端指的是可以从数组的两端插入数据。从前端或后端以push_front()或push_back()添加元素。在增加数据元素时,如果deque容器内原先定义的内存空间不足,deque容器会将新增加的数据元素存储到另外一块内存中。可通过[]访问元素（快速查找）




# 6.map以及迭代器的使用
## 6.1.插入、查看、删除
map就是用来保存键值对的，即<key,value>。
元素的插入、查看、删除。这里我们以一个实际可运行的程序，进行说明，以便以后进行参考和使用。
```
#include<map>  //注意，STL头文件没有扩展名.h
#include<iostream>
#include<string>
using namespace std;

int main() {
	map<int, string> mapStudent;

	// 插入元素的三种方法
	// mapStudent.insert(pair<int, string>(0, "student_zero"));		// 不用纠结pair是什么，反正它就是这么写的
	// mapStudent.insert(map<int, string>::value_type(0,"student_zero"));
	mapStudent[0] = "student_zero";
	
	// 当使用insert插入的<key,value>时，mapStudent已经存在key了。此时insert不会生效
	pair<map<int, string>::iterator, bool> Insert_Pair;			// 接收插入失败的信息
	Insert_Pair = mapStudent.insert(map<int, string>::value_type(0, "student_one"));
	if (!Insert_Pair.second)
		cout << "Error insert new element" << endl;
	// mapStudent[0] = "student_one"; // 覆盖<0,"student_zero">为<0,"student_one">


	// 访问元素的两种方法
	//map<int,string>::iterator iter=  mapStudent.find(0);		// 使用迭代器访问元素
	//cout <<iter->first<<endl;		// 输出0
	//cout << iter->second << endl;    // 输出student_zero
	cout << mapStudent[0]<<endl;			// 数组方式访问元素。输出student_zero

	
	mapStudent[1] = "student_one";		// 插入新元素

	// 使用迭代器访问mapStudent中的所有元素
	map<int, string>::iterator iter;
	cout << "删除前" << endl;
	for (iter = mapStudent.begin(); iter != mapStudent.end(); iter++){
		cout << "iter->first:" << iter->first << "iter->second:" << iter->second << endl;
	}
		
	//int n =  mapStudent.erase(1);	// 删除key为1的元素。如果刪除了會返回1，否則返回0
	mapStudent.erase(mapStudent.begin(), mapStudent.end());//用迭代器范围刪除 : 把整个map清空
	cout << "删除后" << endl;
	for (iter = mapStudent.begin(); iter != mapStudent.end(); iter++) {
		cout << "iter->first:" << iter->first << "iter->second:" << iter->second << endl;
	}

	return 0;
}
```
pair的作用就是将两种类型包装成一个整体，具体可参考[链接](https://blog.csdn.net/sevenjoin/article/details/81937695)
## 6.2.map的操作函数总结
     C++ map是一种关联式容器，包含“关键字/值”对
     begin()         返回指向map头部的迭代器
     clear(）        删除所有元素
     count()         返回指定元素出现的次数, (帮助评论区理解： 因为key值不会重复，所以只能是1 or 0)
     empty()         如果map为空则返回true
     end()           返回指向map末尾的迭代器
     equal_range()   返回特殊条目的迭代器对
     erase()         删除一个元素
     find()          查找一个元素
     get_allocator() 返回map的配置器
     insert()        插入元素
     key_comp()      返回比较元素key的函数
     lower_bound()   返回键值>=给定元素的第一个位置
     max_size()      返回可以容纳的最大元素个数
     rbegin()        返回一个指向map尾部的逆向迭代器
     rend()          返回一个指向map头部的逆向迭代器
     size()          返回map中元素的个数
     swap()           交换两个map
     upper_bound()    返回键值>给定元素的第一个位置
     value_comp()     返回比较元素value的函数

## 6.3.map与vector的深拷贝
map1=map2和vec1 = vec2进行的就是深拷贝，vec1和vec2之间就没有关联，map1和map2之间就没有关联


#7.迭代器
迭代器：一种通用的方法访问具有不同结构的各种容器中的每个元素，是广义的指针。每种容器定义自己的迭代器，如list<T>::iterator、vector<T>::iterator

迭代器++是找到下一个元素，迭代器－－是找到上一个元素。
在双向链表list中，我们可以知道下一个元素就是next所指元素，上一个元素就是prev所指元素。list的迭代器的++操作，就会访问list节点对应的next指针。也就是说list的迭代器的++与指针的++不一样，后者只是地址的增加，而迭代器会根据具体的容器类型执行不同的“++”操作，迭代器是相当于一个智能指针。

其他三种迭代器：reverse_iterator（用于反向遍历）,const_iterator（返回一个常数值）,const_reverse_iterator

#8.操作容器的通用函数
操作容器的通用函数在<algorithm>头文件中定义，以函数模板的形式给出，使用迭代器对数据进行访问。
如果容器有自带某种函数，那么优先使用自带的。如：对于vector对象a，可使用a.sort()进行排序，就不要使用<algorithm>中的sort进行排序。



#其他
**1.emplace、emplace_front、emplace_back和push、push_front、push_back的区别：**
```
S.push(data(1,2));
S.emplce(data(1,2)); // push可以怎么使用，emplace就可以怎么使用。反之，不行。
S.emplce(1,2);  // 与S.emplce(data(1,2));等价，但是由于没有创建data(1,2)所以就节省了内存
```
注意：emplace_back(type) 对应 push_back(type)
emplace(i, type) 对应于 insert(type, i)
emplace_front(type) 对应于 push_front()
但是！对于stack 和 queue，只有push操作，所以也只有emplace操作，此时它们是相对应的。

详细讲解见：[STL - emplace 与 push 的区别](https://blog.csdn.net/Kprogram/article/details/82055673)



**2.STL迭代器辅助函数**
![](https://img2022.cnblogs.com/blog/1617829/202205/1617829-20220507165228885-1962770713.png)






参考：[C/C++中深浅拷贝(map、vector)与内存释放](https://blog.csdn.net/hanxiaoyong_/article/details/112150777)
[C++ map用法总结（整理）](https://blog.csdn.net/sevenjoin/article/details/81943864)
[C++ 教程](https://www.w3cschool.cn/cpp)
[C++中的STL中map用法详解](https://www.cnblogs.com/fnlingnzb-learner/p/5833051.html)
C++语言程序设计教程 第3版  沈显君 ]]></description></item><item><title>W3Cschool:C++多线程</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/05/07/16243176.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Sat, 07 May 2022 08:49:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/05/07/16243176.html</guid><description><![CDATA[C++ 不包含多线程应用程序的任何内置支持。相反，它完全依赖于操作系统来提供此功能，如在Linux中就使用POSIX 编写多线程 C++ 程序。下面介绍POSIX 编写多线程 C++ 程序。
```
#include <pthread.h>
pthread_t tid;  // 创建一个用于保存线程的变量
pthread_create (thread, attr, start_routine, arg) 
// thread：被创建的线程
// attr：设置线程属性
// start_routine：线程执行的函数
// arg：start_routine中传入的参数
pthread_exit (status) 
```

写个鸡巴，不想写了，待续。。。。。。。


# 问题
void 类型数据是什么？
什么时候用？
函数前的void *又是干嘛用的？？
pthread_exit (status)中的status除了是NULL，还可以是什么？














参考：[链接](https://www.w3cschool.cn/cpp/cpp-multithreading.html)]]></description></item><item><title>STL与泛型编程笔记 第二讲</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/05/07/16243162.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Sat, 07 May 2022 08:48:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/05/07/16243162.html</guid><description><![CDATA[#　1.查看标准库源码
在Windows系统中，visual studio默认使用的是微软C++编译器（MSVC），当然你可以修改visual studio使用何种编译器。
我是用的是visual studio 2017，它把C++标准库的源码放在了Visual Studio2017\VC\Tools\MSVC\14.16.27023\include下。其他在visual studio 2017中查看源码的方法请参考[使用Visual Studio查看系统库的源码结构](https://blog.csdn.net/qq_40946921/article/details/89266735)


#　2.list不能使用::sort
标准库提供的全局::sort()算法所使用的迭代器必须是随机访问迭代器（Random Access Iterator）。
链表list的迭代器不支持随机访问，无法使用全局::sort()算法进行排序。
vector和deque的迭代器支持随机访问，可使用全局::sort()算法进行排序。
注：随机访问指的就是直接first+N，便可以得到第N个元素的地址，因为这些相邻元素是按顺序连续存储的。


#　3.面向对象和泛型编程的区别？
面向对象编程（OOP，Object-Oriented Programming）：将数据data和操作method相关联。
泛型编程（GP，Generic Programming）：将数据data和操作method相分离。

采用泛型编程的优点：
- 容器（Containers）和算法（Algorithms）可各自独立实现，提供统一的对外接口即可，两者以迭代器（Iterator）作为桥梁。
- 算法（Algorithms）通过迭代器（Iterator）确定操作范围，并通过迭代器（Iterator）获取和使用容器（Containers）元素。


模板的相关知识，请参考：[C++ 模板](https://www.jianshu.com/p/710acc3d5fc1)


# 4.allcator
即使学会了利用allocator，也不建议去使用它。使用new和malloc就可以。但是需要了解它。【都不要去使用它，那了解它干嘛？？】
C++的内存分配函数的底层都是调用了malloc和free，malloc和free再根据不同的操作系统类型(Windows，Linux，Unix等)底层的系统API来获取内存和释放内存。
malloc分配的内存中不止用来存数据，也存储一些额外的数据（如分配出去的空间大小）。如果分配次数越多，那么内存中数据越零散，这些额外的数据开销就越大。所以一个优秀的分配器，应当尽可能的让这些额外的空间占比更小，让速度更快。

GC2.9的alloc分配器的优化思路：malloc分配的内存中不止用来存数据，也存储一些额外的数据（如分配出去的空间大小）。但是因为同一个容器而言，它的内置类型应当是相同的。所以对于容器的分配器，我们可以对此作出优化。









本小节候捷也没有具体讲，等我看完内存管理，再来补充这一节吧，若想提前学习的，请参考：https://blog.csdn.net/weixin_45067603/article/details/122770539



#5.深度探索list
迭代器++是找到下一个元素，迭代器－－是找到上一个元素。在双向链表list中，我们可以知道下一个元素就是next所指元素，上一个元素就是prev所指元素。
list的迭代器的++操作，就会访问list节点对应的next指针。也就是说list的迭代器的++与指针的++不一样，后者只是地址的增加，而迭代器会根据具体迭代器类型执行不同的“++”操作，迭代器是相当于一个智能指针。


list<int>::iterator a;这里的::是什么意思？？


源码探究：为什么下面这个是倒序？？——学会看源码
```
//使用迭代器倒序输出list容器中的元素
	for (std::list<double>::iterator it = values.begin(); it != values.end();++it) {
		std::cout << *it << " ";
	}
	return 0;
```


参考：[【学习笔记】C++STL和泛型编程-侯捷](https://blog.csdn.net/newson92/article/details/122164204)
]]></description></item><item><title>分配器</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/05/07/16243168.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Sat, 07 May 2022 08:48:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/05/07/16243168.html</guid><description><![CDATA[参考：https://blog.csdn.net/weixin_45067603/article/details/122770539]]></description></item><item><title>侯捷-STL与泛型编程笔记（第一讲、容器概述——0.概述）</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/05/07/16243158.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Sat, 07 May 2022 08:47:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/05/07/16243158.html</guid><description><![CDATA[参考：[链接](https://blog.csdn.net/qq_33053671/article/details/84504632)
#一、简介
C++标准库的header files不带.h后缀的，如：#include<cstdio>
这种形式的head files称为新式headers，新式headers内组件封装在namespace “std”（新式统一规定都在std）
using namespace std;（全部加载）
using std::cout;（cout单个）

常用网站：
- CPlusPlus.com
- CppReference.com
- gcc.gnu.org

我最常使用的是CPlusPlus.com。使用方法就是在搜索框中搜索想要的查询的类。千万不要认为这种开发手册就很复杂，而且是英文的，就不去看。你去认真去看了就会发现，开发手册写得很好。因为我英语不好，所以在搜索函数的后，会直接看开发手册给的实例，比如我在搜索vector的insert函数的使用时，会直接看手册中的代码实例，然后可能会去看看英文的讲解或者直接去百度了。
我认为本视频应该需要配套《stl源码剖析（侯捷）》看。
# 二、STL六大部件（components）
>容器（Containers）：容器存储数据
分配器（Allocators）：分配器为容器分配内存
算法（Algorithms）：算法处理容器的数据
迭代器（Iterators）：迭代器为算法提供访问容器的方式
适配器（Adapters）：进行转换，具体如何转换，以后介绍
仿函式（Functors）：仿函数为类似不同的类相加减提供支持。（？？？我还是不懂仿函式是什么？）
六大部件的关系：
![STL六大部件的关系](https://img2022.cnblogs.com/blog/1617829/202205/1617829-20220507164410109-1834572195.png)


## 2.1.一个例子说明六大部件
```
//一个例子说明六大部件
#include <vector>
#include <algorithm>
#include <functional>
#include <iostream>
using namespace std;

int main()
{
	int ia[6] = {27, 210, 12, 47, 109, 83};
	vector<int, allocator<int>> vi(ia,ia + 6);//<>符号表示模板，allocator<int>是一个分配器模板。
                                              // 如果将本行代码改为vector<int>，则vector会使用默认的分配器
	
	cout << count_if(vi.begin(), vi.end(),
			not1(bind2nd(less<int>(), 40)));    // 输出大于等于四十的数的个数
	return 0;
}
//vector是一个容器containers
//count_if是一个算法algorithm，计算vi里符合条件的元素个数
//vi.begin(), vi.end()是一个迭代器iterator。
//vi.begin()指向第一个元素，vi.end()指向最后一个元素的下一个元素  
//less<int>是一个仿函数function
//bind2nd是一个适配器function adapter，它将40绑定到less函数的第二个形参上
//notl是一个适配器function adapter,表示否定。bind2nd(less<int>(), 40)的结果相当于
//{true,false,true,false,false,false}，则not1(bind2nd(less<int>(), 40))就相当于{false,true,false,true,true,true}
```
我现在暂时对泛性编程的理解是：算法独立与数据结构，也就说函数count_if不止可以用于操作vector类型的数据，还可以操作其他类型的数据，如[这个](http://cplusplus.com/reference/functional/not1/?kw=not1)中的例子

## 2.2.遍历容器中所有元素
```
旧版遍历：
Container<T> c;
...
Container<T>::iterator ite = c.begin();
for (; ite != c.end(); ++ite)
	...

C++11遍历：
for (decl:coll){ // 其中coll为容器或者数组
    statement
}
//举例如下：
//1.
for (int i: {2,3,4,5,6,7,8,9,10})
{
	std::cout << i << std::endl;
}
//2.
int ia[] =  {2,3,4,5,6,7,8,9,10}
for (int i: ia)
{
	std::cout << i << std::endl;
}
//3.
std::vector<double> vec;
...
for (auto elem : vec) {  // auto代表让编译器判断，这里应该是个什么类型
	std::cout << elem << std::endl;   // 不需要进行解引用操作
}

for (auto& elem : vec) {   // auto&使得对elem的修改，就相当于对vec中相应元素的修改
	elem *= 3; 
}
```
## 2.3.容器种类
顺序容器Sequence Containers
- Array（固定元素个数）C++11：就是我们平时使用的数组，不过把现在用一个类将它包装起来。数组元素的个数在定义的时候就已经确定，不可扩充。
- Vector（尾部个数可以扩充）
- Deque（头尾个数可以扩充）
- List（双向链表）
- Forward-List（单向链表）C++11

关联容器Associative Container（通过key可以找到value）：关联容器一般使用红黑树进行实现。查找速度快，但由于插入的时候需要调整红黑树而导致插入速度慢。
- Set/Multiset（key=value）：multiset允许重复元素，Set不允许有重复。
- Map/Multimap(key对应value；multimap允许重复元素，map不允许有重复。

不定序容器Unordered Containers（属于关联容器）:使用hash表进行实现。包括unordered_map、unordered_multimap、unordered_set、unordered_multiset，具体使用，请参考cplusplus.com
各个容器的结构：
![各个容器的结构](https://img2022.cnblogs.com/blog/1617829/202205/1617829-20220507164540006-90034695.png)



适配器（看作一种不能使用迭代器的容器）：
有三种适配器：队列(queue)、优先队列( priority queue)和栈(stack)，
适配器不允许使用迭代器iterator，因为这会破坏栈和队列访问元素的特性（先进后出和先进先出）。

接下来侯捷老师讲解了几种容器的使用，可以直接参考[我的写的博客](https://www.jianshu.com/p/5bfcd6ad88a4)，或者直接在[开发手册](http://cplusplus.com/)中进行学习

allocator：在第一章的allocator，啥也没有介绍。

# 问题
1.map的重复元素指的是key重复吗？？
答：是的，指的就是key不可以重复 

2.如果map或set插入相同key的value时，不会报错。map插入相同key的value时，会将key对应的value改成新插入的value。

3.mutimap不可以使用[]来做插入？？
答：应该是因为multimap允许插入重复元素的原因，所以就不可以使用[]来做插入

4.为什么侯捷将容器适配器stack和queue也当成容器来说明？？ 
答：stack和queue的内部使用的deque进行实现的。由于这两种容器没有自己的数据结构，它们是借用deque进行实现的，所以在技术上，有些人将stack和queue称为Container Adapter。
]]></description></item><item><title>mysql数据库学习</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/05/07/16243139.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Sat, 07 May 2022 08:43:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/05/07/16243139.html</guid><description><![CDATA[数据库学习计划：（1）直接学习这个https://www.w3cschool.cn/mysql/
（2）如果有时间可以学一学《SQL必知必会》里面我不知道的内容

ubuntu20.04安装mysql请参考[链接](https://blog.csdn.net/qq_29761395/article/details/104249924)

登录mysql：
```
mysql -u root -p
```]]></description></item><item><title>redis的基本使用</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/05/07/16243136.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Sat, 07 May 2022 08:41:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/05/07/16243136.html</guid><description><![CDATA[# 1.ubuntu安装redis
安装
```
sudo apt update
sudo apt install redis-server
```
一旦安装完成，Redis 服务将会自动启动。想要检查服务的状态，输入下面的命令：
```
sudo systemctl status redis-server
```
你应该看到下面这些：
```
 redis-server.service - Advanced key-value store
     Loaded: loaded (/lib/systemd/system/redis-server.service; enabled; vendor preset: enabled)
     Active: active (running) since Sat 2020-06-06 20:03:08 UTC; 10s ago
```
# 2.配置 Redis 远程访问
打开 Redis 配置文件：
```
sudo vim /etc/redis/redis.conf
```
如果找不到/etc/redis/redis.conf，请参考[链接](https://blog.csdn.net/qq_39552993/article/details/113433319)
定位到以bind 127.0.0.1 ::1开头的一行，并且将它注释。
如果你的服务器有局域网 IP，并且你想要 Redis 从局域网可以访问 Redis，在这一行后面加上服务器局域网 IP 地址，如下：
```
# bind 127.0.0.1 ::1
bind 192.168.154.130 ::1 #  192.168.154.130为本服务器IP
```
保存这个文件，并且重启 Redis 服务，使应用生效：
```
sudo systemctl restart redis-server
```
下一步，你将需要配置你的防火墙，允许网络流量通过 TCP 端口6379。
通常你想要允许从一个指定 IP 地址或者一个指定 IP 范围来访问 Redis 服务器。例如，想要允许从192.168.121.0/24的连接，运行下面的命令：
```
sudo ufw allow proto tcp from 192.168.121.0/24 to any port 6379
```
确保你的防火墙被配置仅仅接受来自受信任 IP 的连接。
此时，你应该可以从远程位置通过 TCP 连接到 Redis 的 6379 端口。
想要验证所有设置都设置好了，你可以尝试使用redis-cli从你的远程机器上 ping 一下 Redis 服务器。
```
redis-cli -h <REDIS_IP_ADDRESS> ping
```
这个命令将会返回一个响应：PONG

参考：[链接](https://developer.aliyun.com/article/764565#:~:text=Redis%205.0%20%E8%A2%AB%E5%8C%85%E5%90%AB%E5%9C%A8%E9%BB%98%E8%AE%A4%E7%9A%84%20Ubuntu%2020.04%20%E8%BD%AF%E4%BB%B6%E6%BA%90%E4%B8%AD%E3%80%82%20%E6%83%B3%E8%A6%81%E5%AE%89%E8%A3%85%E5%AE%83%EF%BC%8C%E4%BB%A5%20root,%E8%BA%AB%E4%BB%BD%E8%BF%90%E8%A1%8C%E4%B8%8B%E9%9D%A2%E7%9A%84%E5%91%BD%E4%BB%A4%EF%BC%9A%20sudo%20apt%20update%20sudo%20apt%20install%20redis-server)
# 3.redis的基本使用
## 3.1.远程登录命令：
```
redis-cli -h 192.168.154.130 -p 6379 -a "mypass"   # 192.168.154.130为服务器IP，mypass为登录密码
```
## 3.2.Redis支持五种数据类型
Redis支持五种数据类型：string（字符串），hash（哈希），list（列表），set（集合）及zset(sorted set：有序集合)。
###3.2.1.Redis 字符串(String)
Redis 字符串(String)：就是添加一个key，以及一个字符串类型的value


###3.2.2.哈希(Hash)
哈希(Hash)：每一个key下，可以创建多个<field,value>
每个 hash 可以存储 $2^{32} - 1$ 键值对（40多亿）【这是指<field,value>的个数为$2^{32} - 1$吗？】
```
HMSET runoobkey name "redis tutorial" description "redis basic commands for caching"
```
key为runoobkey，<field,value>有<name,"redis tutorial" >、<description,"redis basic commands for caching">


###3.2.3.Redis 列表(List)
Redis 列表(List)：每一个key下，可以创建多个字符串。按照插入顺序排序。


###3.2.4.Redis 集合(Set)
每一个key下，可以创建多个字符串。无序排列，成员唯一。



###3.2.5.Redis 有序集合(sorted set)
Redis 有序集合和集合一样也是 string 类型元素的集合,且不允许重复的成员。
不同的是每个元素都会关联一个 double 类型的分数。redis 正是通过分数来为集合中的成员进行从小到大的排序。
有序集合的成员是唯一的,但分数(score)却可以重复。
集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。 集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)。

我把菜鸟教程里的东西抄一遍也没有意义，所以这里知识粗略总结自己的理解。具体可以参考[菜鸟教程](https://www.runoob.com/redis/redis-tutorial.html)。菜鸟教程对各种命令进行了中文的总结，需要的时候，查阅就行。
当然我们也可以直接查阅官网的[命令手册](https://redis.io/commands/)，官方文档对每个命令所举的例子很好。

redis常用的可视化软件为Redis Desktop Manager，不过好像要钱。



# 问题：
redis如何用于保存关系型数据库的数据
redis不能使用sql？？


NoSQL(NoSQL = Not Only SQL )，意即“不仅仅是SQL”。NoSQL数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，尤其是大数据应用难题，包括超大规模数据的存储。redis是属于NoSQL的。
为什么mysql不行，NoSQL就可以解决大数据应用问题。
NoSQL：这些类型的数据存储不需要固定的模式，无需多余操作就可以横向扩展。【这里的固定模式指mysql数据库中的什么？横向扩展又是指什么？】
]]></description></item><item><title>Redis 设计与实现（第二版）笔记</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/05/07/16243111.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Sat, 07 May 2022 08:36:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/05/07/16243111.html</guid><description><![CDATA[参考：[Redis 设计与实现（第二版）](https://www.w3cschool.cn/hdclil/)
# 0.简介
Remote Dictionary Server(Redis) 是一个 由C语言编写的key-value存储系统。

Redis特点：
- Redis将其数据库完全保存在内存中，仅使用磁盘进行持久化。【持久，即把数据（如内存中的对象）保存到可永久保存的存储设备中（如磁盘）。持久化的主要应用是将内存中的对象存储在数据库中，或者存储在磁盘文件中、XML数据文件中等等。】
- 与其它键值数据存储相比，Redis有一组相对丰富的数据类型。【其他数据库不行吗？】
- Redis可以将数据复制到任意数量的从机中。【其他数据库不行吗？】

Redis的数据都是缓存在内存中。周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。
# 1.数据结构与对象
## 1.1.Redis简单动态字符串
redis创建了一个简单动态字符串（simple dynamic string，SDS）来保存字符串，而没有直接采用C 语言传统的字符串表示（以空字符结尾的字符数组，以下简称 C 字符串）。SDS数据结构如下：
```
struct sdshdr{
    //buf已使用的字节数
    int len;
    //buf未使用的字节数
    int free;
    //字节数组，用于保存字符串
    char buf[];
}
```
SDS数据结构中记录着数组buf中已使用的字节和未使用的字节。
len和free是根据输入的字符串自动生成的。

**SDS 与 C 字符串的区别**：
**1.常数复杂度获取字符串长度**。SDS获取一个 SDS 长度的复杂度仅为 O(1)。对于C字符串，由于C字符串不会记录自身长度，因此只能遍历，直到遇到结尾的空字符为止,时间复杂度为O(N)
**2.SDS杜绝缓冲区溢出**。由于C字符串未记录自身长度，容易导致缓冲区溢出。在执行字符串拼接时，如果没有足够的空间，并且相邻内存地址被其他字符串占用时，字符串的数据将溢出，且容易意外修改相邻的字符串内容。相比而言，SDS会将这种情况扼杀在摇篮之中，SDS API先判断空间是否满足，如果不满足则将空间扩展至执行修改所需的大小。
**3.减少修改字符串时带来的内存重分配次数**
**空间预分配（优化字串增长）**：程序不仅会为 SDS 分配修改所必须要的空间， 还会为 SDS 分配额外的未使用空间。在扩展 SDS 空间之前，SDS API 会先检查未使用空间是否足够， 如果足够的话， API 就会直接使用未使用空间， 而无须执行内存重分配。具体为：
- 增加字串长度以后，字串的长度L小于1MB时，则分配2L+1个字节，（额外的一字节用于保存空字符）；
- 字串的长度L大于等于1MB时，则分配L+1MB+1B的空间（额外的一字节用于保存空字符）

**惰性空间释放（优化字串缩短）**：当 SDS 的 API 需要缩短 SDS 保存的字符串时， 程序并不立即使用内存重分配来回收缩短后多出来的字节， 而是使用 free 属性将这些字节的数量记录起来， 并等待将来使用。
**4.SDS API都是二进制安全的。**
C字符串的字符必须符合某种编码，并且中间不能有空字符，否则读取时会被误以为是字符串结尾。种种局限使得C字符串只能存文本，不能存图片，音频，视频，压缩文件等二进制数据。 为确保Redis对不同使用场景的支持，SDS API都是二进制安全的，也就是所有SDS API都会以二进制的方式存取buf中的数据，数据的写入和读出都是一个样的。由于SDS读取时并不是依靠空字符来判断结束的，而是len属性，所以是二进制安全的。
**5.兼容部分C字符串函数。**
SDS虽然都是二进制安全的，但也遵循以空字符结尾的习惯。SDS API总会在buf数组分配空间时多分配一个字节用于容纳空字符，这是为了保存文本的SDS重用一部分<string.h>库函数，避免代码重复。

SDS API中介绍操作SDS的函数


## 1.2.Redis 链表和链表节点的实现
当一个列表键包含了数量比较多的元素，或者列表中包含的元素都是比较长的字符串时，Redis就会使用链表作为列表键的底层实现。
每个链表节点使用一个 adlist.h/listNode 结构来表示：
```
typedef struct listNode {

    // 前置节点
    struct listNode *prev;

    // 后置节点
    struct listNode *next;

    // 节点的值
    void *value;

} listNode;
```
adlist.h/list链表的数据结构：
```
typedef struct list {

    // 表头节点
    listNode *head;

    // 表尾节点
    listNode *tail;

    // 链表所包含的节点数量
    unsigned long len;

    // 节点值复制函数
    void *(*dup)(void *ptr);

    // 节点值释放函数
    void (*free)(void *ptr);

    //  用于对比链表节点所保存的值和另一个输入值是否相等。
    int (*match)(void *ptr, void *key);

} list;
```
## 1.3.字典










参考：[链接](https://zhuanlan.zhihu.com/p/140726424)
[链接2](https://www.w3cschool.cn/hdclil/)]]></description></item></channel></rss>