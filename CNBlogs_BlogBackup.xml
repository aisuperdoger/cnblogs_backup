<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:trackback="http://madskills.com/public/xml/rss/module/trackback/" xmlns:wfw="http://wellformedweb.org/CommentAPI/" xmlns:slash="http://purl.org/rss/1.0/modules/slash/"><channel><title>博客园-codingbigdog</title><link>https://www.cnblogs.com/codingbigdog/</link><description /><language>zh-cn</language><lastBuildDate>Sun, 25 Sep 2022 06:03:08 GMT</lastBuildDate><pubDate>Sun, 25 Sep 2022 06:03:08 GMT</pubDate><ttl>60</ttl><item><title>C++知识整理</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/09/23/16724400.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Fri, 23 Sep 2022 13:14:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/09/23/16724400.html</guid><description><![CDATA[# 1.C++语言

[C++中的头文件（.h）](https://blog.csdn.net/qq_42775938/article/details/123168445#comments_21679785)


## 1.1 virtual
[C++ static静态成员函数详解](http://c.biancheng.net/view/2228.html)：普通成员函数隐含形参this
[ C++中类的普通成员函数不能作为 pthread_create的线程函数](https://blog.csdn.net/hsd2012/article/details/51207585)：因为普通成员函数隐含形参this
[C++中虚析构函数的作用及其原理分析](https://blog.csdn.net/weicao1990/article/details/81911341)：当父类的析构函数不声明成虚析构函数的时候，当子类继承父类，父类的指针指向子类时，delete掉父类的指针，只调动父类的析构函数，而不调动子类的析构函数


# 2.C++编译


## 2.1 gcc编译和gdb调试的学习
C程序编译成可执行文件后，才能有运行。我常用gcc工具将c程序编译成可执行文件。
GCC编译流程分为四个步骤： 编译预处理、编译、汇编和链接
请参考：[gcc编译和gdb调试的学习](https://blog.csdn.net/qq_42775938/article/details/122346013)

我觉得gdb对我没什么用。知道gdb是对生成的二进制文件进行调试就行。
确实有兴趣的可参考： [gdb调试](https://www.cnblogs.com/codingbigdog/p/16424650.html)



## 2.2 C\C++ 静态库和动态库
[静态库和动态库的简介和制作](https://www.cnblogs.com/codingbigdog/p/16412416.html)
[linux Ｃ\C++动态库（共享库）编译和运行时的链接](https://www.cnblogs.com/codingbigdog/p/16320965.html)
[动态链接库的隐式加载和显示加载](https://www.cnblogs.com/codingbigdog/p/16414555.html)



## 2.3 makefile、cmake和configure脚本
使用g++编译程序的时候，需要依赖很多库文件和头文件，当工程很大时，在命令行中使用一条gcc命令编译整个工程就会显得困难。
所以我们将gcc编译各种程序的命令放入一个文件中，这个文件命名为Makefile。
[makefile使用](https://www.cnblogs.com/codingbigdog/p/16262239.html)

上面我们学到的是linux下Makefile的编写规则，但是不同平台有不同的Makefile文件编写规则，为了解决不同平台编写规则的不同，就需要使用cmake。在使用cmake时，需要开发者编写一种平台无关的CMakeList.txt 文件来定制整个编译流程，然后通过cmake命令就可以根据目标的平台生成所需的本地化Makefile和工程文件。
[cmake入门](https://www.cnblogs.com/codingbigdog/p/16459532.html)

./configure是一种叫autoconf的构建工具自动生成的构建文件，它以shell script的形式存储，在cmake之前是c/c++的主流构建工具。近年来很多项目有从autoconf转向cmake的趋势。autoconf和cmake的共同点是会生成makefile，然后从makefile执行真正的编译构建过程。
[configure生成Makefile文件全过程](https://www.cnblogs.com/Braveliu/p/11340132.html)




# C++与python的互相调用
[python调用C++程序，C++程序调用python程序：pybind11简单使用](https://www.cnblogs.com/codingbigdog/p/16512831.html)
]]></description></item><item><title>大并发服务器架构（陈硕muduo库源码解析）——基础篇</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/09/23/16723428.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Fri, 23 Sep 2022 09:13:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/09/23/16723428.html</guid><description><![CDATA[我从P8开始看的。

# 面向对象的编程和基于对象的编程思想
muduo库不使用抽象类和虚函数作为接口，只暴露具体类，这就意味着muduo库不使用面向对象的编程思想，而使用基于对象的编程思想，以下说明两者的区别：
## 面向对象的编程思想

Thread.h：
```
#ifndef _THREAD_H_
#define _THREAD_H_

#include <pthread.h>

class Thread
{
public:
	Thread();

	// 由于要用到多态，所以这里析构函数设为虚函数。
	// 设为虚函数以后，使用父类指针访问的子类对象结束后，才会调用子类的析构函数，不然只会调用父类的析构函数。
	virtual ~Thread();

	void Start();
	void Join();

	void SetAutoDelete(bool autoDelete);

private:
	// 加了静态，就没有隐含的 this 指针了
	static void *ThreadRoutine(void *arg);
	// 纯虚函数
	virtual void Run() = 0; 
	pthread_t threadId_;
	bool autoDelete_;
};

#endif // _THREAD_H_
```

[C++中虚析构函数](https://blog.csdn.net/weicao1990/article/details/81911341)：设为虚析构函数以后，使用父类指针访问的子类对象结束后，才会调用子类的析构函数，不然只会调用父类的析构函数。

Thread.cpp：
```
#include "Thread.h"
#include <iostream>
using namespace std;


Thread::Thread() : autoDelete_(false)
{
	cout<<"Thread ..."<<endl;
}

Thread::~Thread()
{
	cout<<"~Thread ..."<<endl;
}

void Thread::Start()
{        
        // C++中类的普通成员函数不能作为 pthread_create的线程函数。
        // 所以ThreadRoutine可以设为静态成员函数，但不能是普通成员函数，所以ThreadRoutine也不能直接设为Run
	pthread_create(&threadId_, NULL, ThreadRoutine, this);
}

void Thread::Join()
{
	pthread_join(threadId_, NULL);
}

void* Thread::ThreadRoutine(void* arg)
{
	// static_cast 是强制类型转换为 Thread*
	Thread* thread = static_cast<Thread*>(arg); // static_cast<Thread*>(arg)得到的肯定是一个Thread的子类对象
                                                    // 而thread是父类指针，故这里使用到了多态，所以Run要设为virtual
	thread->Run(); //  ThreadRoutine中不能直接调用Run，因为 ThreadRoutine是静态成员函数，而Run是普通成员函数
	if (thread->autoDelete_)  // 本函数执行完毕，即线程执行完毕，就将对象delete掉
		delete thread;
	return NULL;
}

void Thread::SetAutoDelete(bool autoDelete)
{
	autoDelete_ = autoDelete;
}
```
[ C++中类的普通成员函数不能作为 pthread_create的线程函数](https://blog.csdn.net/hsd2012/article/details/51207585)，这篇文章说隐含传入的this指针与线程函数参数(void\*)不能匹配。但是我觉得它说的有问题，因为this和(void*)明显是匹配的。我觉得“C++中类的普通成员函数不能作为 pthread_create的线程函数”的主要原因是：普通成员函数由于要隐含传入this，所以它在实现上可能与pthread_create要求的函数有所区别，所以不能传入。

Thread_test.cpp：
```
#include "Thread.h"
#include <unistd.h>
#include <iostream>
using namespace std;

class TestThread : public Thread
{
	public:
		TestThread(int count) : count_(count)
		{
			cout<<"TestThread ..."<<endl;
		}

		~TestThread()
		{
			cout<<"~TestThread ..."<<endl;
		}

	private:
		void Run()
		{
			while (count_--)
			{
				cout<<"this is a test ..."<<endl;
				sleep(1);
			}
		}

		int count_;
};

int main(void)
{
	/*
	TestThread t(5);
	t.Start();

	t.Join();
	*/

	TestThread* t2 = new TestThread(5);
	t2->SetAutoDelete(true);
	t2->Start();
	t2->Join();

	return 0;
}

```



## 基于对象的编程思想]]></description></item><item><title>vim 学习3 —— 重学vim基础</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/09/17/16702840.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Sat, 17 Sep 2022 08:06:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/09/17/16702840.html</guid><description><![CDATA[# 1. 基础
由于我学了前两篇的东西以后，还是感觉不太懂vim，所以又去看了看[玩转Vim 从放弃到爱不释手【PegasusWan】](https://www.imooc.com/learn/1129)，并做了如下的记录：



## 1.1 vim多文件操作

概念：
```
Buffer: 内存缓冲区

Window: Buffer的可视化分割区域

Tab: 组织Window为一个工作区
```

Buffer：
```
:ls 列举当前缓冲区

:b [num] 跳转到[num]缓冲区

:b [name] 跳转到[name]缓冲区

:bpre/bnext/bfirst/blast 跳转到上一个/下一个/第一个/最后一个缓冲区

:e [name] 打开[name]文件
```
Window:
```
C-w s 水平分割窗口

C-w v 垂直分割窗口

C-w w 循环切换窗口

C-w h/j/k/l 切换到←/↓/↑/→窗口 

C-w H/J/K/L 移动当前窗口向←/↓/↑/→

C-w = 所有窗口等宽高

C-w _/| 当前窗口最大化高度/宽度

[num]C-w _/| 当前窗口高度设为[num]行/列

vim duck.go duck.py -O   # 在两个窗口中打开两个文件
```
tab（用的不是特别多）：
```
:tabnew 新建标签页

:tabe [name] 在新标签页打开[name]文件

:tabc 关闭当前标签页和窗口

:tabo 只保留当前标签页并关闭其他的

C-w T 将当前窗口移动到新标签页【本标签页有两个以上的窗口才能移动】

:tabn [num] 切换到[num]标签页，没有[num]表示下一个  【[num]gt 效果一样】
:tabp [num] 切换到[num]标签页，没有[num]表示上一个  【[num]gT 效果一样】
```


## 1.2 vim复制粘贴与寄存器的使用

vim在Normal模式复制粘贴： 

- Normal模式下复制粘贴分别使用y（yank）和p（put），剪切d和p

- 可以使用v（visual）命令选中所要复制的地方，然后顺遂p粘贴

- 配合文本对象：比如顺遂yiw复制一个单词，yy复制一行


Insert模式下的复制粘贴：如果在vimrc中设置了autoindent，那么在从别的地方复制代码过来的时候，可能会出现代码混乱。这个时候需要使用`:set paste`。如果需要恢复autoindent，只需要执行`:set nopaste`。


什么是vim的寄存器：

- vim里操作的是寄存器而不是系统剪切版，这和其他编辑器不同

- 默认使用d删除或者y复制的内容都放到了“无名寄存器”

- 用x删除一个字符放到无名寄存器，然后p粘贴，可以调换俩字符

深入寄存器（register）：

- 通过`"{register}`前缀可以指定寄存器，不指定默认无名寄存器

- 比如使用`"ayiw`复制一个单词到寄存器a中，`"bdd`删除当前行到寄存器b中

- :reg a查看寄存器a中的内容

- `"a p`粘贴a寄存器中的内容

其他常见寄存器：

除了有名的寄存器a-z，vim中还有一些其他常见寄存器

- 复制专用寄存器`"0`：使用y复制的文本会被拷贝到复制寄存器0和无名寄存器

- 系统剪切版`"+`可以复制到系统剪切版。`:echo has('clipboard')`查看vim是否支持这个功能。如果不支持，试一试安装：sudo apt install xclip -y

- 其他寄存器，比如`"%`当前文件名，`".`上次插入的文本

- :set clipboard=unnamed可以让你直接复制粘贴系统剪切版内容


##  1.3 vim宏（macro）
vim宏：录制一系列操作。
- vim使用q来录制，同时也也是q结束录制
- 使用q{register}选择要保存的寄存器，把录制的命令保存其中

- 使用@{register}回放寄存器中保存的一系列命令



**实例：给文本的每行都加上双引号**
首先我们要录制如何给一行加上双引号，然后将录制的内容回放到所有行。
给一行加上双引号：
```
qa：将操作存储在a寄存器中
I：到行首，加上双引号
A：到行尾，加上双引号
```
将录制的内容回放到所有行：
```
V：按行选取。选择所有行。
按:，然后输入normal @a，从而将寄存器a中的操作进行回放
```
给文本的每行都加上双引号的其他方法：
```
V,G：全选所有行
按:，然后输入normal I"，这样就给所有行加上了前双引号
# 按:，然后键入ctrl p，可复制上一个命令，即normal I"
按:，然后输入normal A"，这样就给所有行加上了后双引号
```



## 1.4 Vim更换配色

- 使用``` :colorscheme``` 显示当前的主题配色，默认是 default

- 用``` :colorscheme  <ctrl + d>``` 可以显示所有的配色 （注意：命令:colorscheme加一个空格再按ctrl+d）。然后用`:colorscheme 配色方案`，即可更换配色方案。


如果在本地没有满意的配色，可以到GitHub中输入vim colorscheme查找vim各种配色
- [vim-hybrid](https://github.com/w0ng/vim-hybrid "vim-hybrid")这个主题也不错。

- 下载到本地，解压。
- 将 `hybrid.vim` 文件移动到 `~/.vim/colors`（如果没有这个目录的话，使用`mkdir ~/.vim/colors -p`先创建文件夹。然后使用`:colorscheme hybrid`就可以更换配色方案。

- 可以下载多个配色到 `~/.vim/colors`即可随时更换


下面几种流行的配色方案：
- vim-hybird 配色: github.com/w0ng/vim-hybrid
- solarized 配色: github.com/altercation/vim-colors-solarized
- gruvbox 配色: github.com/morhetz/gruvbox



## 1.5 vim配置
vim的配置文件放在~/.vimrc中
nvim的配置文件放在~/.config/nvim/init.vim中


下面是视频中提到的一些常用设置：
```
set number " 设置行号
colorscheme hybrid

" 按F2进入粘贴模式。F2代表set paste或set nopaste
set pastetoggle=<F2> 

" 高亮搜索
set hlsearch

" 设置折叠方式
set foldmethod=indent

"   一些方便的映射
let mapleader= ','  # 设置逗号为leader键

let g:mapleader=','

" 使用jj进入normal模式，`^的作用为：进入normal模式，光标位置保持不变
" help `^  可查看对应的含义
inoremap jj <Esc>`^ 

"使用leader+w 直接保存

inoremap <leader>w <Esc> :w<cr>

noremap < leader>w :w<Cr>

" 切换buffer

nnoremap <silent> [b :bprevious<CR>

nnoremap <silent> [n :bnext<CR>

" use ctrl+h/j/k/L switch window
noremap <C-h> <C-w>h

noremap <C-j> <C-w>j

noremap <C-k> <C-w>k

noremap <C-l> <C-w>l



"Sudo to write

cnoremap w!! w !sudo tee % >/dev/null
```




## 1.6 vim映射

插入模式删除整行的操作：
```
:imap <c-d> <Esc>ddi  代表映射插入模式下的快捷键，先按Esc，然后删除整行（dd），最后回到插入模式（i）
```



```
:nmap - dd
:nmap \ -
```
当你按下\时，Vim会解释其为-，而我们又映射了-，Vim会继续解析为dd，即\起到删除整行的作用。(是不是有点类似于递归)

Vim提供了非递归映射,这些命令不会递归解释，如nnoremap/ynoremap/inoremap

任何时候你都应该使用非递归映射，这样比较安全。





# 2.插件

## 2.1 美化插件
- 修改启动界面: https://github.com/mhinz/vim-startify ，vim的打开界面，可以看到我们最近打开的文件
- 状态栏美化: https://github.com/vim-airline/vim-airline
- 增加代码缩进线条: https://github.com/yggdroot/indentline

安装插件的时候，可能需要fanqiang，并且多执行几次:PlugInstall直到 安装成功。


一般插件的github官网上都有插件相关的变量的说明，可以参照进行设置。


## 2.2 寻找需要的插件
直接用英文进行google，然后就可以找到相关的github项目
https://vimawesome.com


## 2.3 taglist 查看源码
taglist：提供源代码符号的结构化视图。
安装见：https://github.com/yegappan/taglist ，使用插件管理器vim-plug安装此插件即可。




## 2.4 ctrlpvim/ctrlp.vim
配置：
```
let g:ctrlp_map = '<c-p>' 　＂ 使用ctrl p调用插件
```
与ctrlp相比，前面我们提到过的leaderf似乎更加强大。


## 2.5 快速跳转
easymotion/vim-easymotion

配置：
```
nmap ss <PLug>(easymotion-s2) " 由于easymotion-s2也是个映射，所以这里使用非递归映射
```
使用方法：输入ss，然后再输入需要跳转位置的前两个单词，有这两个字母的位置会出现红色的的快捷字母，最后按下相关位置的快捷键。

## 2.6 编辑成对符号的插件
https://github.com/tpope/vim-surround

使用方法：
```
normal模式下增加,删除,修改成对内容
ds (delete a surrounding)
cs (change a surrounding)
ys (you add a surrounding)
```
使用实例：
- `ysiw"`：代表使用`ys`开始增加成对内容，此时会自动进入可视模式，使用`iw`代表选择一个单词，最后使用`"`给此单词两边增加双引号。
- `cs"'`：将双引号替换成单引号
- `cs"[`：将双引号替换成[]，这样会有空格，`cs"]`不会有空格（你试试就知道我的空格是啥）
- `ds'`：删除单引号



## 2.7 模糊搜索
vim中可以使用`\`进行精确地搜索，但是不能实现模糊搜索。

模糊搜索插件：https://github.com/junegunn/fzf.vim

配置：
```
Plug 'junegunn/fzf', { 'do': { -> fzf#install() } }
Plug 'junegunn/fzf.vim'
```
```
使用:Ag [PATTERN]模糊搜索字符串
```
要实现以上功能，需要按照github中的说明，安装相应的依赖，如Ag就需要： `sudo apt-get install silversearcher-ag`


## 2.8 tagbar 浏览源码大纲

preservim/tagbar用于浏览当前文件的源码大纲
需要安装ctag才能实现相应的功能

配置：
```
" tagbar 打开大纲
nnoremap <leader>t :TagbarToggle<CR>
```


# 进阶
我觉得需要继续进阶，可看[链接](https://github.com/wsdjeg/vim-galore-zh_cn)

我只看了一点点，记录在这：
```
:enew：创建未命名文件
:w /tmp/foo：将文件存入/tmp/foo中

g:mapleader：g代表mapleader是全局变量

nvim ~/projects/cpp/muduo/muduo_source/examples/simple/ 使用nvim开启目录。

```
]]></description></item><item><title>vim 学习1——基础篇</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/09/17/16702821.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Sat, 17 Sep 2022 07:59:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/09/17/16702821.html</guid><description><![CDATA[
# 1. vim 学习经验

- 把CapsLock映射成<esc>。这个操作我建议使用操作系统的改键工具来完成。win下的修改教程[链接](https://github.com/susam/uncap#windows-scancode-map-registry-value)，mac下直接在系统设置中改即可。不推荐在vim中改是因为系统内修改一次，所有能开启vi-mode的软件都可以使用CapsLock代替esc了，而不需要每次都重新配置。这条是最重要的一条。设置完这条之后几乎马上就可以体会到vim的好处了。
每当写完一段有小停顿，习惯性按下CapsLock进入normal模式。

- 适应面向搜索编程的思想。我个人感觉vim快最重要的原因就是精准选择。而实现精准选择的必要途径就是搜索。搜索是vim的核心。

- 精确跳转+可视化模式 。掌握精确跳转后，结合v V ctrl+v 这三种可视化模式进行精确选择，配合cdyrp等指令，可以完成极其灵活的代码增删改查。到这一步你会发现vim对你编程速度的提高已经是革命性的了。

- 终端中，输入vimtutor zh，可对vim进行学习和练习



# 2. vimtutor zh中命令的总结

终端中，输入vimtutor zh，可对vim进行学习和练习，下面是对vimtutor中内容做的总结，所以请你直接去vimtutor zh中进行练习，不必看第二节的东西。

##　2.1 移动光标
基本移动：
```
光标在屏幕文本中的移动既可以用箭头键，也可以使用 hjkl 字母键。
         h (左移)       j (下行)       k (上行)     l (右移)

e 命令可以使光标移动到单词末尾，从而实现快速移动。
```
行尾和行首：
```
欲移动光标到行首，请按数字0或^
欲移动光标到行尾，请按$。与快捷键"^"和0不同，快捷键$前可以加上数字表示移动的行数。
例如使用"1$"表示当前行的行尾，"2$"表示当前行的下一行的行尾。
```
文档头和文档尾：
```
CTRL-G 用于显示当前光标所在位置和文件状态信息。
G 用于将光标跳转至文件最后一行。
先敲入一个行号然后输入大写 G 则是将光标移动至该行号代表的行。
gg 用于将光标跳转至文件第一行。
```
括号：
```
如果光标当前位置是括号(、)、[、]、{、}，按 % 会将光标移动到配对的括号上。
```
快速移动：
```
w/e 基于单词移动
f{char}  按f，然后按相应的字符，就会跳转距离此光标最近的此字符。f是向前查找，F是向后查找。
ctrl+f ctrl+u 前后翻屏
```


## 2.2 删除修改、查找替换
删除：
```
删除类命令的格式是：d   [number(数字)]   motion
       [number] - 可以附加的数字，代表动作重复的次数
       motion代表操作的动作，可以为：
            w - 从当前光标当前位置直到下一个单词起始处，包括单词间的空格。
            e - 从当前光标当前位置直到单词末尾，不包括单词间的空格。
            $ - 从当前光标当前位置直到当前行末。
举例如下：
1. 欲从当前光标删除至下一个单词，请输入：dw
2. 欲从当前光标删除至当前行末尾，请输入：d$
3. 欲删除整行，请输入：dd
4. 欲重复一个动作，请在它前面加上一个数字，如d2w代表删除两个单词，再如2dd或d2d 删除两行代表删除两行

dty：从光标开始删除到字符y为止（y不删除）

使用d删除掉的内容，可以通过p粘贴出来
```

修改：
```
更改类命令的格式是：c   [number]   motion。
c的参数和d一样的，比如 w 代表单词，$代表行末等等。
```

查找：
```
输入 / 然后紧随一个字符串是在当前所编辑的文档中正向查找该字符串。
输入 ? 然后紧随一个字符串则是在当前所编辑的文档中反向查找该字符串。
完成一次查找之后按 n 键是重复上一次的命令，可在同一方向上查
找下一个匹配字符串所在；或者按大写 N 向相反方向查找下一匹配字符串所在。
CTRL-O 带您跳转回较旧的位置，CTRL-I 则带您到较新的位置。【这个不太懂，它是什么样的跳转规则？？】


使用查找命令时，如/aaa，查找aaa的时候，可以使用set设置一些选项： 
输入 :set xxx 可以设置 xxx 选项。一些有用的选项如下：
        'ic' 'ignorecase'       查找时忽略字母大小写
        'is' 'incsearch'        查找短语时显示部分匹配
        'hls' 'hlsearch'        高亮显示所有的匹配短语
     选项名可以用完整版本，也可以用缩略版本。


:set ic设置以后需要使用:set noic进行关闭，果您想要仅在一次查找时忽略字母大小写，您可以使用 \c，如：
      /ignore\c <回车>

在选项前加上 no 可以关闭选项：  :set noic
```
替换:
```
在一行内替换头一个字符串 old 为新的字符串 new，请输入  :s/old/new
在一行内替换所有的字符串 old 为新的字符串 new，请输入  :s/old/new/g
将两行之间的所有的字符串 old 替换为新的字符串 new，请输入  :#,#s/old/new/g，如566,571s/old/new/g
在文件内替换所有的字符串 old 为新的字符串 new，请输入  :%s/old/new/g
进行全文替换时询问用户确认每个替换需添加 c 标志        :%s/old/new/gc
```


```
在正常模式下删除光标所在位置的字符，请按： x

要替换光标所在位置的字符，请输入小写的 r 和要替换掉原位置字符的新字符即可。

输入大写的 R 将进入替换模式，直至按 <ESC> 键回到正常模式。
```

## 可视模式下的操作
```
v：进入可视模式
V：进入可视模式，按行选取内容
```
可视模式下的快捷键：
```
iw 选择一个单词

上面提到过的移动光标的操作可以用在这里快速选择字符。
```



## 2.4 其他操作
```
欲退出 Vim 编辑器，请输入 <ESC>   :q!   <回车> 放弃所有改动。
                      或者输入 <ESC>   :wq   <回车> 保存改动。
```
```
欲插入或添加文本，请输入：
         i  在光标前插入文本
         I  在行首插入文本
         a  在光标后插入文本（最常用）
         A  在行尾插入文本

输入小写的 o 可以在光标下方打开新的一行并进入插入模式。
输入大写的 O 可以在光标上方打开新的一行并进入插入模式。
```
```
欲撤消以前的操作，请输入：u (小写的u)
欲撤消在一行中所做的改动，请输入：U (大写的U)
欲撤消以前的撤消命令，恢复以前的操作结果，请输入：CTRL-R
```

```
:!command 用于执行一个外部命令 command。

     请看一些实际例子：
         (MS-DOS)         (Unix)
          :!dir            :!ls            -  用于显示当前目录的内容。
          :!del FILENAME   :!rm FILENAME   -  用于删除名为 FILENAME 的文件。

  :w FILENAME  可将当前 VIM 中正在编辑的文件保存到名为 FILENAME 的文件中，此时编辑的是FILENAME文件。（另存为）

v motion :w FILENAME 可将当前编辑文件中可视模式下选中的内容保存到文件FILENAME 中。
按 v 键使 Vim 进入可视模式进行选取。您可以四处移动光标来选取需要的区域。接着您可以使用一个操作符对选中文本进行操作。例如，按 d 键会删除选中的文本内容、:w FILENAME另存为文件

```
```
 :r FILENAME 可提取磁盘文件 FILENAME 并将其插入到当前文件的光标位置后面。

 :r !ls 可以读取ls命令的输出并将其放置到当前文件的光标位置后面。
```

   
```
  1. 输入 :help 或者按 <F1> 键或 <Help> 键可以打开帮助窗口。  

  2. 输入 :help cmd 可以找到关于 cmd 命令的帮助。

  3. 输入 CTRL-W CTRL-W  可以使您在窗口之间跳转。

  4. 输入 :q 以关闭帮助窗口

  5. 您可以创建一个 vimrc 启动脚本文件用来保存您偏好的设置。

  6. 当输入 : 命令时，按 CTRL-D 可以查看可能的补全结果。
     按 <TAB> 可以使用一个补全。
```

```
使用 v 进入可视模式，选择需要的文本，使用操作符 y 复制文本，p 粘贴先前复制的文本。

```










# 3.Windows下的远程连接工具
- xshell：个人版不要钱
- mobaxterm：我在用的。
- windows终端（不是自带的那个，而是[这个](https://learn.microsoft.com/zh-cn/windows/terminal/install)）
- vscode中的远程连接服务器的功能

本人使用mobaxterm过程中的问题：
在mobaxterm中使用vim编辑远程服务器中的文本时，使用y复制了文本，但此文本没有复制到windows的剪切板上。[解决方法](https://blog.csdn.net/pangchol/article/details/91425637)，在这篇解决方法中配置了export DISPLAY和xhost，这会导致如下影响：vscode远程连接服务器时，打开终端速度慢（或者直接打不开）【这个我还不知道是为什么】。 
xshell中也有此问题，可参考[链接的方法一（方法二亲测无效）](https://www.cnblogs.com/pangchol/archive/2015/12/21/5062115.html)。方法一应该是根据xshell弹出的如下弹窗进行设置的：
![](https://img2022.cnblogs.com/blog/1617829/202209/1617829-20220917163931273-377051316.png)
]]></description></item><item><title>tmux 入门</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/09/14/16692891.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Wed, 14 Sep 2022 06:13:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/09/14/16692891.html</guid><description><![CDATA[# 1.基本概念和使用

tmux中有三个概念：会话、窗口和窗格，具体如下图所示：

![](https://img2022.cnblogs.com/blog/1617829/202209/1617829-20220914104749721-383435642.png)



在linux终端中输入如下内容，开启一个会话
```
tmux new -s mysession  # 创建一个名字为mysession的会话
```
创建完会话以后，默认开启一个窗口，然后我们就可在窗口里面创建窗格或者创建新的窗口：
```
ctrl+b %  # 在水平方向创建一个窗格
# 说明：ctrl+b %：不是同时按这些键，而是先按ctrl+b，然后松开，然后再按shift+5。shift+5就是%的意思。
ctrl+b "  # 在垂直方向创建一个窗格
ctrl+b 方向键  # 窗格间进行切换  
```

```
Ctrl+b c  # 创建一个新的窗口
ctrl+b +n：切换到下一个窗口
ctrl+b +p：切换到上一个窗口
```

其他具体的使用，请直接参考：[Tmux 使用教程](https://www.ruanyifeng.com/blog/2019/10/tmux.html)，tmux刚安装完，需要重新打开终端才能生效。

重启以后tmux会话的恢复：https://www.bilibili.com/video/BV1fA411E7VR

```
tmux attach -t 0 不用写全，
如
tmux att -t 0
```

ssh断开以后，tmux开启的会话也不会被杀死，可以进行重新连接。

tmux和vim中的ctrl+w都是用于分屏的，但是前者是用于将输入命令的命令行窗口进行分屏；后者是使用vim进入文件后，分屏编辑文件。

工作中：
一般新建两个窗口，一个窗口用于使用nvim编辑项目，一个窗口用于执行各种脚本

参考：[手把手教你使用终端复用神器 tmux](https://www.bilibili.com/video/BV1KW411Z7W3)
# 2.tmux配置文件（~/.tmux.conf）
我的配置文件：
```
# 以下内容参考：https://xpgeng.gitbooks.io/omooc2py/content/guide/Tmux-Guide.html
# 更改启动快捷键前缀C+b为C+a

# remap prefix from 'C-b' to 'C-a'
# 原本的ctrl a是跳转到命令开头，现在需要点击两次ctrl a才能跳转到开头。
unbind C-b
set -g prefix C-a
bind-key C-a send-prefix

# 更改分屏快捷键

# split panes using | and -
bind | split-window -h
bind - split-window -v
unbind '"'
unbind %

# 不同窗口间移动改成Alt+ 箭头

# switch panes using Alt-arrow without prefix
bind -n M-Left select-pane -L
bind -n M-Right select-pane -R
bind -n M-Up select-pane -U
bind -n M-Down select-pane -D

# 使用鼠标切换窗口
set -g mouse on

# 以下内容参考：https://gist.github.com/Godsing/c817baaeb44ceaaf57c91f047eaf5501
# 自定义状态栏
# set -g status-utf8 on # 状态栏支持utf8，这个有问题
set -g status-interval 1 # 状态栏刷新时间
set -g status-justify left # 状态栏列表左对齐
setw -g monitor-activity on # 非当前窗口有内容更新时在状态栏通知

#set -g status-bg black # 设置状态栏背景黑色
#set -g status-fg yellow # 设置状态栏前景黄色
#set -g status-style "bg=black, fg=yellow" # 状态栏前景背景色

set -g status-left "#[bg=#88cc44] Sess: #S " # 状态栏-左侧内容 (#S: 会话(session)名称)
#set -g status-right 'Continuum status: #{continuum_status}' # 状态栏右侧内容
set -g status-left-length 300 # 状态栏-左边长度300
set -g status-right-length 500 # 状态栏-左边长度500

set -wg window-status-format " #I:#W " # 状态栏-(当前窗口除外的其他)窗口名称格式
set -wg window-status-separator "" # 状态栏-窗口名称之间的间隔
set -wg window-status-current-format " #I:#W #F " # 状态栏-当前窗口名称格式(#I：序号，#w：窗口名称，#F：间隔符)
set -wg window-status-current-style "bg=black, fg=yellow" # 状态栏-当前窗口名称的背景色
#set -wg window-status-last-style "fg=black" # 状态栏最后一个窗口名称的样式

set -g message-style "bg=#202529, fg=#91A8BA" # 指定消息通知的前景、后景色
```
重启tmux以后，配置生效。






 ]]></description></item><item><title>深度学习和pytorch的使用</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/09/13/16689508.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Tue, 13 Sep 2022 08:07:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/09/13/16689508.html</guid><description><![CDATA[以下所有内容来自与项目Test2_alexnet，项目Test2_alexnet的目录结构如下：
```
├── model.py
├── predict.py
└── train.py
```
项目的Test2_alexnet的具体内容在本博客的最后。


# 1.将数据放入GPU进行计算
```
device = torch.device("cuda:0" if torch.cuda.is_available() else "cpu")  # 选择设备
net = AlexNet(num_classes=5, init_weights=True)
net.to(device)      # 将次此模型指定在ＧＰＵ上运行
# 训练的时候需要将每个batch的图像和和标签都指定到GPU上，如：
outputs = net(images.to(device))
loss = loss_function(outputs, labels.to(device))
# 预测时也需要将每个batch的图像和和标签都指定到GPU上，如：
outputs = net(val_images.to(device))
predict_y = torch.max(outputs, dim=1)[1]
acc += torch.eq(predict_y, val_labels.to(device)).sum().item()
```

# 2. transforms对图像进行变换
```
from torchvision import transforms
data_transform = transforms.Compose([transforms.RandomResizedCrop(224),   
                                     transforms.RandomHorizontalFlip(),
                                     transforms.ToTensor(),
                                     transforms.Normalize((0.5, 0.5, 0.5), (0.5, 0.5, 0.5))]),
```
transforms.Compose()将多个变换进行打包。transforms中有各种各样用于变换的类。

# 3.torch.utils.data.DataLoader加载图片和对图片进行变换
torch.utils.data.DataLoader如下：
```
nw = min([os.cpu_count(), batch_size if batch_size > 1 else 0, 8])  # 使用多线程加载数据。在debug时，一般需要置为0
train_loader = torch.utils.data.DataLoader(dataset=train_dataset,
                                               batch_size=batch_size,         # batch_size代表一次同时喂入的数据
                                               shuffle=True,                         # shuffle=True:打乱数据
                                               num_workers=nw)                 #  num_workers=nw多线程来读数据                                                                               
```
dataset可以是Map-style datasets和Iterable-style datasets，这两种类似介绍如下：

**1.Map-style datasets：**

Map-style型的类需要包含`__getitem__(self,i)`和`__len__(self)`两个函数。
- `__getitem__(self,i)`中定义使用下标访问时所返回的东西，如dataset[i]返回的东西。这里要求dataset[i]必须返回图像和标签，即return img,target。img和target的shape有什么要求，

Map-style型的类的定义，举例如下：
```
import torch
from PIL import Image
import json
import numpy as np
import torchvision.transforms as transforms
import os
identity = lambda x:x # 传入参数x，return x
class SimpleDataset:
    def __init__(self, data_file, transform, target_transform=identity): # 这都可以是自定义的
        with open(data_file, 'r') as f:
            self.meta = json.load(f)
        self.transform = transform
        self.target_transform = target_transform


    def __getitem__(self,i): #
        image_path = os.path.join(self.meta['image_names'][i])
        # print(image_path)
        img = Image.open(image_path).convert('RGB')
        img = self.transform(img)
        target = self.target_transform(self.meta['image_labels'][i])
        return img, target

    def __len__(self):
        return len(self.meta['image_names'])
```
从以上可以看出图像的加载和变换一般都是在通过下标访问数据时（如a[0]）被执行的，即函数`__getitem__`被执行。

还有一个常用的包torchvision.datasets.ImageFolder用于导入数据：
```
train_dataset = datasets.ImageFolder(root=os.path.join(image_path, "train"),        # datasets.ImageFolder加载数据集要求目录为类别名
                                         transform=data_transform)
train_dataset.class_to_idx:返回一个字典，key为类名，value为类对应的数字标签
```
ImageFolder返回的是Map-style datasets

**2.Iterable-style datasets**

暂时没有遇到过，请参考官网[链接](https://pytorch.org/docs/stable/data.html)

# 4.训练网络
## 4.1 一般训练过程
传统的训练函数，一个batch是这么训练的：
```
for i,(images,target) in enumerate(train_loader):
    # 1. input output
    images = images.cuda(non_blocking=True)
    target = torch.from_numpy(np.array(target)).float().cuda(non_blocking=True)
    outputs = model(images)
    loss = criterion(outputs,target)

    # 2. backward
    optimizer.zero_grad()   # reset gradient
    loss.backward()
    optimizer.step()            
```
1.获取loss：输入图像和标签，通过infer计算得到预测值，计算损失函数；
2.optimizer.zero_grad() 清空过往梯度；
3.loss.backward() 反向传播，计算当前梯度；
4.optimizer.step() 根据梯度更新网络参数
## 4.2 变相提高batch的方法
简单的说就是进来一个batch的数据，计算一次梯度，更新一次网络，使用梯度累加是这么写的：
```
for i,(images,target) in enumerate(train_loader):
    # 1. input output
    images = images.cuda(non_blocking=True)
    target = torch.from_numpy(np.array(target)).float().cuda(non_blocking=True)
    outputs = model(images)
    loss = criterion(outputs,target)

    # 2.1 loss regularization
    loss = loss/accumulation_steps   
    # 2.2 back propagation
    loss.backward()
    # 3. update parameters of net
    if((i+1)%accumulation_steps)==0:
        # optimizer the net
        optimizer.step()        # update parameters of net
        optimizer.zero_grad()   # reset gradient
```
1.获取loss：输入图像和标签，通过infer计算得到预测值，计算损失函数；
2.loss.backward() 反向传播，计算当前梯度；
3.多次循环步骤1-2，不清空梯度，使梯度累加在已有梯度上；
4.梯度累加了一定次数后，先optimizer.step() 根据累计的梯度更新网络参数，然后optimizer.zero_grad() 清空过往梯度，为下一波梯度累加做准备；
总结来说：梯度累加就是，每次获取1个batch的数据，计算1次梯度，梯度不清空，不断累加，累加一定次数后，根据累加的梯度更新网络参数，然后清空梯度，进行下一次循环。

一定条件下，batchsize越大训练效果越好，梯度累加则实现了batchsize的变相扩大，如果accumulation_steps为8，则batchsize '变相' 扩大了8倍，是我们这种乞丐实验室解决显存受限的一个不错的trick，使用时需要注意，学习率也要适当放大。
更新1：关于BN是否有影响，之前有人是这么说的：
 As far as I know, batch norm statistics get updated on each forward pass, so no problem if you don't do .backward() every time. 

BN的估算是在forward阶段就已经完成的，并不冲突，只是accumulation_steps=8和真实的batchsize放大八倍相比，效果自然是差一些，毕竟八倍Batchsize的BN估算出来的均值和方差肯定更精准一些。
参考：[链接](https://cloud.tencent.com/developer/article/1700045)


## 4.3 其他
[python进度条库tqdm（泰拳大妈）详解](https://zhuanlan.zhihu.com/p/163613814)：使用循环遍历tqdm包装起来的可迭代对象，当循环结束，进度条就到达100%。

[requires_grad，grad_fn，grad的含义及使用](https://blog.csdn.net/qq_42775938/article/details/125849362)：x的梯度指的是loss对x的偏导值

[Pytorch optimizer.step() 和loss.backward()的关系](https://cloud.tencent.com/developer/article/1653756)：loss.backward()在参数的grad上填上梯度，optimizer.step()使用这个梯度更新参数。


# 5.卷积
nn.Conv2d(3, 48, kernel_size=11, stride=4, padding=2) 
代表输入的channel为3，输出的channel为48。卷积核为11x11。
其中padding可为int或tuple。padding=2：在周围补两圈零，padding=(1,2)：代表在上下各补一行零，左右两侧各补两列零。还有可以利用nn.ZeroPad2d()补零（自己google）
# 6.模型保存
## 6.1 保存模型的方法
```
# 保存整个模型
torch.save(net, path) # 这样保存可能会保存到确切的目录，导致模型在别的地方不能被加载

# 保存模型参数（推荐）
state_dict = net.state_dict()
torch.save(state_dict , path)
```
torch.save(列表，路径)可以用于保存任何列表，如：
```
import torch
torch.save([1,{"a":1,"b":2},"dsdsds"],'./cache/test.pkl')
```

## 6.2 保存断点继续训练
保存断点
```
checkpoint = {
        "net": model.state_dict(),
        'optimizer':optimizer.state_dict(),
        "epoch": epoch
    }
if not os.path.isdir("./models/checkpoint"):
    os.mkdir("./models/checkpoint")
    torch.save(checkpoint, './models/checkpoint/ckpt_best_%s.pth' %(str(epoch)))
```
将网络训练过程中的网络的权重，优化器的权重保存，以及epoch 保存，便于继续训练恢复
在训练过程中，可以根据自己的需要，每多少代，或者多少epoch保存一次网络参数，便于恢复，提高程序的鲁棒性。

从模型的断点继续训练：
```
start_epoch = -1
 
if RESUME:
    path_checkpoint = "./models/checkpoint/ckpt_best_1.pth"  # 断点路径
    checkpoint = torch.load(path_checkpoint)  # 加载断点
 
    model.load_state_dict(checkpoint['net'])  # 加载模型可学习参数
 
    optimizer.load_state_dict(checkpoint['optimizer'])  # 加载优化器参数
    start_epoch = checkpoint['epoch']  # 设置开始的epoch

for epoch in  range(start_epoch + 1 ,EPOCH):
    # print('EPOCH:',epoch)
    for step, (b_img,b_label) in enumerate(train_loader):
        train_output = model(b_img)
        loss = loss_func(train_output,b_label)
        # losses.append(loss)
        optimizer.zero_grad()
        loss.backward()
        optimizer.step()
```
参考：[链接](https://blog.csdn.net/weixin_35698091/article/details/112429883)
[链接](https://blog.csdn.net/LXYTSOS/article/details/90639524)
## 6.3 模型的可复现性
```
import torch
import random
import numpy as np
 
def set_random_seed(seed = 10,deterministic=False,benchmark=False):
    random.seed(seed)
    np.random(seed)
    torch.manual_seed(seed)
    torch.cuda.manual_seed_all(seed)
    if deterministic:
        torch.backends.cudnn.deterministic = True
    if benchmark:
        torch.backends.cudnn.benchmark = True
```
torch.backends.cudnn.deterministic = True和torch.backends.cudnn.benchmark = True使得每次卷积计算采用的是相同的策略。
设置 torch.backends.cudnn.benchmark=True 将会让程序在开始时花费一点额外时间，为整个网络的每个卷积层搜索最适合它的卷积实现算法，进而实现网络的加速。适用场景是网络结构固定（不是动态变化的），网络的输入形状（包括 batch size，图片大小，输入的通道）是不变的，其实也就是一般情况下都比较适用。反之，如果卷积层的设置一直变化，将会导致程序不停地做优化，反而会耗费更多的时间。
参考：[链接](https://blog.csdn.net/qq_36791000/article/details/121786560)

可变学习率：参考——[链接](https://blog.csdn.net/weixin_35698091/article/details/112429883)
# 7.损失函数
## 7.1.nn.CrossEntropyLoss()
```
torch.nn.CrossEntropyLoss(weight=None, size_average=None, ignore_index=- 100, reduce=None, reduction='mean', label_smoothing=0.0)
```
首先输入预测值和真实值。预测值的size为(minibatch,C)和真实值的size为(minibatch)。这里的C是类别数。
对于一个样本x的损失函数的计算如下：

![](https://img2022.cnblogs.com/blog/1617829/202209/1617829-20220913155917305-827823831.png)


x[class]真实类对应的预测概率。
损失函数中也有权重weight参数设置，若设置权重，则公式为：


![](https://img2022.cnblogs.com/blog/1617829/202209/1617829-20220913155936142-942342289.png)


当数据不平衡的时候，weight经常被使用。weight是一个1D得tensor，所以weight[class]是一个数。数据不平衡一般指的是存在一些类的样本数很少。如果类class的样本数少一些，那么weight[class]在weight中就会设置的比较大一些。
具体可参见：[链接](https://blog.csdn.net/geter_CS/article/details/84857220)
[链接](https://zhuanlan.zhihu.com/p/159477597)：可知交叉熵就通过求最大化似然估计得到的
官方[链接](https://pytorch.org/docs/stable/generated/torch.nn.CrossEntropyLoss.html)


# 8.batch normalization
直接看：https://zhuanlan.zhihu.com/p/34879333
我完全没看懂为什么使用batch normalization，但是能看懂如何进行batch normalization操作。
batch normalization：网络每次接收batch个数据，每层都会输出batch个特征向量，对每个特征进行标准化。标准化：减去平均值除以标准差，然后使用两个参数进行调整。

出现的原因：
输入变化一点点，各层的输出就会改变很多。（那小样本中是不是就要保持这一特性）
梯度下降导致了参数的变化，然后就导致了每一次分布的不同。
文中所说的分布，好像是指：对于f(x)，当输入所有的x时，f(x)得到的一群点，这群点就叫分布。


文中说，微弱的变化会被放大。我的疑问：神经网络不应该是会学习到什么地方应该放大，什么地方不应该放大吗？
文中说，梯度下降导致参数改变，导致各层分布改变。我的疑问：这不就是神经网络学习的过程吗？不应该让它变吗？
文中说这样的学习效率过慢？那这样慢慢学，会不会到达更好的效果？
看不懂，文中说的陷入梯度饱和区，不应该更不容易陷入梯度饱和区吗？

固定每一层网络输入值的分布来对减缓ICS问题？



#其他
1.assert和format的使用
```
 assert os.path.exists(image_path), "{} path does not exist.".format(image_path)
```
2.dict.items以及for的简便使用
```
cla_dict = dict((val, key) for key, val in flower_list.items())  # flower_list为一个字典
```
3.numpy与torch
numpy中有的函数，torch几乎都有对应的函数。所以如果需要对torch数组进行某种操作A时，可以百度numpy操作A。如搜索“numpy判断数组相同”比搜索“torch判断数组相同”，更容易得到想要的结果。





# 项目Test2_alexnet
结构：
```
├── model.py
├── predict.py
└── train.py
```
train.py：
]]></description></item><item><title>编程不用鼠标？操作浏览器也可以！——类vim操作</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/09/09/16674091.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Fri, 09 Sep 2022 14:20:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/09/09/16674091.html</guid><description><![CDATA[参考：https://zhuanlan.zhihu.com/p/92869469

安装：在chrome商店中查找安装Surfingkeys。

常见快捷键：
```
ctrl+T：新建标签页
j和k：上下移动
d和e：上下翻页。还可以使用空格进行下翻。 
h/l：左右滚动
f：每个可点的地方都有相应的快捷键
gg：移到最上面
G：移动最下面
ab：添加书签
b：在书签中搜索
E和R：左右移动标签页。b站自带快捷键导致无法移动。
在文本框中编辑的时候可以使用esc进行退出，然后就可以使用各种快捷键。
在文本框中编辑的时候可以使用ctrl+i开启vim编辑器。
```

视频中提到的ctrl +e ctrl +n没有用，可能是因为被chrome的快捷键给覆盖了。我还没找到修改chrome快捷键的方法。
ctrl +n也没有用。

windows以及chrome自带的快捷键，参考[windows以及chrome自带的快捷键](https://blog.csdn.net/qq_42775938/article/details/104141418)]]></description></item><item><title>Ubuntu和windows中挂载使用nas服务器</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/09/05/16659848.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Mon, 05 Sep 2022 14:26:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/09/05/16659848.html</guid><description><![CDATA[# 1. Ubuntu中挂载使用nas服务器

在将nas挂载到ubuntu上前，首先要将ubuntu系统的ip修改为和nas在同一个网段，ubuntu修改ip的命令如下：
sudo ifconfig ens33 192.168.1.31 netmask 255.255.255.0  【临时方法，重启后会失效】【参考：[链接](https://blog.csdn.net/davidhzq/article/details/102991577)】




[本博客的方法三亲测有效](https://blog.csdn.net/ShareProgress/article/details/121033909)
要注意nas地址和本地地址的格式，如：
我的nas地址为：//ip地址/share   【//不要漏写了】【share为nas中的文件名】
本地地址：使用绝对地址，如/home/ubuntu1/nas

上面临时修改ip，重启以后ip会被修改回去，此时挂载会断掉，重启以后就需要重新修改ip和执行挂载命令：
```
sudo ifconfig ens33 192.168.1.31 netmask 255.255.255.0 # 修改ip
sudo mount -a  # 执行挂载，使得/etc/fstab生效
```

# 2. windows中挂载使用nas服务器
在将nas挂载到windows上前，首先要将windows系统的ip修改为和nas在同一个网段，具体自己百度。

挂载流程如下：
![](https://img2022.cnblogs.com/blog/1617829/202209/1617829-20220906100719025-1473442731.png)

![](https://img2022.cnblogs.com/blog/1617829/202209/1617829-20220906100728570-1290911055.png)

按照示例输入地址：
![](https://img2022.cnblogs.com/blog/1617829/202209/1617829-20220906100910523-2892822.png)
最后在弹出的窗口中输入用户名和密码。
挂载成功，即可看到自己的存储盘。
]]></description></item><item><title>陈硕 Linux多线程服务端编程使用muduo C++网络库 总结</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/09/05/16659399.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Mon, 05 Sep 2022 11:59:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/09/05/16659399.html</guid><description><![CDATA[# 第六章 
库安装：按照书中写的进行安装和测试就行。

muduo采用Reactor模式，Reactor模式——要求主线程（I/O处理单元）只负责监听文件描述上是否有事件发生，有的话就立即将该事件通知工作线程（逻辑单元）。如epoll_wait——注册事件，事件发生后通知主线程，主线程将已经发生的事件放入请求队列，并唤醒请求队列上的某个线程去处理这个事件。

介绍了目录结构，我们只需要知道muduo包含基础库（包括线程库等）和网络库。公开接口和内部接口的简介可以大概看一下，知道有这个东西就行。

十几个可用于学习的实例。


《TCP网络编程本质论》，这一小节中说的东西都比较抽象，我们需要对[链接](https://www.cnblogs.com/codingbigdog/p/16244095.html)中的阻塞和非阻塞的知识进行了解，并且知道缓冲区一般指什么——缓冲区：一般指的就是一个char类型数组，这个数组可能用于装待发送数据（发送缓冲区），也可能用于装接收到的数据（接收缓冲区）。
即使只有了上面的知识，可能还是会优点迷糊，不过没关系，以后在回来看也行。

两个代码实现——echo服务和finger服务：echo服务代码可能看起来有点乱（因为没学过boost），可以先看finger服务代码，再回头过来看echo服务代码。

数独服务器：以echo服务的实现为蓝本进行实现的。

方案0~4都是阻塞式网络编程，即首先从listenfd中取出connfd，然后就一直等待客户向connfd发送数据（等待connfd变得可读），如果客户一直不发数据，那么它就一直阻塞在那里。
【设】服务器端用于监听客户请求的套接字设为listenfd；服务器端接收到的客户套接字设为connfd；客户端用于发起连接的套接字设为clientfd。

从方案5开始就引入了IO复用，IO复用select/poll/epoll的作用：以epoll为例，首先将listenfd进行上树并监听这棵树，当listenfd上有客户连接时，我们从listenfd中取出connfd，取出connfd以后，不会一直等待客户向connfd发送数据，而是将connfd加入到监听树上，此时监听树就是监听listenfd（监听是否有新连接）和connfd（监听客户发送的数据）

方案5就是使用poll设计的简单的服务器。树上如果有listenfd和connfd两个套接字，由于它们两者监听的东西不同，所以触发的处理过程也不同，这就是方案5中将这两个处理过程封装成两个独立函数的原因。

首先我们要知道——一个tcp连接可能会发送多个请求
方案6（thread per request）：每个请求都使用一个线程来处理
方案7（worker thread per connection）：每个tcp连接都使用一个线程来处理

方案8：全部的IO工作都在一个Reactor线程完成，而计算任务交给thread pool。【这不是Proactor模式吗？】

方案9（one loop per thread）：
一个Reactor是什么意思？Reactor不是一种设计模式吗？
答：这里的一个Reactor应该代表的是一个方案5的那一套代码。从书中的示例图可以看出，方案9指的是每个线程中都有IO复用函数poll，我觉得`one loop per thread`代表的就是一个线程中有一个IO复用函数poll。知道了这一点，我们再看看书中的这一段话，就清楚了许多了：
>这是muduo内置的多线程方案，也是Netty内置的多线程方 案。这种方案的特点是one loop per thread，有一个main Reactor负责 accept(2)连接，然后把连接挂在某个sub Reactor中（muduo采用round_robin的方式来选择sub Reactor），这样该连接的所有操作都在那个sub Reactor所处的线程中完成。多个连接可能被分派到多个线程中，以充 分利用CPU。

【muduo的默认线程模型为方案9】 

方案11：把方案8和方案9进行结合。用多个Reactor来处理IO，使用线程池处理计算任务。


# 第七章
看五个简单TCP示例之前，可以先复习一下echo服务器的实现，这样你就会发现这五个简单TCP示例很简单。【再看一遍，可以深入源码看一遍】
看到这五个代码的时候，发现陈硕提供的源码里都有CMakeLists.txt文件，让我们更加方便地生成可执行文件。
这五个代码中都实现了两个回调函数：连接时调用的函数（onConnection）和接收数据时调用的函数（onMessage）



# 第八章
## 8.0 
什么都不做的EventLoop：我对s00添加了注释，可以先看代码再看书，书其实讲的不是很清楚。

## 8.1 Reactor的关键结构：
本节讲Reactor最核心的事件分发机制，即将IO multiplexing拿到的IO事件分发给各个文件描述符（fd）的事件处理函数。

本节的代码中有三个类，分别为EventLoop、Poller和Channel，函数的调用过程如下：

![](https://img2022.cnblogs.com/blog/1617829/202209/1617829-20220922213519514-945063227.png)

在EventLoop类中有一个Poller类型的成员变量poller_，而poller_中存储着channel类型的对象。

Channel类：
- Channel类中有：套接字、监听的事件、发生的事件、各个事件的回调函数。channel中的成员函数update将本channel加入到EventLoop对象的成员变量poller_中。
- Channel传入本EventLoop对象来干嘛：将本channel加入到EventLoop对象的成员变量poller_中。

Poller类：Poller类只负责检测是否有事件发生，并将发生事件的channel放进activeChannels中。事件回调函数的调用不在Poller类中进行。
- Poller中使用pollfds_保存套接字和需要监听的事件。
- Poller中使用IO复用函数poll监听事件的发生，将发生事件的channel都放进activeChannels中。遍历activeChannels，调用各个channel中的事件回调函数。
- Poller传入本EventLoop对象来干嘛：调用Poller成员函数时判断当前线程和创建EventLoop对象时的线程是否一致。
- Poller.h中不使用include <poll.h>中的pollfd，而是自己前向声明了一个struct pollfd，为什么这么做？Poller.cc中又使用了include <poll.h>中的pollfd？

Reactor就是将IO multiplexing拿到的IO事件分发给各个文件描述符（fd）的事件处理函数。其中“IO multiplexing拿到IO事件”由Poller类的poll()实现，poll()返回有事件的channel。处理函数的调用由channel类实现。


8.2 TimerQueue定时器
Timer：中包含了到期时间和到期时需要调用的回调函数
TimerId：不太明白有什么用？？
TimerQueue：

如何在几乎不改其他类的情况下添加新功能





# 大并发服务器架构（陈硕muduo库源码解析）
参考：
视频：https://www.bilibili.com/video/BV1Zt411K7Gg/
ppt和示例代码：https://github.com/zhengchunxian-ai/muduo_server_learn
笔记：https://github.com/Anita-Mul/muduo


主要内容：
EXCEPTION 12
THREAD 13
mutexlock 14
无界队列和有界队列 blockingQueue 15
threadpool 16
singleton 17
线程特定数据 TSD  18
线程本地单例类封装19
日志类封装20
日志类 21 22
并发服务器设计23 24
TCP网络编程本质 25
poll/epoll 26
定时器事件 27
定时器实现28
线程与进程29
eventloopthread封装30
socket的封装31
acceptor 32
tcpserver tcpconnection 33
tcpconnection  生存期管理34
muduo库如何支持多线程35
应用层缓冲区BUffer设计 36
其他缓存和tcpconnection 中send shutdown方法37
完善tcpconnettion 38
muduo对tcp客户端程序的支持39
muduo http库源码分析40
muduo inspect库源码分析41
五个简单tcp协议42
文件传输实例 43
聊天服务器 44 45
测试两天机器延迟RTT 46
限制最大连接数 踢掉空闲连接 47
高效率多线程异步日志48
ABCBank49

P10开始介绍muduo源码，前面都是在介绍基础。


我就从p8开始看吧，前面的基础以后再看,
[大并发服务器架构（陈硕muduo库源码解析）——基础篇](https://www.cnblogs.com/codingbigdog/p/16723428.html)
]]></description></item><item><title>labuladong总结</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/09/04/16656008.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Sun, 04 Sep 2022 12:36:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/09/04/16656008.html</guid><description><![CDATA[# 双指针技巧秒杀七道链表题目
合并两个有序链表和链表的分解：
- 接收指针：用于接收的链表是带头部的，以便于返回接收结果。接收指针有两个，一个指向头部，一个指向尾部。
- 遍历指针：有几个需要遍历的链表，就有几个遍历指针。
]]></description></item><item><title>游双 网络编程总结</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/09/01/16647770.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Thu, 01 Sep 2022 12:39:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/09/01/16647770.html</guid><description><![CDATA[读书建议：如果某个地方看不懂，请将你到底不懂什么东西描述出来。你可能会发现作者在下一段就给予了你解释



1.概述：

数据链路层：ARP(IP转MAC)、RARP（MAC转IP）

网络层：IP协议、ICMP（检测网络：就是发出去看有什么回应）

传输层：TCP（可靠、连接、流）、UDP（不可靠、无连接、数据报）

应用层：ping、telnet（远程登录）、OSPF、DNS

2.MTU：帧最多能携带多少上层协议数据（比如IP数据报），如以太网帧的MTU是1500字节

ICMP协议、TCP协议和UDP协议都使用IP协议

应用层协议使用的端口号都可在/etc/services文件中找到

ARP：广播问一下“你们谁的IP是A，请告诉我你的mac为多少”

ARP协议能实现任意网络层地址到任意物理地址的转换，不过本书仅讨论从IP地址到以太网地址（MAC地址）的转换。

ARP有一个高速缓存，保存经常（最近）访问的IP到mac的映射。

Linux下可以使用arp命令来查看和修改ARP高速缓存。

使用tcpdump进行抓包，从而观察ARP通信过程

DNS：域名到IP的映射

/etc/resolv.conf文件来存放DNS服务器的IP地址

使用host命令访问DNS服务器

使用tcpdump进行抓包，从而观察DNS通信过程

socket：数据链路层、网络层和传输层协议处于内核，需要通过socket进行操作。故socket就是一个系统调用。





2.IP协议

IP协议提供无状态、无连接、不可靠的服务。

​	无状态：IP数据报的发送是相互独立的，数据报的发送没有关联。上层协议（如tcp协议）自己处理乱序的、重	复的报	文段。

​	无连接：每次发送都需要指明目的地的IP

​	不可靠：IP层检测到发送失败，IP层不会下达重传命令，而是向传输层报告错误。传输层根据报告的错误进行相	应的处理，如进行重传，当然重传的数据报也会经历传输层、网络层和数据链路层。

分层协议的每一层可以看作一个实现一定功能的函数，函数直接相互独立。上层函数中生成的数据放入下层函数进行处理，下层函数将收到的数据拆解送到上层。

将IPv4的数据报每32个bit（四个字节）分为一行，前三行为一些版本、长度等信息；第四和第五行为32位的源地址和目的地址；故IPv4的头部至少由五行（20个字节）构成。IPv4头部除了前20字节以外，还有40字节的可选选项

IP数据报的头部构成：

​		第一行：4位版本号（如IPv4或IPv6）；4位头部长度：每bit表示4个字节；8位服务类型TOS（表示此数据报要进行什么样的发送，有最小延时，最大吞吐量，最高可靠性和最小费用）；16位数据报总长度（每bit表示一个字节，故最大数据报为65535个字节，但一般MTU为1500字节，故最大数据报为1500字节）

​		第二行：16位标识（同一个分片标识相同）；3位标志字段（分别为保留、禁止分片、这是否是最后一个分片）；13位分片偏移（每bit代表8字节，代表分片在数据报中的位置）

​		第三行：8位生存时间（TTL，经过的路由跳数）；8位协议（数据报交给上层什么协议进行处理，有ICMP、TCP、UDP等）；16位CRC校验位；

​		第四和五行：32位源地址和32位目的地址

​		40字节的可选选项：记录经过的路由IP；记录被在每一跳被转发时的时间；经过指定的所有IP；只能经过指定的所有IP（traceroute程序需要使用）

使用tcpdump观察IPv4头部结构

IP分片，用tcpdump抓取分片





3.IP数据报转发

判断IP数据报是否是给本机的，如果是，则交给传输层；如果不是，则进行转发；这也侧面说明了起转发功能的路由器，只有网络层和数据链路层，没有传输层和应用层。

route命令或netstat命令查看路由表。

路由查找：1）找完全匹配的IP 2）找网络号相同的IP 3）发送给默认路由（网关）

通过route命令可以手动修改路由。BGP、RIP、OSPF等协议可以自动更新路由

主机一般只发送和接收数据报，修改/proc/sys/net/ipv4/ip_forward文件为1，则主机将具有转发功能。

ICMP重定向报文用于更新路由表：当检测到不合理的转发时，告诉说走哪条比较合理

修改/proc/sys/net/ipv4/conf/all/accept_redirects内核参数可指定是否允许接收ICMP重定向报文

主机重定向实例

IPv6协议并不是IPv4协议的简单扩展，而是完全独立的协议。





4.TCP

TCP（可靠、连接、流）、UDP（不可靠、无连接、数据报）

面向连接： 两个人打电话时，双方确认并建立连接后才能进行通信。
面向无连接：在邮局寄信时，你只需要将信放在邮筒里，不需要给收件人通知，收件人也不知道你给他寄信了。

TCP是一对一的；UDP则非常适合于广播和多播

在UDP中，如果有n个send就要有n个recv。如果recv比较少 ，会因为接收数据不及时而产生丢包。是这个意思吗？？？

可靠：每个发送都需要应答。超时重传：超过某时间未收到应答则重发

UDP协议则和IP协议一样，提供不可靠服务。它们都需要上层协议来处理数据确认和超时重传。 上层协议来处理的意思是

TCP头部结构：用于指定通信的源端端口，目的端端口，管理TCP连接等

客户端的端口号由系统自动选取，服务器则使用知名服务端口号

TCP头部选项：修改linux的某些文件启动和关闭某些选项。

使用tcpdump观察TCP头部信息

三次握手建立连接和释放连接

同步报文段和结束报文段没有携带任何应用程序数据，但它们也要占用一个序号值

半关闭状态：我告诉你我的发送已经结束了，但是我还可以收数据的

利用iptable命令过滤收到的数据包

tcpdump抓取超时重连发送的数据

/proc/sys/net/ipv4/tcp_syn_retries中可修改进行超时重连的次数

TCP的三次握手中的每次握手客户端和服务器所处的状态名称

TIME_WAIT：收到服务器的结束报文时客户端处于的状态，然后客户端将会发送确认报文。TIME_WAIT状态在持续2MSL后，会被转化成CLOSED。

TIME_WAIT的作用：1）确认丢失时，对服务器重复发送的结束报文进行处理 2）处理来迟的TCP报文

TIME_WAIT的副作用：如果程序使用的是固定的端口（如知名服务端口号），在程序结束后，端口会被占用一段时间，导致程序重启。

服务器程序可以通过设置socket选项SO_REUSEADDR来强制使用被处于TIME_WAIT状态的连接所占用的socket地址。

我们也可以通过修改内核参数/proc/sys/net/ipv4/tcp_tw_recycle来快速回收被关闭的socket，从而使得TCP连接根本就不进入TIME_WAIT状态

复位报文段：复位报文段就是携带RST标志的报文段，以通知对方关闭连接或重新建立连接。

1）访问不存在端口或处于TIME_WAIT的端口时，对方将会返回复位报文段

2）一旦**发送了**复位报文段，**发送端**所有排队等待发送的数据都将被丢弃。这是异常终止连接的方法。

3）A关闭连接或异常终止了连接，而B没有接收到结束报文段，此时B如果发送信息，A就会返回复位报文段。





5.TCP交互数据流：

​		客户端对服务器返回数据的确认都不带应用程序数据。这是因为要携带应用程序数据要等用户输入才行，而用户输入的速度是比较慢。

​		服务器对客户端返回数据的确认一般都带应用程序数据。这里的确认是指对客户端发送请求的确认，而携带的应用程序数据是指客户端请求的数据。所以一般是将客户端请求的数据和对请求的确认一起发送回客户端。

​		Nagle算法：每输入一个字符就用一个TCP报文进行传输，这样会导致网络拥塞。Nagle算法：报文未被确认之前不发送新的报文，但发送方在等待确认的同时收集本端需要发送的数据，并在确认到来时以一个TCP报文段将它们全部发出。

TCP成块数据流：发送方会连续发送多个TCP报文段，接收方可以一次确认所有这些报文段。服务器每发送4个TCP报文段就传送一个PSH标志（tcpdump输出标志P）给客户端，以通知客户端的应用程序尽快读取数据

外带数据：用于告诉对方本端发生的紧急事件。一般使用TCP头部中的紧急指针标志和紧急指针两个字段。接收端只将紧急事件的最后一个字节读入一个特殊的缓存

TCP设置SO_OOBINLINE选项时，则带外数据将和普通数据一样被TCP模块存放在TCP接收缓冲区中。紧急指针可以用来指出带外数据的位置

iperf是一个测量网络状况的工具

TCP超时重传：TCP服务必须能够重传超时时间内未收到确认的TCP报文段。重传几次后，就尝试利用ARP重新获取目的地的mac地址。

控制超时重传次数的文件：：/proc/sys/net/ipv4/tcp_retries1和/proc/sys/net/ipv4/tcp_retries2。故有这样一个认识，所有我们学习的网络传输协议都是用一个一个文件实现的。如果我们要修改某一个协议中的某一个值时候，只需要百度“linux修改xx”就可以了。所以说linux中万物都是文件。





6.以下内容几乎全部摘录自《计算机网络 by谢希仁》，因为《计算机网络 by谢希仁》和《Linux高性能服务器编程 by 游双》对本部分内容的讲述有所出入。有时间在对这部分内容进行深究。

可靠传输：

​		以字节为单位的滑动窗口：1）A收到确认，根据确认号和接收方窗口值调整窗口 2）B收到从头开始的连续字节，窗口才能向前移动并发出确认

​		超时重传的时间选择

​		SACK：告诉发送方，我那个部分没有收到，请你再发一下。

流量控制：

​		发太快，来不及接收：发送窗口不能比接收方给出的接收窗口大

​		发太小：使用Nagle算法——先将第一个数据字节发送出去，然后就等待对此数据报的确认并在等待期间缓存所有到达的数据。当收到确认或数据达到发送窗口大小的一半或数据达到最大长度，就立刻发送一个报文段。

​		糊涂窗口综合征：接收方发送的确认，它确认的数据太小，使得发送窗口增长缓慢。解决方法：1）等接收缓存可以装一个最长报文时，再发确认。或 2）等接收缓存一半是空闲的。**这样老是等这等那的，不就不能实现实时的传输了？？？？**

拥塞控制：

​		慢开始：拥塞窗口cwnd初始化为2~4SMSS（最大报文段）。每收到一次确认，拥塞窗口就增加min(N,SMSS)，其中N为此次确认中包含的之前未被确认的字节数，SMSS为最大报文段的字节数。每经过一个轮次cwnd就翻倍（具体见计算机网络（谢希仁））。

​		拥塞避免：当cwnd超过门限值时，则每个轮次cwnd都加1（即线性增加），而不是每个轮次cwnd都翻倍。(《Linux高性能服务器编程 by 游双》对线性增加提到了其他的算法)

​							当发生超时，门限值=cwnd/2，cwnd=1

​		快重传：接收方已发送M2的确认后，若未收到M3，则M4、M5……每到达一个都会使接收方发送一个对M2的重复确认。当发送方收到三个重复的确认时，则发送方就会赶快重发M3（快重传）。

​		快恢复：出现快重传时，使用快恢复。门限值=cwnd/2，cwnd=门限值，即立刻开启拥塞避免算法。

拥塞发生依据：1）超时却未收到确认 2）受到三个对同一报文的重复确认





7.linux下设置代理：export http_proxy=“ip:端口”。

正向代理：将我们的请求送给正向代理服务器，让它替我们请求

反向代理：通过反向服务器将众多请求分散给多个服务器，实现负载均衡。大型网站通常将反向代理作为公网访问地址，阻止web攻击

透明代理：我理解的是：网关总是将请求发送给一个正向代理服务器，则称为透明代理。此时不需要对局域网内的所有主机进行设置，所有主机都通过网关使用正向代理服务器。应该就是通过路由器翻墙的原理。

在服务器上配置squid程序就可以实现代理。squid是一个支持所有代理的软件。

使用tcpdump抓取传输数据包

squid程序通过读取/etc/resolv.conf文件获得DNS服务器的IP地址。**这个IP地址是自动生成的吗？？？**

Linux将目标主机名及其对应的IP地址存储在/etc/hosts配置文件，如果程序在/etc/hosts文件中未找到目标机器名对应的IP地址，它将求助于DNS服务。

用户可以通过修改/etc/host.conf文件来自定义系统解析主机名的方法和顺序（一般是先访问本地件/etc/hosts，再访问DNS服务）

TCP连接中，发送结束报文的同时是可以携带数据的

HTTP的请求：HTTP的九种请求方法。Linux中的命令：HEAD、GET和POST。其含义基本与HTTP协议中的同名请求方法相同。

HTTP的应答：状态码（如404）；Cookie（携带用户信息）





8.第五章：
1.socket的主要API都定义在sys/socket.h头文件

实现主机名和IP地址之间的转换，以及服务名称和端口号之间的转换，定义在netdb.h头文件

字节序分为大端字节序（big endian）和小端字节序（little endian）。

现代PC大多采用小端字节序，因此小端字节序又被称为主机字节序。

一般大端字节序也称为网络字节序，即在网络中一般将字节序统一转化为大端进行传播，即接收方收到的第一个字节被当作高位看待

通过c语言的union结构实现机器的字节序的判断

将数据转化为同一种字节序进行传输的四个函数

2.通用socket地址结构体： sockaddr_storage和sockaddr，可以用于存放IPv4或IPv6地址等

地址族与协议族对应表。在bits/socket.h头文件中，地址族与协议族可以混用。

通用socket地址结构体设置与获取IP地址和端口号较烦琐，故一般使用专用socket地址结构体，如sockaddr_in和sockaddr_in6用于IPv4和IPv6。所有专用socket地址（以及sockaddr_storage）类型的变量在实际使用时都需要转化为通用socket地址类型sockaddr（强制转换即可），因为所有socket编程接口使用的地址参数的类型都是sockaddr（所有与socket编程相关的函数使用的地址参数的类型都是sockaddr）。

十进制字符串表示IPv4地址，以及用十六进制字符串表示IPv6地址。

（用点分十进制字符串表示的IPv4地址或用十六进制字符串表示的IPv6地址）和用网络字节序整数表示的IP地址之间的转换的函数



socket在linux中被当成文件描述符

socket函数：初始化socket，返回一个int类型

bind函数：给socket绑定IP和端口

listen函数：让socket处于监听状态

accept函数：从监听队列中获取连接

accept调用对于客户端网络断开毫不知情（这里与作者的实验和我的实验结果完全不一致？？？）

accept只是从监听队列中取出连接，而不论连接处于何种状态（如上面的ESTABLISHED状态和CLOSE_WAIT状态），更不关心任何网络状况的变化（这里与作者的实验和我的实验结果完全不一致？？？）

connnect：与服务器建立连接并返回一个socket供客户端读写，通过对socket的读写来与服务器进行通信。实际上只返回了一个int类型的变量，这就说明了connnect在系统内部完成了对真正的socket进行了一系列操作。

close：关闭指定的套接字。如果不止有一个进程引用了该套接字，则close的作用变为将套接字的引用计数减一。

shutdown：不论是否有其他进程引用了该套接字，都关闭此套接字。shutdown还可以只关socket的读或写。



linux下可以使用read和write或recv和send对数据进行读写。

recv成功时返回实际读取到的数据的长度，它可能小于我们期望的长度len。因此我们可能要多次调用recv，才能读取到完整的数据

send成功时返回实际写入的数据的长度

flags参数为数据收发提供了额外的控制，通常设置为0。flags参数只对send和recv的当前调用生效，而后面我们将看到如何通过setsockopt系统调用永久性地修改socket的某些属性。

发送和接收外带数据（紧急数据）。接收紧急数据会导致正常的数据不能通过一个recv调用全部读出

socket编程接口中用于UDP数据报读写的系统调用是recvfrom和sendto。recvfrom/sendto系统调用也可以用于面向连接（STREAM）的socket的数据读写，只需要把最后两个参数都设置为NULL

socket编程接口还提供了通用数据读写函数（recvmsg和sendmsg）

内核通知应用程序带外数据到达的两种常见方式是：I/O复用产生的异常事件和SIGURG信号。

利用sockatmark判断读取的数据是否为外带数据，然后利用带MSG_OOB标志的recv调用来接收带外数据

获取本端socket地址以及远端的socket地址：getsockname和getpeername



fcntl系统调用是控制文件描述符属性的通用POSIX方法。getsockopt和setsockopt是专门用来读取和设置socket文件描述符属性的方法。getsockopt和setsockopt通过设置socket选项的方法来读取和设置socket文件描述符属性

服务器端的有些soket选项必须在调用listen前进行设置才会有效，即三次握手前设置。客户端的有些soket选项必须在调用connnect前进行设置才会有效，即三次握手前设置。

listen监听队列中接受的连接至少已经完成了TCP三次握手的前两个步骤。connect调用后，TCP三次握手就已完成

对监听socket设置这些socket选项，那么accept返回的连接socket将自动继承这些选项。（这句话什么意思，什么叫监听socket选项）

SO_REUSEADDR选项：

​		服务器程序可以通过设置socket选项SO_REUSEADDR来强制使用被处于TIME_WAIT状态的连接所占用的socket地址。

​		我们也可以通过修改内核参数/proc/sys/net/ipv4/tcp_tw_recycle来快速回收被关闭的socket，从而使得TCP连接根本就不进入TIME_WAIT状态

SO_RCVBUF和SO_SNDBUF选项：

​		设置接受和发送缓存的大小，设置的大小不能低于系统设定的最小值。我们可以修改/proc/sys/net/ipv4/tcp_rmem和/proc/sys/net/ipv4/tcp_wmem来强制TCP接收缓冲区和发送缓冲区的大小没有最小值限制。

​		这里有一个通过tcpdump抓取的通信过程，很有意思可以看一看

SO_RCVLOWAT和SO_SNDLOWAT选项（一般设为1）：大于SO_RCVLOWAT时可读，大于SO_SNDLOWAT可写

SO_LINGER选项：

​		用于控制close系统调用在关闭TCP连接时的行为。（如果通过close没有成功关闭，而是引用计数减一，此时这些行为还会发生吗？？）

​		l_onoff等于0：代表此功能关闭

​		l_onoff不为0，l_linger等于0：丢弃TCP发送缓冲区中残留的数据，发送复位报文段，这种情况给服务器提供了异常终止一个连接的方法

​		l_onoff不为0，l_linger大于0：具体见书中内容



可以用主机明代替IP地址，用服务器名代替端口号。

gethostbyname和gethostbyaddr：

​		gethostbyname函数通常先在本地的/etc/hosts配置文件中查找主机，如果没有找到，再去访问DNS服务器。

​		gethostbyaddr函数根据IP地址获取主机的完整信息。

getservbyname和getservbyport：getservbyname函数根据名称获取某个服务的完整信息，getservbyport函数根据端口号获取某个服务的完整信息。它们实际上都是通过读取/etc/services文件来获取服务的信息的。

上面四个函数都是不可重入的，但有可重入的版本。

正如Linux下所有其他函数的可重入版本的命名规则那样，这些函数的函数名是在原函数名尾部加上_r（re-entrant）。

getaddrinfo：可通过主机名获取IP，通过服务器名获取端口号。

getnameinfo：通过socket地址同时获得以字符串表示的主机名和服务名





第六章 高级I/O函数：本章实际上本质是对文件描述符进行操作的函数进行介绍

用于创建文件描述符的函数，包括pipe、dup/dup2函数

用于读写数据的函数，包括readv/writev、sendfile、mmap/munmap、splice和tee函数。

用于控制I/O行为和属性的函数，包括fcntl函数



pipe函数创建的这两个文件描述符fd[0]和fd[1]分别构成管道的两端。用fd[1]写入的数据，用fd[0]读出。

写端文件描述符fd[1]的引用计数减少至0，则fd[0]的read操作将返回0，即读取到了文件结束标记（EOF）

读端文件描述符fd[0]的引用计数减少至0，则fd[1]的write操作将失败，并引发SIGPIPE信号

我们可以使用fcntl函数来修改管道容量

socketpair函数方便地创建双向管道。



dup和dup2：复制文件描述符。dup——取当前可用最小整数值作为文件描述符。dup——取第一个不小于file_descriptor_two的整数值作为文件描述符。

【注】通过dup和dup2创建的文件描述符并不继承原文件描述符的属性，比如close-on-exec和non-blocking等（这两个是啥？？我怎么不记得见过？？）

先关闭标准输出文件描述符STDOUT_FILENO（其值是1），然后通过dup()复制socket文件描述符connfd。此时由于1是最小可用的，c故onnfd就被复制到了值为1的文件描述符上。此时printf产生的输出会传送到客户端中。



readv函数将数据从文件描述符读到分散的内存块中，即分散读；writev函数则将多块分散的内存数据一并写入文件描述符中，即集中写。

Web服务器上实现集中写的程序



sendfile函数实现：两个文件描述符之间的传递数据完全在内核中操作，从而避免了内核缓冲区和用户缓冲区之间的数据拷贝，这种数据传递也叫零拷贝。

用sendfile函数传输文件的一个程序。和“Web服务器上实现集中写的程序”实现相同功能，但是简单多了。



mmap函数和munmap函数：用于申请和释放内存。申请的内存可以作为进程间通信的共享内存

POSIX是IEEE为要在各种UNIX操作系统上运行的软件而定义的**一系列API标准的总称**

上面提到的大多数函数都是成功时返回0或操作东西的数量，失败则返回-1并设置errno。



splice函数：用于在两个文件描述符之间移动数据，也是零拷贝操作。fd_in和fd_out必须至少有一个是管道文件描述符。

将客户端发送的数据原样返回给客户端的程序



tee：tee函数在两个管道文件描述符之间复制数据，也是零拷贝操作，它不消耗数据（啥叫不消耗数据？？）。fd_in和fd_out必须都是管道文件描述符

6-5代码标注：从STDIN_FILENO就可以看出来，只要使用相应的文件描述符，就可以对系统内已经定义好的文件描述符进行使用



fcntl函数：提供了对文件描述符的各种控制操作，ioctl比fcntl能够执行更多的控制。

将文件描述符设置为非阻塞的（这会产生什么效果呢？？？）

当被关联的文件描述符可读或可写时，系统将触发SIGIO信号；当被关联的文件描述符（而且必须是一个socket）上有带外数据可读时，系统将触发SIGURG信号。将信号和文件描述符关联的方法，就是使用fcntl函数为目标文件描述符指定宿主进程或进程组。使用SIGIO时，还需要利用fcntl设置其O_ASYNC标志。SIGIO和SIGURG这两个信号与其他Linux信号不同





第七章 Linux服务器程序规范

后台进程（守护进程）、日志系统、linux服务器程序拥有自己的运行账户、配置文件、linux服务器进程启动时会生成一个PID文件



**日志这部分没有实例，我完全看不懂？？？？？**

Linux提供一个守护进程来处理系统日志——syslogd，现在一般用rsyslogd（syslogd升级版）

rsyslogd守护进程可以接收用户进程输出的日志和内核日志。

用户进程通过**syslog函数**生成系统日志并将日志放入到/dev/log中，rsyslogd则监听该文件以获取用户进程的输出

内核日志由printk等函数打印至内核的环状缓存（ring buffer）中。环状缓存的内容直接映射到/proc/kmsg文件中。rsyslogd则通过读取该文件获得内核日志。

rsyslogd守护进程的各种配置文件的说明

syslog函数：应用程序使用syslog函数与rsyslogd守护进程通信。

openlog应该是对输出日志内容的补充。对后续syslog调用的行为进行配置。

setlogmask：用于设置掩码，日志级别大于掩码的信息被忽略

closelog()：关闭掩码

什么叫日志，保存日志干嘛，日志保存起来不就行。那处理系统日志——syslogd是用来干嘛的？？举一个例子说明一下，这玩意能干嘛？？找一个有关于rsyslogd和syslog函数的实例



一个进程拥有两个用户ID：UID和EUID

EUID：如果程序设置了set-user-id标志，那么当某用户使用该程序时，此用户的EUID变为该程序拥有者的ID，同时该用户暂时具有该程序拥有者的权限。如使用su程序时，EUID为0（root），用户暂时拥有了root用户的权限，

给程序test_uid设置set-user-id标志：sudo chomd +s  test_uid

将以root身份启动的进程切换为以一个普通用户身份运行。

大部分服务器就必须以root身份启动，但不能以root身份运行

每个进程都具有GID和EGID吗？？它们是干嘛的？？和进程组是什么关系？？



Linux下每个进程都隶属于一个进程组，因此它们除了PID信息外，还有进程组ID（PGID）

每个进程组都有一个首领进程，其PGID和PID相同。

 getpgid：获得进程所在的进程组的ID

setpgid：设置当前进程到某个进程组



一些有关联的进程组将形成一个会话

setsid用于创建会话，该函数**不能**由进程组的首领进程调用。

调用setsid会产生的效果：1）调用进程称为会话首领 2）新建一个进程组，调用进程成为此进程组的首领 3）调用进程甩开终端

getsid获取会话的SID，SID就是首领所在的进程组的PGID。



ps命令可查看进程、进程组和会话之间的关系

用于系统资源限制的函数：getrlimit和setrlimit，如可以设置用户可以创建的进程数限制。

Web服务器的逻辑根目录并非文件系统的根目录“/”，而是站点的根目录（对于Linux的Web服务来说，该目录

一般是/var/www/）。所以需要改变进程的根目录。

获取进程当前工作目录和改变进程工作目录的函数分别是：getcwd和chdir

通过chroot可以改变函数的根目录，chroot并不改变进程的当前工作目录，所以调用chroot之后，我们仍然需要使用chdir(“/”)来将工作目录切换至新的根目录。改变进程的根目录之后，程序可能无法访问类似/dev的文件（和目录），因为这些文件（和目录）并非处于新的根目录之下。

 daemon函数：服务器程序后台化



除了TIME_WAIT，去记录以下FIN_WAIT1等东西是啥，并解决accept那里运行与作者的结果不一致问题。





第八章 高性能服务器程序框架（后续章节的总览）

I/O处理单元、逻辑单元、提高服务器性能的其他建议



I/O处理单元：服务器和客户端之间的通信过程实际上对socket文件的读写过程，也就是一个输入输出的过程（I\O的过程）。所以I/O处理单元应该是用于同时处理多个客户端请求的方式。

逻辑单元：服务器给客户端分配的逻辑单元是由fork系统调用创建的子进程。也就是给每一个客户端的请求都分配一个子进程来进行处理



C/S模型非常适合资源相对集中的场合，并且它的实现也很简单，但其缺点也很明显：服务器是通信的中心，当访问量过大时，可能所有客户都将得到很慢的响应。

P2P模型可以看作C/S模型的扩展：每台主机既是客户端，又是服务器。



服务器程序种类繁多，但其基本框架都一样，不同之处在于逻辑处理

服务器编程框架：I/O处理单元、请求队列、逻辑单元、网络存储单元

I/O处理单元：

​		单个服务器程序：等待并接受新的客户连接。也有可能接收客户数据，将服务器响应数据返回给客户端

​		服务器机群：它实现负载均衡，从所有逻辑服务器中选取负荷最小的一台来为新客户服务。

逻辑单元：

​		单个服务器程序：它分析并处理客户数据，然后将结果传递给I/O处理单元或者直接发送给客户端。一个逻辑单元通常是一个进程或线程

​		服务器机群：一个逻辑单元本身就是一台逻辑服务器。

网络存储单元：可以是数据库、缓存和文件，甚至是一台独立的服务器。但它不是必须的。

请求队列：请求队列是各单元之间的通信方式的抽象（这是什么意思，我不理解？？？）。请求队列通常被实现为池的一部分。



I/O模型 

socket在创建的时候默认是阻塞的。我们可以给socket系统调用的第2个参数传递SOCK_NONBLOCK标志，或者通过fcntl系统调用的F_SETFL命令，将其设置为非阻塞的

阻塞I/O：系统调用可能因为无法立即完成而被操作系统挂起，直到等待的事件发生为止。如调用recv后，需要等待对方send的数据送达。非阻塞I/O中，调用recv后，程序会继续执行下一条命令，在对方send的数据送达时，程序会接收到相应通知（通知一般是内核发送给程序的），并调用相应的处理函数。

socket的基础API中，可能被阻塞的系统调用包括accept、send、recv和connect。

通过I/O复用和SIGIO信号可以实现非阻塞I/O：如，非阻塞I/O中，调用recv后，程序会继续执行下一条命令，在对方send的数据送达时，程序会接收到SIGIO信号，SIGIO信号的信号处理函数将被触发。

I/O复用函数本身是阻塞的，它们能提高程序效率的原因在于它们具有同时监听多个I/O事件的能力，当监听到相应的事件就给相应的程序发送相应的通知。。

I/O复用函数是select、poll和epoll_wait

同步I/O与异步I/O

POSIX规范所定义的异步I/O模型：数据的读写处理完全由内在内核中



两种高效的事件处理模式：Reactor和Proactor。

服务器程序通常需要处理三类事件：I/O事件、信号及定时事件。

同步I/O模型通常用于实现Reactor模式，异步I/O模型则用于实现Proactor模式。不过，也可以使用同步I/O方式模拟出Proactor模式。

Reactor模式：要求主线程（I/O处理单元）只负责监听文件描述上是否有事件发生，有的话就立即将该事件通知工作线程（逻辑单元）。如epoll_wait——注册事件，事件发生后通知主线程，主线程将已经发生的事件放入请求队列，并唤醒请求队列上的某个线程去处理这个事件。

Proactor模式：与Reactor模式不同，Proactor模式将所有I/O操作都交给主线程和内核来处理，工作线程仅仅负责业务逻辑。以aio_read和aio_write为例——注册事件并告诉内核读（写）缓冲区的位置，当socket上的数据被读入用户缓冲区后 或 当用户缓冲区的数据被写入socket之后，向应用程序发送一个信号，以通知应用程序数据处理。
我理解的Proactor模式：以['https://blog.csdn.net/qq_44345567/article/details/106039844">链接1</a>进行操作。<br> <img src="https://img-blog.csdnimg.cn/62f516ee04744fd48a5aio_read和aio_write为例——主线程中注册事件并定义一个变量buf用于接收客户发送过来的数据。事件经过上面的注册以后，当客户发送数据过来的时候，内核就会自动地将数据放入buf中并触发工作线程去处理buf中的数据。也就是说Reactor模式的工作线程处理的是一个一个套接字，然后从套接字中读取数据 或 使用套接字发送数据。
而Proactor模式的工作线程处理的是一个一个具体的数据，而所有的I/O操作都放在了主线程和内核中（即所有对套接字的读写都放在了主线程和内核中）


模拟Proactor模式：主线程执行数据读写操作，读写完成之后，主线程向工作线程通知这一“完成事件”。



服务器的两种高效的并发模式：半同步/半异步（half-sync/half async）模式和领导者/追随者（Leader/Followers）模式。



半同步/半异步模式：

这里的同步和异步和I/O模型中所说的不同。

“同步”指的是程序完全按照代码序列的顺序执行；异步：程序顺序执行的过程中，可能有有各种事件触发各种函数的执行

同步和异步的优缺点

半同步/半异步模式：结合同步和异步。异步线程监听客户请求、将请求插入请求队列中。请求队列将通知某个工作在同步模式的工作线程来读取并处理该请求对象。

为什么感觉I/O模型和半同步/半异步模式描述的是一个东西？？？答：确实好像就是一个东西

半同步/半异步模式的变种——半同步/半反应堆（half-sync/half-reactive）模式：半同步/半反应堆模式采用的事件处理模式是Reactor模式，它要求工作线程自己从socket上读取客户请求和往socket写入服务器应答。

半同步/半反应堆模式的缺点

 高效的半同步/半异步模式：无请求队列，主线程只管理监听socket，连接socket由工作线程来管理。



领导者/追随者模式：轮流做领导去监听I/O事件，有事件时，领导就派追随者去处理或领导自己去处理（此时可调用promote_new_leader选出新的领导）

句柄Handle：一个文件描述符。领导将事件处理器绑定到Handle上，当Handle上检测到事件，领导调用事件处理器进行处理



有限状态机：

根据数据包类型对应不同状态，不同状态编写不同的处理逻辑。执行完一个逻辑后就改变状态，不同的状态就可以执行不同的逻辑。

没看完，看得我很烦！！！以后再说吧！草



提高服务器性能的其他建议：

池：从池中获取硬件资源，池中的资源是预先静态分配的，如果资源不够时，就再动态分配一些并加入池中。池可分为多种，常见的有内存池、进程池、线程池和连接池

- 内存池：用于socket的接收缓存和发送缓存

- 进程池和线程池：用于并发编程。拿一个进程或线程出来处理新来到的客户请求

- 连接池：很多建好的与数据库的连接，只需要从连接池中取出连接，就可以访问数据库。

数据复制

- 当应用程序不关心数据内容时，可以直接用零拷贝
- 当两个工作进程之间要传递大量的数据时，使用共享内存来在它们之间直接共享这些数据，而不是使用管道或者消息队列来传递

上下文切换和锁





# 第九章 I/O复用
I/O复用：监听多个文件描述符上面的事件
先看[我对I/O复用的总结](https://www.cnblogs.com/codingbigdog/p/16244095.html)



EPOLLONESHOT事件：
select、poll和epoll都能同时监听多个文件描述符，通过某种结构体变量来告诉内核监听哪些文件描述符上的哪些事件，并使用该结构体类型的参数来获取内核处理的结果。

select：只能处理可读、可写及异常事件，需要用三个参数分别处理这三种事件
poll：任何事件都被统一处理，接口较为简洁。每次select和poll调用都返回整个用户注册的事件集合（其中包括就绪的和未就绪的）
epoll：它在内核中维护一个事件表，返回就绪的事件
select和poll都只能工作在相对低效的LT模式，而epoll则可以工作在ET高效模式。并且epoll还支EPOLLONESHOT事件。

EPOLLONESHOT事件：一个socket连接在任一时刻都只被一个线程处理，直到此线程处理完毕以后，其他线程才能处理此socket，实现过程如下：文件描述符fd注册了EPOLLONESHOT事件，则操作系统最多触发fd上注册的一个可读、可写或者异常事件，且只触发一次，触发以后，epoll就检测不到fd上面发生的事件。触发事件一般会开启一个线程去处理相应的事件。此线程最后要将fd上的EPOLLONESHOT事件重置，这样使得epoll有机会再次检测到fd上的事件，进而使得其他线程有机会为fd服务。
从上面可以看出，注册了EPOLLONESHOT事件以后，每一个时刻只有一个线程在对fd进行操作。EPOLLONESHOT事件解决的是同一个时刻，有多个线程操作同一个套接字的情况。

EPOLLONESHOT事件的示例代码、其他的示例代码。

linux内部实现了一个超级服务xinetd，用于处理telnet、echo等操作。









# 第十章 信号

信号：通知进程的信息

kill函数：一个进程给其他进程发送信号的API是kill函数

可以自定义一个处理信号的函数，也可以使用SIG_IGN（忽略信号）和SIG_DFL（使用信号的默认处理方式）

Linux信号

使用sigaction函数可以重启被信号中断的系统调用

信号掩码指定哪些信号不能发送给本进程

我有时看到复杂的数据类型的名字的时候我会有点懵，但是没有关系，我就把它理解成一个类（事实上也有可能是一个结构体等）

signal函数：传入信号处理函数的指针和要捕获的信号

sigaction比较高级的signal函数



Linux使用数据结构sigset_t来表示一组信号，以及对sigset_t的一些操作

sigprocmask用于设置或查看进程的信号掩码

被挂起的信号：收到被屏蔽的信号，信号会被挂起。等到屏蔽被取消以后，进程会立即获取该信号。多次获取到同一被屏蔽的信号，屏蔽在被取消以后，该信号的处理函数也只被触发一次

sigpending获得进程当前被挂起的信号集

fork调用产生的子进程将继承父进程的信号掩码，但具有一个空的挂起信号集。



信号处理函数往管道的写端写入信号值，主循环监听管道的读端文件描述符上的可读事件。信号事件就能和其他I/O事件一样被处理，即统一事件源

代码没看



网络编程相关信号

SIGHUP信号可以用来强制服务器重读配置文件

xinetd处理SIGHUP的流程

往一个读端关闭的管道或socket连接中写数据将引发SIGPIPE信号

用SIGURG检测带外数据是否到达。代码还没看


黑马程序员笔记：https://www.cnblogs.com/codingbigdog/p/16246557.html





# 第11章  定时器
定时器：用于计时，时间到了，就去处理相应的任务。如过一定时间就去检测一个客户连接的活动状态。

Linux提供了三种定时方法：**socket选项SO_RCVTIMEO和SO_SNDTIMEO、SIGALRM信号、I/O复用系统调用的超时参数。**

**1.socket选项SO_RCVTIMEO和SO_SNDTIMEO**：使用setsockopt函数和选项SO_RCVTIMEO/SO_SNDTIMEO给socket设置接收数据超时时间和发送数据超时时间。函数send、sendmsg、recv、recvmsg、accept和connect中使用此socket会产生不同的效果。
send、sendmsg、connect：在一定时间没有将数据发送成功，返回错误。
recv、recvmsg、accept：在一定时间没有接收到数据，返回错误。
**代码11-1connect_timeout.cpp**：connect中使用设置定时的套接字——十秒之内没有连接成功，返回错误。

**2.SIGALRM信号：**由alarm和setitimer函数设置的实时闹钟一旦超时，将触发SIGALRM信号（见[C++ 信号处理](https://www.cnblogs.com/codingbigdog/p/16246557.html)）。因此，我们可以利用该信号的信号处理函数来处理定时任务。本书中介绍了两个具体的定时器实现代码：
- 基于升序链表：将定时器都放入一个链表中，链表按照超时时间做升序排序。
代码：util_timer结构体代表一个定时器，其中包含一个时间，包含一个回调函数
sort_timer_lst类：用于生成一个升序的定时器链表，并通过成员函数添加、删除链表中的定时器
- 升序定时器链表的实际应用——关闭非活动连接：将超过一定时间没有使用的套接字从epoll树上删除。
代码：每隔一段时间alarm发送一个SIGALRM信号，信号处理函数通过通道将此信号通知给主循环，主循环中通过tick()遍历定时器链表并删除超时套接字。

**3.I/O复用系统调用的超时参数：**将epoll_wait函数的形参timeout设为相应的值。经过timeout的时间后，epoll_wait会被触发并epoll_wait的返回值为0。



管理定时器的容器：时间轮和时间堆。容器指的是装一个一个定时器的地方。
- 时间轮：一个轮子上有N个槽，每个槽代表一个链表。每一个链表代表一个时间。比如一个槽代表一秒，一圈有六十槽，那么一圈就代表六十秒。当指针指向了第n个槽的时候，可能代表已经过了n秒（假设一个槽代表一秒），也可能代表过了N+n、2N+n、3N+n...秒。处理该槽上超时的节点，并删除此节点。
代码：使用数组tw_timer *slots[N]表示时间轮，slots中每个元素指向一个定时器链表，链表无序。
tw_timer类用于表示定时器，成员变量rotation表示圈数，time_slot表示定时器属于时间轮上哪个槽。在本代码中，一个槽代表一秒，一圈六十秒，所以rotation=x，time_slot=y代表x分t秒。

- 时间堆：使用最小堆来存储定时器，每一次都将堆顶的定时器的超时时间作为依据，当超时时间到了就执行堆顶定时器的任务，并删除堆顶元素。
代码：还没看。











































# 问题：

1.wan和lan的区别？？

2.如何根据IP数据报中的8位服务类型TOS，实现相应服务？？

3.在5.1.2中的内存对齐是什么意思？？ 

4.在5.4中的程序想要说明什么？？？我没看懂？、

5.“3.9 TCP超时重传”有个问题未解决？？？

6."P172内存对齐"是什么？？

7.“p175void指针”

8."宏有什么用？直接定一个变量不就行了"

9.什么叫不可重入？

答：如果一个函数的执行期间被中断后，到重新恢复到断点进行执行的过程中，函数所依赖的环境没

有发生改变，那么这个函数就是可重入的

我们知道中断时确实保存一些上下文，但是仅限于返回地址，cpu寄存器等之类的少量上下文，而函

数内部使用的诸如全局或静态变量，buffer等并不在保护之列，所以如果这些值在函数被中断期间发

生了改变，那么当函数回到断点继续执行时，其结果就不可预料了。

10.CGI服务器啥？？

11.人手一个的web服务器项目，我该如何脱颖而出？
答：C++基础基础较为牢固、算法题做得比较好、还有其他别的项目、我学的正是进去工作以后要用的。。。。。。。。]]></description></item><item><title>C++ delete进行了什么操作</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/09/01/16646690.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Thu, 01 Sep 2022 07:29:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/09/01/16646690.html</guid><description><![CDATA[


```
#include<iostream>

class A{
public:
        void t(){
                std::cout<< "hello world!" << std::endl;
        }
        ~A(){
                std::cout<< "调用析构函数" << std::endl;
        }
        int a;
};

int main(){
        A *p = new A;
        p->a = 2;
        delete p;
        p->t();
        std::cout << "p->a:" << p->a << std::endl;

        return 0;
}
```
输出：
```
调用析构函数
hello world!
p->a:0
```
delete p操作首先会调用p指向对象的析构函数，然后将成员变量a置空，但是delete操作并没有将p所指向的内存全部置空，这就是为什么依然可以通过p->t()和p->a访问成员的原因。

还需要注意的是：delete操作并没有将t()删除，因为t()是所有对象共有的。

还可以参考[链接](https://bbs.csdn.net/topics/392044647)进行学习。
]]></description></item><item><title>leetcode临时存储</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/08/31/16643326.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Wed, 31 Aug 2022 07:39:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/08/31/16643326.html</guid><description><![CDATA[```

class Solution {
public:
    int binarySearch(vector<int>& nums, int target, bool lower) {
        int left = 0, right = (int)nums.size() - 1, ans = (int)nums.size();
        while (left <= right) { 
            int mid = (left + right) / 2; // 中间偏左的数，所以mid在某一时刻会落在left上
            if (nums[mid] > target || (lower && nums[mid] >= target)) {
                right = mid - 1;
                ans = mid; 
            } else {
                left = mid + 1;
            }
        }
        return ans;
    }

    int search(vector<int>& nums, int target) {
        int leftIdx = binarySearch(nums, target, true); // 找第一个大于等于target 的下标
        int rightIdx = binarySearch(nums, target, false) - 1; // 第一个大于target 的位置减一
        if (leftIdx <= rightIdx){   //&& rightIdx < nums.size() && nums[leftIdx] == target && nums[rightIdx] == target) {
            return rightIdx - leftIdx + 1;
        }
        return 0;
    }
};
```

1.binarySearch函数中的nums[mid] >= target与nums[mid] > target的区别？
答：首先明白两点：
- 使用二分法不断地移动左右两边，ans每次都是查找范围的最右边+1。
- 当lower为true时，nums[mid] > target || (lower && nums[mid] >= target)等价于nums[mid] >= target
当lower为false时，nums[mid] > target || (lower && nums[mid] >= target)等价于nums[mid] > target

则：
如果nums中有target，那么肯定会有left和right之间全都是target的时刻，此时nums[mid] > target和nums[mid] >= target的区别就显现出来了，前者是left向右移，后者是right向左移。


2.search中的rightIdx < nums.size() && nums[leftIdx] == target && nums[rightIdx] == target可以没有吗？
答：可以。如果nums中没有target，那么binarySearch(nums, target, false)将会等于binarySearch(nums, target, true)，也就是说leftIdx=rightIdx+1，即leftIdx>rightIdx。


3.nums中没有target，那么ans会落在哪里？
答：不管nums中有没有target，最后的结果一定是left=right+1，即ans=left。

4.nums中没有target，那么ans会大于还是小于target？
答：不一定，情况很复杂。

二分法不会用，可以参考：[链接](https://www.cnblogs.com/zhaozhibo/p/14983880.html)。博文中对二分法查找目标值和二分法查找目标值的左右边界进行了介绍，这两种情况的不同在于遇到了target以后，是否继续收缩查找区间，而不同的收缩方向决定了查找的是左边界还是右边界。
博文的查找边界的代码，最终会使得left=right，此时如果是查找右边界，则右边界为right-1（left-1）；此时如果是查找左边界，则左边界为right（left）。
上面提到的leetcode答案只是将博文中的代码进行了整合。两者都有下面情况：
- 查找左边界代码：如果nums为空，会返回0。
查找右边界代码：如果nums为空，会返回-1。
- 没有target时，查找左边界代码和查找右边界代码返回相同的数。



我对leetcode答案的修改：
```
class Solution {
public:
    int binarySearch(vector<int>& nums, int target, bool lower) {
        int left = 0, right = (int)nums.size() - 1, ans = (int)nums.size();
        while (left <= right) { 
            int mid = (left + right) / 2; // 中间偏左的数，所以mid在某一时刻会落在
            if (nums[mid] > target || (lower && nums[mid] >= target)) {
                right = mid - 1;
                ans = mid; 
            } else {
                left = mid + 1;
            }
        }
        return ans;
    }

    int search(vector<int>& nums, int target) {
        int leftIdx = binarySearch(nums, target, true); // 找第一个大于等于target 的下标
        
        // 如果target很多的时候，这种方法的效率就会低很多。
        int n = 0;
        if( leftIdx< nums.size() && nums[leftIdx] == target){  // leftIdx不会低于零，所以不用写判断语句
            for(;leftIdx<nums.size() && nums[leftIdx]==target; ++leftIdx)  ++n;
        }

        return n;
    }
};
```
]]></description></item><item><title>Nginx </title><link>http://www.cnblogs.com/codingbigdog/archive/2022/08/29/16636443.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Mon, 29 Aug 2022 08:43:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/08/29/16636443.html</guid><description><![CDATA[Nginx中有一个 master 进程和多个 worker 进程，master 进程主要用来管理 worker 进程， worker用于处理网络请求。通过向master发送信号，就可以管理master和worker，如./nginx -s reload就是向master发送了reload信号。

一个连接请求过来，每个进程worker都有可能处理这个连接，怎么做到的呢？首先，每个 worker 进程都是从 master 进程 fork 过来，在 master 进程里面，先建立好需要 listen 的 socket（listenfd）之后，然后再 fork 出多个 worker 进程。所有 worker 进程的 listenfd 会在新连接到来时变得可读，为保证只有一个进程处理该连接，所有 worker 进程在注册 listenfd 读事件前抢 accept_mutex，抢到互斥锁的那个进程注册 listenfd 读事件，在读事件里调用 accept 接受该连接。当一个 worker 进程在 accept 这个连接之后，就开始读取请求，解析请求，处理请求，产生数据后，再返回给客户端，最后才断开连接，这样一个完整的请求就是这样的了。我们可以看到，一个请求，完全由 worker 进程来处理，而且只在一个 worker 进程中处理。
使用epoll等实现高并发。

参考：https://www.w3cschool.cn/nginx/sd361pdz.html]]></description></item><item><title>vim 学习2——vim的插件配置和 C++环境配置</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/08/25/16624274.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Thu, 25 Aug 2022 06:51:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/08/25/16624274.html</guid><description><![CDATA[请对照我参考的up主视频，进行学习。

# 4. vim 配置C++环境
参考视频：https://www.bilibili.com/video/BV1dL411V75t
init.vim：https://github.com/cateduo/nvim/blob/main/init.vim

安装nvim：
```
sudo apt-get install neovim
```

创建和编辑nvim配置文件：
```
mkdir ~/.config/nvim
nvim ~/.config/nvim/init.vim  【使用nvim进行编辑，而不是使用vim进行编辑】
```
下面在init.vim文件中进行配置：
首先配置基本的选项：
```
set number " 设置行号
" set relativenumber " 设置相对行号，自己把注释取消掉看看效果
"下面将tab键改为两个空格
set expandtab
set tabstop=2
set shiftwidth=2
set softtabstop=2
set ignorecase " 忽略大小写
set smartcase " 智能大小写
set notimeout " 关闭命令输出的等待超时
" set jumpoptions=stack " 以栈的方式进行跳转。这个好像无效了
set mouse=a
" set paste
let mapleader = "\<SPACE>" " 将leader键映射为空格。这里的\是转义字符。
```

常见的vim插件管理器有：vim-plug, Vundle, Pathogen, Dein.Vim, volt等。综合性能、易用性、文档等几个方面,这里推荐使用vim-plug。

**下载插件管理器vim-plug：**
```
" 首先判断插件管理器是否存在，如果不存在，则去下载，并执行PlugInstall进行安装
if empty(glob('~/.config/nvim/autoload/plug.vim')) 
  :exe '!curl -fLo ~/.config/nvim/autoload/plug.vim --create-dirs
              \ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim'
  au VimEnter * PlugInstall --sync | source $MYVIMRC
endif

call plug#begin('~/.config/nvim/plugged')
  Plug 'cateduo/vsdark.nvim'
call plug#end()
```
将需要的插件放入begin和end之间，然后执行：
```
:source  ~/.config/nvim/init.vim # 重新加载配置文件（也可以退出nvim，然后重新进入）
:PlugInstall    # 安装插件
```

**问题一：**
插件就会自动被下载到~/.config/nvim/plugged文件夹下，如上面的代码会自动将插件从github.com/cateduo/vsdark.nvim下载下来。在下载文件的过程中可能会出现如下问题：
```
curl: (7) Failed to connect to raw.githubusercontent.com port 443: Connection refused）
```
解决方法：设置DNS为114.114.114.114或者8.8.8.8就好了。设置方法：[链接](https://blog.csdn.net/booklijian/article/details/116491288)

**问题二：**
配置中使用curl下载插件管理器，如果提示错误：curl: (23) Failure writing output to destination，则我们需要执行：
```
sudo snap remove curl  # 通过snap下载curl就会出现上面的错误
sudo apt install curl
```
**问题三：**
安装过程可能需要kexue上网

**问题四：**
安装过程可能失败，多执行几次:PlugInstall就可以了

有了上面的知识，我们接下来会安装和配置各种各样的插件。

## 4.1 主题插件
```
call plug#begin('~/.config/nvim/plugged')
  Plug 'cateduo/vsdark.nvim'
call plug#end()

" ==== cateduo/vsdark.nvim的配置 ====
set termguicolors
let g:vsdark_style = "dark"
colorscheme vsdark
```
从上面代码，我们可以看出，添加插件就是在begin和end之间添加插件在github中的位置，然后在begin和end外面做一些对此插件的配置。


使用xshell时，发现：使用nvim编辑文本时，文本一篇漆黑。我们需要对xshell进行设置：“工具” -> “选项” -> “高级”，然后勾选使用本色。

## 4.2 文件浏览器
```
call plug#begin('~/.config/nvim/plugged')
  " file explorer
  Plug 'preservim/nerdtree'
call plug#end()

" ==== preservim/nerdtree ====
nnoremap <LEADER>e :NERDTreeToggle<CR>
```
配置信息中，将leader键+e映射为打开文件浏览器（:NERDTreeToggle<CR>（CR是回车的意思）），并且我们前面已经使用let mapleader = "\<SPACE>"将leader键映射为空格键，所以只用空格+e就可以打开文件浏览器，这里的`\`代表转义字符，对`<`进行转义。

`NERDTree 文件目录`可以打开相应的目录

通过ctrl+w+w 就可以在工作文件和文件浏览器之间进行切换。

## 4.3 coc插件

![](https://img2022.cnblogs.com/blog/1617829/202209/1617829-20220909101912553-789582237.png)

上图中，首先我们需要在vim/nvim中安装coc.nvim插件，然后安装语言服务器（c++、python等）。当我们在nvim中进行编程的时候，coc.nvim插件就会通过LSP协议与语言服务器进行交互，从而实现代码的补全等操作。

安装coc.nvim插件：
```
call plug#begin('~/.config/nvim/plugged')
  " lsp
  Plug 'neoclide/coc.nvim', {'branch': 'release'}
call plug#end()
```
安装以后，可能会提示缺少依赖nodejs，可以通过[链接](https://github.com/nodesource/distributions/blob/master/README.md#debinstall)对nodejs进行安装。
还可能需要依赖yarn（sudo apt install yarn）。

安装coc以后，可能出现如下警告：
```
coc.nvim switched to custom popup menu from 0.0.82 
you have to change key-mapping of <tab> to make it work. 
checkout current key-mapping by ":verbose imap <tab>"
```
上面警告的意思是：需要我们自己配置tab键的含义，但是使用了up主的配置文件，还是会有上述的问题，所以我参考了https://github.com/neoclide/coc.nvim#example-vim-configuration中对tab的配置，对up主的配置文件进行了修改，修改后的配置文件如下：
```
" ==== neoclide/coc.nvim ====
" coc extensions
let g:coc_global_extensions = [
      \ 'coc-json',
      \ 'coc-tsserver',
      \ 'coc-css',
      \ 'coc-html',
      \ 'coc-vimlsp',
      \ 'coc-cmake',
      \ 'coc-highlight',
      \ 'coc-pyright'
      \ ]
" 上面的配置在重新进入init.vim时会自动安装coc的语言服务器（可能需要多次进入init.vim才能完全下载成功），但是也可以通过CocInstall安装语言服务器，如:CocInstall coc-pyright
" 其他的语言服务器，可参考：https://github.com/neoclide/coc.nvim/wiki/Language-servers

set signcolumn=number " 在行号的位置提醒错误

" 配置tab和shift tab对候选词进行选取

" <TAB> to select candidate forward or
" pump completion candidate
" 使用tab键向下选择自动补全的候选词
inoremap <silent><expr> <TAB>
      \ coc#pum#visible() ? coc#pum#next(1) :
      \ CheckBackspace() ? "\<Tab>" :
      \ coc#refresh()
" <s-TAB> to select candidate backward
" 使用shift+tab向上选择自动补全的候选词
inoremap <expr><S-TAB> coc#pum#visible() ? coc#pum#prev(1) : "\<C-h>"

" Make <CR> to accept selected completion item or notify coc.nvim to format
" <C-g>u breaks current undo, please make your own choice.
" 按回车键确认我们所选择的候选词
inoremap <silent><expr> <CR> coc#pum#visible() ? coc#pum#confirm()
                              \: "\<C-g>u\<CR>\<c-r>=coc#on_enter()\<CR>"

function! CheckBackspace() abort
  let col = col('.') - 1
  return !col || getline('.')[col - 1]  =~# '\s'
endfunction


" 使用K来跳转到帮助文档，如将光标定位到nnoremap，然后使用K可进行跳转
nnoremap <silent> K :call <SID>show_documentation()<CR> 
function! s:show_documentation() 
  if(index(['vim', 'help'], &filetype) >= 0)
    execute 'h '.expand('<cword>')
  elseif (coc#rpc#ready())
    call CocActionAsync('doHover')
  else
    execute '!' . &keywordprg . " " . expand('<cword>')
  endif
endfunction

" highlight link CocHighlightText Visual
" autocmd CursorHold * silent call CocActionAsync('highlight')   " TODO

" 重命名，重命名一个，其他与此同名的，也会被重命名
nmap <leader>rn <Plug>(coc-rename)
" 格式化配置，具体可参考coc的github网站。
xmap <leader>f <Plug>(coc-format-selected)
command! -nargs=0 Format :call CocAction('format')

augroup mygroup
  autocmd!
  autocmd FileType typescript,json setl formatexpr=CocAction('formatSelected')
  autocmd User CocJumpPlaceholder call CocActionAsync('showSignatureHelp')
augroup end

" diagnostic info 错误提示信息
nnoremap <silent><nowait> <LEADER>d :CocList diagnostics<CR>
nmap <silent> <LEADER>- <Plug>(coc-diagnostic-prev) " 跳转到上一个错误
nmap <silent> <LEADER>= <Plug>(coc-diagnostic-next) " 跳转到下一个错误
nmap <LEADER>qf <Plug>(coc-fix-current) " 自动修复错误
 
" Remap <C-f> and <C-b> for scroll float windows/popups. 滚动浮窗
if has('nvim-0.4.0') || has('patch-8.2.0750')
  nnoremap <silent><nowait><expr> <C-f> coc#float#has_scroll() ? coc#float#scroll(1) : "\<C-f>"
  nnoremap <silent><nowait><expr> <C-b> coc#float#has_scroll() ? coc#float#scroll(0) : "\<C-b>"
  inoremap <silent><nowait><expr> <C-f> coc#float#has_scroll() ? "\<C-r>=coc#float#scroll(1)\<CR>" : "\<Right>"
  inoremap <silent><nowait><expr> <C-b> coc#float#has_scroll() ? "\<C-r>=coc#float#scroll(0)\<CR>" : "\<Left>"
  vnoremap <silent><nowait><expr> <C-f> coc#float#has_scroll() ? coc#float#scroll(1) : "\<C-f>"
  vnoremap <silent><nowait><expr> <C-b> coc#float#has_scroll() ? coc#float#scroll(0) : "\<C-b>"
endif

" statusline support
" set statusline^=%{coc#status()}%{get(b:,'coc_current_function','')}  "TODO

" GoTo code navigation. 代码的跳转，包括跳转到定义、跳转到实现等
nmap <silent> gd <Plug>(coc-definition)
nmap <silent> gD :tab sp<CR><Plug>(coc-definition)
nmap <silent> gy <Plug>(coc-type-definition)
nmap <silent> gi <Plug>(coc-implementation)
nmap <silent> gr <Plug>(coc-references)

" 使用nvim编辑cpp文件，然后输入:Gcmake后，就会调用下面函数，此函数判断当前目录下是否有CMakeLists.txt文件，
" 如果有的话，就在当前目录的.vscode目录下生成compile_commands.json。

function! s:generate_compile_commands() 
  if empty(glob('CMakeLists.txt')) 
    echo "Can't find CMakeLists.txt"
    return
  endif
  if empty(glob('.vscode'))
    execute 'silent !mkdir .vscode'
  endif
  execute '!cmake -DCMAKE_BUILD_TYPE=debug
      \ -DCMAKE_EXPORT_COMPILE_COMMANDS=1 -S . -B .vscode'
endfunction
command! -nargs=0 Gcmake :call s:generate_compile_commands()
```

ccls不放在init.vim中的coc_global_extensions下进行安装，而在外面进行安装：
```
sudo apt install ccls
```

然后需要对ccls进行配置，可以在nvim编辑的文件中输入:CocConfig进入ccls配置文件\~/.config/nvim/coc-settings.json，配置如下（文中的注释记得去掉）：
```
{
  "suggest.labelMaxLength": 60,
  "suggest.completionItemKindLabels": {
    "class": "\uf0e8",
    "color": "\ue22b"
  },
  "cmake.formatter": "cmake-format",
  "languageserver": {
    "ccls": {
      "command": "ccls", 
      "filetypes": [ "c", "cc", "cpp", "c++", "objc", "objcpp" ],
      "rootPatterns": [ "compile_commands.json", ".git/", ".hg/", ".vscode", ".vim/" ],
      "initializationOptions": {
        "highlight": {"lsRanges": true},
        "cache": {  
          "directory": "/tmp/ccls" # 缓冲文件所在的路径
        },
        "clang": {  # 编译器，如果你使用的是gdb编译器，那么可以按照https://github.com/neoclide/coc.nvim/wiki/Language-servers#ccobjective-c进行配置
          "resourceDir": "/usr/lib/clang/13.0.0"
        },
        "completion": {
          "detailedLable": true,
          "placeholder": true
        },
        "index": {
          "onChange": false,
          "initialNoLinkage": true,
          "threads": 2
        },
        "compilationDatabaseDirectory": ".vscode/"
      }
    }
  }
}

```
上面的`"compilationDatabaseDirectory": ".vscode/"`代表到.vscode文件夹下查找compile_commands.json文件，根据compile_commands.json就可以查找到头文件和库文件所在目录，而compile_commands.json是由cmake或make生成的。

**cmake生成compile_commands.json：**
```
cmake -DCMAKE_BUILD_TYPE=debug -DCMAKE_EXPORT_COMPILE_COMMANDS=YES -S . -B .vscode

-S  指定源文件根目录，必须包含一个CMakeLists.txt文件
-B  指定构建目录，构建生成的中间文件和目标文件的生成路径  

在当前目录的.vscode目录下生成compile_commands.json

平常cmake只会生成CMakeCache.txt、CMakeFiles、cmake_install.cmake、Makefile。上面的cmake多生成了compile_commands.json等文件。

在coc的配置文件中，我们还写了一个generate_compile_commands函数。有了generate_compile_commands函数，我们就可以通过输入:Gcmake来执行上面的cmake命令。

```




如果我们只有Makefile文件，却没有CMakeLists.txt文件，此时可以通过项目https://github.com/rizsotto/Bear生成compile_commands.json，有兴趣可以看一下这个项目。配置好此项目以后，通过以下命令就可以生成compile_commands.json：
```
bear -- make -C .. -j4
```












## 4.4 vimspector插件
跳转分为了两个，一个是光标移到某个函数，需要进入这个函数；一个是调试的过程中，调试到某个函数（从47:35开始）。coc插件插件实现了前者，而接下来要介绍的vimspector将实现后者。

![](https://img2022.cnblogs.com/blog/1617829/202209/1617829-20220912123308950-1459776741.png)

安装插件：
```
call plug#begin('~/.config/nvim/plugged')
  " debug
  " --enable-rust --enable-python分别代表安装C++和python的相关编译器
  Plug 'puremourning/vimspector', {'do': './install_gadget.py --enable-rust --enable-python'} 
call plug#end()
```

.vimspector.json：
up主完整的配置文件中可以看到：我们可以使用:Gvimspector命令自动生成.vimspector.json文件。从函数的定义来看，我们必须在~/.config/nvim/vimspector_conf/下面预先准备好c.json和python.json，c.json和python.json的内容如下：

C++的配置文件（c.json）：
```
{
  "configurations": {
    "Launch": {
      "adapter": "CodeLLDB",
      "configuration": {
        "request": "launch",
        "program": "${workspaceFolder}/test",
        "cwd": "${workspaceFolder}",
        "args": [ ],
        "environment": [ ],
        "externalConsole": true,
        "MIMode": "lldb"
      }
    }
  }
}
```

python的配置文件（python.json）：
```
{
  "configurations": {
    "run": {
      "adapter": "debugpy",
      "configuration": {
        "request": "launch",
        "type": "python",
        "cwd": "${workspaceFolder}",
        "program": "${file}",
        "stopOnEntry": true,
        "args": [],
        "console": "integratedTerminal"
      },
      "breakpoints": {
        "exception": {
          "raised": "N",
          "uncaught": ""
        }
      }
    }
  }
}

```
${workspaceFolder}代表.vimspector.json所在目录



## 4.5 LeaderF——查找项目中的某个变量
```
call plug#begin('~/.config/nvim/plugged')
  " file finder
  Plug 'Yggdroot/LeaderF', { 'do': ':LeaderfInstallCExtension' }
call plug#end()

" ==== Yggdroot/LeaderF ====
let g:Lf_WindowPosition='right' " 查找窗口的位置
let g:Lf_PreviewInPopup=1  " 此选项指定是否在弹出窗口中预览结果。
let g:Lf_CommandMap = {
\   '<C-p>': ['<C-k>'],
\   '<C-k>': ['<C-p>'],
\   '<C-j>': ['<C-n>']
\}  " 这一段我觉得没什么用
nmap <leader>f :Leaderf file<CR>   "　查找文件名
nmap <leader>b :Leaderf! buffer<CR>　 " 查找buffer中的文件名
nmap <leader>F :Leaderf rg<CR>    " 查找文件中的内容  无法实现？？
" nmap <leader>m :Leaderf mru<CR>   " 查询最近打开过的文件
let g:Lf_DevIconsFont = "DroidSansMono Nerd Font Mono" " 字体和图标
```
要使用`nmap <leader>F :Leaderf rg<CR>`，必须安装ripgrep，直接见[官网](https://github.com/BurntSushi/ripgrep)进行安装。

具体使用可参考：https://blog.csdn.net/qq_42475711/article/details/96731337


## 4.6 注释与开启终端
```
call plug#begin('~/.config/nvim/plugged')
  " enhance editor
  Plug 'tomtom/tcomment_vim'
  
  " terminal
  Plug 'skywind3000/vim-terminal-help'  " alt = 打开终端  
call plug#end()

" ==== tomtom/tcomment_vim ====

let g:tcomment_textobject_inlinecomment = ''  " 不知道说明什么意思，官网也找不到，先放着吧
nmap <LEADER>cn g>c  " leader键+cn 注释
vmap <LEADER>cn g>   " 将选中文本进行注释
nmap <LEADER>cu g<c  " leader键+cu 取消注释
vmap <LEADER>cu g<   " 将选中文本取消注释
```

:help tcomment查看插件的帮助


## 4.7 up主完整的配置文件
```
" request:
"   1. node
"   2. npm
"   3. python3 (pip3 install neovim)
nnoremap <space>rl :so ~/.config/nvim/init.vim<CR>
nnoremap <space>rc :e ~/.config/nvim/init.vim<CR>

set number
set relativenumber
set expandtab
set tabstop=2
set shiftwidth=2
set softtabstop=2
set ignorecase
set smartcase
set notimeout
set mouse=a

let mapleader = "\<SPACE>" " defualt ,

if empty(glob('~/.config/nvim/autoload/plug.vim'))
  :exe '!curl -fLo ~/.config/nvim/autoload/plug.vim --create-dirs
              \ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim'
  au VimEnter * PlugInstall --sync | source $MYVIMRC
endif


" =======================
" ===  plugins  begin ===
" =======================
call plug#begin('~/.config/nvim/plugged')
  
  " enhance editor
  Plug 'tomtom/tcomment_vim'
  
  " terminal
  Plug 'skywind3000/vim-terminal-help'
  
  " file explorer
  Plug 'preservim/nerdtree'

  " file finder
  Plug 'Yggdroot/LeaderF', { 'do': ':LeaderfInstallCExtension' }

  " highlight
  Plug 'cateduo/vsdark.nvim'
  Plug 'jackguo380/vim-lsp-cxx-highlight'
  
  " lsp
  Plug 'neoclide/coc.nvim', {'branch': 'release'}
  
  " debug
  Plug 'puremourning/vimspector', {'do': './install_gadget.py --enable-rust --enable-python'}
  
call plug#end()
" =======================
" ===   plugins  end  ===
" =======================


" =================================
" ===   plugins  configuration  ===
" =================================

" ==== tomtom/tcomment_vim ====

let g:tcomment_textobject_inlinecomment = ''
nmap <LEADER>cn g>c
vmap <LEADER>cn g>
nmap <LEADER>cu g<c
vmap <LEADER>cu g<


" ==== preservim/nerdtree ====

nnoremap <LEADER>e :NERDTreeToggle<CR>


" ==== Yggdroot/LeaderF ====
let g:Lf_WindowPosition='right'
let g:Lf_PreviewInPopup=1
let g:Lf_CommandMap = {
\   '<C-p>': ['<C-k>'],
\   '<C-k>': ['<C-p>'],
\   '<C-j>': ['<C-n>']
\}
nmap <leader>f :Leaderf file<CR>
nmap <leader>b :Leaderf! buffer<CR>
nmap <leader>F :Leaderf rg<CR>
let g:Lf_DevIconsFont = "DroidSansMono Nerd Font Mono"


" ==== cateduo/vsdark.nvim ====

set termguicolors
let g:vsdark_style = "dark"
colorscheme vsdark


" ==== jackguo380/vim-lsp-cxx-highlight 一些高亮的配置 ====

hi default link LspCxxHlSymFunction cxxFunction
hi default link LspCxxHlSymFunctionParameter cxxParameter
hi default link LspCxxHlSymFileVariableStatic cxxFileVariableStatic
hi default link LspCxxHlSymStruct cxxStruct
hi default link LspCxxHlSymStructField cxxStructField
hi default link LspCxxHlSymFileTypeAlias cxxTypeAlias
hi default link LspCxxHlSymClassField cxxStructField
hi default link LspCxxHlSymEnum cxxEnum
hi default link LspCxxHlSymVariableExtern cxxFileVariableStatic
hi default link LspCxxHlSymVariable cxxVariable
hi default link LspCxxHlSymMacro cxxMacro
hi default link LspCxxHlSymEnumMember cxxEnumMember
hi default link LspCxxHlSymParameter cxxParameter
hi default link LspCxxHlSymClass cxxTypeAlias


" ==== neoclide/coc.nvim ====

" coc extensions
let g:coc_global_extensions = [
      \ 'coc-json',
      \ 'coc-tsserver',
      \ 'coc-css',
      \ 'coc-html',
      \ 'coc-vimlsp',
      \ 'coc-cmake',
      \ 'coc-highlight',
      \ 'coc-pyright'
      \ ]

set signcolumn=number

" 配置tab和shift tab对候选词进行选取

" <TAB> to select candidate forward or
" pump completion candidate
" 使用tab键向下选择自动补全的候选词
inoremap <silent><expr> <TAB>
      \ coc#pum#visible() ? coc#pum#next(1) :
      \ CheckBackspace() ? "\<Tab>" :
      \ coc#refresh()
" <s-TAB> to select candidate backward
" 使用shift+tab向上选择自动补全的候选词
inoremap <expr><S-TAB> coc#pum#visible() ? coc#pum#prev(1) : "\<C-h>"

" Make <CR> to accept selected completion item or notify coc.nvim to format
" <C-g>u breaks current undo, please make your own choice.
" 按回车键确认我们所选择的候选词
inoremap <silent><expr> <CR> coc#pum#visible() ? coc#pum#confirm()
                              \: "\<C-g>u\<CR>\<c-r>=coc#on_enter()\<CR>"

function! CheckBackspace() abort
  let col = col('.') - 1
  return !col || getline('.')[col - 1]  =~# '\s'
endfunction

nnoremap <silent> K :call <SID>show_documentation()<CR>
function! s:show_documentation()
  if(index(['vim', 'help'], &filetype) >= 0)
    execute 'h '.expand('<cword>')
  elseif (coc#rpc#ready())
    call CocActionAsync('doHover')
  else
    execute '!' . &keywordprg . " " . expand('<cword>')
  endif
endfunction

" highlight link CocHighlightText Visual
" autocmd CursorHold * silent call CocActionAsync('highlight')   " TODO

nmap <leader>rn <Plug>(coc-rename)
xmap <leader>f <Plug>(coc-format-selected)
command! -nargs=0 Format :call CocAction('format')

augroup mygroup
  autocmd!
  autocmd FileType typescript,json setl formatexpr=CocAction('formatSelected')
  autocmd User CocJumpPlaceholder call CocActionAsync('showSignatureHelp')
augroup end

" diagnostic info
nnoremap <silent><nowait> <LEADER>d :CocList diagnostics<CR>
nmap <silent> <LEADER>- <Plug>(coc-diagnostic-prev)
nmap <silent> <LEADER>= <Plug>(coc-diagnostic-next)
nmap <LEADER>qf <Plug>(coc-fix-current)

" Remap <C-f> and <C-b> for scroll float windows/popups.
if has('nvim-0.4.0') || has('patch-8.2.0750')
  nnoremap <silent><nowait><expr> <C-f> coc#float#has_scroll() ? coc#float#scroll(1) : "\<C-f>"
  nnoremap <silent><nowait><expr> <C-b> coc#float#has_scroll() ? coc#float#scroll(0) : "\<C-b>"
  inoremap <silent><nowait><expr> <C-f> coc#float#has_scroll() ? "\<C-r>=coc#float#scroll(1)\<CR>" : "\<Right>"
  inoremap <silent><nowait><expr> <C-b> coc#float#has_scroll() ? "\<C-r>=coc#float#scroll(0)\<CR>" : "\<Left>"
  vnoremap <silent><nowait><expr> <C-f> coc#float#has_scroll() ? coc#float#scroll(1) : "\<C-f>"
  vnoremap <silent><nowait><expr> <C-b> coc#float#has_scroll() ? coc#float#scroll(0) : "\<C-b>"
endif

" statusline support
" set statusline^=%{coc#status()}%{get(b:,'coc_current_function','')}  "TODO

" GoTo code navigation.
nmap <silent> gd <Plug>(coc-definition)
nmap <silent> gD :tab sp<CR><Plug>(coc-definition)
nmap <silent> gy <Plug>(coc-type-definition)
nmap <silent> gi <Plug>(coc-implementation)
nmap <silent> gr <Plug>(coc-references)

function! s:generate_compile_commands()
  if empty(glob('CMakeLists.txt'))
    echo "Can't find CMakeLists.txt"
    return
  endif
  if empty(glob('.vscode'))
    execute 'silent !mkdir .vscode'
  endif
  execute '!cmake -DCMAKE_BUILD_TYPE=debug
      \ -DCMAKE_EXPORT_COMPILE_COMMANDS=1 -S . -B .vscode'
endfunction
command! -nargs=0 Gcmake :call s:generate_compile_commands()

" ==== puremourning/vimspector ====
let g:vimspector_enable_mappings = 'HUMAN'

function! s:generate_vimspector_conf()
  if empty(glob( '.vimspector.json' ))
    " if &filetype == 'c' || 'cpp' " up主原本这样写是不行的
    if (&filetype == 'c') || (&filetype=='cpp') 
      !cp ~/.config/nvim/vimspector_conf/c.json ./.vimspector.json
    elseif &filetype == 'python'
      !cp ~/.config/nvim/vimspector_conf/python.json ./.vimspector.json
    endif
  endif
  e .vimspector.json
endfunction

command! -nargs=0 Gvimspector :call s:generate_vimspector_conf()

nmap <Leader>v <Plug>VimspectorBalloonEval
xmap <Leader>v <Plug>vimspectorBalloonEval
```
]]></description></item><item><title>C++11 enable_shared_from_this </title><link>http://www.cnblogs.com/codingbigdog/archive/2022/08/14/16585553.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Sun, 14 Aug 2022 07:43:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/08/14/16585553.html</guid><description><![CDATA[请直接参考：[C++11中enable_shared_from_this的用法解析](https://blog.csdn.net/breadheart/article/details/112451022)

> std::enable_shared_from_this 能让一个对象（假设其名为 t ，且已被一个 std::shared_ptr 对象 pt 管理）安全地生成其他额外的 std::shared_ptr 实例（假设名为 pt1, pt2, ... ） ，它们与 pt 共享对象 t 的所有权。
       
> 若一个类 T 继承 std::enable_shared_from_this<T> ，则会为该类 T 提供成员函数： shared_from_this 。 当 T 类型对象 t 被一个为名为 pt 的 std::shared_ptr<T> 类对象管理时，调用 T::shared_from_this 成员函数，将会返回一个新的 std::shared_ptr<T> 对象，它与 pt 共享 t 的所有权。







**什么时候使用：**当一个类被共享智能指针 share_ptr 指向，且在类的成员函数里需要把当前类对象作为参数传给其他函数时，这时就需要传递一个指向自身的 share_ptr。下面例子描述了这一种情况：



```
#include <iostream>
#include <stdlib.h>
#include <memory>
using namespace std;

// 比较推荐的写法
struct Good : std::enable_shared_from_this<Good> // note: public inheritance
{
    std::shared_ptr<Good> getptr() {
        return shared_from_this();
    }
};

int main()
{
    // 正确的用法: 两个 shared_ptr 共享同一个对象
    std::shared_ptr<Good> gp1 = std::make_shared<Good>();
    std::shared_ptr<Good> gp2 = gp1->getptr();
    std::cout << "gp2.use_count() = " << gp2.use_count() << '\n';
}
```
首先在main函数，使用make_shared创建了一个对象，并使用智能指针gp1管理这个对象
然后gp1->getptr()中调用shared_from_this()，shared_from_this()的作用是：返回一个智能指针，此智能指针和gp1共享同一个对象。

**不能够直接返回this**：一般来说，我们不能直接将 this 指针返回。如果函数将 this 指针返回到外部某个变量保存，然后这个对象自身已经析构了，但外部变量并不知道，此时如果外部变量再使用这个指针，就会使得程序崩溃。
]]></description></item><item><title>bits &lt;&lt; 8 会被提升位int</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/08/08/16563106.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Mon, 08 Aug 2022 11:04:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/08/08/16563106.html</guid><description><![CDATA[```
#include <iostream>
#include <bitset>

using namespace std;

int main()
{
    unsigned char bits = 0xff;
    auto bits2 = bits << 8;

    if (typeid(bits2) == typeid(int))  // bits2被提升为int类型
    {
        cout << (bitset<32> (bits << 8));  // 转化为32位的int类型数据，并以二进制格式进行输出
    }
}
```]]></description></item><item><title>从零开始重写sylar C++高性能分布式服务器框架 </title><link>http://www.cnblogs.com/codingbigdog/archive/2022/08/07/16560076.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Sun, 07 Aug 2022 14:15:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/08/07/16560076.html</guid><description><![CDATA[本博客是对此视频的总结：https://www.bilibili.com/video/BV184411s7qF
作者博客：http://www.sylar.top
项目地址：https://github.com/sylar-yin/sylar

# 随笔

一个项目一般具有以下目录结构：
```
bin — 二进制
build — 中间文件路径
cmake — cmake函数文件夹
CMakeLists.txt — cmake的定义文件
lib — 库的输出路径
Makefile
sylar — 源代码路径
tests — 测试代码
```

先写头文件，

看到第3讲，准备看第四讲

前三讲说了三个类——Logger 、LogAppender、LogFormatter
Logger 相当于是主类
LogAppender是一个基类，有两种子类，两个子类分别为“输出日志到文件”和“输出日志到终端”
LogFormatter：日志格式化



LogEvent是存放信息的地方，包括文件名、线程号、协程号等内容。
LogFormatter是安排数据摆放顺序，包含模式解析等功能（可以看看log4j标准)
LogAppender是输出地，可以选择文件或控制台进行输出，里面也包含了LogFormatter对象，来保证不同的输出地可以以不同的格式呈现。
Logger是日志器，作为控制中枢可以将同一个信息添加多个LogAppender和LogFormatter对象来保证可以同时往多个地方输出

可以看出LogEvent、LogFormatter和LogAppender都是可以扩展的，即可扩展输出内容、扩展输出格式和扩展输出地。

参考：[链接](https://blog.csdn.net/m0_55292629/article/details/125147780)

LogEvent用于存放各种信息。LogFormatter用于组织LogEvent的信息成一定的格式，如下：
2019-06-17 00:28:45     9368    main    6       [INFO]  [system]        sylar/tcp_server.cc:64  server bind success: [Socket sock=9 is_connected=0 family=2 type=1 protocol=0 local_address=0.0.0.0:8020]



每一个类中都定义了本类的智能指针类型ptr，如LogFormatter类中：
```
class LogFormatter {
 public:
     typedef std::shared_ptr<LogFormatter> ptr;
};
```


C++11以后，可以直接在定义成员变量的时候进行初始化，如
```
class{
  int getA(){return A;}
private:
  int A=1
};
```


一般现在头文件中规划要实现那几个类和类中的函数，然后再去写具体的cpp文件。


要学会使用int32_t和uint32_t等类型，而不是只会使用int。

# C++ 宏的高级使用
```
#include <iostream>
#include<string>
using namespace std;

enum Level
{
    /// 未知级别
    UNKNOW = 0,
    /// DEBUG 级别
    DEBUG = 1,
    /// INFO 级别
    INFO = 2,
    /// WARN 级别
    WARN = 3,
    /// ERROR 级别
    ERROR = 4,
    /// FATAL 级别
    FATAL = 5
};

int main()
{
     Level level = DEBUG;

    switch (level)
    {
#define XX(name)      \
    case name:        \
        cout<< #name; \
        break;   // 到此为止相当于宏的定义。宏XX是一个一个case语句。

        XX(DEBUG);
        XX(INFO);
        XX(WARN);
        XX(ERROR);
        XX(FATAL);
#undef XX  // XX是一个临时使用的宏，这里进行取消定义
    default:
        cout<<"UNKNOW";
    }

    return 0;
}  
```


变量、函数、类的命名：
]]></description></item><item><title>虚函数</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/08/07/16558945.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Sun, 07 Aug 2022 05:37:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/08/07/16558945.html</guid><description><![CDATA[本博客是对[链接](https://blog.csdn.net/qq_42048450/article/details/117282640)的补充

修改原文中实例
```
 
#include<iostream>  
using namespace std;  
  
class A  
{  
public:  
    void foo()  
    {  
        printf("1\n");  
    }  
    virtual void fun()  
    {  
        printf("2\n");  
    }  
};  
class B : public A  
{  
public:  
    void foo()  //隐藏：派生类的函数屏蔽了与其同名的基类函数
    {  
        printf("3\n");  
    }  
    void fun()  //多态、覆盖
    {  
        printf("4\n");  
    }  
};  
int main(void)  
{  
    A a;  
    B b;  
    A *p = &a;  
    p->foo();  //输出1
    p->fun();  //输出2
    p = &b;
    // 修改内容    
    b.foo();    //输出3
    p->foo();  //取决于指针类型，输出1
    p->fun();  //取决于对象类型，输出4，体现了多态
    return 0;  
}

```]]></description></item><item><title>大话设计模式 总结 </title><link>http://www.cnblogs.com/codingbigdog/archive/2022/08/07/16558931.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Sun, 07 Aug 2022 05:24:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/08/07/16558931.html</guid><description><![CDATA[设计模式：让你真正学会使用面向对象进行编程

学完本书，可以再GoF的《设计模式》

《大话设计模式》的C++版本代码：[链接](https://www.cnblogs.com/Galesaur-wcy/p/15928225.html)

附录A是面向对象的基础知识



![](https://img2022.cnblogs.com/blog/1617829/202208/1617829-20220827153424142-266242005.png)

![](https://img2022.cnblogs.com/blog/1617829/202208/1617829-20220827154055107-1055191861.png)

重点如下（标星的为重点）：
![](https://img2022.cnblogs.com/blog/1617829/202208/1617829-20220827154328183-175114565.png)




通过[图说设计模式](https://design-patterns.readthedocs.io/zh_CN/latest/index.html)知道设计模式的分类，然后一个一个去百度，如果百度中讲得很乱，就回到《大话设计模式》中进行查阅。
或者通过[图说设计模式](https://design-patterns.readthedocs.io/zh_CN/latest/index.html)知道设计模式的分类，然后回到《大话设计模式》中进行查阅，如果书看不懂，再百度。


可参考黑马程序员的视频+博客https://blog.csdn.net/weixin_42636062
也可直接参考菜鸟教程



1.封装、继承和多态，以及简单工厂

命名要让人知道这个东西是啥，是干嘛的。

凡出现除法运算都要假设用户会输入零和字符，故要进行处理。

面向对象的编程的目的是让程序易维护（只改一小部分且不担心影响全局）、扩展（加入想要的功能且不担心影响全局；在不用把所有源码给你的条件下实现扩展）和复用。这些是通过封装、继承、多态把程序的耦合度降低实现。

封装：计算器的实现，需将计算和显示分开。即让业务逻辑和界面逻辑分开。即将业务逻辑用一个类封装好，在界面逻辑中调用它。

继承：1）将输入用set和get函数实现，并封装成一个基类A 2）每个运算都用一个类进行实现 3）**简单工厂**：将前面定义的类的对象都放进一个类中进行实例化。用一个switch根据输入自动选择实例化哪个运算类。

多态：由于所有的运算都继承于基类A，所以所有运算的对象都可以用基类的对象的指针a进行指向。当a调用方法B时，不同子类的方法B的实现是不一样，同样使用a->B得到的效果是不同。多态指的就是：使用相同的代码a->B却可以根据a具体指向的对象而实现出不同的效果，这个不同的效果就是多态。

利用继承和封装与直接将所有的运算实现放在一个函数中相比的好处：1）实现了易维护、扩展和复用 2）将每一个运算都用一个类进行实现，这样公司要你增加或修改一个运算类时，不需要把全部的运算都交给你，避免你把以前正确的东西瞎鸡巴改成错误的

UML类图：所有东西都总结在开头的图中了，看开头的图就行





2.策略模式

简单工厂：简单工厂仅仅指的是用一个switch根据输入自动选择实例化哪个运算类，前面定义抽象类等东西和它没有关系。

策略模式：策略模式（Strategy Pattern）定义了一组同类型的算法，在不同的类中封装起来，每种算法可以根据当前场景相互替换（指的应该就是多态），从而使算法的变化独立于使用它们的客户端（即算法的调用者）。

策略模式的内容不仅仅包括Context对Strategy对象的封装，还包括了抽象类Strategy的使用，抽象类Strategy起到了对算法的封装作用（就是抽象类普遍的作用）。父类Strategy的对象和对父类Strategy的对象的操作都封装到Context类中，Strategy的对象在类中被进行了一系列操作以后，最终利用一个函数返回算法的结果。故给Context对象中的函数传入各种各样的参数时，实际上在Context对象的内部是对Strategy对象进行操作，最后利用Strategy对象返回一个算法结果，也就是通过一个Context对象实现了向外提供统一的API。

使用Context对Strategy对象进行封装与直接使用Strategy对象的区别就是：Context对Strategy对象进行封装，对Strategy对象的操作都放在了Context中。

何时使用策略模式：一系列算法最终返回的东西是相同的（完成的工作相同），但是算法的实现过程不同。策略模式的目的就是向调用者屏蔽算法的实现过程，提供统一的API供调用者使用。只要在分析过程中听到需要在不同时间应用不同的业务规则，就可以考虑使用策略模式处理这种变化的可能性

简单工厂模式我需要让客户端认识两个类，CashSuper 和CashFactory,而策略模式与简单工厂结合的用法，客户端就只需要认识一个类CashContext就可以了。耦合更加降低。





3.单一职责原则(SRP)， 就一个类而言，应该仅有一个引起它变化的原因。可以简单理解成类的功能单一。

4.开放-封闭原则，是说软件实体(类、模块、函数等等)应该可以扩展，但是不可修改。即不能修改，但可以扩展的思想。面对需求，对程序的改动是通过增加新代码进行的，而不是更改现有的代码。这里的扩展应该有两层意思，第一：子类继承父类并对父类进行扩展；第二：增加子类。

设计人员必须对于他设计的模块应该对哪种变化封闭做出选择。他必须先猜测出最有可能发生的变化种类，然后构造抽象来隔离那些变化。书中的本句话下面有例子。

拒绝不成熟的抽象和抽象本身一样重要。

5.强内聚：指类中的功能完善【我的理解】

松耦合：类间尽量互相独立【我的理解】

依赖倒转原则：编程的最开始要确定的是本程序需要向外面提供什么样的接口，以提供此接口为目的进行编程，即面向接口的编程。

高层通过统一的接口调用低层模块，低层向高层屏蔽实现的细节。如调用操作数据库的相关函数的时候， 这个函数最好是与具体的数据库无关的。

里氏代换原则：子类型必须能够替换掉它们的父类型。这样父类才能被复用，子类也能够在父类的基础上增加新的行为。





6.在软件开发过程中，有时想用一些现存的组件。这些组件可能只是完成了一些核心功能。但在不改变其结构的情况下，可以动态地扩展其功能。所有这些都可以釆用装饰器模式来实现。

其主要缺点是：装饰器模式会增加许多子类，过度使用会增加程序得复杂性。

ConcreteDecoratorX的Operation()就是先调用被装饰对象的Operation()，然后在此基础添加一些新的东西，这些新的东西就被称为装饰。

装饰类也必须继承自Component的原因：因为装饰类对象是用于装饰Component对象，而装饰类对象本身也要可以被装饰，所以装饰类对象本身也要是Component的子类，这样装饰类对象本身才可以被装饰。

定义Decorator抽象类的原因是让装饰类可以被多态地使用。

使用多个装饰类一层一层地装饰Component对象，最后的Component对象的Operation()相当于是一个包含所有装饰的函数。实际上调用最后的Component对象的Operation()后，会一层一层地往上调用被装饰对象的Operation()。

打印了啥就相当于穿了啥。

如果只有一个 ConcreteComponent类而没有抽象的Component类，那么Decorator类可是ConcreteComponent的一个子类。同样道理，如果只有一个ConcreteDecorator类，那么就没有必要建立一个单独的 Decorator类，而可以把Decorator和ConcreteDecorator的责任合并成一个类。



不影响被装饰类的同时添加额外的功能，有效地把类的核心职责和装饰功能区分开了

要保证装饰类之间彼此独立，这样它们就可以以任意的顺序进行组合了



装饰是继承关系的一个替代方案。我觉得装饰是继承的一种特殊形式。

动态地给一个对象添加一些额外的职责。就增加功能来说，Decorator模式相比生成子类更为灵活。不改变接口的前提下，增强所考虑的类的性能。 	

何时使用：

  1）需要扩展一个类的功能，或给一个类增加附加责任。

  2）需要动态的给一个对象增加功能，这些功能可以再动态地撤销。

  3）需要增加一些基本功能的排列组合而产生的非常大量的功能，从而使继承变得 不现实。





0.附录A

类： 类就是具有相同的属性和功能的对象的抽象的集合

对象：就是类的实例化

方法重载：相同函数名，不同形参和返回值

多态：父类对象可以用来装子类对象。C++中利用父类的指针指向子类对象。

多态例子：由于子类都重写了父类中Shout的方法，所以将子类对象装在父类对象后，通过父类对象调用Shout方法时，调用的是子类中的Shout方法。也就是父类对象中装哪个子类，调用的就是哪个子类的Shout方法，这就是多态。多态：父类对象中装哪个子类，调用的就是哪个子类的Shout方法。

重构：将相同代码都放入基类，只在子类中重写不同部分。

抽象类：实例化一只猫，我们能得到一只具体的猫。但是实例化一只动物，一只动物是什么样的？我们会发现动物不需要实例化，动物是一个抽象的概念。

故，抽象类不能实例化；抽象方法必须被子类重写；有抽象方法的类必须定义成抽象类

一般具体类不用来做继承，抽象类才用做继承。简单工厂模式中的计算器实现中，我觉得Operation就可以弄成一个抽象类，当然Operation里面可以没有抽象方法。Operation定义成抽象类，代表Operation是一个不需要具有实例化功能的类。

接口：抽象类是用来表示所有子类的共同特征和功能，而接口是给几个特殊的子类添加共同的功能。如果B和C继承接口A并各自实现了自己的a功能，那么A定义的对象就可以用来装B和C，通过A定义的对象就可以多态地访问a







C++ 接口是使用 抽象类 来实现的？？？？？













问题：

350页？？？




# 李建忠


## 策略模式

![](https://img2022.cnblogs.com/blog/1617829/202208/1617829-20220814193644511-738375786.png)


C++的类中，写了虚函数，一般都要写一个虚的析构函数，不然多态的内存释放时，可能会出问题。


工程开发中，一般将一个类放在一个文件中？


# 黑马程序员
请参考此链接，对本博客进行学习，因为此链接有的内容，我一般不添加，我只添加我的理解：https://blog.csdn.net/weixin_42636062



## 简单工厂模式
简单工厂模式：假设有很多类（一般这些类都来自一个基类），并且这些类初始化对象的过程可能很复杂，此时就可以将所有类初始化对象的过程都放进一个类中，这个类称为工厂类。然后我们只要向工厂类的对象传入相应的参数，就可以获取相应的类的对象。下面举一个例子：
```
#include <bits/stdc++.h>
using namespace std;

//抽象水果
class AbstractFruit {
public:
	virtual void ShowName() = 0;
};

//苹果
class Apple :public AbstractFruit {
public:
	virtual void ShowName() {
		cout << "我是苹果!" << endl;
	}
};

//香蕉
class Banana :public AbstractFruit {
public:
	virtual void ShowName() {
		cout << "我是香蕉!" << endl;
	}
};

//鸭梨
class Pear :public AbstractFruit {
public:
	virtual void ShowName() {
		cout << "我是鸭梨!" << endl;
	}
};

//水果工厂
class FruitFactor {
public:
	static AbstractFruit * CreateFruit(string flag) {
		if (flag == "apple") {
			return new Apple;
		}
		else if (flag == "banana") {
			return new Banana;
		}
		else if (flag == "pear") {
			return new Pear;
		}
		else {
			return NULL;
		}
	}
};

void test01() {
	FruitFactor* factory = new FruitFactor;
	AbstractFruit* fruit = factory->CreateFruit("apple");
	fruit->ShowName();
	delete fruit;

	fruit = factory->CreateFruit("banana");
	fruit->ShowName();
	delete fruit;

	fruit = factory->CreateFruit("pear");
	fruit->ShowName();
	delete fruit;

	fruit = NULL;
	delete factory;
	factory = NULL;
}

int main(){
	test01();
	return 0;
}
```
【注】上面的工厂类中，各个水果类创建对象的过程只有一句new，但是有时创建对象的过程可能比较复杂，本例子只是为了演示的方便。
【缺点】添加或修改一个水果类，不需要修改类的源代码。但是需要修改工厂类FruitFactor，即需要添加一个else if。

简单工厂模式实现了对象创建和使用的分离。





## 工厂类
为了解决简单工厂中，添加水果类时，需要修改工厂类的问题。我们将工厂类进行抽象。如下：
```
#include <bits/stdc++.h>
using namespace std;

//抽象水果
class AbstractFruit {
public:
	virtual void ShowName() = 0;
};

//苹果
class Apple :public AbstractFruit {
public:
	virtual void ShowName() {
		cout << "我是苹果!" << endl;
	}
};

//香蕉
class Banana :public AbstractFruit {
public:
	virtual void ShowName() {
		cout << "我是香蕉!" << endl;
	}
};

//鸭梨
class Pear :public AbstractFruit {
public:
	virtual void ShowName() {
		cout << "我是鸭梨!" << endl;
	}
};

//抽象工厂
class AbstractFruitFactory {
public:
	virtual AbstractFruit* CreateFruit() = 0;
};


//苹果工厂
class AppleFactory :public AbstractFruitFactory {
public:
	virtual AbstractFruit* CreateFruit() {
		return new Apple;
	}
};

//香蕉工厂
class BananaFactory :public AbstractFruitFactory {
public:
	virtual AbstractFruit* CreateFruit() {
		return new Banana;
	}
};

//鸭梨工厂
class PearFactory :public AbstractFruitFactory {
public:
	virtual AbstractFruit* CreateFruit() {
		return new Pear;
	}
};


void test01() {
	AbstractFruitFactory* factory = NULL;
	AbstractFruit* fruit = NULL;

	//创建一个苹果工厂
	factory = new AppleFactory;
	fruit = factory->CreateFruit();
	fruit->ShowName();
	delete fruit;
	delete factory;

	//创建一个香蕉工厂
	factory = new BananaFactory;
	fruit = factory->CreateFruit();
	fruit->ShowName();
	delete fruit;
	delete factory;

	//创建一个鸭梨工厂
	factory = new PearFactory;
	fruit = factory->CreateFruit();
	fruit->ShowName();
	delete fruit;
	delete factory;
	fruit = NULL;
	factory = NULL;

}

int main() {
	test01();
	return 0;
}
```
从本代码中，我对代码可扩展性的有了一些片面的理解，即代码可扩展性就是指：有一个基类，然后你在下面扩展出子类。通过在基类下面扩展子类的方式，就可以增加需要的功能，而不用修改源代码。所以如果以后如果你遇到了扩展代码需要修改源码的问题，就可以试着将一个类分解成多个的子类（就像上面的工厂模式一样），然后用一个基类“统帅”这些子类。


## 抽象工厂

简单工厂模式：一个工厂类中负责创建一系列水果对象
工厂模式：抽象出一个基类，然后每个子类中负责创建一个水果对象
抽象工厂模式：抽象出一个基类，然后每个子类中负责创建一系列水果对象。为什么每个种类的水果，都要有一个抽象？？直接用一个水果基类，不就行了？

csdn评论区说：讲的有问题




## 单例模式

系统中某个类的对象只能存在一个，从而节约系统资源。比如你打开双击打开任务管理器，打开以后，你再次双击任务管理器，打开的还是上一次打开的那个。

单例模式直接参考：[链接](https://blog.csdn.net/unonoi/article/details/121138176)









## 代理模式

代理模式的定义：为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用。举例如下：
```
#include <iostream>
using namespace std;

//提供一种代理来控制对其他对象的访问
class AbstraactCommonInterface {
public:
	virtual void run() = 0;

};

//我已经写好的系统
class Mysystem :public AbstraactCommonInterface{
public:
	virtual void run() {
		cout << "系统启动..." << endl;
	}
};

//必须有权限验证，不是所有人都能来启动我的启动，必须提供用户名和密码
class MysystemProxy :public AbstraactCommonInterface {
public:
	MysystemProxy(string username,string password) {
		this->mUsername = username;
		this->mPassword = mPassword;
		
	}
	bool checkUsernameAndPassword() {
		if (mUsername == "admin"&&mPassword == "admin") {
			return true;
		}
		return false;
	}
	virtual void run() {
		if (checkUsernameAndPassword()) {
			cout << "用户名和密码正确，验证通过..." << endl;
			this->pSystem->run();
		}
		else {
			cout << "用户名或密码错误，权限不足...." << endl;
		}
	}
	~MysystemProxy() {
		if (pSystem != NULL) {
			delete pSystem;
		}
	}
public:
	Mysystem* pSystem;
	string mUsername;
	string mPassword;
};

void test01() {
	MysystemProxy* proxy = new MysystemProxy("root","admin");
	proxy->run();
}


int main() {
#if 0
	//这样不行。是个人都能启动
	Mysystem* system = new Mysystem;
	system -> run();
#endif
	//调用代理模式
	test01();
	return 0;
}

```
上面代码中，类Mysystem用于启动系统，但是不是所有人都可以启动系统，必须进行权限的验证，所以就创建了额外的类MysystemProxy进行权限验证，然后就再通过MysystemProxy间接启动系统。
代理类MysystemProxy的作用：为其他对象提供一种代理以控制对Mysystem的对象的访问





参考：[链接](https://design-patterns.readthedocs.io/zh_CN/latest/index.html)
# 结构型模式
结构型模式(Structural Pattern)：描述如何将“类和类结合”或“类和对象结合”，就像搭积木，可以通过简单积木的组合形成复杂的、功能更为强大的结构。
根据[合成复用原则](https://blog.csdn.net/niu2212035673/article/details/78076139)，我们尽量使用“类和对象结合”的方式。


## 适配器模式
请直接看《大话设计模式》的相关部分。《大话设计模式》中认为适配器模式为：将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原来由于接口不兼容而不能一起工作的那些类可以一起工作。
我看来书中的内容，我对上面这句话的理解为：为了让客户可以使用adaptee类提供的功能，使用了adapter类对adaptee类进行适配。**所以我认为适配器的本质就是在adapter类中调用adaptee对象提供的功能，并将此功能以特定的API形式向外提供。也就是说适配器的本质是对待适配类adaptee进行封装**

由于适配器模式本质是对功能进行封装，所以[C++实现设计模式——适配器(Adapter)模式](https://blog.csdn.net/yxh_1_/article/details/116085949)中提到的将访问mysql,sqlite3,postgersql三种数据库封装成统一的接口，也被算在了适配器模式的里面。




我觉得这篇博文对适配器模式的示例代码可以看一看——[适配器模式C++详解](https://blog.csdn.net/ahelloyou/article/details/123264127)。在本篇博文中，客户需要自己创建adaptee对象，然后将此对象，输入到adapter中，从而完成对adaptee对象的适配。
而在《大话设计模式》中，adaptee对象是在adapter对象创建时，自动创建的。  


**什么时候使用适配器？**
答：A在系统中的很多地方都是使用旧版的API，而新版的API和旧版的API差别很大。此时提供API的人不可能为了A将API修改回去，而A将系统中的旧版的API换成新版的又很困难，这时就需要适配器的帮助。  
**所以适配器模式是不得已使用的模式，能够避免当然是最好的。**




## 桥接模式
在《大话设计模式》中，首先使用了继承的方式，不断地向抽象的手机添加品牌、软件功能，但是这会使得继承关系变得很长。然后在文中提到了合成聚合复用原则，根据合成聚合复用原则，我们知道组合方式是给类添加新功能的最优方式。


合成聚合复用原则： 当想给一个类增加新的功能，有三种方法，第一种就是直接修改代码，第二种是通过继承方式，第三种是通过组合方式。而合成聚合复用原则认为组合/聚合方式是最优的方式。

我看[C++设计模式——桥接模式](https://blog.csdn.net/u012581604/article/details/72887029)和《大话设计模式》以后，认为桥接模式是：实现一个系统需要的东西可以分为很多个大类，每个大类还可以分为很多个小类，此时每个大类都应该有一个独立与其他大类的基类，并在基类下派生子类。而基类之间通过组合的方式进行关联。如《大话设计模式》中将手机品牌和手机软件作为两个基类，再如[C++设计模式——桥接模式](https://blog.csdn.net/u012581604/article/details/72887029)将系统和手机品牌作为两个基类。























# 原则
## 里氏替换原则
可查看：[里氏替换原则解读](https://geek-docs.com/design-pattern/design-principle/liskov-substitution-principle.html)
里氏替换原则:
>1.子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法
>2.子类可以添加自己的东西
>3.当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。什么叫做更加宽松？？



## 合成聚合复用原则
可查看：[合成复用原则（C++)](https://blog.csdn.net/niu2212035673/article/details/78076139)
合成聚合复用原则： 当想给一个类增加新的功能，有三种方法，第一种就是直接修改代码，第二种是通过继承方式，第三种是通过组合方式。而合成聚合复用原则认为组合/聚合方式是最优的方式。
]]></description></item><item><title> 沈显君 C++语言程序设计教程 第3版  总结</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/08/07/16558928.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Sun, 07 Aug 2022 05:22:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/08/07/16558928.html</guid><description><![CDATA[总结于：沈显君 C++语言程序设计教程 第3版 


1.类

1.1 类与成员

class与struct：class中的成员变量默认为private。protected代表成员可以被该类和其子类存取，但是类的对象是无法直接访问protected成员的

类的成员变量可以定义为该类的指针和引用，不能定义该类的变量。成员函数中可以该类的变量（对象）。

类外和类内（以时间换空间）声明成员函数。类外用“类名::”指明成员函数属于哪个类。

对象共享成员函数的定义。

定义为protected 等级的成员可以被该类及其子类存取。

1.2 构造函数与析构函数

构造函数：给数据成员赋初值。函数名与类名相同，没有返回值和void，为public类型的。可以用多个构造函数

析构函数：如释放在构造函数中申请的内存。函数名为类名前加~，没有返回值和void。只能有一个析构函数。

拷贝构造函数

​	用一个对象初始化一个新建立的对象。用于初始化对象、作为实参、作为返回值。

​	四个注意点

深拷贝构造函数：如开辟内存，存储原对象中的指针指向的数据





1.3 对象的指针和引用

引用作为函数形参是最好的

使用new和delete建立动态对象

this指针指向的是当前对象的地址（不常用）。

组合对象：含有其他类的对象作为数据成员的类，此类声明的对象叫做组合对象。

​					组合类中的对象成员以其在类中声明的先后顺序依次构造,而不是根据构造函数初始化列表中成员对象					构造函数声明的先后顺序来决定。

1.4 静态成员：为所有对象所共享的成员

类内声明、类外初始化。

静态成员函数：静态成员函数主要为了调用方便，不需要生成对象就能调用。静态成员函数中不能调用非静态成员。非静态成员函数中可以调用静态成员。	

1.5 友元函数

友元函数是在类内定义或声明的普通函数，友元函数中创建的对象可以访问private和protect类型的数据成员。

友元类：将A声明为B的友元类，那么A成员函数中创建的B类对象b，b可以访问private和protect类型的数据成员。

1.6 常成员与常对象

利用const进行修饰的不可更改的量（代表此量只读）。

作用：函数实参的保护（此量只读）

常对象：由构造函数进行初始化后就不能修改了，对象只能调用常成员函数，常成员函数中不能对数据成员进行修改。

常数据成员：类中的常数据成员只能通过构造函数的初始化列表进行初始化

常成员函数：函数声明和具体定义的地方都要带const。不能更新对象的数据成员,也不能调用该类中没有用const修饰的成员函数。

对象的内存分布。

6.继承和派生：基类派生子类（派生类），子类继承基类特性

继承的作用：更清楚地表达类与类之间所具有的共同性和差异性、增加代码的可重用性

子类中同名函数的覆盖的作用：对基类函数进行限制、改造或扩充，使得暴露的接口（函数名）一样但功能有所不同

继承和组合：没看懂？？？？、

公有继承：派生类成员无法访问私有成员。基类的公有成员在派生类中仍然为公有成员。保护成员在派生类中仍然是保护成员。派生类成员无法访问私有成员，这就是为什么要有protected，protected就是让子类可以访问父类中受保护的成员。派生类和父类的对象都无法直接访问protected的成员，即成员是受保护的。

私有继承：经过私有继承之后，所有基类的成员都成为派生类的私有成员或不可访问的成员

保护继承：基类的公有成员和保护成员被继承后作为派生类的保护成员。派生类成员无法访问私有成员。

6.3 派生类的构造与析构

构造函数：利用构造函数初始化列表对基类进行初始化。基类有自定义构造函数，子类也就需要定义。

析构函数：负责对新增的非对象成员进行清理



6.5 多继承与二义性

多继承：子类有两个或两个以上的父类。

多继承的构造函数调用顺序：基类的构造函数，成员对象的构造函数，子类的构造函数。析构函数与此顺序相反

 二义性问题：多个基类中拥有同名的成员A，子类调用A时编译器无法确定调用的是哪个A。

二义性解决：1）利用类的作用域分辨符 2）派生类中重定义此函数 3）将部分基类中的A改名

6.6 虚基类

间接二义性：

​		子类继承父类中成员是将成员复制一份。

​		间接二义性：当B和C都继承了A，然后D又继承了B和C。如果A中有成员a，那么D中就有两个不同的a。

虚基类：虚基类就是让当B和C都“虚”继承了A，B和C共同维护一个副本。



7多态：一个值取不同数据类型就叫多态。

多态：给同一函数名输入不同类型对象时，会自动调用不同处理函数，得到不同结果。虽然函数名相同但是处理的对象不同，实现的功能也只是类似而不相同。

大话设计模式中我对多态的理解：由于所有的运算都继承于基类A，所以所有运算的对象都可以用基类的对象的指针a进行指向。当a调用方法B时，不同子类的方法B的实现是不一样，同样使用a->B得到的效果是不同。多态指的就是：使用相同的代码a->B却可以根据a具体指向的对象而实现出不同的效果，这个不同的效果就是多态。



联编：确定函数输入的是什么类型的对象？

运算符重载：运算符重载相当于定义函数名相同但是形参不同的函数。编译器会根据输入函数的实参判断需要调用的函数。

运算符重载方式：

​		重载为类A的友元函数：可以重载为类A的友元函数，类A的对象就是运算符函数所要处理对象。

​		重载为类的成员函数：重载为类A的成员函数，则类A的对象和输入形参共同成为运算符所需处理对象。后置		单目运算符需要带一个整型形参，从而与前置单目运算符区别

让父类的指针指向子类对象时，如果父类和子类中有同名函数A，利用指针调用A时调用的是父类的函数A。虚函数是用来让指针调用A时调用的是子类的函数A

抽象类：建立抽象类，就是为了通过它多态地使用其中的成员函数，为一个类族提供统--的操作界面。通过抽象类的指针和引用可以指向并访问各派生类成员。





8.模板：逻辑功能相同而函数参数类型不同的多个重载函数用一个函数来描述

template<class class1,…… >：template中只对函数中使用的类进行抽象表示。可以有普通数据类型，此时相当于函数的形参。

函数调用形式：函数名<具体类型名1,具体类型名2,……,常量表达式> (实参表)：尖括号中说明函数中使用的类具体指的是啥

9.STL(Standard Template Library)：就是一些可扩展的类模板的集合，这些类叫做容器类

泛型：一个值取不同数据类型

STL主要由5个部分组成,分别是容器(container)、迭代器(iterator)、适配器(adaptor)、算法(algorithm)和函数对象(function object)。



9.1 容器

容器就是类模板，此类模板是用来生成不同数据类型下的数据结构，如生成int型栈、char型栈等。容器是个类肯定包含对数据结构的操作，如进栈、出栈、获取栈中元素个数等。

常见容器：

顺序容器

​		vector（向量）：动态数组。从后端以push_back()添加元素。如果vector容器发现存储空间不足，整个容器中的数据元素将会被搬到一个新的、更大的内存空间中。并将所有数据元素复制到新的内存空间中。可通过[]访问元素（快速查找）。

​		容器valarray代表数学意义上的向量。

​		list（双向链表）：每个元素均有指针指向前一个元素和下一个元素（快速 插入或删除）。list 容器中的元素可以分散存储在内存空间里，而不是必须存储在一整块连续的内存空间中。不可通过[]访问元素（快速查找）

​		deque（双端队列）：与vector类似，这里的双端指的是可以从数组的两端插入数据。从前端或后端以push_front()或push_back()添加元素。在增加数据元素时,如果deque容器内原先定义的内存空间不足,deque容器会将新增加的数据元素存储到另外一块内存中。可通过[]访问元素（快速查找）

9.2 迭代器：一种通用的方法访问具有不同结构的各种容器中的每个元素，是广义的指针。每种容器定义自己的迭代器，如list<T>::iterator、vector<T>::iterator

其他三种迭代器：reverse_iterator（用于反向遍历）,const_iterator（返回一个常数值）,const_reverse_iterator

9.3 适配器：可将顺序容器转为其他类型的容器。

三种适配器：队列(queue)、优先队列( priority queue)和栈(stack)，

适配器也是类模板，但不是容器，无法使用迭代器。

1.直接将适配器当成类模板来用：

```
queue<int> q; // 创建一个q队列
q.push(1);
q.pop();
```

2.利用适配器将顺序容器转为其他类型的容器。

```C++
container adapter < typename T, container < typename T> > 变量名;
// container < typename T>表示待转化的顺序容器，两个typename T是一样的
// container < typename T>与右边的“>”之间要有一个空格，以免编译错误。
// 如将list转为queue：
queue<int, list<int> > list_q;
list_q.push(1);
list_q.pop();
```





关联容器：包括集合（set和multiset（允许有重复的元素））和键值对（map和multimap（允许同一个键有多个值））

STL算法：在<algorithm>头文件中定义，以函数模板的形式给出，使用迭代器对数据进行访问















问题：

1.构造函数可以是私有的吗？

2.没有多继承，用虚继承会对结果产生影响吗？
]]></description></item><item><title>gcc能编译通过的，g++不一定能编译通过</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/08/05/16553436.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Fri, 05 Aug 2022 02:12:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/08/05/16553436.html</guid><description><![CDATA[下面语句g++无法编译通过，但是gcc可以。
```
void *vptr
char *ptr;
ptr = vptr;
```]]></description></item><item><title>所学所有知识的整理</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/08/01/16542024.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Mon, 01 Aug 2022 14:03:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/08/01/16542024.html</guid><description><![CDATA[# 1.一些编程的经验
## 1.1 代理的使用

推荐：https://glados.rocks，其他也可以。（不保证安全）
优点：
教育邮箱注册送一年（这个优惠应该还存在），其他邮箱好像送三天。
每天签到，签一天送一天！！使用[glados自动签到脚本](https://github.com/DullSword/GLaDOS-CheckIn)实现永久白嫖。

在windows下使用拨号上网，记得将网络的名字改为英文，不然无法正常使用clash。

## 1.2 虚拟机
在学习ubuntu时，可以下个虚拟机，在虚拟机里面玩ubuntu系统。玩的时候记得拍快照。
拍快照就是“对ubuntu系统此刻的状态进行存档”，以便玩崩后进行恢复。
这里推荐使用虚拟机VM（自己去google一个激活码），去官网下（翻墙下得快），别的地方下可能会有问题，比如主机和虚拟机之间不能复制文本和文件。

在我的使用体验上来看，除了性能外，虚拟机上ubuntu的使用和实际的ubuntu系统没多大差别，主要的差别在网络连接上，所以利用其进行学习ubuntu的使用。下面介绍一下在虚拟机连接网络的两种方式——**NAT和桥接：**
**桥接：**虚拟机上的系统被分配一个与所在主机同一个网段的ip，此时虚拟机上的系统相当于一个独立的主机。
**net：**虚拟机上的系统通过与所在主机来访问互联网。（我现在主要用桥接模式）

在网络编程相关的实验中，由于我没有很多台电脑，所以我在虚拟机中创建了两个ubuntu系统，一个作为客户端，一个作为服务器端，然后让处于同一个局域网的这两个系统进行网络通信。

vm和ubuntu20.04镜像的下载链接如下：
[VM](https://www.vmware.com/products/workstation-pro.html)
[ubuntu20.04镜像](https://releases.ubuntu.com/20.04/)


## 1.3 一些常用资源的推荐
**搜索引擎推荐：**
google.com
baidu.com
cn.bing.com
gzh.sogou.com（搜索一些微信公众号资源）
zh.sa1lib.org（搜索电子书，淘宝上能买到的，几乎都能搜到）
我喜欢电子书是可复制的，所以我平常首先在zh.sa1lib.org上搜书并选泽下载MOBI或EPUB或AZW3格式的书，并通过https://convertio.co/zh/将上述电子书转换为pdf版，此时的pdf版就是可复制的。

**写博客，记录所学，博客推荐：**
每次我学了就忘，看过的内容，过一段时间也记不起来，我的方法是通过写博客记录所学。
博客园（推荐使用）：写的时候自动备份，不会丢失。还可以将所有博客备份到本地（博客备份到本地使用的[脚本](https://github.com/superdogdad/cnblogs_backup)）。博客园还可以自定义博文的皮肤（自行百度）。
Csdn：不要用，会不幸——写的时候没有自动备份

我认为写博客的目的就是为了以后需要的时候能找到它，所以发现有用的博客不需要抄一遍放在自己的博客，只需要将博客收藏成书签起来——推荐使用chrome浏览器收藏书签。
收藏书签的原因：记住所有的知识是不可能的，但是我们要用相关知识的时候，可以找到是重要。
收藏书签的时候可以对书签内容进行总结提炼成一句话。

**C++相关推荐：**
《C++ primer》、游双的高性能服务器开发、陈硕的网络库开发



## 1.4 学习新知识
各个博客网站的专栏可以帮助我们快速的学习，如csdn中：
![](https://img2022.cnblogs.com/blog/1617829/202209/1617829-20220921110925280-824946802.png)


## 其他

linux下源码安装的一般流程，请参考[链接](https://blog.csdn.net/weixin_42732867/article/details/104789431)





# 2.Docker

docker的目的：代码下载下来以后，要配置代码所需的依赖，这很麻烦。所以将代码和代码所需的依赖包装在一个称作为镜像的东西里面，然后我们直接将镜像下载下来，运行这个镜像就相对于运行了代码。

镜像（Image）：Docker 镜像（Image），就相当于是一个 root 文件系统，文件系统中存储有代码和代码所需依赖。比如官方镜像 ubuntu:16.04 就包含了完整的一套 Ubuntu16.04 最小系统的 root 文件系统。
容器（Container）：镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。
[docker使用](https://www.cnblogs.com/codingbigdog/p/16533716.html)



# 3.IDE

## 3.1 vscode
**vscode简介和下载：**
C++有两种常用的IDE——vscode和clion，我现在习惯于使用vscode，理由如下：暂时觉得vscode会比clion好用一些，因为clion操作远程服务器时需要在本地保留一份代码，然后修改本地代码，最后将修改的代码上传到服务器上。而vscode可以通过remote ssh插件直接操作远程服务器的代码，不需要在本地保留一份代码。
下载：https://code.visualstudio.com/Download
推荐使用上述官网网址下载
百度直接搜到的vscode，大多是第三方的下载地址，建议别用。

Vscode连接远程服务器教程见：[Vscode连接远程服务器和python和C++调试配置 ](https://www.cnblogs.com/codingbigdog/p/16533723.html)


# 4.C++
[C++知识整理](https://www.cnblogs.com/codingbigdog/p/16724400.html)
]]></description></item><item><title>Vscode连接远程服务器和python和C++调试配置</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/29/16533723.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Fri, 29 Jul 2022 14:07:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/29/16533723.html</guid><description><![CDATA[
### 0.服务器开启ssh
自己有服务器，如果要通过vscode进行连接，就需要先在服务器上先开启ssh服务。
请参考[链接](https://blog.csdn.net/qq_45164331/article/details/122533327)



### 1.下载和安装
下载：https://code.visualstudio.com/Download
推荐使用上述官网网址下载
百度直接搜到的vscode，大多是第三方的下载地址，建议别用。

### 2.安装remote ssh和编辑配置文件
搜索remote ssh：
![](https://img2022.cnblogs.com/blog/1617829/202207/1617829-20220729222250979-57143614.png)

然后点击如下区域：
![](https://img2022.cnblogs.com/blog/1617829/202207/1617829-20220729222119159-1304795872.png)


出现配置文件如下：
![](https://img2022.cnblogs.com/blog/1617829/202207/1617829-20220729222154448-1993867108.png)

配置文件说明：
```
Host 名称            # 自己随便取的
    HostName ip     # 服务器ip
    Port 22         # 通过ssh连接服务器，服务器必须开启ssh
    User   name     #  linux用户名称
```
【注】上面的配置文件中HostName、Port和User前面是一个<Tab>
保存配置文件后，出现类似下图的结果：
![](https://img2022.cnblogs.com/blog/1617829/202207/1617829-20220729222853556-767058491.png)
上图中有三个服务器，右击服务器，即可选择打开，如下：
![](https://img2022.cnblogs.com/blog/1617829/202207/1617829-20220729223150422-620187330.png)
然后就会提示输入密码，正确输入密码以后，就可以打开终端操作服务器了。






### 3.打开终端

![](https://img2022.cnblogs.com/blog/1617829/202207/1617829-20220729223656341-276163478.png)

进入项目目录下，执行code .   ,即可在当前目录下开启vscode：

![](https://img2022.cnblogs.com/blog/1617829/202207/1617829-20220729223754823-1988717046.png)

输入密码以后，可以看到：

![](https://img2022.cnblogs.com/blog/1617829/202207/1617829-20220729224314069-1321659926.png)

然后我们就可以对服务器文件进行远程操作。
我们还可以直接拖动本地文件到目录下，从而将文件上传到服务器。
我们还可以右击文件，点击下载，将服务器文件下载到本地。

【注】多人同时连接一台服务器的相同账户的时候，可能会出现有人关闭\开启vscode，其他人也会自动关闭\开启一个vscode

### 4.vscode常用快捷键
|快捷键|含义|
| ---- | ---- | 
|    Ctrl P  | 快速查找并打开某个文件     | 
|   Ctrl F   |   在当前文件里搜索字符串    | 
|Ctrl shift F | 在当前工作目录的所有文件里搜索某个字符串 |
|Ctrl + ` |快速打开或关闭终端|
|Alt + / | 快速切换到debug界面（如果在调试状态）|
|Ctrl + B | 快速打开或关闭侧边栏|


### 5.python和C++插件
python和C++插件：
![](https://img2022.cnblogs.com/blog/1617829/202207/1617829-20220731141726628-1521626523.png)


### 6.python和C++调试配置(tasks.json 和 launch.json)

在项目所在文件夹下建立.vscode文件夹，在.vscode中建立launch.json和tasks.json：

C++调试配置：https://www.cnblogs.com/codingbigdog/p/16459417.html
python调试配置：https://www.cnblogs.com/codingbigdog/p/16282625.html

### 7.其他配置




### 问题

tasks.json 和 launch.json、c_cpp_properties.json、settings.json 
这个都是干嘛的？

python和C++的调试配置可以放在同一个launch.json中。
]]></description></item><item><title>docker使用</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/29/16533716.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Fri, 29 Jul 2022 14:06:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/29/16533716.html</guid><description><![CDATA[

#　1.介绍和安装
安装：参考菜鸟教程的手动安装进行安装。[菜鸟教程](https://www.runoob.com/docker/docker-tutorial.html)

docker的目的：代码下载下来以后，要配置代码所需的依赖，这很麻烦。所以将代码和代码所需的依赖包装在一个称作为镜像的东西里面，然后我们直接将镜像下载下来，运行这个镜像就相对于运行了代码。

镜像（Image）：Docker 镜像（Image），**就相当于是一个 root 文件系统，文件系统中存储有代码和代码所需依赖**。比如官方镜像 ubuntu:16.04 就包含了完整的一套 Ubuntu16.04 最小系统的 root 文件系统。
容器（Container）：镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。

看一下是不是文件系统：
```
sudo docker run -i -t ubuntu:20.04 /bin/bash
```
结果：
![](https://img2022.cnblogs.com/blog/1617829/202207/1617829-20220730155521338-54179680.png)

参数：
-t: 在新容器内指定一个伪终端或终端。
-i: 允许你对容器内的标准输入 (STDIN) 进行交互。
/bin/bash：代表在“root@712f2e8b8439:/#”下输入的脚本，使用/bin/bash来解释执行。

[docker 命令每次都需要sudo解决方案](https://blog.csdn.net/Saladbobo/article/details/119750929)

# 2.使用docker部署一个简单的c/c++程序
请直接参考：[使用docker部署一个简单的c/c++程序](https://blog.csdn.net/weixin_43142797/article/details/105895167)

说明：
本博客中使用的镜像codenvy/cpp_gcc应该就是在ubuntu镜像中的相关目录下添加了g++相关的配置环境而已。

查看镜像和容器：
```
docker images   # 列出镜像列表
docker ps -a    # 查看正在运行和已经停止的容器
```
删除镜像和容器：
```
docker rm -f 容器ID或名字   # 删除容器
docker rmi 镜像ID或名字     # 删除镜像
```

上传镜像到远程：
```
docker login    # 登录
docker push REPOSITORY名称或IMAGE ID  # 上传
# 拉取远程镜像
```



















# 3.零基础手写一个 Docker（未完）

总结：[零基础手写一个 Docker](https://www.bilibili.com/video/BV1K44y1j7DV)，如下：

## 3.1 chroot
chroot的作用是:改变进程的根目录，使它不能访问该目录之外的其它文件。

进程运行时使用的根目录，叫rootfs (根文件系统)。在linux系统中，进程运行时默认使用的rootfs就是linux的文件系统，即进程运行时，默认从linux的文件系统中查找程序运行的相关依赖。chroot的作用就是改变进程使用的rootfs。


chroot NEWROOT [COMMAND [ARCG]..]
●NEWROOT:表示要切换到的新root目录
●COMMAND：指的是切换root目录后需要执行的命令




复制linux的ls和bash到chroot指定的文件系统中进行使用：
```
mkdir rootfs_dir_1
cd rootfs_dir_1

# 定位可执行文件ls和bash所在目录
which ls    
/usr/bin/ls
which bash
/usr/bin/bash

# 复制linux的ls和bash到chroot指定的文件系统中
mkdir bin
cp /usr/bin/ls bin
cp /usr/bin/bash bin

# 进入文件系统rootfs_dir_1，并执行/bing/ls
sudo chroot ../rootfs_dir_1 /bin/ls
chroot: failed to run command ‘/bin/ls’: No such file or directory # 找不到执行ls所需要的依赖库，所以报错


file bin/ls  # 查看ls的信息
bin/ls: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=2f15ad836be3339dec0e2e6a3c637e08e48aacbd, for GNU/Linux 3.2.0, stripped
# 可以看到ls是动态链接的执行程序
# bash同理，也是动态链接的执行程序


# 查看ls和bash所依赖的动态库：
ldd /bin/ls
        linux-vdso.so.1 (0x00007fff9ffa5000)
        libselinux.so.1 => /lib/x86_64-linux-gnu/libselinux.so.1 (0x00007faf2031a000)
        libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007faf20128000)
        libpcre2-8.so.0 => /lib/x86_64-linux-gnu/libpcre2-8.so.0 (0x00007faf20098000)
        libdl.so.2 => /lib/x86_64-linux-gnu/libdl.so.2 (0x00007faf20092000)
        /lib64/ld-linux-x86-64.so.2 (0x00007faf2037e000)
        libpthread.so.0 => /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007faf2006f000)

ldd /bin/bash
        linux-vdso.so.1 (0x00007ffd9cde5000)
        libtinfo.so.6 => /lib/x86_64-linux-gnu/libtinfo.so.6 (0x00007f001de6b000)
        libdl.so.2 => /lib/x86_64-linux-gnu/libdl.so.2 (0x00007f001de65000)
        libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f001dc73000)
        /lib64/ld-linux-x86-64.so.2 (0x00007f001dfdb000)

mkdir lib
mkdir lib64
```
编写cp.sh脚本将依赖库复制到rootfs_dir_1的相应目录下，cp.sh内容如下:
```
cp /lib/x86_64-linux-gnu/libselinux.so.1 /lib/x86_64-linux-gnu/libc.so.6 /lib/x86_64-linux-gnu/libpcre2-8.so.0  /lib/x86_64-linux-gnu/libdl.so.2  /lib/x86_64-linux-gnu/libpthread.so.0 lib/
cp /lib64/ld-linux-x86-64.so.2 lib64/

cp  /lib/x86_64-linux-gnu/libtinfo.so.6 /lib/x86_64-linux-gnu/libdl.so.2  /lib/x86_64-linux-gnu/libc.so.6 lib/

cp /lib64/ld-linux-x86-64.so.2 lib64/
```
运行cp.sh
```
sh cp.sh
```
重新运行/bin/ls和/bin/bash，运行成功，如下：
```
sudo chroot ../rootfs_dir_1 /bin/ls
bin  cp.sh  lib  lib64

sudo chroot ../rootfs_dir_1 /bin/bash   # 开启一个shell
bash-5.0# 
bash-5.0# ls
bin  cp.sh  lib  lib64
bash-5.0# exit   # 退出
```
进入bash-5.0#之后运行的ls，指是rootfs_dir_1/bin/ls，即使用bash进入shell以后，然后输入ls，此时shell就会在当前文件系统的bin目录（rootfs_dir_1/bin）中查找可以执行文件ls。

运行sudo chroot ../rootfs_dir_1 ，会自动查找rootfs_dir_1/bin目录下是否有bash可执行文件，用于开启一个shell，如下：
```
sudo chroot ../rootfs_dir_1  # 开启一个shell
bash-5.0# 
```

sudo chroot ../rootfs_dir_1 /可执行文件A：这样的程序只会在执行完，可执行文件A后，就退出了文件系统rootfs_dir_1。
rootfs_dir_1被当成了根目录，然后 “/可执行文件A”代表执行根目录下的可执行文件A。

## 3.2 busybox【安装错了】
busybox是一个集成了一百多个最常用linux命令和工具的软件，甚至还集成了一个http服务器和一个telnet服务器,而所有这一切功能却只有1M左右的大小适用于
●嵌入式设备
●移动设备(安卓)
●超小的linux发行版(alpine linux）

根据[busybox安装](https://blog.csdn.net/m0_48958478/article/details/121628631)配置安装环境，但是这篇文章中未将busybox安装到指定目录中，从这篇文章([安装busybox到指定目录下](https://blog.csdn.net/lly374685868/article/details/80611741))可以知道如何指定安装目录。请将两篇文章结合起来看，然后再进行安装。

```
busybox ls  # 执行busybox中的ls命令
```

busybox安装在busybox目录下：
```
sudo chroot ./busybox /bin/ls
chroot: failed to run command ‘/bin/ls’: No such file or directory
```
我发现直接执行./busybox/bin/ls是可以运行的，但是却出现上面的错误。这是因为./busybox/bin/ls依赖的动态库不在busybox目录下，而在linux系统的lib目录下：
```
ldd busybox/bin/ls
        linux-vdso.so.1 (0x00007ffed202a000)
        libm.so.6 => /lib/x86_64-linux-gnu/libm.so.6 (0x00007f919ffff000)
        libresolv.so.2 => /lib/x86_64-linux-gnu/libresolv.so.2 (0x00007f919ffe3000)
        libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f919fdf1000)
        /lib64/ld-linux-x86-64.so.2 (0x00007f91a026d000)
```

busybox的安装方法还是有问题，待解决。。。。。












## 3.3 其他
容器访问网络方式：
veth、 bridge网桥、NAT

容器会对进程所能使用的CPU资源设置上限，一旦超过上限，就会跑不了。


容器的基石：
rootfs做文件系统，namespace 做隔离，cgroup 做限制，分层镜像

rootfs
namespace
cgroup
veth/bridge/nat
AUFS

# 问题
问题：
docker hub中的库和镜像的区别？
一个库中可以存多个镜像？
tag是什么？
]]></description></item><item><title>C++多线程中的join, detach, joinable</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/27/16526544.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Wed, 27 Jul 2022 13:21:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/27/16526544.html</guid><description><![CDATA[thread对象构造完成（线程开始执行）之后，对象析构之前，我们必须选择是等待它（join）或者让它在后台运行（detach），如果你在thread对象析构前没有这么做，那么线程将会终止，因为thread的析构函数中调用了std::terminate()。
join的意思是父线程等待子线程结束
detach的含义是主线程和子线程相互分离，但是主线程结束了，子线程也会结束。

joinable()函数是一个布尔类型的函数，他会返回一个布尔值来表示当前的线程是否是可执行线程(能被join或者detach)，因为相同的线程不能join两次，也不能join完再detach，同理也不能detach完再join，所以joinable函数就是用来判断当前这个线程是否可以joinable的。通常不能被joinable有以下几种情况：

       1）由thread的缺省构造函数而造成的（thread()没有参数）。

       2）该thread被move过（包括move构造和move赋值）。

       3）该线程被join或者detach过。


线程没有执行join和detach时：
```
#include <iostream>
#include <thread>
#include <unistd.h>

using namespace std;
void func2(){
    cout<<"22222"<<endl;
}
 
void func(){
    cout<<"11111111"<<endl;
    thread t(func2);
    cout<<"33333333"<<endl;
}

int main(){
    func();
    cout<<"main"<<endl;

    sleep(10);

    return 0;
}
```
结果：
```
g++ -Wall -g -std=c++11 -pthread test2.cpp -o test2
./test2 
11111111
33333333
terminate called without an active exception
Aborted (core dumped)
```
在函数func中，启动线程t，但是线程t没有执行join或detach，那么在函数func执行完毕的时候就会发生错误，从而中断整个程序。

[使用detach时，如果子线程还没清理垃圾，主线程就结束了，那么就会导致内存溢出](https://blog.csdn.net/yixinuestc/article/details/122229052)

[C++多线程，请参考此链接进行学习](https://blog.csdn.net/m0_37621078/article/details/104909834)


参考：[C++多线程中的join, detach, joinable](https://blog.csdn.net/Charles_Zaqdt/article/details/104134965)
]]></description></item><item><title>计算机网络知识点总结:以太网</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522427.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Tue, 26 Jul 2022 11:51:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522427.html</guid><description><![CDATA[
                    <p>一，以太网的接口和线缆</p> 
<p>1，不同以太网标准的技术要求：传输介质与作用距离</p> 
<p>2，直连与交叉线的选择：不同种接口（指MDI和MDI-X）选直连，同种接口选交叉，现在能自适应，但旧设备要注意</p> 
<p>以太网接口标识：e，f，g</p> 
<p>S口是serial接口的意思，也叫高速异步串口，主要是连接广域网的V.35线缆用的，说白了就是路由器和路由器连接时候用的，可以用命令设置带宽，一般也就在10M、8M左右。</p> 
<p>F口是FastEthernet接口，叫快速以太网口，主要连接以太网（局域网）用的，说白了就是连接交换机或电脑用的，用普通的双绞线就可以连接，速率默认是100Mbps，可以用命令限速，但是不可能超过100Mbps。</p> 
<p>E口是Ethernet接口，叫以太网接口，也是主要连接以太网（局域网）用的，也是用普通的双绞线就可以连接，速率默认是10Mbps，现在新型的设备上已经把这个接口淘汰了。</p> 
<p>另外，路由器上还有一个必不可少的接口是Console口，叫控制口，这个接口是用来调试路由器的。</p> 
<p>另外有的路由器还有AUX接口，也是控制接口；</p> 
<p>G口，是千兆以太网接口，是连接以太网用的。</p> 
<p>3，（1）网络设备接口分MDI (Medium Dependent Interface，终端到网络连接设备 )和MDI_X（交叉，终端到终端）两种。</p> 
<p>（2）一般路由器的以太网接口、主机的网卡接口类型为MDI。交换机的接口类型可以为MDI或MDI_X。Hub(集线器)的接口类型为MDI_X。即：主机和路由器属于同种；交换机和Hub属于同种</p> 
<p>（3）双绞线可以分为直连网线和交叉网线，直连网线用于连接MDI和MDI_X，交叉网线用于连接MDI和MDI，或者MDI_X和MDI_X。即： &nbsp;&nbsp; &nbsp;直连用于不同种；交叉用于同种</p> 
<p>2、以太网有哪几种介质？ &nbsp; &nbsp;</p> 
<p>包括同轴电缆、双绞线和光纤。</p> 
<p>以太网有哪几种速率？ &nbsp; &nbsp;</p> 
<p>10M、100M、1000M、10G。</p> 
<p>二，了解以太网端口的几项基本技术：</p> 
<p>自协商--以太网速率提高而如何与原10M以太网设备兼容的问题（利旧问题）--常引起ping通问题</p> 
<p>流量控制—处理与发送速率不对等—网络的可靠性</p> 
<p>端口聚合：提高带宽和可靠性—设备的可靠性 &nbsp;</p> 
<p>端口镜像：大流量数据的备份与监测—数据的可靠性</p> 
<p>1，（1）自协商功能允许一个网络设备将自己所支持的工作模式信息传递给网络上的对端，并接受对方可能传递过来的相应信息</p> 
<p>自协商功能完全由物理层芯片设计实现，简单地是通过上电后测试脉冲实现的因此并不使用专用数据报文或带来任何高层协议开销。</p> 
<p>注意：只对双绞线T而言，对光纤通信不支持自协商，需手动配置两端速率/<span style="color:#86ca5e;"><strong>工作模式</strong></span>，如果光纤两端的配置不同，是不能通信的。（实验时需注意，ping不通的原因之一）</p> 
<p>（2）以太网电接口有下面三种双工模式</p> 
<p>全双工：端口同时发送和接收数据包</p> 
<p>半双工：端口同一时刻只能发送数据包或接收数据包</p> 
<p>自协商：端口双工状态由本端口和对端端口自动协商而定 &nbsp; &nbsp;</p> 
<p>以太网光接口只能工作在全双工模式下</p> 
<p>2，流量控制—处理与发送速率不对等（一般是交换机所具有的技术）</p> 
<p>半双工—发送csma/cd协议的模拟（不是真正）冲突信号，从而使对方停下</p> 
<p>全双工—不使用csma/cd协议，所以采用发送专门的pause帧，并用组播地址01-80-C2-00-00-01进行发送</p> 
<p>3，（1）端口聚合：也称为端口捆绑、端口聚集或链路聚合。 &nbsp; 端口聚合将多个接口聚合在一起形成1个汇聚组，以实现负载分担。从外面看起来，1个汇聚组好象就是1个接口&nbsp;。多根链路合并为一根eth-trunk，提高流量负载分组和可靠性（同组成员彼此动态备份）</p> 
<p>（2）端口聚合的优点：</p> 
<p>第一，增加网络带宽。端口聚合可以将多个连接的接口捆绑成为一个逻辑端口，捆绑后的带宽是每个独立接口的带宽总和。当接口上的流量增加而成为限制网络性能的瓶颈时，采用支持该特性的交换机可以轻而易举地增加网络的带宽（例如，可以将2－4个100Mbit/s端口连接在一起组成一个200—400Mbit/s的连接）</p> 
<p>第二，提高网络连接的可靠性。当主干网络以很高的速率连接时，一旦出现网络连接故障，将会导致大量的数据丢失。高速服务器以及主干网络连接必须保证绝对的可靠。采用端口聚合技术可以保障网络连接的可靠性。例如，将一根电缆错误地拔下来不会导致链路中断。也就是说，组成端口聚合的某一接口连接失败，网络数据将自动重定向到那些正常工作的连接上。这个过程非常快，只需要更改一个访问地址就可以了。然后，交换机将数据转到其他端口，该特性可以保证网络无间断地工作。</p> 
<p>（3）端口聚合的限制条件</p> 
<p>&nbsp; 端口聚合两端的物理参数必须保持一致 进行聚合的链路的数目 、进行聚合的链路的速率 、进行聚合的链路的双工方式 &nbsp;</p> 
<p>&nbsp; 端口聚合两端的逻辑参数必须保持一致：同一个汇聚组中端口的基本配置必须保持一致，基本配置主要包括STP、QoS、VLAN、端口等相关配置</p> 
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;STP配置一致，包括：端口的STP开启/关闭、与端口相连的链路属性（如点对点或非点对点）、STP优先级、路径开&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; 销、报文发送速率限制、是否环路保护、是否根保护、是否为边缘端口。</p> 
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;QoS配置一致，包括：流量限速、优先级标记、缺省的802.1p优先级、带宽保证、拥塞避免、流重定向、流量统计等。</p> 
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;VLAN配置一致，包括：接口上允许通过的VLAN、接口缺省VLAN ID。 接口配置一致，包括：接口的链路类型，如&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Trunk、Hybrid、Access属性。</p> 
<p>4，端口镜像：端口镜像一般应用于流量观测和故障定位中，它把特定的业务数据复制一份，传送到监控设备，然后进行镜像数据分析。 端口镜像可以分为基于端口的镜像和基于流的镜像两种。大流量，如视频流量拷贝到其他端口</p> 
<p>（1）基于端口的镜像是把被镜像端口的进出数据报文完全拷贝一份到镜像端口，进行流量观测或者故障定位</p> 
<p>（2）基于流的镜像只对满足条件的数据流进行镜像。这些流可能具有相同的目地地址，端口号等，可根据需求灵活定义。</p> 
<p>5，问题：</p> 
<p>（1）什么是自协商技术？ &nbsp;</p> 
<p>自协商技术是为了解决不同速率以太网设备之间的兼容性，协商内容包括端口的速度、双工模式等。</p> 
<p>（2）半双工流量控制和全双工流量控制有什么区别？ &nbsp; &nbsp;</p> 
<p>半双工流量控制使用反向压力（backpressure）方法，当网络拥塞时，交换机将插入“载波检测”或者强行制造一次冲突。 &nbsp; &nbsp;在全双工情况下，IEEE 802.3x规定了一种64字节的“PAUSE”MAC控制帧的格式。当端口发生阻塞时，交换机向信息源发送“PAUSE”帧，告诉信息源暂停一段时间再发送信息。</p> 
<p>（3）端口汇聚和端口镜像有什么作用？ &nbsp; &nbsp;</p> 
<p>端口汇聚可以提高链路带宽，实现流量负载分担，提高网络的可靠性；&nbsp;端口镜像一般应用于流量观测和故障定位中，它把特定的业务数据复制一份，传送到监控设备，然后进行镜像数据分析。</p> 
<p>三，VLAN技术原理和配置</p> 
<p>可以先看这个:<a href="https://baijiahao.baidu.com/s?id=1628398215665219628&amp;wfr=spider&amp;for=pc">https://baijiahao.baidu.com/s?id=1628398215665219628&amp;wfr=spider&amp;for=pc</a></p> 
<p>1，VLAN产生的原因：传统的以太网交换机在转发数据时，采用源地址学习的方式，自动学习各个端口连接的主机的MAC地址，形成转发表，然后依据此表进行以太网帧的转发，整个转发的过程自动完成，所有端口都可以互访，维护人员无法控制端口之间的转发。 该网络存在如下缺陷：</p> 
<p>网络的安全性差。由于各个端口之间可以直接互访，增加了用户进行网络攻击的可能性。</p> 
<p>网络效率低。用户可能收到大量不需要的报文，这些报文同时消耗网络带宽资源和客户主机CPU资源，例如不必要的广播报文。</p> 
<p>业务扩展能力差。网络设备平等的对待每台主机的报文，无法实现有差别的服务，例如无法优先转发用于网络管理的以太网帧。</p> 
<p>2，VLAN技术的目标：VLAN(Virtual Local Area Networks)技术把用户划分成多个逻辑的网络(group)，组内可以通信，组间不允许通信。二层转发的单播、组播、广播报文只能在组内转发，并且很容易地实现组成员的添加或删除。</p> 
<p>3，通过标签管理实现VLAN：在现有的交换网络环境中，以太网的帧有两种格式： 没有加上VLAN标记的标准以太网帧（untagged frame）；有VLAN标记(VLANID)的以太网帧（tagged frame).支持VLAN技术的交换机，转发以太网帧时不再仅仅依据目的MAC地址，同时还要考虑该端口的VLAN配置情况，从而实现对二层转发的控制.</p> 
<p>4,确定标签中的VLAN ID取值：</p> 
<p>(1)基于端口：网络管理员给交换机的每个端口配置PVID，即Port VLAN ID，有些场合称为端口默认VLAN。如果收到的是untagged帧，则VLAN ID的取值为PVID。</p> 
<p>(2)基于MAC地址：网络管理员配置好MAC地址和VLAN ID的映射关系表，如果收到的是untagged帧，则依据该表添加VLAN ID。</p> 
<p>(3)基于协议：网络管理员配置好以太网帧中的协议域和VLAN ID的映射关系表，如果收到的是untagged帧，则依据该表添加VLAN ID。</p> 
<p>(4)基于子网：根据报文中的IP地址信息，确定添加的VLAN ID。</p> 
<p>(5)基于策略：安全性非常高，基于MAC地址+IP地址、MAC地址+IP地址+接口。成功划分VLAN后，可以达到禁止用户改变IP地址或MAC地址的目的。</p> 
<p>注意1:所有以太网帧在交换机内都是以tagged frame的形式流动的，即某端口从本交换机其他端口收到的帧一定是tagged的。 但端口从对端设备收到的帧，可能是untagged或者是tagged的，如果收到的是tagged frame，则进入转发过程，如果该端口收到的是untagged frame，则必须加上标签。 简单地说从交换机内部收到的帧不需要加标签处理；从对端收到的可能需要加标签</p> 
<p>注意2:设备同时支持多种方式时，一般情况下，优先使用顺序为：基于策略→基于MAC地址→基于子网→基于协议→基于端口。 基于端口划分VLAN的优先级最低，但是是最常用的VLAN划分方式。</p> 
<p>5,交换机端口类型</p> 
<p>引入VLAN功能后，交换机的接口被划分为三种类型Access接口、Trunk接口、Hybrid接口，及三种链路类型：access、trunk、hybrid。</p> 
<p>(1)access类型只属于一个VLAN，一般用于连接计算机端口。</p> 
<p>Access接口，用于连接主机，有如下特点：</p> 
<p>&nbsp;仅仅允许唯一的VLAN ID通过本接口，这个值与接口的PVID相同。</p> 
<p>如果该接口收到的对端设备发送的帧是untagged，交换机将强制加上该接口的PVID。</p> 
<p>Access接口发往对端设备的以太网帧永远是untagged frame。</p> 
<p>很多型号的交换机默认接口类型是access，PVID默认是1，VLAN 1由系统创建，不能被删除。</p> 
<p>(2)trunk类型可以允许多个vlan通过，可以接收和发送多个vlan的报文，一般用于交换机之间的端口。</p> 
<p>(3)hybrid类型可以允许多个vlan通过，可以接受和发送多个vlan的报文，可以用于交换机之间连接，也可以用于连接用户计算机。</p> 
<p><img alt="" class="has" height="347" src="https://img-blog.csdnimg.cn/20191102184537542.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzc1OTM4,size_16,color_FFFFFF,t_70" width="834"></p> 
<p>(3)Access端口的收发规则：不接收带标签的数据包，发出的数据包也是不带标签的</p> 
<p>Trunk端口的收发规则：接收带标签的数据包，发出的数据包也是带标签</p> 
<p>6,问题:1.交换机有哪几种端口类型？</p> 
<p>答：access、trunk、hybrid。</p> 
<p>2.Trunk端口发往对端设备的一定是tagged frame吗？</p> 
<p>答：大多数情况下是tagged frame，但是如果待转发帧的VLAN ID与PVID值相同，则移除标签后转发。</p> 
<p>四,VLAN路由</p> 
<p>具体还是看这个:<a href="https://baijiahao.baidu.com/s?id=1628398215665219628&amp;wfr=spider&amp;for=pc">https://baijiahao.baidu.com/s?id=1628398215665219628&amp;wfr=spider&amp;for=pc</a></p> 
<p>1,VLAN路由的原理：与真实的LAN类而不同，真实的只用路由器，VlAN的可以用三层交换机</p> 
<p>&nbsp;2,二层交换机和路由器在功能上的集成构成了三层交换机，三层交换机在功能上实现了VLAN的划分、VLAN内部的二层交换和VLAN间路由的功能。(这时相当于二层交换机+路由器=三层交换机,或者说是一个内置了路由软件的二层交换机)</p> 
<p>3,VLAN路由的目的是什么？</p> 
<p>答：VLAN的优点是可以隔离广播域，但这也引起另外一个问题，就是广播域之间如果需要通信的话，那怎么办呢？在这里就提出了VLAN路由的概念，目的就是为了实现不同VLAN间的相互通信</p> 
<p>4.实现VLAN间的通信有多少种方法？</p> 
<p>答：如果交换是普通的二层交换机的话，只能通过路由器配置单臂路由实现VLAN间的通信；但如果交换是三层交换机，可以通过配置三层VLAN接口实现VLAN间的通信。</p> 
<p>&nbsp;</p> 
<p>五,1,STP概述:</p> 
<p>(1)生成树产生的原因：透明网桥的自学习算法中的广播算法与冗余环路结合带来的广播风暴问题；同路由表类似的MAC表的不稳定收敛 (即环路引起的问题:广播风暴和MAC地址表不稳定)</p> 
<p>(2)生成树协议STP的作用：消除环路/提供备份</p> 
<p>(3)生成树协议STP的基本原理：以树形是连通的/无环路的最小子图</p> 
<p>(4)STP协议中的几个基本概念和选取方法：根桥/根端口/指定端口/替换备份端口；选取优先级+MAC地址较小者（与DR中的IP地址不一样）--多个交换机相连时并非所有端口都是活动的)</p> 
<p>2,生成树基本计算过程:STP协议中定义了根桥（Root Bridge）、根端口（Root Port）、指定端口（Designated Port）、路径开销（Path Cost）等概念。通过构造一棵树的方法达到裁剪冗余的环路的目的，同时实现链路备份和路径最优化。用于构造这棵树的算法称为生成树算法SPA（Spanning Tree Algorithm）。 为了计算生成树，交换机之间需要交换相关信息和参数，这些信息和参数被封装在配置BPDU（Configuration Bridge Protocol Data Unit）中，在交换机之间传递</p> 
<p>生成树形成概述:1. 从所有的网桥（交换机是多端口的网桥）中选择一个作为根网桥；</p> 
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2. 计算从本网桥到根网桥的最短路径；</p> 
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3. 对每一个共享网段，选择距根桥最近的网桥作为指定网桥，负责该网段的数据转发；</p> 
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4. 对每一个网桥，选择一个根端口。从根端口给出的路径是从本网桥到根网桥的最短路径；</p> 
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;5.选择除根端口以外的指定端口。</p> 
<p>具体行为,自行百度</p> 
<p>3,STP存在的问题</p> 
<p>(1)临时环路问题</p> 
<p>解决临时环路的方法是：在一个端口从不转发状态进入转发状态之前，需要等待一个足够长的时间，以使需要进入不转发状态的端口有足够时间完成生成树计算，并进入不转发状态。</p> 
<p>(2)部分VLAN不能互通:</p> 
<p>解决方法:多生成树协议MSTP</p> 
<p>4,问题:</p> 
<p>生成树协议如何在网络中计算出一棵无环的树？</p> 
<p>在网络中选出一个根交换机，为每个非根交换机选择一个根端口，为每个网段选择一个指定端口，将既不是根端口也不是指定端口的端口设为阻塞状态。</p> 
<p>生成树协议如何解决临时环路问题？</p> 
<p>当一个端口从不转发状态转为转发状态之前，要经过两个Forward Delay间隔，以确保网络中其它交换机完成生成树计算。</p> 
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<p>&nbsp;</p>
                ]]></description></item><item><title>hello flask</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522428.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Tue, 26 Jul 2022 11:51:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522428.html</guid><description><![CDATA[
                    <pre>from flask import Flask

app = Flask(__name__)

@app.route('/')
def hello():
    return "hello world"

@app.route('/about')
def about():
    return '这是一个用flask建立的小网站'

@app.route('/user/&lt;username&gt;')
def show_user(username):
    return 'User Name is {}'.format(username)

if __name__ == '__main__':
    app.run()</pre>
                ]]></description></item><item><title>数据库基础1</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522429.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Tue, 26 Jul 2022 11:51:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522429.html</guid><description><![CDATA[
                    <h2><strong><strong><strong>实验一 &nbsp;数据库的定义和建立实验</strong></strong></strong></h2> 
<h3><strong><strong><strong>一、实验目的</strong></strong></strong></h3> 
<p style="margin-left:0pt;">要求学生熟练掌握和使用T－SQL﹑SQL Server企业管理器创建数据库﹑基本表﹑视图﹑索引和修改表结构，及向数据库输入数据的操作；学会创建和使用表的主码、外码和约束。</p> 
<h3><strong><strong><strong>二、实验内容</strong></strong></strong></h3> 
<p style="margin-left:0pt;">1﹑创建相应的数据库和查看数据库属性；</p> 
<p style="margin-left:0pt;">（1）创建数据库及日志文件</p> 
<p style="margin-left:0pt;">create&nbsp; database EDUCATION&nbsp;&nbsp;//数据文件的SQL语句</p> 
<p style="margin-left:0pt;">on primary(&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //默认属于PRIMARY文件组，可省略</p> 
<p style="margin-left:0pt;">name='EDUCATION',&nbsp;&nbsp;&nbsp; //主数据文件的逻辑名称</p> 
<p style="margin-left:0pt;">&nbsp;</p> 
<p style="margin-left:0pt;">filename='C:\ProgramFiles\MicrosoftServer\MSSQL11.MSSQLSERVER\MSSQL\DATA\EDUCATION.mdf', &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //主数据文件的物理名称</p> 
<p style="margin-left:0pt;">size=5mb,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//主数据文件的初始大小</p> 
<p style="margin-left:0pt;">maxsize=unlimited,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //主数据文件增长的最大值</p> 
<p style="margin-left:0pt;">filegrowth=1mb&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //主数据文件自动增量</p> 
<p style="margin-left:0pt;">)</p> 
<p style="margin-left:0pt;">&nbsp;</p> 
<p style="margin-left:0pt;">//日志文件的SQL语句</p> 
<p style="margin-left:0pt;">log on(</p> 
<p style="margin-left:0pt;">name='EDUCATION_log', //日志文件的逻辑名称</p> 
<p style="margin-left:0pt;">filename='C:\ProgramFiles\MicrosoftSQLServer\MSSQL11.MSSQLSERVER\MSSQL\DATA\EDUCATION_log.ldf', &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //日志文件的物理名称</p> 
<p style="margin-left:0pt;">size=2mb,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //日志文件的初始大小</p> 
<p style="margin-left:0pt;">maxsize=unlimited,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //日志文件增长的最大值</p> 
<p style="margin-left:0pt;">filegrowth=10%&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //日志文件自动增量</p> 
<p style="margin-left:0pt;">)</p> 
<p style="margin-left:0pt;">&nbsp;</p> 
<ol><li>查看数据库属性</li></ol>
<p style="margin-left:0pt;"><span style="color:#0000ff;">exec</span>&nbsp;<span style="color:#800000;">sp_helpdb</span>&nbsp;<span style="color:#000000;">experiment</span><span style="color:#808080;">;</span><span style="color:#808080;">//查看（1）中我们的配置</span></p> 
<p style="margin-left:0pt;">&nbsp;</p> 
<p style="margin-left:0pt;">2﹑创建基本表﹑确定表的主码和相应的约束，为主码建索引；</p> 
<ol><li>创建基本表、确定表的主码和相应的约束条件：</li></ol>
<p style="margin-left:0pt;">create table S(</p> 
<p style="margin-left:0pt;">SNO char(4) primary key,</p> 
<p style="margin-left:0pt;">SNAME char(20) unique,</p> 
<p style="margin-left:0pt;">STATUS char(4),</p> 
<p style="margin-left:0pt;">CITY char(20)</p> 
<p style="margin-left:0pt;">)</p> 
<p style="margin-left:0pt;">create table SPJ(</p> 
<p style="margin-left:0pt;">SNO char(4),</p> 
<p style="margin-left:0pt;">Foreign key(SNO) references S(SNO)</p> 
<p style="margin-left:0pt;">)</p> 
<p style="margin-left:0pt;">……</p> 
<p style="margin-left:0pt;">……</p> 
<ol><li>为主码建立索引：</li></ol>
<p style="margin-left:0pt;">为S表建立索引，S表按SNO降序建唯一索引：</p> 
<p style="margin-left:0pt;">Create unique index SSno on S(sno DESC)</p> 
<p style="margin-left:0pt;">&nbsp;</p> 
<p style="margin-left:0pt;">3﹑创建﹑查看视图；</p> 
<ol><li>创建：</li></ol>
<p style="margin-left:0pt;">Create view name</p> 
<p style="margin-left:0pt;">As</p> 
<p style="margin-left:0pt;">Select SNAME</p> 
<p style="margin-left:0pt;">From S</p> 
<p style="margin-left:0pt;">Where Sno=’S1’</p> 
<p style="margin-left:0pt;">With check option;</p> 
<ol><li>查看：</li></ol>
<p style="margin-left:0pt;"><span style="color:#0000ff;">Select</span><span style="color:#000000;">&nbsp;SNAME</span></p> 
<p style="margin-left:0pt;"><span style="color:#0000ff;">From</span><span style="color:#000000;">&nbsp;S</span></p> 
<p style="margin-left:0pt;"><span style="color:#0000ff;">Where</span><span style="color:#000000;">&nbsp;Sno</span><span style="color:#808080;">=</span><span style="color:#ff0000;">'S1'</span><span style="color:#808080;">;</span></p> 
<p style="margin-left:0pt;">&nbsp;</p> 
<p style="margin-left:0pt;">5﹑利用T－SQL和SQL Server企业管理器向数据库输入数据。</p> 
<p style="margin-left:0pt;"><span style="color:#0000ff;">Insert</span></p> 
<p style="margin-left:0pt;"><span style="color:#0000ff;">Into</span><span style="color:#000000;">&nbsp;S</span><span style="color:#808080;">(</span><span style="color:#000000;">SNO</span><span style="color:#808080;">,</span><span style="color:#000000;">SNAME</span><span style="color:#808080;">,</span><span style="color:#0000ff;">STATUS</span><span style="color:#808080;">,</span><span style="color:#000000;">CITY</span><span style="color:#808080;">)</span></p> 
<p style="margin-left:0pt;"><span style="color:#0000ff;">Values</span><span style="color:#808080;">(</span><span style="color:#ff0000;">'S10'</span><span style="color:#808080;">,</span><span style="color:#ff0000;">'好爸爸'</span><span style="color:#808080;">,</span><span style="color:#ff0000;">'10'</span><span style="color:#808080;">,</span><span style="color:#ff0000;">'厦门'</span><span style="color:#808080;">)</span></p>
                ]]></description></item><item><title>模型融合易错点</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522430.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Tue, 26 Jul 2022 11:51:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522430.html</guid><description><![CDATA[
                    <p>bagging：（原文链接：https://blog.csdn.net/u014791046/article/details/46832891）</p> 
<p>使用bagging加强后的算法的性能会出现一些有规律的变化。一般而言，若原来的算法的稳定性差，使用bagging后，算法的准确率会得到较大程度的提高。若原来的算法的稳定性高，则使用bagging后，算法的准确率会略微降低。因此，在考虑使用bagging之前，要先知道原算法的稳定性。</p> 
<p>&nbsp;</p>
                ]]></description></item><item><title>安卓开发：intent</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522431.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Tue, 26 Jul 2022 11:51:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522431.html</guid><description><![CDATA[
                    <h2>intent介绍</h2> 
<ol><li>那我们到底是怎么从一个窗口跳转到另个窗口的，一个窗口的信息是怎么传递给另一个窗口的呢？没错，就是通过intent。下面我们来简单的介绍一下intent。</li><li>Android中使用Intent的方式有两种，分别为显式Intent和隐式Intent。</li></ol>
<pre class="has"><code>//显式intent（这一个代码块，只介绍一个窗口怎么跳到另一个窗口）
//方法一：
//创建Intent对象，指定启动的类名。就是如果intent对象被启动那么窗口就会从MainActivity所对应的
//窗口跳转到SecondActivity所对应的窗口

SecondActivity Intent intent=new Intent(MainActivity.this, SecondActivity.class); 

//启动intent

startActivity(intent);

//方法二：除了通过指定类名的方式来跳转窗口外，显式Intent还可以根据目标组件的包名、全路径来指
//定要跳转的窗口。
//setClassName(“包名”,“类的全路径名称”);
intent.setClassName(“com.jxust.cn”,“com.jxust.cn.chapter_shengtime”);
//启动Activity
startActivity(intent);


//隐式intent（我不懂，但我把别人的笔记放在下面）：
在程序中没有明确指定需要启动的Activity,Android系统会根据在Androidmanifest.xml文件当中设置
//的动作（action）、类别（category）、数据（Uri和数据类型）来启动合适的组件。

&lt;activity android:name=".MainActivity"&gt;
  &lt;intent-filter&gt;
&lt;!—设置action属性，根据name设置的值来指定启动的组件--&gt;
    &lt;action android:name="android.intent.action.MAIN" /&gt;
    &lt;category android:name="android.intent.category.LAUNCHER" /&gt;
            &lt;/intent-filter&gt;
        &lt;/activity&gt;

//说明：&lt;action&gt;标签指定了当前Activity可以响应的动作为android.intent.action.MAIN，而
//&lt;category&gt;标签则包含了一些类别信息，只有当这两者中的内容同时匹配时，Activity才会启动。
ntent intent=new Intent();
Intent.setAction(“android.intent.action.MAIN”);
StartActivity(intent);
</code></pre> 
<pre class="has"><code>//窗口和窗口之间的跳转实现了，那么窗口和窗口之间的信息怎么传递？下面我们来介绍一下
Intent intent=new Intent(this,SecondActivity.class);
//传递参数
intent.putExtra(键, 值);//“值“可以是任意类型的数据，”键“就是给“值”取一个名字就叫“键”，
                       //“键”可以用来索引
startActivity(intent);



如果需要传递的参数比多时，就需要使用putExtras()方法传递数据，该方法传递的是Bundle对象，具体的代码如下:
Intent intent=new Intent(this,SecondActivity.class);
Bundle bundle=new Bundle();
bundle.putString("phone","123456");
bundle.putString("sex","男");
bundle.putString("age","18"); 
intent.putExtras(bundle);
startActivity(intent); 




//被启动的窗口怎么接受到数据的呢？
Intent intent=this.getIntent();
String receive_str=intent.getStringExtra(键);//”键“在这里就被用到了</code></pre> 
<pre class="has"><code>利用onActivityResult获取跳转到的目标窗口的返回值：


如果启动一个Activity，并且希望返回结果给当前的Activity，那么可以使用startActivityForResult()方法来启动Activity


startActivityForResult(Intent intent, int requestCode)
第一个参数为普通Intent，指定要启动的NewActivity
第二个参数为请求码，即调用startActivityForResult()传递过去的值


为了获取被启动Activity的返回结果，需要执行以下两个步骤：
1.被启动的Activity需要调用setResult(int resultCode,Intent data)方法设置返回的结果数据
2.跳转前的Activity要重写onActivityResult(int requestCode,int resultCode,Intent intent)方法接收结果数据


onActivityResult(int requestCode, int resultCode, Intent data) 
第一个参数为请求码，即调用startActivityForResult()传递过去的值
第二个参数为结果码，结果码用于标识返回数据来自哪个新Activity
第三个参数为返回的数据，来自NewActivity
</code></pre> 
<pre class="has"><code>利用onActivityResult获取返回值与intent.getStringExtra获取返回值的区别？
坑，未填。。。。。。。。。
</code></pre> 
<h2>我们来实战一下吧。。。</h2> 
<h2>目标：</h2> 
<ol><li> <p>做一个登入和注册的界面：在登入界面中点击注册按钮，就跳转到注册界面。注册完了之后，点击完成，就会跳转到登入页面。此时的登入页面已经自动填写了已注册的信息。点击登入，跳转到一个界面上，这个界面上显示“欢迎 小明”</p> </li><li> <p>我们要创建三个窗口，那我们就要创建三个activity，三个layout。三个activity分别是：MainActivity（登入） Activity2（点击登入后跳转到的欢迎界面）Activity3（注册）。这个三个activity分别对应三个layout为：<strong><em><span style="color:#660e7a;"><strong><em>activity_main、mylayout2</em></strong></span></em></strong><span style="color:#000000;">、</span><strong><em><span style="color:#660e7a;"><strong><em>mylayout</em></strong></span></em></strong></p> </li></ol>
<p>&nbsp;</p> 
<p>1，在MainActivity中填入：</p> 
<pre class="has"><code>package com.example.lesson3;

import androidx.appcompat.app.AppCompatActivity;

import android.os.Bundle;

import android.content.Intent;
import android.os.Bundle;
import android.view.View;
import android.widget.Button;
import android.widget.EditText;
import android.widget.Toast;


public class MainActivity extends AppCompatActivity {

    //创建两个Button用于登入和注册，创建两个EditText，用于输入账号和密码
    private Button btnLogin,btnReg;
    private EditText edtName,edtPwd;
    private final int REQUEST_CODE=101;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        btnLogin = (Button) findViewById(R.id.btnLogin);
        btnReg = (Button) findViewById(R.id.btnReg);
        edtName = (EditText) findViewById(R.id.edtName);
        edtPwd = (EditText) findViewById(R.id.edtPwd);

        //点击登入，向Activity2传递用户名
        btnLogin.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                Intent intent=new Intent(MainActivity.this, Activity2.class);
                String name=edtName.getText().toString();
                String pwd=edtPwd.getText().toString();
                intent.putExtra("name",name);
                intent.putExtra("pwd",pwd);
                startActivity(intent);
            }
        });

        //点击注册，跳转到Activity3。进行注册，
        btnReg.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                Intent intent=new Intent(MainActivity.this, Activity3.class);
                startActivityForResult(intent,REQUEST_CODE);
            }
        });
    }



    @Override
    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
        super.onActivityResult(requestCode, resultCode, data);
        if(requestCode==REQUEST_CODE){
            String name=data.getStringExtra("name");
            String pwd=data.getStringExtra("pwd");
            edtName.setText(name);
            edtPwd.setText(pwd);
        }
    }

}
</code></pre> 
<p>2，在Activity3中填入：</p> 
<pre class="has"><code>package com.example.lesson3;

import android.app.Activity;

import android.content.Intent;
import android.os.Bundle;
import android.view.View;
import android.widget.Button;
import android.widget.EditText;
import android.widget.Toast;

public class Activity3 extends Activity {
    private Button btnReg;
    private EditText edtName, edtPwd, edtRePwd;
    private static final int RESULT_CODE = 101;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.mylayout);
        btnReg = (Button) findViewById(R.id.btnReg);
        edtName = (EditText) findViewById(R.id.edtName);
        edtPwd = (EditText) findViewById(R.id.edtPwd);
        edtRePwd = (EditText) findViewById(R.id.edtRepwd);

        btnReg.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                String name = edtName.getText().toString();
                String pwd = edtPwd.getText().toString();
                String repwd = edtRePwd.getText().toString();
                if (!"".equals(pwd) &amp;&amp; pwd.equals(repwd)) {
                    //获得启动该Activity的Intent对象
                    Intent intent = getIntent();
                    intent.putExtra("name", name);
                    intent.putExtra("pwd", pwd);
                    //设置结果码，并设置结束后返回的Activity
                    setResult(RESULT_CODE, intent);
                    //结束RegActivity
                    Activity3.this.finish();
                } else {
                    Toast.makeText(Activity3.this, "密码输入不一致", Toast.LENGTH_LONG).show();
                }
            }
        });
    }
}
</code></pre> 
<p>3，在Activity2中填入：</p> 
<pre class="has"><code>package com.example.lesson3;

import android.app.Activity;
import android.content.Intent;
import android.os.Bundle;
import android.widget.TextView;

public class Activity2 extends Activity {
    private TextView welcome;

    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.mylayout2);
        welcome=(TextView)findViewById(R.id.welcome);
        Intent intent=this.getIntent();
        String name=intent.getStringExtra("name");
        welcome.setText("Hello "+name);
    }
}
</code></pre> 
<p>4，在<span style="color:#000000;">在AndroidManifest.xml中</span></p> 
<pre class="has"><code>4，在AndroidManifest.xml中
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.example.lesson3"&gt;

    &lt;application
        android:allowBackup="true"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/AppTheme"&gt;
        &lt;activity android:name=".MainActivity"&gt;
            &lt;intent-filter&gt;
                &lt;action android:name="android.intent.action.MAIN" /&gt;

                &lt;category android:name="android.intent.category.LAUNCHER" /&gt;
            &lt;/intent-filter&gt;
        &lt;/activity&gt;

//下面两个activity为新添加的：
       &lt;activity android:name=".Activity3"&gt;
        &lt;/activity&gt;
        &lt;activity android:name=".Activity2"&gt;
        &lt;/activity&gt;
    &lt;/application&gt;

&lt;/manifest&gt;</code></pre> 
<p>5，<span style="color:#000000;">在layout拖拽，形成界面</span></p> 
<p style="margin-left:0pt;">&nbsp;</p> 
<p style="margin-left:0pt;">&nbsp;</p>
                ]]></description></item><item><title>failed to push some refs to</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522432.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Tue, 26 Jul 2022 11:51:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522432.html</guid><description><![CDATA[
                    <p>来自百度知道：<br> 　　在使用git 对源代码进行push到gitHub时可能会出错，信息如下<br><br> 　　此时很多人会尝试下面的命令把当前分支代码上传到master分支上。<br> 　　$ git push -u origin master<br> 　　但依然没能解决问题<br><br> 　　出现错误的主要原因是github中的README.md文件不在<a href="https://www.baidu.com/s?wd=%E6%9C%AC%E5%9C%B0%E4%BB%A3%E7%A0%81&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao">本地代码</a>目录中<br><br> 　　可以通过如下命令进行代码合并【注：pull=fetch+merge]<br> 　　git pull --rebase origin master<br><br> 　　执行上面代码后可以看到<a href="https://www.baidu.com/s?wd=%E6%9C%AC%E5%9C%B0%E4%BB%A3%E7%A0%81&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao">本地代码</a>库中多了README.md文件</p>
                ]]></description></item><item><title>java文件加密解密，文件对话的方式\拖动的方式载入</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522433.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Tue, 26 Jul 2022 11:51:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522433.html</guid><description><![CDATA[
                    <p>Example12_8.java</p> 
<pre class="has"><code class="language-java">public class Example12_8 {
	   public static void main(String args[]) {
	      WindowReader win=new WindowReader();
	      win.setTitle("使用文件对话框读写文件"); 
	   }
	}</code></pre> 
<p>WindowReader.java</p> 
<pre class="has"><code class="language-java">import java.awt.*;
import java.awt.datatransfer.DataFlavor;
import java.awt.dnd.DnDConstants;
import java.awt.dnd.DropTarget;
import java.awt.dnd.DropTargetAdapter;
import java.awt.dnd.DropTargetDropEvent;
import java.awt.event.*;
import javax.swing.*;
import java.io.*;
import java.util.List;
public class WindowReader extends JFrame implements ActionListener {
   JFileChooser fileDialog ;//文件对话框对象
   /*组件和窗口*/
   JTextField text;//文本框
   JButton button,//文件对话框触发按钮
   			enButton,//加密触发按钮
   			deButton;//解密触发按钮
   Box baseBox,//
   		boxH1,//水平的box
   		boxH2;//水平的box
   File dir;//文件所在的目录
   String name,//文件的名字
   			houzhui;//文件的后缀
   private static final int numOfEncAndDec = 0x99;//密钥
   private static int dataOfFile = 0; //文件字节内容

   
   WindowReader() {
      init();//建立图形界面
      /*实现文件拖入*/
      new DropTarget(text, DnDConstants.ACTION_COPY_OR_MOVE,
              new DropTargetAdapter()
              {
                 @Override
                 public void drop(DropTargetDropEvent dtde)
                 {
                    try
                    {
                       // 如果拖入的文件格式受支持
                       if (dtde
                             .isDataFlavorSupported(DataFlavor.javaFileListFlavor))
                       {
                          // 接收拖拽来的数据
                          dtde.acceptDrop(DnDConstants.ACTION_COPY_OR_MOVE);
                          @SuppressWarnings("unchecked")
                          List&lt;File&gt; list = (List&lt;File&gt;) (dtde.getTransferable()
                                .getTransferData(DataFlavor.javaFileListFlavor));
                          text.setText("");
                          for (File file : list)
                          {
                             text.setText(file.getAbsolutePath());
                          }
                          // 指示拖拽操作已完成
                          dtde.dropComplete(true);
                       }
                       else
                       {
                          // 拒绝拖拽来的数据
                          dtde.rejectDrop();
                       }
                    }
                    catch (Exception e)
                    {
                       e.printStackTrace();
                    }
                 }
              });
      
      setSize(300,400);
      setVisible(true);
      setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
   }
   
   /*建立图形界面*/
   void init() {
	  setLayout(new FlowLayout());
	  JLabel biaoqian= new JLabel("选择文件：");   //标签
	  text = new JTextField(15);              //文本框
	  button = new JButton("选择");           //按钮
	  enButton=new JButton("加密");
	  deButton=new JButton("解密");
	  boxH1=Box.createHorizontalBox();
  	  boxH1.add(biaoqian);
  	  boxH1.add(Box.createHorizontalStrut(8));
  	  boxH1.add(text);
  	  boxH1.add(Box.createHorizontalStrut(8));
  	  boxH1.add(button);
      
  	  boxH2=Box.createHorizontalBox();
      boxH2.add(enButton);
  	  boxH2.add(Box.createHorizontalStrut(8));
  	  boxH2.add(deButton);
  	
      baseBox=Box.createVerticalBox();
      baseBox.add(boxH1);
      baseBox.add(Box.createVerticalStrut(10));
      baseBox.add(boxH2);
      add(baseBox);      
      text.addActionListener(this);  
      button.addActionListener(this);
      enButton.addActionListener(this);
      deButton.addActionListener(this);
      fileDialog=new JFileChooser();
   }
   
   /*三个Button事件实现，文件选择，文件加密，文件解密*/
   public void actionPerformed(ActionEvent e) {
      if(e.getSource()==button) {//判断激发了什么事件
         int state=fileDialog.showSaveDialog(this);//打开目录并返回整型（表示打开了一个文件or没有打开）
         if(state==JFileChooser.APPROVE_OPTION) {
           try{ 
               File f=fileDialog.getCurrentDirectory();//所选文件的目录  
               String str1=fileDialog.getSelectedFile().getName();//所选文件的名字
               text.setText(f.getAbsolutePath()+"\\"+str1);
           }
           catch(Exception exp){}
         }      
       }
      /*else if(e.getSource()==text){
    	  mainstr=e.getActionCommand();
    	  /*int local=str.lastIndexOf("\\");
    	  String str1=str.substring(local);
    	  String g[]=str1.split("[.]");
    	  name=g[0];
    	  houzhui=g[1];
    	  this.dir=new File(str.replace(str1,""));
      }*/
      else if(e.getSource()==enButton) {
    	  try {
    		split(text.getText());
    	  	InputStream fis  = new FileInputStream(new File(dir,name+"."+houzhui));
    	  	OutputStream fos = new FileOutputStream(new File(dir,name+"的加密文件."+houzhui));
    
    	  	while ((dataOfFile = fis.read()) &gt; -1) {
    	  		fos.write(dataOfFile^numOfEncAndDec);
    	  	}
    
    	  	fis.close();
    	  	fos.flush();
    	  	fos.close();
      	 }
    	 catch(Exception exp){}
      }
      else if(e.getSource()==deButton) {
    	  try {
    		split(text.getText());
    	  	InputStream fis  = new FileInputStream(new File(dir,name+"."+houzhui));
    	  	OutputStream fos = new FileOutputStream(new File(dir,name+"的解密文件."+houzhui));
    
    	  	while ((dataOfFile = fis.read()) &gt; -1) {
    	  		fos.write(dataOfFile^numOfEncAndDec);
    	  	}
    
    	  	fis.close();
    	  	fos.flush();
    	  	fos.close();
      	 }
    	 catch(Exception exp){}
      }
   }
   void split(String str) {
	  int local=str.lastIndexOf("\\");
 	  String str1=str.substring(local);
 	  String g[]=str1.split("[.]");
 	  this.name=g[0];
 	  this.houzhui=g[1];
 	  this.dir=new File(str.replace(str1,""));
   }
   
}
</code></pre> 
<p>&nbsp;</p>
                ]]></description></item><item><title>jdk配置</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522434.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Tue, 26 Jul 2022 11:51:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522434.html</guid><description><![CDATA[
                    <p>1，安装JDK 选择安装目录 安装过程中会出现两次 安装提示 。第一次是安装 jdk ，第二次是安装 jre 。建议两个都安装在同一个java文件夹中的不同文件夹中。（不能都安装在java文件夹的根目录下，jdk和jre安装在同一文件夹会出错）</p> 
<p>如图为正确做法：</p> 
<p><a href="http://jingyan.baidu.com/album/6dad5075d1dc40a123e36ea3.html?picindex=1"><img alt="JDK安装与环境变量配置" class="has" src="https://imgsa.baidu.com/exp/w=500/sign=261eb1c31d950a7b75354ec43ad0625c/6a63f6246b600c33ed52343d1a4c510fd9f9a118.jpg"></a></p> 
<p>2.安装完JDK后配置环境变量 &nbsp;计算机→属性→高级系统设置→高级→环境变量</p> 
<p>系统变量→新建 JAVA_HOME 变量 。</p> 
<p>变量值填写jdk的安装目录（本人是 E:\Java\jdk1.7.0)</p> 
<p>3.系统变量→寻找 Path 变量→编辑</p> 
<p>在变量值最后输入&nbsp;%JAVA_HOME%\bin（注意原来Path的变量值末尾有没有;号，如果没有，先输入；号再输入上面的代码）（注意原来Path的变量值末尾以“\”结尾的，就直接添加）</p> 
<p>4.新建 classpath 环境变量 ，classpath=.;%JAVA_HOME%\lib;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\tools.jar</p>
                ]]></description></item><item><title>Qt create出现“error while building/deploying project”怎么办？？</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522435.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Tue, 26 Jul 2022 11:51:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522435.html</guid><description><![CDATA[
                    <p>我是第一次写的时候出现这个的。</p> 
<p>解决方法是将保存路径换成英文，保存路径不能包含中文（中文太高深了Qt create看不懂！！）</p>
                ]]></description></item><item><title>windows下scp使用传数据到linux</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522404.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Tue, 26 Jul 2022 11:51:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522404.html</guid><description><![CDATA[<p>打开windows的cmd，输入：</p>
<pre><code>scp -r F:\1.png mm@10.22.18.26:/home/mm # 加-r可以传送文件夹
</code></pre>]]></description></item><item><title>pull request</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522342.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Tue, 26 Jul 2022 11:51:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522342.html</guid><description><![CDATA[
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>“Pull Request 是一种通知机制。<br> 你修改了他人的代码，将你的修改通知原来的作者，希望他合并你的修改，这就是 Pull Request。”</p> 
<p>假设要pull request的库为https://github.com/usernameA/repository<br> 1.fork原仓库<br> 首先你需要对库repository进行fork。假设fork以后，仓库repository在你的github中的地址为https://github.com/mynameA/repository<br> 2.修改代码，并上传到远程仓库<br> 执行：</p> 
<pre><code class="prism language-bash"><span class="token function">git</span> clone https://github.com/mynameA/repository  <span class="token comment"># 将仓库从你的github克隆下来</span>
创建分支feature、修改、add、commit、merge
<span class="token function">git</span> push -u origin feature  <span class="token comment"># 第一次需要指明origin和feature，以后只需要输入git push就相当于git push -u origin feature </span>
</code></pre> 
<p>3.执行pull request<br> 在https://github.com/mynameA/repository中创建pull request，如下：<br> <img src="https://img-blog.csdnimg.cn/d22a6cb0a298455db26083e6bcb3ef58.png" alt="在这里插入图片描述"></p> 
<p>选择将mynameA/repository的哪个分支merge到usernameA/repository的哪个分支，如下：<br> <img src="https://img-blog.csdnimg.cn/f7abfcee833445e19f20e36426b8aea5.png" alt="在这里插入图片描述"></p> 
<p><strong>说明1：</strong></p> 
<pre><code class="prism language-bash"><span class="token function">git</span> push -u origin master  
相当于 
<span class="token function">git</span> branch --set-upstream-to<span class="token operator">=</span>origin/master master // 将远程仓库origin的master分支与本地仓库master分支关联 
加 
<span class="token function">git</span> push origin master
</code></pre> 
<p><strong>说明2：</strong><br> 在我们push前，应该让本地仓库和https://github.com/usernameA/repository保持同步，而不是和https://github.com/mynameA/repository保持同步，执行下面命令：</p> 
<pre><code class="prism language-bash"><span class="token function">git</span> remote <span class="token function">add</span> remoteA https://github.com/usernameA/repository <span class="token comment">#　将远程库添加进来，命名为remoteA</span>
<span class="token function">git</span> fetch remoteA   <span class="token comment">#　获取远程库中的最新更改</span>
<span class="token function">git</span> merge remoteA/master <span class="token comment"># 合并远程的最新代码到本分支</span>
</code></pre> 
<p>git pull remoteA/master:feature # 合并仓库remoteA中的master到本地仓库的feature分支中<br> git pull = git fetch 和 git merge<br> 命令格式如下：<br> git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</p> 
<p>参考：<a href="https://blog.csdn.net/dwx_top/article/details/119574394">pull request</a><br> <a href="https://www.bilibili.com/video/BV1s3411g7PS">git、github 保姆级教程入门，工作和协作必备技术，github提交pr - pull request</a></p>
                ]]></description></item><item><title>解决VMware虚拟机桥接模式无法上网的解决方法 ubuntu</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522343.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Tue, 26 Jul 2022 11:51:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522343.html</guid><description><![CDATA[
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>由于我的主机使用拨号上网的，我进行了如下操作：<br> 1.如果没有如下的网络符号，则按照<a href="https://blog.csdn.net/qq_44345567/article/details/106039844">链接1</a>进行操作。<br> <img src="https://img-blog.csdnimg.cn/62f516ee04744fd48a58790aa8089768.png" alt="在这里插入图片描述"></p> 
<p>2.我按照<a href="https://blog.csdn.net/qq_42775938/article/details/121055837">链接2</a>配置了拨号上网</p>
                ]]></description></item><item><title>2. git rebase的基本使用</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522344.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Tue, 26 Jul 2022 11:51:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522344.html</guid><description><![CDATA[
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>git rebase：改变基底。下面举例说明git rebase的作用：</p> 
<pre><code class="prism language-bash">A---B   remote master
A---B   <span class="token builtin class-name">local</span> master
</code></pre> 
<p>如上图，首先通过git pull同步远程的master分支。<br> 然后我新建了一个feature分支用于开发相关的功能，如下图：</p> 
<pre><code class="prism language-bash">A---B   remote master
A---B   <span class="token builtin class-name">local</span> master
	 <span class="token punctuation">\</span>
	  C---D   feature
</code></pre> 
<p>我在feature上实现功能时，有人在远程上传了新的提交，如下：</p> 
<pre><code class="prism language-bash">A---B---E   remote master
A---B   <span class="token builtin class-name">local</span> master
	 <span class="token punctuation">\</span>
	  C---D   feature
</code></pre> 
<p>此时如果我需要合并feature到master，我需要回到master分支去做git pull操作，从而同步远程的master，如下：</p> 
<pre><code class="prism language-bash">A---B---E   remote master
A---B---E   <span class="token builtin class-name">local</span> master
	 <span class="token punctuation">\</span>
	  C---D   feature
</code></pre> 
<p>然后我回到feature上，使用git rebase master改变feature的基底，结果如下：</p> 
<pre><code class="prism language-bash">A---B---E   remote master
A---B---E   <span class="token builtin class-name">local</span> master
		 <span class="token punctuation">\</span>
	 	  C---D   feature
</code></pre> 
<p>将分支feature的基底改为E的过程中，会进行冲突检查。假设C和E有冲突，处理冲突的过程如下：</p> 
<pre><code class="prism language-bash"><span class="token number">1</span>.对冲突文件进行修改
<span class="token number">2</span>.git <span class="token function">add</span> <span class="token builtin class-name">.</span>
<span class="token number">3</span>.git commit -m<span class="token string">"处理C和E的冲突"</span>
<span class="token number">4</span>.git rebase --continue <span class="token comment"># 这个命令表示继续进行rebase，如果上面刚提交的版本"处理C和E的冲突"与D有冲突，那么就会回到步骤1</span>
</code></pre> 
<p>在进行完rebase操作以后，最后我们一般在master中执行git merge feature来实现合并，结果如下：</p> 
<pre><code class="prism language-bash">A---B---E   remote master
A---B---E--------F   <span class="token builtin class-name">local</span> master
		 <span class="token punctuation">\</span>     /
	 	  C---D   feature
</code></pre> 
<p>上面的这个使用merge和rebase的过程时官网推荐的，即<br> 第一步，次级分支rebase main<br> 第二步， main merge次级分支</p> 
<p>git rebase -i master 可以进行交互式的rebase操作【暂时不学，以后再说】</p> 
<p>参考：<br> https://www.bilibili.com/video/BV19B4y1u7vm<br> https://www.bilibili.com/video/BV1Xb4y1773F<br> https://www.csdn.net/tags/Mtjacg3sMDMyMjUtYmxvZwO0O0OO0O0O.html</p>
                ]]></description></item><item><title>python提取COCO数据集中特定的类</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522345.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Tue, 26 Jul 2022 11:51:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522345.html</guid><description><![CDATA[
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <pre><code class="prism language-cpp"><span class="token keyword">import</span> <span class="token module">os</span>
from shutil <span class="token keyword">import</span> <span class="token module">copyfile</span><span class="token punctuation">,</span>move

src_path <span class="token operator">=</span> <span class="token char">'./labels/train2017/'</span>  # 标签
img_path <span class="token operator">=</span> <span class="token char">'./images/train2017/'</span>  # 图像
dst_label_path <span class="token operator">=</span> <span class="token char">'./traffic_train_coco/labels/'</span>
dst_img_path <span class="token operator">=</span> <span class="token char">'./traffic_train_coco/images/'</span>
cls_id <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token char">'79'</span><span class="token punctuation">]</span>  # 牙刷

labels <span class="token operator">=</span> os<span class="token punctuation">.</span><span class="token function">listdir</span><span class="token punctuation">(</span>src_path<span class="token punctuation">)</span>
labels<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token keyword">for</span> label in labels<span class="token operator">:</span>
    <span class="token keyword">if</span> label<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token char">'t'</span><span class="token operator">:</span>
        <span class="token keyword">continue</span>
    # 存标签
    tmp <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token keyword">for</span> line in <span class="token function">open</span><span class="token punctuation">(</span>src_path <span class="token operator">+</span> <span class="token char">'/'</span> <span class="token operator">+</span> label<span class="token punctuation">)</span><span class="token operator">:</span>
        str_list <span class="token operator">=</span> line<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        # 被选类别的标签
        <span class="token keyword">for</span> i in <span class="token function">range</span><span class="token punctuation">(</span><span class="token function">len</span><span class="token punctuation">(</span>cls_id<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">:</span>
            <span class="token keyword">if</span> str_list<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> cls_id<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">:</span>
                # 改成自己的标签，这里是数组下标
                tmp <span class="token operator">=</span><span class="token number">1</span>
                <span class="token keyword">break</span>
    # 没有被选类别
    <span class="token keyword">if</span> tmp <span class="token operator">==</span> <span class="token number">0</span><span class="token operator">:</span>
        <span class="token keyword">continue</span>
    # 新的标签文件
    <span class="token function">move</span><span class="token punctuation">(</span>src_path <span class="token operator">+</span> <span class="token char">'/'</span> <span class="token operator">+</span> label<span class="token punctuation">,</span> dst_label_path <span class="token operator">+</span> <span class="token char">'/'</span> <span class="token operator">+</span> label<span class="token punctuation">)</span>
    <span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">copyfile</span><span class="token expression"><span class="token punctuation">(</span>src_path <span class="token operator">+</span> </span><span class="token char">'/'</span> <span class="token expression"><span class="token operator">+</span> label<span class="token punctuation">,</span> dst_label_path <span class="token operator">+</span> </span><span class="token char">'/'</span> <span class="token expression"><span class="token operator">+</span> label<span class="token punctuation">)</span></span></span>

    image <span class="token operator">=</span> label<span class="token punctuation">[</span><span class="token operator">:</span><span class="token operator">-</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token char">'.jpg'</span>
    # 拷贝有被选类别的图片
    <span class="token function">move</span><span class="token punctuation">(</span>img_path <span class="token operator">+</span> <span class="token char">'/'</span> <span class="token operator">+</span> image<span class="token punctuation">,</span> dst_img_path <span class="token operator">+</span> image<span class="token punctuation">)</span>
    <span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">copyfile</span><span class="token expression"><span class="token punctuation">(</span>img_path <span class="token operator">+</span> </span><span class="token char">'/'</span> <span class="token expression"><span class="token operator">+</span> image<span class="token punctuation">,</span> dst_img_path <span class="token operator">+</span> image<span class="token punctuation">)</span></span></span>


</code></pre> 
<p>参考：<a href="https://blog.csdn.net/ManiacLook/article/details/121951887">链接</a></p>
                ]]></description></item><item><title>telnet与防火墙</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522346.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Tue, 26 Jul 2022 11:51:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522346.html</guid><description><![CDATA[
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>Telnet 命令通常用来远程登录，是TCP/IP协议族中的一员。<br> Telnet 命令还可以作为别的用途，比如确定远程服务的状态，比如确定远程服务器的某个端口是否能访问。<br> 默认情况下，Telnet 在端口 23 上运行。如果您的系统上正在运行任何防火墙，请确保启用必要的端口：</p> 
<pre><code class="prism language-bash"><span class="token function">sudo</span> ufw allow 23
<span class="token function">sudo</span> ufw reload
<span class="token function">sudo</span> ufw <span class="token function">enable</span>
</code></pre> 
<p>telnet 命令的一般格式如下：</p> 
<pre><code class="prism language-bash">telnet <span class="token punctuation">[</span>hostname/ipaddress<span class="token punctuation">]</span> <span class="token punctuation">[</span>port number<span class="token punctuation">]</span>
</code></pre> 
<p>下面的示例命令测试在IP为192.168.77.21的服务器的端口 153上是否开启了监听：</p> 
<pre><code class="prism language-bash">telnet 192.168.77.21 153
</code></pre> 
<p>输出：</p> 
<pre><code class="prism language-bash">Trying 192.168.77.21<span class="token punctuation">..</span>.
Connected to 192.168.77.21.
Escape character is <span class="token string">'^]'</span><span class="token keyword">.</span>
</code></pre> 
<p>参考：<a href="https://www.cnblogs.com/qichunlin/p/8877983.html">链接</a><br> <a href="https://www.yundongfang.com/Yun71091.html#:~:text=Telnet%20%E9%80%9A%E5%B8%B8%E5%9C%A8%20TCP%20%E7%AB%AF%E5%8F%A3%2023%20%E4%B8%8A%E4%BE%A6%E5%90%AC%E7%94%A8%E6%88%B7%E7%9A%84%E6%89%80%E6%9C%89%E8%AF%B7%E6%B1%82%EF%BC%8C%E4%BD%86%E6%82%A8%E5%8F%AF%E4%BB%A5%E7%9B%B8%E5%BA%94%E5%9C%B0%E6%9B%B4%E6%94%B9%E5%AE%83%E3%80%82%20%E6%AD%A5%E9%AA%A4%201.,%E4%B8%8A%20%E5%AE%89%E8%A3%85%20Telnet%20%E3%80%82%20%E9%BB%98%E8%AE%A4%E6%83%85%E5%86%B5%E4%B8%8B%EF%BC%8CTelnet%20%E5%9C%A8%20Ubuntu%20%E5%9F%BA%E7%A1%80%E5%AD%98%E5%82%A8%E5%BA%93%E4%B8%AD%E5%8F%AF%E7%94%A8%E3%80%82">链接</a></p>
                ]]></description></item><item><title>C++ signal() 函数</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522347.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Tue, 26 Jul 2022 11:51:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522347.html</guid><description><![CDATA[
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>先看下面一段代码：</p> 
<pre><code class="prism language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;csignal&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
 
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
 
<span class="token keyword">void</span> <span class="token function">signalHandler</span><span class="token punctuation">(</span> <span class="token keyword">int</span> signum <span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Interrupt signal ("</span> <span class="token operator">&lt;&lt;</span> signum <span class="token operator">&lt;&lt;</span> <span class="token string">") received.\n"</span><span class="token punctuation">;</span>
 
    <span class="token comment">// 清理并关闭</span>
    <span class="token comment">// 终止程序  </span>
   <span class="token function">exit</span><span class="token punctuation">(</span>signum<span class="token punctuation">)</span><span class="token punctuation">;</span>  
 
<span class="token punctuation">}</span>
 
<span class="token keyword">int</span> main <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 注册信号 SIGINT 和信号处理程序</span>
    <span class="token function">signal</span><span class="token punctuation">(</span>SIGINT<span class="token punctuation">,</span> signalHandler<span class="token punctuation">)</span><span class="token punctuation">;</span>  
 
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
       cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Going to sleep...."</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
       <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
 
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>signal(SIGINT, signalHandler); 代表当程序检测到SIGINT信号的时候，执行signalHandler函数。SIGINT信号是程序终止(interrupt)信号，故当你按ctrl+c时，就相当于释放了程序终止(interrupt)信号，就会自动调用signalHandler函数。<br> signal(registered signal, signal handler)这个函数接收两个参数：第一个参数是代表了信号的编号；第二个参数是一个指向信号处理函数的指针。有以下几种信号编号：<br> <img src="https://img-blog.csdnimg.cn/041c8e66d3d242e0ae01cb7c703bb258.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAcXFfNDI3NzU5Mzg=,size_13,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br> 参考：<a href="https://www.runoob.com/cplusplus/cpp-signal-handling.html">链接</a></p>
                ]]></description></item><item><title>c++ #define 宏</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522348.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Tue, 26 Jul 2022 11:51:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522348.html</guid><description><![CDATA[
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="1define__1"></a>1.#define 宏的使用：</h3> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">PI</span> <span class="token expression"><span class="token number">3.1415926</span> </span><span class="token comment">// 把程序中出现的PI全部换成3.1415926</span></span>
</code></pre> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">S</span><span class="token expression"><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span> a<span class="token operator">*</span>b </span><span class="token comment">// area=S(3,2)；第一步被换为area=a*b; ，第二步被换为area=3*2;</span></span>
</code></pre> 
<pre><code class="prism language-cpp"><span class="token comment">// 实参如果是表达式容易出问题</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">S</span><span class="token expression"><span class="token punctuation">(</span>r<span class="token punctuation">)</span> r<span class="token operator">*</span>r</span></span>

area<span class="token operator">=</span><span class="token function">S</span><span class="token punctuation">(</span>a<span class="token operator">+</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 第一步换为area=r*r;,第二步被换为area=a+b*a+b;</span>
<span class="token comment">//正确的宏定义是 #define S(r) ((r)*(r))</span>
</code></pre> 
<p>更具体可见<a href="https://www.cnblogs.com/zhizhiyu/p/10155614.html">链接</a></p> 
<h3><a id="2undef_20"></a>2.#undef使用</h3> 
<p>undef用于取消宏定义</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span>  </span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">PI</span> <span class="token expression"><span class="token number">3.14</span>  </span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">undef</span> <span class="token expression">PI  </span></span>
<span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>  
   <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%f"</span><span class="token punctuation">,</span>PI<span class="token punctuation">)</span><span class="token punctuation">;</span>  
<span class="token punctuation">}</span>
</code></pre> 
<p>执行上面示例代码，得到以下结果</p> 
<pre><code class="prism language-bash">Compile Time Error: <span class="token string">'PI'</span> undeclared
</code></pre> 
<p>参考<a href="https://www.yiibai.com/cprogramming/c-preprocessor-undef.html">链接</a></p>
                ]]></description></item><item><title>Visual Studio 2017 C++使用</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522349.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Tue, 26 Jul 2022 11:51:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522349.html</guid><description><![CDATA[
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>参考：<a href="https://www.bilibili.com/video/BV1zs411u7vp?spm_id_from=333.999.0.0">链接</a><br> <a href="https://www.bilibili.com/video/BV1Cs411A7Mi?spm_id_from=333.999.0.0">链接</a><br> 本博客是以上两个视频的笔记</p> 
<h2><a id="1_3"></a>1.安装</h2> 
<p>只选下面这个就可以<br> <img src="https://img-blog.csdnimg.cn/5dc6df210b5647da93dcc7df516ec5ca.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAcXFfNDI3NzU5Mzg=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br> 安装详情,自行百度</p> 
<h2><a id="2__7"></a>2 项目建立流程</h2> 
<h3><a id="21__8"></a>2.1 新建项目</h3> 
<p><img src="https://img-blog.csdnimg.cn/91c38ffaafae425ba527daa22c1d5fa4.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAcXFfNDI3NzU5Mzg=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br> 我们将项目名称设为Test，解决方案名称设为Code。一个解决方案中可以建立多个项目。每一个项目都可以转化成一个exe或dll文件。<br> 点击确定以后出现下图窗口：<br> <img src="https://img-blog.csdnimg.cn/ef761cc3db7446b592e980ab2e71ccd9.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAcXFfNDI3NzU5Mzg=,size_14,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br> 点击确定以后就成功建立了项目。<br> 在视图菜单下可以找到解决方案资源管理器，通过解决方案资源管理器可以看到解决方案下的项目文件，如下图所示：<img src="https://img-blog.csdnimg.cn/ef814977c5944e07b71227720393a455.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAcXFfNDI3NzU5Mzg=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br> 右击“源文件”可添加cpp文件。</p> 
<h3><a id="22_SDL_16"></a>2.2 安全开发生命周期（SDL）检查</h3> 
<p>为了项目开发更加的安全，用VS开发C++程序默认进行安全开发生命周期（SDL）检查，这就会有一些以前常用的东西报错，如下面代码就会报错：</p> 
<pre><code class="prism language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;stdio.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> m<span class="token punctuation">;</span>
	<span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>编译（生成目录下面有一个编译按钮）一下，出现如下错误：</p> 
<pre><code class="prism language-bash">This <span class="token keyword">function</span> or variable may be unsafe. Consider using scanf_s instead. 
To disable deprecation, use _CRT_SECURE_NO_WARNINGS.
See online <span class="token function">help</span> <span class="token keyword">for</span> details.
</code></pre> 
<p>通过上面那串英文，我们可以得出以下两种解决方案：</p> 
<pre><code class="prism language-cpp"><span class="token comment">// 修改scanf为scanf_s。scanf_s才遵循SDL，更安全。</span>
<span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;stdio.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> m<span class="token punctuation">;</span>
	<span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>或</p> 
<pre><code class="prism language-cpp"><span class="token comment">// 定义一个宏_CRT_SECURE_NO_WARNINGS。此宏的意思是说本cpp文件不进行SDL检查，请不要再报错了</span>
<span class="token macro property">#<span class="token directive keyword">define</span> _CRT_SECURE_NO_WARNINGS</span>
<span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;stdio.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> m<span class="token punctuation">;</span>
	<span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>如果这个宏要在项目的很多文件中使用，一般会将宏定义在项目中，从而防止宏的重定义。定义过程如下：<br> <img src="https://img-blog.csdnimg.cn/a452338869c74a439b2570a4007bfaf2.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAcXFfNDI3NzU5Mzg=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br> 右击项目Test，选择属性。<br> 在配置上选择当前活动的项目。<br> 然后按照上图点击编辑，然后将宏_CRT_SECURE_NO_WARNINGS复制上去，结果如下所示，然后点击确定。<br> <img src="https://img-blog.csdnimg.cn/7dc3366724cb44f493860ddd2f68743b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAcXFfNDI3NzU5Mzg=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br> 关闭SDL检查的方法是：项目-&gt;属性-&gt;C/C+±&gt;SDL检查，选测否，就可以将其关闭了</p> 
<h2><a id="3__66"></a>3 其他</h2> 
<h3><a id="31_VS_67"></a>3.1 帮助文档与重新选择需要下载的VS组件</h3> 
<p>点击相应函数，再点击F1就可跳转到此函数的帮助文档中了。这个文档是通过浏览器打开的，如果需要下载帮助文档的组件，过程如下：<br> 右击VS2017，点击更改<br> <img src="https://img-blog.csdnimg.cn/56585b35c3254a07b80bfc10fde70344.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAcXFfNDI3NzU5Mzg=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br> 单个组件下勾选Help Viewer，然后点击修改<br> <img src="https://img-blog.csdnimg.cn/deefd48981bf4f3497c4581caa0f6ef8.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAcXFfNDI3NzU5Mzg=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p> 
<p><img src="https://img-blog.csdnimg.cn/8cbc2b0ddbab4edba8dc33530dee5820.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAcXFfNDI3NzU5Mzg=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br> 然后出现：<br> <img src="https://img-blog.csdnimg.cn/92a303745e9242c8b0c302ad97d887d3.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAcXFfNDI3NzU5Mzg=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br> 点击添加，添加成功后，点击更新<br> 然后就可以在如下地方搜索函数的使用方法<br> <img src="https://img-blog.csdnimg.cn/3648a18742774732ac8e3d1e4da9686b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAcXFfNDI3NzU5Mzg=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p> 
<h3><a id="32__80"></a>3.2 解决方案中的多个项目</h3> 
<p>右击项目，选择设为启动项，就可以调试和运行相应的项目，如下图所示<br> <img src="https://img-blog.csdnimg.cn/a9c345727c2e4eeb98ba21b371f8d151.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAcXFfNDI3NzU5Mzg=,size_11,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p> 
<h3><a id="33__84"></a>3.3 解决方案的目录结构</h3> 
<p><img src="https://img-blog.csdnimg.cn/d00b2cbec64940e7b3eb4f971b97a326.png" alt="在这里插入图片描述"><br> .vs：存放一些缓存内容<br> Debug：存放Debug和x86下的exe等文件（下面有介绍）<br> Test和Test2是两个项目文件，项目文件的目录结构如下：<br> <img src="https://img-blog.csdnimg.cn/f670edb3a45e442dbfbc84f446103ff3.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAcXFfNDI3NzU5Mzg=,size_17,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br> 可以看到，除了cpp文件和头文件，还有一些vs创建的与项目相关的文件。其中Debug和Release是编译时候的中间文件，即编译时产生的obj【注：C++是先将cpp文件编译乘obj文件，再将obj文件链接成exe文件】<br> 项目中的中间文件Debug和Release、解决方案里面的Debug和Release，还有.vs文件都是可以删除的，将这些文件删除以后再发给别人，别人还是可以成功运行这个程序的。<br> exe文件的生成：点击生成解决方案可生成.exe文件，生成解决方案是可以通过如下选项进行选择的：<br> <img src="https://img-blog.csdnimg.cn/b227138302ae42d2a87a921bfa554f99.png" alt="在这里插入图片描述"><br> 可以选择Debug、Release和x86、x64。如果选择的是Debug和x86，那么就会在解决方案的目录下的Debug目录中生成exe等文件。如果选择的是Release和x86，那么就会在解决方案的目录下生成一个名为Release的文件夹用于存放exe等文件。<br> 如果选择的是x64，那么就会在解决方案的目录下生成一个名为x64的文件夹用于存放Debug和Release。<br> 这里的x86和x64应该是代表此exe文件可以在哪个种系统中运行。<br> vs中的程序有debug和release两个版本，程序员可以对Debug版进行调试，Release版是给用户使用的，用户一般不在发布版本上进行调试。debug程序通常比release程序要慢，尤其是处理视频方便release要比debug快很多。<br> debug跟release在初始化变量时所做的操作是不同的，debug是将每个字节位都赋成0xcc， 而release的赋值近似于随机。如果你的程序中的某个变量没被初始化就被引用，就很有可能出现异常：用作控制变量将导致流程导向不一致；用作数组下标将会使程序崩溃；更加可能是造成其他变量的不准确而引起其他的错误。所以在<strong>声明变量后马上对其初始化一个默认的值是最简单有效的办法</strong>，否则项目大了你找都没地方找。代码存在错误在debug方式下可能会忽略而不被察觉到。debug方式下数组越界也大多不会出错，在release中就暴露出来了，这个找起来就比较难了。【参考<a href="https://blog.csdn.net/gxiaob/article/details/9045085">链接</a>】</p> 
<h3><a id="34_Win32Win32_100"></a>3.4 Win32控制台（控制台应用）与Win32项目（桌面应用程序）</h3> 
<p><img src="https://img-blog.csdnimg.cn/17288b5027244e12bc03878d7c567f10.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAcXFfNDI3NzU5Mzg=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br> Win32控制台（控制台应用）是一个只有输入输出的黑框框<br> Win32项目（桌面应用程序）是可以添加按钮等控件的程序</p> 
<h3><a id="35__exe_104"></a>3.5 发布exe文件</h3> 
<p>直接发送解决方案目录中的Release文件夹下的exe文件给别人，则会因为别人电脑里没有相应的运行库而无法成功运行程序。解决方法如下：<br> 方法一：将项目的运行库修改为“多线程(/MT)”。<br> <img src="https://img-blog.csdnimg.cn/16c9af9ecf3742d799bd24b9eaa7b5b6.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAcXFfNDI3NzU5Mzg=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br> 此时生成的Release版的exe文件中是包含运行库的<br> 方法二：让想要运行你的程序的人安装相应的运行库，运行库的名字一般为Visual C++ Redistributable for Visual Studio 20xx。可以在<a href="https://visualstudio.microsoft.com/zh-hans/downloads/">链接</a>中找到。这个运行库可以在你没有安装Visual Studio 20xx的条件下，运行用Visual Studio 20xx编写的exe文件。<br> <img src="https://img-blog.csdnimg.cn/ca0997d96ca24c63879fa889e61c428a.png" alt="在这里插入图片描述"></p> 
<p>上面的发布方法不适用于MFC程序。MFC：利用微软提供的C++组件类创建界面</p> 
<h3><a id="36__113"></a>3.6 调试</h3> 
<p>请选择Debug模式下进行调试<br> <img src="https://img-blog.csdnimg.cn/bf0018dd88764c54982490f45b2f1abb.png" alt="在这里插入图片描述"><br> 调试下的开始调试和本地Windows调试器是一个东西<br> 逐语句：一条语句一条语句执行， 会进入函数<br> 逐过程：不会进入函数<br> 断点：程序执行到断点会暂停，点击继续后会执行到下一个断点<br> 条件断点：点击下图的螺丝，就可以设置条件断点。<br> <img src="https://img-blog.csdnimg.cn/3be8cff73163482bb9f0bbc99a2d48e5.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAcXFfNDI3NzU5Mzg=,size_12,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br> 下面设置条件断点：当a等于10000时程序暂停<br> <img src="https://img-blog.csdnimg.cn/5b7dc34aa16a42768633e35ba93af19c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAcXFfNDI3NzU5Mzg=,size_14,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br> 在调试目录下还有很多用于调试的功能，如调用堆栈和监视<br> <img src="https://img-blog.csdnimg.cn/a09a52852abb4616ac498ee01bbe79ee.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAcXFfNDI3NzU5Mzg=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br> 在调用堆栈中，我们可以查看被调用函数的相关信息，如下：</p> 
<p><img src="https://img-blog.csdnimg.cn/c3edb38d8349499fa95f2ca96fe7be3b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAcXFfNDI3NzU5Mzg=,size_12,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br> 在监视中，我们可以输入想要查询的变量，从而得到该变量此时的值为多少。下图查询a此时的值为10<br> <img src="https://img-blog.csdnimg.cn/104a097da0f242598339f25df6208a36.png" alt="在这里插入图片描述"></p> 
<h3><a id="37__131"></a>3.7 代码分发方式</h3> 
<ol><li>源码：头文件+源文件</li><li>动态库：头文件(可选)+LIB文件(可选)+DLL 文件</li><li>静态库：头文件+LIB文件<br> <img src="https://img-blog.csdnimg.cn/5a5b8461e3fe4291af08150667f133f4.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAcXFfNDI3NzU5Mzg=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br> <img src="https://img-blog.csdnimg.cn/be946ea5423c48cdb8f8862fd20b39d7.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAcXFfNDI3NzU5Mzg=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></li></ol> 
<h4><a id="371_LIB_137"></a>3.7.1 静态库配置方法（头文件+LIB文件）</h4> 
<p>方法一：在代码的开头添加如下代码：</p> 
<pre><code class="prism language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">"头文件的绝对路径"</span></span>
<span class="token macro property">#<span class="token directive keyword">pragma</span> comment(lib, "lib文件的绝对路径")</span>
</code></pre> 
<p>方法二：在项目的属性里面配置，如下：<br> 配置头文件：<br> <img src="https://img-blog.csdnimg.cn/bb230e68a54f4e64a7c0d6d585de320a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAcXFfNDI3NzU5Mzg=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br> 将头文件所在目录放进附加包含目录中。注意不要把头文件都放进去。<br> 配置lib文件：<br> <img src="https://img-blog.csdnimg.cn/8ff6eda4e6644eda82e0792288bb6608.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAcXFfNDI3NzU5Mzg=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br> 将lib文件所在目录放进附加包含目录中。注意不要把lib文件都放进去。然后在添加lib文件，如下：<br> <img src="https://img-blog.csdnimg.cn/540735cc8afb4142a6c7c84e5f375625.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAcXFfNDI3NzU5Mzg=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br> 配置好了，以后下面有个确定是需要点的，不然配置不会保存<br> 配置的时候，注意下面两个要匹配好<br> <img src="https://img-blog.csdnimg.cn/5143d85c2347466f8a1198fbf6bd9619.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAcXFfNDI3NzU5Mzg=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p> 
<h4><a id="372_LIBDLL__155"></a>3.7.2 动态库配置方法（头文件(可选)+LIB文件(可选)+DLL 文件）</h4> 
<p>头文件(可选)+LIB文件(可选) 和静态库配置方法一样，这里就不再赘述。<br> DLL文件的配置方法为：将DLL文件放在和exe文件同一个路径下就可以了</p> 
<h3><a id="38__159"></a>3.8 动态库的建立</h3> 
<p>参考：https://www.bilibili.com/video/BV1hE411Y7vd?spm_id_from=333.999.0.0，不想写了，心累。。。</p>
                ]]></description></item><item><title>C++ using namespace std</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522350.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Tue, 26 Jul 2022 11:51:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522350.html</guid><description><![CDATA[
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="1namespaceusing_0"></a>1.namespace和using</h3> 
<p>C＋＋标准程序库中的所有标识符都被定义于一个名为std的namespace中。<br> 由于namespace的概念，使用C＋＋标准程序库的任何标识符时，可以有三种选择：<br> 1、直接指定标识符。例如std::ostream而不是ostream。完整语句如下：<br> std::cout &lt;&lt; std::hex&lt;&lt; 3.4&lt;&lt; std::endl;<br> 2、使用using关键字。<br> using std::cout;<br> using std::endl;<br> 以上程序可以写成<br> cout &lt;&lt; std::hex&lt;&lt; 3.4&lt;&lt; endl;<br> 3、最方便的就是使用using namespace std;<br> 例如：<br> #include <br> #include <br> #include <br> using namespace std;<br> 这样命名空间std内定义的所有标识符都有效（曝光）。就好像它们被声明为全局变量一样。那么以上语句可以如下写:<br> cout &lt;&lt; hex&lt;&lt; 3.4&lt;&lt; endl;</p> 
<h3><a id="2namespace_18"></a>2.自定义的名空间（namespace）</h3> 
<pre><code class="prism language-cpp"><span class="token comment">//#include &lt;conio.h&gt;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">namespace</span> car <span class="token comment">// 名空间的定义</span>
<span class="token punctuation">{<!-- --></span>
  <span class="token keyword">int</span> model<span class="token punctuation">;</span>
  <span class="token keyword">int</span> length<span class="token punctuation">;</span>
  <span class="token keyword">int</span> width<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">namespace</span> plane
<span class="token punctuation">{<!-- --></span>
  <span class="token keyword">int</span> model<span class="token punctuation">;</span>
  <span class="token keyword">namespace</span> size <span class="token comment">// 名空间的嵌套</span>
  <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> length<span class="token punctuation">;</span>
    <span class="token keyword">int</span> width<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>



<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
  
  plane<span class="token operator">::</span>size<span class="token operator">::</span>length<span class="token operator">=</span><span class="token number">70</span><span class="token punctuation">;</span>
  std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"the length of plane is "</span><span class="token operator">&lt;&lt;</span>plane<span class="token operator">::</span>size<span class="token operator">::</span>length<span class="token operator">&lt;&lt;</span><span class="token string">"m."</span><span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>参考：<a href="https://blog.csdn.net/quyafeng2011/article/details/68921750">链接1</a><br> <a href="https://blog.csdn.net/weixin_40597170/article/details/79827221">链接2</a></p>
                ]]></description></item><item><title>C++中的头文件（.h）</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522351.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Tue, 26 Jul 2022 11:51:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522351.html</guid><description><![CDATA[
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="1_0"></a>1.定义</h2> 
<p>头文件是扩展名为 .h 的文件，头文件也是C++的源代码，头文件中包含了 C++中函数、类、对象等的声明和宏定义，它可以被多个源文件通过#include引用共享。</p> 
<h2><a id="2_2"></a>2.使用头文件原因</h2> 
<p>C++中有“单一定义”规则，即一个对象只能被定义一次，如果在一个源文件中定义了一个函数，其他的源文件想要使用这个函数就需要在使用前声明一下这个函数，在编译结束之后，编译器链接的时候再去查找这些函数的定义。<br> 故要使用其他文件中定义的函数、类、对象（变量）时，需要对函数、类、对象进行声明。这些声明文件一般放在一个头文件中，这样只要通过#include就可以一下引入所有的声明。当然也可以在头文件中定义宏。<br> 自定义的头文件，使用#include"头文件.h"。对于标准库头文件的包含使用#include&lt;头文件.h&gt;</p> 
<h2><a id="3_6"></a>3.编译过程中的头文件</h2> 
<p>C++代码的编译主要通过以下几个过程：预编译-&gt;编译-&gt;汇编-&gt;链接【可参考：<a href="https://blog.csdn.net/qq_42775938/article/details/122346013">链接</a>(建议先看此链接，再看下面内容)】，最后生成可执行文件。<br> 在预编译阶段，编译器将#include"头文件.h"替换成“头文件.h”中具体的声明内容。<br> 在链接阶段，编译器查找声明对象的定义。</p> 
<h3><a id="31_10"></a>3.1.预编译阶段，头文件被替换</h3> 
<p>我们看一个简单的例子，下面是一个头文件CA.h</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">CA_H</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">CA_H</span></span>
 
<span class="token keyword">int</span> <span class="token function">Fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
</code></pre> 
<p>头文件中的函数、类、对象（变量）必须在一个源文件有进行定义，这里在A.cpp中进行定义。<br> A.cpp：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"CA.h"</span></span>
<span class="token keyword">int</span> <span class="token function">Fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>B.cpp中引用头文件：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"CA.h"</span></span>
 
<span class="token keyword">int</span> <span class="token function">Fun1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> <span class="token function">Fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	<span class="token keyword">return</span> <span class="token function">Fun1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>预编译命令：</p> 
<pre><code class="prism language-bash">g++ -E B.cpp -o B.i
</code></pre> 
<p>经过预处理后， B.i：</p> 
<pre><code class="prism language-cpp"># <span class="token number">1</span> <span class="token string">"B.cpp"</span>
# <span class="token number">1</span> <span class="token string">"&lt;built-in&gt;"</span>
# <span class="token number">1</span> <span class="token string">"&lt;command-line&gt;"</span>
# <span class="token number">1</span> <span class="token string">"/usr/include/stdc-predef.h"</span> <span class="token number">1</span> <span class="token number">3</span> <span class="token number">4</span>
# <span class="token number">1</span> <span class="token string">"&lt;command-line&gt;"</span> <span class="token number">2</span>
# <span class="token number">1</span> <span class="token string">"B.cpp"</span>
# <span class="token number">1</span> <span class="token string">"CA.h"</span> <span class="token number">1</span>



<span class="token keyword">int</span> <span class="token function">Fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
# <span class="token number">2</span> <span class="token string">"B.cpp"</span> <span class="token number">2</span>

<span class="token keyword">int</span> <span class="token function">Fun1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
 <span class="token keyword">return</span> <span class="token function">Fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
 <span class="token keyword">return</span> <span class="token function">Fun1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>可以看到，B.cpp中的头文件#include "CA.h"都被CA.h中的具体内容所代替。<br> 【注】“＃”是注释</p> 
<h3><a id="32_75"></a>3.2.使用头文件</h3> 
<pre><code class="prism language-bash">g++ A.cpp B.cpp -o main
</code></pre> 
<p>B.cpp中通过头文件引入的东西，会在A.cpp中自动找到。</p> 
<h2><a id="4_80"></a>4.如何写头文件</h2> 
<p>参考：<a href="https://blog.csdn.net/lyanliu/article/details/2195632">链接</a><br> 在写头文件时需要注意，在开头和结尾处必须按照如下样式加上预编译语句（如下）<br> Circle.h：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">CIRCLE_H</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">CIRCLE_H</span></span>

 <span class="token comment">// 你的代码写在这里</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
</code></pre> 
<p>#ifndef代表没有定义CIRCLE_H时，才能进入if。进入if之后，第一步就是执行#define CIRCLE_H来定义CIRCLE_H。这样做以后，即使重复引入头文件，也不会重复执行if中的东西。<br> 至于CIRCLE_H这个名字实际上是无所谓的，你叫什么都行，只要符合规范都行。原则上来说，非常建议把它写成这种形式，因为比较容易和头文件的名字对应。<br> 下面举个最简单的例子来描述一下，咱就求个圆面积。<br> 第1步，建立一个空工程（以在VS2003环境下为例）。<br> 第2步，在头文件的文件夹里新建一个名为Circle.h的头文件，它的内容如下：</p> 
<pre><code class="prism language-cpp"> <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">CIRCLE_H</span></span>
 <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span>  <span class="token macro-name">CIRCLE_H</span></span>

 <span class="token keyword">class</span>  <span class="token class-name">Circle</span>
 <span class="token punctuation">{<!-- --></span>
<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">double</span> r<span class="token punctuation">;</span><span class="token comment">//半径</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">Circle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//构造函数</span>
    <span class="token function">Circle</span><span class="token punctuation">(</span><span class="token keyword">double</span> R<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//构造函数</span>
    <span class="token keyword">double</span> <span class="token function">Area</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//求面积函数</span>
<span class="token punctuation">}</span> <span class="token punctuation">;</span>

 <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
</code></pre> 
<p>在头文件里，并不写出函数的具体实现。<br> 第3步，要给出Circle类的具体实现，因此，在源文件夹里新建一个Circle.cpp的文件，它的内容如下：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span>  <span class="token string">" Circle.h "</span></span>

<span class="token class-name">Circle</span><span class="token double-colon punctuation">::</span><span class="token function">Circle</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
 <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">this</span><span class="token operator">-&gt;</span>r<span class="token operator">=</span><span class="token number">5.0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token class-name">Circle</span><span class="token double-colon punctuation">::</span><span class="token function">Circle</span><span class="token punctuation">(</span> <span class="token keyword">double</span>  R<span class="token punctuation">)</span>
 <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">this</span><span class="token operator">-&gt;</span>r<span class="token operator">=</span>R<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

 <span class="token keyword">double</span>  <span class="token class-name">Circle</span><span class="token double-colon punctuation">::</span> <span class="token function">Area</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
 <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token number">3.14</span><span class="token operator">*</span>r<span class="token operator">*</span>r<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>一般实现Circle.h的cpp文件取名为Circle.cpp<br> 最后，我们建一个main.cpp来测试我们写的Circle类，它的内容如下：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span>  <span class="token string">&lt; iostream &gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span>  <span class="token string">" Circle.h "</span></span>
 <span class="token keyword">using</span>   <span class="token keyword">namespace</span>  std<span class="token punctuation">;</span>

 <span class="token keyword">int</span>  <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
 <span class="token punctuation">{<!-- --></span>
    Circle <span class="token function">c</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout<span class="token operator">&lt;&lt;</span><span class="token string">"Area="</span><span class="token operator">&lt;&lt;</span>c<span class="token punctuation">.</span><span class="token function">Area</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>运行命令：</p> 
<pre><code class="prism language-bash">g++ Circle.cpp main.cpp -o main
./main
</code></pre> 
<h2><a id="5Chh_153"></a>5.C++头文件有.h和没有.h</h2> 
<p>iostream.h是非标准头文件，iostream是标准头文件形式。iostream.h时代没有名词空间，即所有库函数包括头文件iostream.h都声明在全局域。为了体现结构层次，c++标准委员会引入了名词空间这一概念，并把所有库函数声明由全局域改到了名词空间std。iostream.h里面定义的所有类以及对象都是在全局空间里，所以可以直接使用cout，但如果你用iostream，就不能直接使用cout了，iostream里面所定义的东西都在标准命名空间std里面，所以你必须加上 using namespace std才能使用cout。<br> 故而，<br> 在早些时候，这两种头文件是等价：<br> #include&lt;iostream.h&gt; // 这个现在已经不支持了<br> 和<br> #include <br> using namespace std;<br> 现在标准的C++头文件没有.h扩展名，将以前的C的头文件转化为C++的头文件后，可以加上c的前缀表示来自于c，例如cmath就是由math,h变来。<br> 注意：c语言的string.h变为cstring，和c++的string是两个完全不同的东西。</p> 
<h2><a id="6hpp_166"></a>6.后缀为.hpp的文件</h2> 
<p>后缀为.hpp的文件一般提供程序使用的接口。</p> 
<p>我们公司和另一家软件公司合作，这样就必然要互相提供一些软件的信息（比如一些类，它到底是要做什么的），可是在提供这些信息的同时我们又不像让对方知道我们这些类的具体实现，毕竟这些是我们公司的算法核心和心血啊。所以这个时候就可以把类的接口（这个类是要做什么的）放在*.hpp文件中，而具体类的实现放在 .cpp文件。这时候我们只要给对方公司.hpp文件就行了。这样既提供了必要的信息，又保护了我们的核心代码。</p> 
<p>参考：<a href="https://blog.csdn.net/ddllrrbb/article/details/84729366">链接1</a><br> <a href="https://blog.csdn.net/quyafeng2011/article/details/68921750">链接2</a><br> <a href="https://www.cnblogs.com/galoishelley/p/3844281.html">链接3</a><br> <a href="https://blog.csdn.net/hmd3394969/article/details/114162657">链接4</a><br> <a href="https://blog.csdn.net/u013921430/article/details/79288554">链接5</a><br> <a href="https://zhuanlan.zhihu.com/p/387773355">链接6</a></p>
                ]]></description></item><item><title>无线网卡驱动的知识</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522352.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Tue, 26 Jul 2022 11:51:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522352.html</guid><description><![CDATA[
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>插入无线网卡后，需要安装相应的驱动。可以直接咨询厂家驱动如何安装。<br> 我手里的无线网卡在插入进windows电脑的时候，会出现一个弹窗，在弹窗中选择setup就可以安装好相应的驱动。驱动安装完成后，就可以看到WIFI列表。</p>
                ]]></description></item><item><title>leetcode怎么刷</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522353.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Tue, 26 Jul 2022 11:51:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522353.html</guid><description><![CDATA[
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>做一题总结一题，找相似的题，从而保证这种题型以后都会。<br> 刷剑指offer（专项版）就行</p>
                ]]></description></item><item><title>拨号上网与以太网</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522354.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Tue, 26 Jul 2022 11:51:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522354.html</guid><description><![CDATA[
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>拨号上网与以太网是两种不同的网络。<br> 以太网实现了区域接入的电子设备进行数据传输，然后通过路由器接入互联网。<br> 而宽带拨号则实现了计算机接入互联网。宽带拨号实现的数据涉及范围比以太网的更广更多。<br> 中国国内拨号上网的用户基本都是使用基于PPPoE协议的 ADSL 。 PPPoE全称为Point to Point Protocol over Ethernet ( 以太网 上的 点对点协议 )，是将以太网和PPP协议结合后的协议，通过PPPoE技术和 宽带调制解调器 (比如ADSL Modem)就可以实现高速宽带网的个人 身份验证 访问，为每个用户创建虚拟拨号连接，这样就可以高速连接到Internet。<br> 参考：<a href="https://zhidao.baidu.com/question/1836051588331878580.html#:~:text=%E4%B8%80%E3%80%81%E5%AE%9A%E4%B9%89%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A%E4%BB%A5%E5%A4%AA%E7%BD%91%E6%98%AF%E5%B1%80%E5%9F%9F%E7%BD%91%E7%9A%84%E4%B8%80%E7%A7%8D%EF%BC%8C%E8%AF%A5%E7%A7%8D%E5%B1%80%E5%9F%9F%E7%BD%91%E7%9A%84%E6%8B%93%E6%89%91%E7%BB%93%E6%9E%84%E6%98%AF%E4%BB%A5%E6%80%BB%E7%BA%BF%E5%9E%8B%E4%B8%BA%E5%9F%BA%E7%A1%80%E7%9A%84%E3%80%82%20%E8%80%8C%E5%AE%BD%E5%B8%A6%E6%8B%A8%E5%8F%B7%EF%BC%88%E5%8D%B3%E5%AE%BD%E5%B8%A6%E8%BF%9E%E6%8E%A5%EF%BC%89%E6%98%AF%E4%B8%80%E7%A7%8D%E6%8F%8F%E8%BF%B0%EF%BC%8C%E5%AE%83%E6%8F%8F%E8%BF%B0%E7%94%B5%E5%AD%90%E4%B9%8B%E9%97%B4%E6%88%96%E8%80%85%E7%94%B5%E5%AD%90%E7%BA%BF%E8%B7%AF%E4%B9%8B%E9%97%B4%E7%9A%84%E9%A2%91%E7%8E%87%E8%8C%83%E5%9B%B4%EF%BC%8C%E9%A2%91%E7%8E%87%E7%9A%84%E8%8C%83%E5%9B%B4%E8%B6%8A%E5%A4%A7%E6%84%8F%E5%91%B3%E7%9D%80%E9%A2%91%E5%AE%BD%E8%B6%8A%E9%AB%98%E3%80%82,%E4%BA%8C%E3%80%81%E4%BC%A0%E8%BE%93%E5%8E%9F%E7%90%86%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A%E4%BB%A5%E5%A4%AA%E7%BD%91%E6%98%AF%E9%80%9A%E8%BF%87%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8E%A5%E5%85%A5%E5%B1%80%E5%9F%9F%E7%BD%91%E7%BD%91%E7%BB%9C%EF%BC%8C%E9%80%9A%E8%BF%87%E6%AF%8F%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9%E5%8F%91%E9%80%81%E5%92%8C%E6%8E%A5%E6%94%B6%E4%BF%A1%E6%81%AF%E7%9A%84%E6%93%8D%E4%BD%9C%E4%BC%A0%E8%BE%93%E6%95%B0%E6%8D%AE%E4%BF%A1%E6%81%AF%E3%80%82%20%E8%80%8C%E5%AE%BD%E5%B8%A6%E6%8B%A8%E5%8F%B7%E6%98%AF%E9%80%9A%E8%BF%87%E4%BC%A0%E7%BB%9F%E7%9A%84%E7%94%B5%E8%AF%9D%E7%BA%BF%E7%B3%BB%E7%BB%9F%EF%BC%8C%E5%88%A9%E7%94%A8%E5%85%B6%E4%B8%AD%E9%93%9C%E7%BA%BF%E7%9A%84%E4%BD%8E%E9%A2%91%E9%83%A8%E5%88%86%E5%BA%A7%E4%BD%8D%E4%BC%A0%E8%BE%93%E9%80%9A%E9%81%93%E4%BD%9C%E4%B8%BA%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E7%9A%84%E9%80%9A%E9%81%93%E3%80%82">链接1</a><br> <a href="https://baike.baidu.com/item/%E6%8B%A8%E5%8F%B7%E4%B8%8A%E7%BD%91/7343999#:~:text=%E4%B8%AD%E5%9B%BD%E5%9B%BD%E5%86%85%E6%8B%A8%E5%8F%B7%E4%B8%8A%E7%BD%91%E7%9A%84%E7%94%A8%E6%88%B7%E5%9F%BA%E6%9C%AC%E9%83%BD%E6%98%AF%E4%BD%BF%E7%94%A8%E5%9F%BA%E4%BA%8EPPPoE%E5%8D%8F%E8%AE%AE%E7%9A%84%20ADSL%20%E3%80%82%20PPPoE%E5%85%A8%E7%A7%B0%E4%B8%BAPoint%20to%20Point%20Protocol%20over,%E4%B8%8A%E7%9A%84%20%E7%82%B9%E5%AF%B9%E7%82%B9%E5%8D%8F%E8%AE%AE%20%29%EF%BC%8C%E6%98%AF%E5%B0%86%E4%BB%A5%E5%A4%AA%E7%BD%91%E5%92%8CPPP%E5%8D%8F%E8%AE%AE%E7%BB%93%E5%90%88%E5%90%8E%E7%9A%84%E5%8D%8F%E8%AE%AE%EF%BC%8C%E9%80%9A%E8%BF%87PPPoE%E6%8A%80%E6%9C%AF%E5%92%8C%20%E5%AE%BD%E5%B8%A6%E8%B0%83%E5%88%B6%E8%A7%A3%E8%B0%83%E5%99%A8%20%28%E6%AF%94%E5%A6%82ADSL%20Modem%29%E5%B0%B1%E5%8F%AF%E4%BB%A5%E5%AE%9E%E7%8E%B0%E9%AB%98%E9%80%9F%E5%AE%BD%E5%B8%A6%E7%BD%91%E7%9A%84%E4%B8%AA%E4%BA%BA%20%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%20%E8%AE%BF%E9%97%AE%EF%BC%8C%E4%B8%BA%E6%AF%8F%E4%B8%AA%E7%94%A8%E6%88%B7%E5%88%9B%E5%BB%BA%E8%99%9A%E6%8B%9F%E6%8B%A8%E5%8F%B7%E8%BF%9E%E6%8E%A5%EF%BC%8C%E8%BF%99%E6%A0%B7%E5%B0%B1%E5%8F%AF%E4%BB%A5%E9%AB%98%E9%80%9F%E8%BF%9E%E6%8E%A5%E5%88%B0Internet%E3%80%82">链接2</a></p>
                ]]></description></item><item><title>linux常见错误</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522355.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Tue, 26 Jul 2022 11:51:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522355.html</guid><description><![CDATA[
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>有些东西设置以后，需要重启才能生效</p>
                ]]></description></item><item><title>有了mac为什么要有ip？有了ip为什么要有mac？</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522356.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Tue, 26 Jul 2022 11:51:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522356.html</guid><description><![CDATA[
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>MAC,全称media access，是每一块网络接口卡的地址，与硬件接口有关，地址唯一；<br> IP地址，英文名Internet Protocol address，指明计算机到网络的某条链接，主机可以有多个IP地址；</p> 
<h3><a id="macip_2"></a>有了mac为什么要有ip？</h3> 
<p>我的理解是：IP地址将世界分为了一块一块，每一网段为一块。这样，就只需要维护到每一个块的路径。如果不使用IP地址，就需要维护到每一个主机的路径。而主机可能会发生频繁地移动，只要有一个主机发生移动就需要更新全网的信息。<br> 还有一个问题：假设主机都不移动，此时要将世界分为了一块一块，就需要购买mac前缀一样的网卡。那么厂家要根据你的需求烧录一定数量的前缀一样的网卡，这样就非常麻烦。</p> 
<h3><a id="ipmac_5"></a>有了ip为什么要有mac？</h3> 
<p>网络层协议有很多种，mac的作用就是：不管网络层使用的什么协议，都用统一的mac协议进行传输。<br> 如果没有mac地址，那么不同网络使用不同的协议，会导致使用不同协议的网络之间不同能通信。当数据从A到达B（A和B使用不同的网络层协议），B会依据自己的协议处理从A获取到的数据。但由于协议的不同，B对数据的处理会出现问题。我们很容易想到，只需要添加一个类型标识符，指出数据应交给哪个协议处理。<br> 所以为什么需要定义mac地址呢？只需要判断类型标识符以后，用相应网络层协议进行处理不就行了？？？</p>
                ]]></description></item><item><title>默认网关是啥</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522357.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Tue, 26 Jul 2022 11:51:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522357.html</guid><description><![CDATA[
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>默认网关就是一个IP地址，默认网关也可以指此IP所指向的路由器。<br> 当主机发现目的IP和主机IP不在同一网段的时候，会默认将数据发送到默认网关上。</p>
                ]]></description></item><item><title>桥接和net</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522358.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Tue, 26 Jul 2022 11:51:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522358.html</guid><description><![CDATA[
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>桥接：虚拟机上的系统被分配一个与所在主机同一个网段的ip，可以直接与局域网内的主机进行通信<br> net：虚拟机上的系统通过与所在主机间的通信，从而访问其他主机<br> 在对《linux高性能服务器编程 by游双》进行学习的时候，发现需要多个主机建立一个局域网，而我们没有多个电脑。此时可以利用虚拟机建立多个系统，这多个系统就是在同一个局域网中的。</p>
                ]]></description></item><item><title>void指针(void*)用法</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522359.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Tue, 26 Jul 2022 11:51:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522359.html</guid><description><![CDATA[
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h1><a id="0void_0"></a>0.void*简介</h1> 
<p>void*是一种特殊的指针类型，可用于存放任意对象的地址。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token operator">*</span>pv <span class="token operator">=</span><span class="token operator">&amp;</span>obj<span class="token punctuation">;</span> <span class="token comment">// obj 可以是任意类型的对象</span>
</code></pre> 
<p>void指针pv只保存了对象obj的首地址，并不知道obj是什么类型，所以通过pv无法取出obj。但是如果我们指明obj的类型，我们就可以取出obj对象。例子如下：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>


<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">void</span> <span class="token operator">*</span>a <span class="token operator">=</span> <span class="token operator">&amp;</span>b<span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> a<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>			
	cout <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span>a<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>  <span class="token comment">// 输出与cout &lt;&lt; a;一致</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 输出1。(int*)a将void指针强制转换为int类型，相当于指明了a为int型。</span>
	
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre> 
<h3><a id="1void_23"></a>1.void*作为函数形参</h3> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">void_test</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> data<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    num <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span>data<span class="token punctuation">;</span> 		<span class="token comment">// (int*)的作用是将data当成一个int指针（强制类型转换）</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"num = %d\n"</span><span class="token punctuation">,</span> num<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> val<span class="token punctuation">;</span>

    val <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>
    <span class="token function">void_test</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 将以上代码编译并运行，输出结果为：</span>
<span class="token comment">// num = 123</span>
</code></pre> 
<h3><a id="2void_48"></a>2.void指针的加一操作</h3> 
<p>在ANSI中下面代码是错误的</p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token operator">*</span> pvoid<span class="token punctuation">;</span>
pvoid<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">//ANSI：错误</span>
pvoid <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">//ANSI：错误</span>
</code></pre> 
<p>GNU指定void *的算法操作与char *一致</p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token operator">*</span> pvoid<span class="token punctuation">;</span>
pvoid<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">//GNU：正确</span>
pvoid <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">//GNU：正确</span>
</code></pre> 
<p>为迎合ANSI标准，并提高程序的可移植性，我们可以这样编写实现同样功能的代码：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token operator">*</span> pvoid<span class="token punctuation">;</span>
<span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span>pvoid<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">//ANSI：正确；GNU：正确</span>
<span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span>pvoid <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">//ANSI：错误；GNU：正确</span>
</code></pre> 
<p>GNU和ANSI还有一些区别，总体而言，GNU较ANSI更“开放”，提供了对更多语法的支持。但是我们在真实设计时，还是应该尽可能地迎合ANSI标准。</p> 
<h3><a id="_69"></a>其他</h3> 
<p>如果函数的参数可以是任意类型指针，那么应声明其参数为void *<br> 典型的如内存操作函数memcpy和memset的函数原型分别为：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token operator">*</span> <span class="token function">memcpy</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>dest<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>src<span class="token punctuation">,</span> size_t len<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token operator">*</span> <span class="token function">memset</span> <span class="token punctuation">(</span> <span class="token keyword">void</span> <span class="token operator">*</span> buffer<span class="token punctuation">,</span> <span class="token keyword">int</span> c<span class="token punctuation">,</span> size_t num <span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>参考：https://www.cnblogs.com/geekham/p/4225993.html</p>
                ]]></description></item><item><title>linux中输入ctrl-z</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522360.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Tue, 26 Jul 2022 11:51:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522360.html</guid><description><![CDATA[
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>ctrl-z: 挂起在命令行窗口运行的进程，而并非结束进程，用户可以在命令行窗口中输入fg/bg来让进程继续执行。<br> 输入fg：在前台执行（在当前命令行窗口执行），此时可以使用ctrl-z再次挂起该进程<br> 输入bg：在后台执行（在当前命令行窗口看不到执行过程），<br> 一个比较常用的功能：正在使用vi编辑一个文件时，需要执行shell命令查询一些需要的信息，可以使用ctrl-z挂起vi，等执行 完shell命令后再使用fg恢复vi继续编辑你的文件（当然，也可以在vi中使用！command方式执行shell命令，但是没有该方法方便）。</p> 
<p>参考：https://blog.csdn.net/mylizh/article/details/38385739</p>
                ]]></description></item><item><title>C++ main函数参数</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522361.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Tue, 26 Jul 2022 11:51:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522361.html</guid><description><![CDATA[
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>C++的main函数可以没有输入参数，也可以有输入参数，而且只能有两个参数，习惯上coding如下：</p> 
<pre><code class="prism language-cpp"> <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> 或者 <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">*</span> argv<span class="token punctuation">)</span>
</code></pre> 
<p>其中，argc = argument count ：表示传入main函数的数组元素个数，为int类型，而 argv = argument vector ：表示传入main函数的指针数组，为char**类型。第一个数组元素argv[0]是程序名称，并且包含程序所在的完整路径。argc至少为1，即argv数组至少包含程序名。<br> 　 一般编译器默认使用argc和argv两个名称作为main函数的参数，但这两个参数如此命名并不是必须的，你可以使用任何符合C++语言命名规范的变量名，但要保证第一个参数类型为int型，第二个参数为char**型。<br> 　 由于main函数不能被其他函数调用，因此不可能在程序内部取得实际值。main函数的参数值是从操作系统命令行上获取的。在window系统中，假如编译链接成的可执行文件为my_project.exe，则在命令提示符(快捷键windows+R，输入cmd)中，键入如下命令(可执行文件 参数 参数 参数 …)：</p> 
<pre><code class="prism language-cpp">my_project<span class="token punctuation">.</span>exe jisongxie <span class="token number">1996</span>
</code></pre> 
<p>将会传递三个参数给main函数，第一个argv[0]是前面提到的文件名，第二个argv[1]是"jisongxie"，第三个argv[2]是“1996”。同理，可以传入更多的参数。在ubuntu系统中，可以通过终端进行相同的操作。<br> 　　传入的参数数组类型为char *字符串类型，可以通过atoi，atof函数进行类型的转换。<br> 　　1、atoi，即ascii to integer，把字符串转换成int<br> 　　2、atof，即ascii to float，把字符串转换成double<br> 　　3、atol，即ascii to long int，把字符串转换成long int<br> 　　4、atoll，即ascii to long long int，把字符串转换成long long int<br> 　　例如上述输入的1996，可以得到如下：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> year <span class="token operator">=</span> <span class="token function">atoi</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// year = 1996</span>
</code></pre> 
<p>因此，通过上述的命令行输入以及程序里面的类型转换，可以通过命令行窗口传入值(字符串和数字)到程序中运行。</p> 
<p>参考：<a href="https://www.cnblogs.com/jisongxie/p/7892366.html">链接</a></p>
                ]]></description></item><item><title>C++用字符数组存储字符串</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522362.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Tue, 26 Jul 2022 11:51:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522362.html</guid><description><![CDATA[
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>使用char类型的数组保存字符串。每个字符串都需要以’\0’结尾，所以字符串数组的长度最小等于字符个数+1<br> 三种等价的初始化方式：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">char</span> str<span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{<!-- --></span><span class="token string">'H'</span><span class="token punctuation">,</span><span class="token string">'e'</span><span class="token punctuation">,</span><span class="token string">'l'</span><span class="token punctuation">,</span><span class="token string">'l'</span><span class="token punctuation">,</span><span class="token string">'o'</span><span class="token punctuation">,</span><span class="token string">','</span><span class="token punctuation">,</span><span class="token string">'W'</span><span class="token punctuation">,</span><span class="token string">'o'</span><span class="token punctuation">,</span><span class="token string">'r'</span><span class="token punctuation">,</span><span class="token string">'l'</span><span class="token punctuation">,</span><span class="token string">'d'</span><span class="token punctuation">,</span><span class="token string">'\0'</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// 初始化列表</span>
<span class="token keyword">char</span> str1<span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"Hello,World"</span><span class="token punctuation">;</span> <span class="token comment">// 指定字符数组长度,字符串末尾隐含设为'\0'</span>
<span class="token keyword">char</span> str2<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"Hello,World"</span><span class="token punctuation">;</span>   <span class="token comment">// 未指定字符数组长度,字符串末尾隐含设为'\0'</span>
</code></pre> 
<p>当然还可以使用string定义字符串，这里不赘述。</p> 
<p>参考：https://blog.csdn.net/shizheng_Li/article/details/105752490</p>
                ]]></description></item><item><title>1×1的卷积核</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522363.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Tue, 26 Jul 2022 11:51:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522363.html</guid><description><![CDATA[
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>卷积核都有增加非线性。1×1的卷积核只在通道上进行处理，其他的卷积核是在通道和面上进行处理。</p>
                ]]></description></item><item><title>CUDA error: CUBLAS_STATUS_NOT_INITIALIZED when calling `cublasCreate(handle)`</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522365.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Tue, 26 Jul 2022 11:51:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522365.html</guid><description><![CDATA[
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>torch.utils.data.DataLoader(train_dataset, batch_size=batch_size, shuffle=True, batch num_workers=nw)中的nw在windows中需设为零</p>
                ]]></description></item><item><title>我的研究想法</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522366.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Tue, 26 Jul 2022 11:51:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522366.html</guid><description><![CDATA[
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>1.读论文的时候，需要将论文中好的做法用自己语言提炼出来。<br> 2.看到论文可能存在的不足，或者你认为可以用的方法时，记得记下来</p>
                ]]></description></item><item><title>1. git学习</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522367.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Tue, 26 Jul 2022 11:51:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522367.html</guid><description><![CDATA[
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>学习目标：<br> 熟练在vscode中使用git，熟练版本控制的各种操作。<br> 熟练使用git的版本对比、分支合并。</p> 
<h1><a id="1git_4"></a>1.git基本使用</h1> 
<p>你的本地仓库由 git 维护的三棵“树”组成。第一个是你的工作目录（workspace），保存着正在修改的文件；第二个是 暂存区（Index），它像个缓存区域，临时保存你的改动；最后是 HEAD，它指向你最后一次提交的结果。下面是git操作的一个流程图：<br> <img src="https://img-blog.csdnimg.cn/969b95c30c1047d881273df2e73b1557.png" alt="在这里插入图片描述"><br> 安装好git后，在命令行或终端中使用下面的命令可以设置git自己的名字和电子邮件。这是因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址，这样谁修改了哪行代码就都可以查询出来。在命令行输入：</p> 
<pre><code class="prism language-bash"><span class="token function">git</span> config --global user.name <span class="token string">"Your Name"</span>
<span class="token function">git</span> config --global user.email <span class="token string">"email@example.com"</span>
</code></pre> 
<p>注意git config命令的–global参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。上面这个命令只要配置一次，以后不需要再配置了。<br> 注意：</p> 
<pre><code class="prism language-bash">--global：系统某个用户的全局设置
--local：对单独的某个项目进行设置。
参考：https://www.lmlphp.com/user/57828/article/item/709802/
</code></pre> 
<p>下面介绍一下git的常用操作：</p> 
<pre><code class="prism language-bash"><span class="token function">git</span> init  <span class="token comment"># 用于初始化git库，生成了.git文件，.git中存放着暂存区和分支（master）的数据</span>
<span class="token function">git</span> <span class="token function">add</span> file2.txt file3.txt <span class="token comment"># 添加到暂存区</span>
<span class="token function">git</span> <span class="token function">add</span> <span class="token builtin class-name">.</span> <span class="token comment"># 添加所有文件到暂存区</span>
<span class="token function">git</span> commit -m <span class="token string">"fix(text.txt):change balabala"</span> <span class="token comment"># 将暂存区的文件全部存储到当前分支中。-m后为注释，用于说明提交内容是啥。</span>
<span class="token comment"># 提交的说明是有一定规范的，如上，fix表示进行的操作，text.txt代表操作的文件，change balabala 代表具体做了什么操作</span>
<span class="token comment"># 具体我们可以搜索“git commit风格”进行进一步了解。	</span>

<span class="token function">git</span> status：查看workspace、stage和repository的状态。

<span class="token function">git</span> <span class="token function">diff</span> readme.txt <span class="token comment"># 查看HEAD指向的readme.txt与本地的readme.txt相比做了哪些修改</span>
<span class="token function">git</span> <span class="token function">diff</span> HEAD -- readme.txt <span class="token comment"># 命令可以查看工作区和版本库里面最新版本的区别</span>
<span class="token function">git</span> log <span class="token comment"># 查看提交的历史以及版本对应的ID号</span>
<span class="token function">git</span> log --pretty<span class="token operator">=</span>oneline <span class="token comment"># 查看提交历史（只包含简要信息）</span>
<span class="token function">git</span> reset --hard 1094a <span class="token comment"># 退回到ID开头为1094a的版本</span>
<span class="token function">git</span> reset --hard HEAD^ <span class="token comment"># 退回到上一个版本，上上一个版本就是HEAD^^，往上100个版本是HEAD~100</span>
    			       <span class="token comment"># HEAD指向的是当前分支</span>
<span class="token function">git</span> reflog <span class="token comment"># 用来记录你的每一次命令，可用于查看生成过的每一个版本的ID</span>
<span class="token function">git</span> checkout -- readme.txt <span class="token comment"># 丢弃工作区的修改,如误删了readme.txt和修改了readme.txt</span>
<span class="token function">git</span> reset HEAD readme.txt <span class="token comment"># 可以把暂存区的修改撤销掉（unstage）</span>


<span class="token function">git</span> checkout -- <span class="token operator">&lt;</span>filename<span class="token operator">&gt;</span>  <span class="token comment"># 此命令会使用 HEAD 中的最新内容替换掉你的工作目录中的文件。</span>
							<span class="token comment"># 已添加到暂存区的改动以及新文件都不会受到影响。</span>

<span class="token comment"># 假如你想丢弃你在本地的所有改动与提交，</span>
<span class="token comment">#　可以到服务器上获取最新的版本历史，并将你本地主分支指向它：</span>
<span class="token function">git</span> fetch origin
<span class="token function">git</span> reset --hard origin/master


HEAD指向当前分支
master、feature都相当于指针
</code></pre> 
<h1><a id="2_55"></a>2.本地仓库与远程仓库连接</h1> 
<h2><a id="21_56"></a>2.1.生成公钥和私钥</h2> 
<p>1.Windows下打开Git Bash或linux终端中输入：</p> 
<pre><code class="prism language-bash">ssh-keygen -t rsa -C <span class="token string">"youremail@example.com"</span>
</code></pre> 
<p>你需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码。<br> windows下的C:\Users\用户名\.ssh里有id_rsa和id_rsa.pub两个文件，id_rsa是私钥，id_rsa.pub是公钥，<br> linux中id_rsa和id_rsa.pub两个文件可以在~/.ssh目录下找到</p> 
<p>2.将id_rsa.pub中的内容添加到https://github.com/settings/keys中，添加位置如下：<br> <img src="https://img-blog.csdnimg.cn/7add42bb029e44fd9dcf844f8a467d9f.png" alt="在这里插入图片描述"></p> 
<p>在linux下通过cat显示id_rsa.pub的内容，然后再复制内容到下图的key中（通过其他方式得到key可能格式不对）。</p> 
<h2><a id="22_70"></a>2.2.本地仓库与远程仓库连接</h2> 
<p>前面我们已经介绍过本地库的创建，下面介绍如何将本地仓库上传到远程仓库中。<br> 1.首先给远程仓库取名为origin（起什么名都可以）：</p> 
<pre><code class="prism language-bash"><span class="token function">git</span> remote <span class="token function">add</span> origin git@github.com:username/learngit.git <span class="token comment"># 使用ssh方式提交代码。（由于前面配置了ssh key，所以使用这种方式）</span>
<span class="token comment"># git remote add origin git@gitee.com:username/learngit.git # gitee的上传命令</span>
<span class="token comment"># git remote add origin https://gitee.com/username/test.git # 使用https方式提交代码</span>

<span class="token comment"># 更一般的命令如下：</span>
<span class="token comment"># git remote add origin &lt;server&gt; # 如此你就能够将你的改动推送到所添加的服务器上去了。</span>
</code></pre> 
<p>远程库的名字就是origin，这是Git常用的叫法。请千万注意，把上面的username/learngit.git替换成你自己的GitHub仓库。使用git命令将本地仓库通过https方式上传到github，需要进行如下操作：</p> 
<pre><code class="prism language-bash"><span class="token function">git</span> remote <span class="token function">add</span> origin https://token@github.com/username/test.git 
</code></pre> 
<p>token的获取，具体可参看<a href="https://blog.csdn.net/qq_42775938/article/details/125435012">链接</a><br> 2.将本地库的所有内容推送到远程库上：</p> 
<pre><code class="prism language-bash"><span class="token function">git</span> push -u origin master  
相当于以下两个：
<span class="token function">git</span> branch --set-upstream-to<span class="token operator">=</span>origin/master master // 将远程仓库origin的master分支与本地仓库master分支绑定
<span class="token function">git</span> push origin master
也就是说-u起到了绑定作用，如果我们需要将一份已经写好的代码提交到多个git远端时，就可以不用-u参数进行绑定。
</code></pre> 
<p>若有如下提示，请输入yes（不可以按回车）：<br> <img src="https://img-blog.csdnimg.cn/a0922fae4dd4461fb64c0d4afc435100.png" alt="在这里插入图片描述"><br> 4.断开远程连接与克隆</p> 
<pre><code class="prism language-bash"><span class="token comment"># 远程库操作</span>
<span class="token function">git</span> remote -v <span class="token comment"># 查看远程库信息：</span>
<span class="token function">git</span> remote remove origin <span class="token comment"># 此处的“删除”其实是解除了本地和远程的绑定关系，并不是物理上删除了远程库</span>

<span class="token comment"># 克隆</span>
<span class="token function">git</span> clone 相应链接 <span class="token comment"># 开启代理，可能会导致克隆失败</span>
<span class="token function">git</span> clone git@github.com:superDogDad/test.git <span class="token comment">#使用ssh协议,ssh协议速度最快。</span>
<span class="token function">git</span> clone https://github.com/superDogDad/test.git 

<span class="token function">git</span> clone /path/to/repository <span class="token comment"># 创建一个本地仓库的克隆版本</span>
<span class="token function">git</span> clone username@host:/path/to/repository <span class="token comment"># 使用此命令克隆任意服务器中的远程仓库</span>
</code></pre> 
<p><img src="https://img-blog.csdnimg.cn/9d2a27f746ff48c989d05765c7350446.png" alt="在这里插入图片描述"></p> 
<h1><a id="3_112"></a>3.分支管理</h1> 
<p>前面我们都是使用git push origin master将把本地master分支的最新修改推送至GitHub。但是通常我们不直接修改master分支，而是新建一个分支来修改代码，然后将分支提交到github中。提交到github中以后，你的领导会评估你的分支与master中代码的差别，然后再决定是否将你的分支与master进行合并。</p> 
<p>1.生成、切换、提交和删除分支：</p> 
<pre><code class="prism language-bash"><span class="token function">git</span> branch  feature_x 		<span class="token comment"># 建一个叫做“feature_x”的分支</span>
<span class="token function">git</span> checkout -b feature_x 	<span class="token comment"># 建一个叫做“feature_x”的分支，并切换过去</span>
<span class="token function">git</span> checkout master 		<span class="token comment"># 切换回主分支</span>
<span class="token function">git</span> branch -d feature_x 	<span class="token comment"># 把新建的分支删掉</span>
<span class="token function">git</span> push origin <span class="token operator">&lt;</span>branch<span class="token operator">&gt;</span> 	<span class="token comment"># 提交你的分支到远程。除非你将分支推送到远端仓库，不然该分支就是 不为他人所见的</span>
</code></pre> 
<p>2.更新和合并分支</p> 
<pre><code class="prism language-bash"><span class="token function">git</span> pull origin master:brantest  <span class="token comment"># git pull=git fetch + git merge。</span>
								<span class="token comment"># 将远程主机origin的master分支拉取过来，与本地的brantest分支合并。</span>
<span class="token function">git</span> pull origin master			<span class="token comment"># 如果远程分支是与当前分支合并，则冒号后面的部分可以省略。</span>

<span class="token function">git</span> merge <span class="token operator">&lt;</span>branch<span class="token operator">&gt;</span>				<span class="token comment"># 要合并其他分支到你的当前分支</span>
<span class="token function">git</span> <span class="token function">diff</span> <span class="token operator">&lt;</span>source_branch<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>target_branch<span class="token operator">&gt;</span>  <span class="token comment"># 在合并改动之前，你可以使用如下命令预览差异</span>
</code></pre> 
<h1><a id="4log_135"></a>4.log</h1> 
<p>git log用于查阅本地仓库的历史记录</p> 
<pre><code class="prism language-bash"><span class="token function">git</span> log --author<span class="token operator">=</span>bob  <span class="token comment">#　查看bob的提交记录</span>
<span class="token function">git</span> log --pretty<span class="token operator">=</span>oneline	<span class="token comment"># 一个压缩后的每一条提交记录只占一行的输出</span>
<span class="token function">git</span> log --graph --oneline --decorate --all <span class="token comment"># 通过 ASCII 艺术的树形结构来展示所有的分支, 每个分支都标示了他的名字和标签</span>
<span class="token function">git</span> log --name-status <span class="token comment"># 看看哪些文件改变了</span>
<span class="token function">git</span> log --help        <span class="token comment"># 查看帮助</span>
</code></pre> 
<p>常用如下：</p> 
<pre><code class="prism language-bash"> <span class="token function">git</span> log --graph --pretty<span class="token operator">=</span>oneline --abbrev-commit 
 或
 <span class="token function">git</span> log --oneline --graph
</code></pre> 
<h1><a id="5_151"></a>5.错误修改</h1> 
<pre><code class="prism language-bash"><span class="token function">git</span> checkout -- <span class="token operator">&lt;</span>filename<span class="token operator">&gt;</span>  <span class="token comment"># 此命令会使用 HEAD 中的最新内容替换掉你的工作目录中的文件。</span>
							<span class="token comment"># 已添加到暂存区的改动以及新文件都不会受到影响。</span>

<span class="token comment"># 假如你想丢弃你在本地的所有改动与提交，</span>
<span class="token comment">#　可以到服务器上获取最新的版本历史，并将你本地主分支指向它：</span>
<span class="token function">git</span> fetch origin
<span class="token function">git</span> reset --hard origin/master
</code></pre> 
<h1><a id="6_162"></a>6.实用小贴士</h1> 
<p>内建的图形化 git：gitk<br> 彩色的 git 输出：git config color.ui true<br> 显示历史记录时，每个提交的信息只显示一行：git config format.pretty oneline<br> 交互式添加文件到暂存区：git add -i</p> 
<h1><a id="7github_169"></a>7.github</h1> 
<p>Repositories：存放项目<br> Star：收藏<br> watch：有更新时会提醒<br> fork：在你的账号中创建此仓库的副本，Pull Request 把你的提交贡献回原仓库。（具体还得实战演练演练）</p> 
<p>github使用小技巧：<br> 在仓库中点击"."可以开启在线的vscode</p> 
<h1><a id="8_181"></a>8.问题</h1> 
<p>1.新提交到暂存区的东西，会覆盖掉旧的吗？<br> 答：提交到暂存区的东西是一个一个修改，所以不存在覆盖一说。新提交的修改和以前提交的修改会在commit以后，一同上传到仓库中。</p> 
<p>2.版本退回方法？<br> git reset --hard HEAD^<br> 遇到不会的，再去百度</p> 
<p>3.去看官方文档<br> 答：有空，再说。</p> 
<p>4.代码自动备份软件：git是一个版本管理工具，那代码自动备份是不是有相应的软件呢，毕竟暂存区也是在本地，一旦电脑崩溃就啥都没了。<br> 答：似乎没有备份代码的软件，但是我们可以通过github进行代码备份。<br> 通过设置脚本进行自动commit和上传来进行备份。<br> 一般开发一个新功能feature，都是需要开辟一个新分支。我们设置自动上传的代码以后，要让这些代码都是自动上传到feature中。这样就不会影响master等重要的分支。<br> 可参考如下链接，进行设置：<a href="https://zhuanlan.zhihu.com/p/76906272">链接</a></p> 
<p>5.除了vscode的git插件，还有git的可视化软件可以用吗？<br> 答：github桌面版等</p> 
<p>6.github不支持大文件存储，大文件存储请参考： https://git-lfs.github.com</p> 
<h1><a id="9_209"></a>9.最后</h1> 
<p>git的学习，可以先在廖雪峰的网站中进行学习，然后将这个网站当成字典，需要的时候去查询。当然菜鸟教程更全，更适合当字典。</p> 
<p>复习廖雪峰的git教程的时候，只需要看廖雪峰教程每小节下面的总结即可知道还要不要认真看这一节。</p>
                ]]></description></item><item><title>设置环境变量——bashrc与profile</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522368.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Tue, 26 Jul 2022 11:51:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522368.html</guid><description><![CDATA[
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>bashrc与profile都用于保存用户的环境信息，bashrc用于交互式non-loginshell，而profile用于交互式login shell。（这句我没看懂）</p> 
<p>/etc/profile，/etc/bashrc 是系统全局环境变量设定<br> ~/.profile，~/.bashrc用户目录下的私有环境变量设定</p> 
<p>当登入系统获得一个shell进程时，其读取环境设置脚本分为三步:<br> 1.首先读入的是全局环境变量设置文件/etc/profile，然后根据其内容读取额外的文档，如/etc/profile.d和/etc/inputrc<br> 2.读取当前登录用户Home目录下的文件~/.bash_profile，其次读取~/.bash_login，最后读取~/.profile，这三个文档设定基本上是一样的，读取有优先关系<br> 3.读取~/.bashrc<br> ~/.profile与~/.bashrc的区别:</p> 
<ul><li>这两者都具有个性化定制功能</li><li>~/.profile可以设定本用户专有的路径，环境变量，等，它只能登入的时候执行一次</li><li>~/.bashrc也是某用户专有设定文档，可以设定路径，命令别名，每次shell script的执行都会使用它一次</li></ul>
                ]]></description></item><item><title>linux基础入门</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522369.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Tue, 26 Jul 2022 11:51:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522369.html</guid><description><![CDATA[
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="1_0"></a>1.文件和目录管理</h3> 
<pre><code class="prism language-cpp">创建：mkdir
删除：rm
删除非空目录：rm <span class="token operator">-</span>rf file目录
删除日志 rm <span class="token operator">*</span>log <span class="token punctuation">(</span>等价<span class="token operator">:</span> $find <span class="token punctuation">.</span><span class="token operator">/</span> <span class="token operator">-</span>name “<span class="token operator">*</span>log” <span class="token operator">-</span>exec rm <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span> <span class="token punctuation">;</span><span class="token punctuation">)</span>
移动：mv
复制：cp source_dir  dest_dir <span class="token punctuation">(</span>复制目录：cp <span class="token operator">-</span>r source_dir  dest_dir<span class="token punctuation">)</span>
显示当前路径<span class="token operator">:</span> pwd
</code></pre> 
<h3><a id="2_11"></a>2.性能监控</h3> 
<pre><code class="prism language-cpp">$ps <span class="token operator">-</span>ef	 # 查询正在运行的进程信息，常与grep结合使用，如：
$ps <span class="token operator">-</span>ef <span class="token operator">|</span> grep colin115  # 查询归属于用户colin115的进程
$pgrep <span class="token operator">-</span>l re  # 查询进程名中含有re的进程
$kill PID	# 杀死进程
</code></pre> 
<pre><code class="prism language-cpp">$top	# 显示进程信息，并实时更新。输入以下内容得到相应结果：
i：使top不显示任何闲置或者僵死进程。
P：根据CPU使用百分比大小进行排序。
M：根据驻留内存大小进行排序。
</code></pre> 
<h3><a id="3_24"></a>3.网络工具</h3> 
<p>netstat</p> 
<pre><code class="prism language-cpp">netstat <span class="token operator">-</span>a		# 列出所有端口
netstat <span class="token operator">-</span>at		# 列出所有 tcp 端口
netstat <span class="token operator">-</span>l		# 列出所有有监听的服务状态
$netstat <span class="token operator">-</span>antp <span class="token operator">|</span> grep <span class="token number">6379</span>	# 查看<span class="token number">6379</span>端口情况
</code></pre> 
<h3><a id="4_33"></a>4.用户与组</h3> 
<pre><code class="prism language-cpp">$useradd <span class="token operator">-</span>m username # 创建了<span class="token operator">/</span>home<span class="token operator">/</span>username目录和相应用户
$passwd username	 # 给用户设置密码
$userdel <span class="token operator">-</span>r username # 删除用户并且删除<span class="token operator">/</span>home<span class="token operator">/</span>username目录
$su userB 			 # 切换用户
$groups				 # 查看用户所在组
$usermod <span class="token operator">-</span>G groupNmame username # 一个用户可以属于多个组，将用户加入到组
$usermod <span class="token operator">-</span>g groupName username  # 变更用户所属的根组<span class="token punctuation">(</span>将用加入到新的组，并从原有的组中除去）
</code></pre> 
<h3><a id="5_43"></a>5.文件访问权限</h3> 
<h5><a id="51_44"></a>5.1查看权限</h5> 
<p>使用ls -l可查看文件的属性字段，文件属性字段总共有10个字母组成，第一个字母表示文件类型，如果这个字母是一个减号”-”,则说明该文件是一个普通文件。字母”d”表示该文件是一个目录，字母”d”,是dirtectory(目录)的缩写。 后面的9个字母为该文件的权限标识，3个为一组，分别表示文件所属用户、用户所在组、其它用户的读写和执行权限；</p> 
<pre><code class="prism language-cpp">ls <span class="token operator">-</span>l 文件<span class="token operator">/</span>目录		# 查看文件的权限，如
<span class="token punctuation">[</span><span class="token operator">/</span>home<span class="token operator">/</span>weber#<span class="token punctuation">]</span>ls <span class="token operator">-</span>l <span class="token operator">/</span>etc<span class="token operator">/</span>group
<span class="token operator">-</span>rwxrw<span class="token operator">-</span>r<span class="token operator">--</span> colin king <span class="token number">725</span> <span class="token number">2013</span><span class="token operator">-</span><span class="token number">11</span><span class="token operator">-</span><span class="token number">12</span> <span class="token number">15</span><span class="token operator">:</span><span class="token number">37</span> <span class="token operator">/</span>home<span class="token operator">/</span>colin<span class="token operator">/</span>a
</code></pre> 
<p>表示这个文件对文件拥有者colin这个用户可读写、可执行；对colin所在的组（king）可读可写；对其它用户只可读；</p> 
<h4><a id="52_53"></a>5.2修改文件权限</h4> 
<pre><code class="prism language-cpp">字母法：
$chmod <span class="token function">userMark</span><span class="token punctuation">(</span><span class="token operator">+</span><span class="token operator">|</span><span class="token operator">-</span><span class="token punctuation">)</span>PermissionsMark
userMark取值：
u：用户
g：组
o：其它用户
a：所有用户
PermissionsMark取值：
r<span class="token operator">:</span>读
w：写
x：执行
如：
$chmod a<span class="token operator">+</span>x main         对所有用户给文件main增加可执行权限
$chmod g<span class="token operator">+</span>w blogs        对组用户给文件blogs增加可写权限
数字法：
使用三个数表示权限，第一位指定文件拥有者的权限，第二位指定组权限，
第三位指定其他用户的权限，每位通过<span class="token function">4</span><span class="token punctuation">(</span>读<span class="token punctuation">)</span>、<span class="token function">2</span><span class="token punctuation">(</span>写<span class="token punctuation">)</span>、<span class="token function">1</span><span class="token punctuation">(</span>执行<span class="token punctuation">)</span>三种数值的和来确定权限。
如<span class="token function">6</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">)</span>代表有读写权，<span class="token function">7</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token operator">+</span><span class="token number">2</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>有读、写和执行的权限。如：
$chmod <span class="token number">740</span> main     将main的用户权限设置为rwxr<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>

更改文件或目录的拥有者：
$chown username 文件或目录
$chown <span class="token operator">-</span>R weber server<span class="token operator">/</span>  # 将server目录下的所有文件的拥有者都变为weber
</code></pre> 
<h3><a id="ubuntu_79"></a>ubuntu目录结构</h3> 
<p>1、/：目录属于根目录，是所有目录的绝对路径的起始点，Ubuntu 中的所有文件和目录都在跟目录下。<br> 2、/etc（存放配置文件）：绝大多数系统和相关服务的配置文件都保存在这里，这个目录的内容一般只能由管理员进行修改。像密码文件、设置网卡信息、环境变量的设置等都在此目录中。此目录的 rcn.d 目录中存放不同启动级别所启动的服务，network 目录放置网卡的配置信息等。<br> 3、/home（每个用户都在这个目录下建立一个目录）：系统默认的用户家目录，新增用户账号时，用户的家目录都存放在此目录下，~表示当前用户的家目录，~test表示用户test的家目录。建议单独分区，并设置较大的磁盘空间，方便用户存放数据<br> 4、/bin :此目录中放置了所有用户能够执行的命令。<br> 5、/sbin：此目录中放置了一般是只有系统管理有才能执行的命令。<br> 6、/dev：存放linux系统下的设备文件，<strong>访问该目录下某个文件，相当于访问某个设备</strong>，常用的是挂载光驱mount /dev/cdrom /mnt。<br> 7、/mnt：此目录主要是作为挂载点使用。（不是很明白？？）<br> 8、/usr：此目录包含了所有的命令、说明文件、程序库等，此目录下有很多重要的目录，常见的有：/usr/local 这个目录包含管理员自己安装的程序；/usr/share 包含文件的帮助文件；/usr/bin 和/usr/sbin 包含了所有的命令（这里应该指的是非root用户可以使用的命令）。<br> 9、/var：包含了日志文件、计划性任务和邮件等内容。<br> 10、/lib：包含了系统的函数库文件。<br> 11、/lost+found：包含了系统修复时的回复文件。<br> 12、/tmp：包含了临时的文件。一般用户或正在执行的程序临时存放文件的目录,任何人都可以访问,重要数据不可放置在此目录下<br> 13、/boot：系统的内核所在地，也是启动分区。<strong>放置linux系统启动时用到的一些文件</strong>。/boot/vmlinuz为linux的内核文件，以及/boot/gurb。建议单独分区，分区大小100M即可<br> 14、/media：主要用于挂载多媒体设备。（应该是指在此建立对应设备的相应文件）<br> 15、/root：系统管理员的宿主目录。<br> 参考：<a href="https://www.cnblogs.com/hf8051/p/5074903.html#:~:text=ubuntu%20--%20%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84,1%E3%80%81/%EF%BC%9A%E7%9B%AE%E5%BD%95%E5%B1%9E%E4%BA%8E%E6%A0%B9%E7%9B%AE%E5%BD%95%EF%BC%8C%E6%98%AF%E6%89%80%E6%9C%89%E7%9B%AE%E5%BD%95%E7%9A%84%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84%E7%9A%84%E8%B5%B7%E5%A7%8B%E7%82%B9%EF%BC%8CUbuntu%20%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E9%83%BD%E5%9C%A8%E8%B7%9F%E7%9B%AE%E5%BD%95%E4%B8%8B%E3%80%82%202%E3%80%81/etc%EF%BC%9A%E6%AD%A4%E7%9B%AE%E5%BD%95%E9%9D%9E%E5%B8%B8%E9%87%8D%E8%A6%81%EF%BC%8C%E7%BB%9D%E5%A4%A7%E5%A4%9A%E6%95%B0%E7%B3%BB%E7%BB%9F%E5%92%8C%E7%9B%B8%E5%85%B3%E6%9C%8D%E5%8A%A1%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E9%83%BD%E4%BF%9D%E5%AD%98%E5%9C%A8%E8%BF%99%E9%87%8C%EF%BC%8C%E8%BF%99%E4%B8%AA%E7%9B%AE%E5%BD%95%E7%9A%84%E5%86%85%E5%AE%B9%E4%B8%80%E8%88%AC%E5%8F%AA%E8%83%BD%E7%94%B1%E7%AE%A1%E7%90%86%E5%91%98%E8%BF%9B%E8%A1%8C%E4%BF%AE%E6%94%B9%E3%80%82%20">链接</a></p> 
<h3><a id="7_96"></a>7.其他</h3> 
<pre><code class="prism language-cpp">sudo passwd root 	# Ubuntu创建root用户
$uname <span class="token operator">-</span>a 			# 查看系统版本
$lsb_release <span class="token operator">-</span>a 	# 查看系统版本，排列整齐地显示
wget url	# 下载文件
Ctl<span class="token operator">-</span>U   删除光标到行首的所有字符
Ctl<span class="token operator">-</span>W   删除当前光标到前边的最近一个空格之间的字符
</code></pre> 
<p>参考：<a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/index.html">链接</a></p>
                ]]></description></item><item><title>正则表达式</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522370.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Tue, 26 Jul 2022 11:51:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522370.html</guid><description><![CDATA[
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>正则表达式就是用来匹配字符串的，如你需要在一个文件中查找以“奥特曼”为开头的字符串，此时就需要正则表达式。</p> 
<h3><a id="1_1"></a>1.元字符</h3> 
<p><img src="https://img-blog.csdnimg.cn/766b04555e7141d48a7aa07958d0c85b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAcXFfNDI3NzU5Mzg=,size_17,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br> <img src="https://img-blog.csdnimg.cn/cd7dc140c84347588cffba1c97346ecf.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAcXFfNDI3NzU5Mzg=,size_17,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br> ^：匹配字符串的开始，如^abc就是匹配以abc开头的字符串</p> 
<h3><a id="2__5"></a>2. 重复限定符</h3> 
<p><img src="https://img-blog.csdnimg.cn/d6ffb06a82754d5db05349e5df805eb5.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAcXFfNDI3NzU5Mzg=,size_17,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br> *：重复前面那个字符零次或多次，如^(ab)*：重复ab零次或多次</p> 
<h3><a id="3_8"></a>3.区间</h3> 
<p>1.限定0到9 可以写成[0-9]<br> 2.限定A-Z 写成[A-Z]<br> 如：<br> ^((13[0-2])|(15[5-6])|(18[5-6])|145|176)\d{8}$于匹配联通的号码</p> 
<h3><a id="4_13"></a>4.贪婪与非贪婪（懒惰）</h3> 
<p>贪婪：尽可能多地匹配</p> 
<pre><code class="prism language-cpp"><span class="token number">1</span>   文本：<span class="token number">61762828</span> <span class="token number">176</span> <span class="token number">2991</span> <span class="token number">87321</span>
<span class="token number">2</span>   贪婪模式：<span class="token punctuation">(</span>\d<span class="token punctuation">{<!-- --></span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span>\d<span class="token punctuation">{<!-- --></span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token number">3</span>   匹配结果：<span class="token number">617628</span>
<span class="token number">4</span>   匹配结果：<span class="token number">2991</span>
<span class="token number">5</span>   匹配结果：<span class="token number">87321</span>
解答：
<span class="token number">1.</span><span class="token string">"617628"</span>是前面的\d<span class="token punctuation">{<!-- --></span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">}</span>匹配出了<span class="token number">61</span>，后面的匹配出了<span class="token number">7628</span>
<span class="token number">2.</span><span class="token string">"2991"</span> 是前面的\d<span class="token punctuation">{<!-- --></span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">}</span>匹配出了<span class="token number">29</span> ，后面的匹配出了<span class="token number">91</span>
<span class="token number">3.</span><span class="token string">"87321"</span>是前面的\d<span class="token punctuation">{<!-- --></span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">}</span>匹配出了<span class="token number">87</span>，后面的匹配出了<span class="token number">321</span>
</code></pre> 
<p>非贪婪：尽可能少地匹配，非贪婪量词是在贪婪量词后面加个“？”<br> <img src="https://img-blog.csdnimg.cn/b24d974bd6c94a3c891f1cf0424dd577.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAcXFfNDI3NzU5Mzg=,size_17,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-cpp"><span class="token number">1</span>   文本：<span class="token number">61762828</span> <span class="token number">176</span> <span class="token number">2991</span> <span class="token number">87321</span>
<span class="token number">2</span>   贪婪模式：<span class="token punctuation">(</span>\d<span class="token punctuation">{<!-- --></span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">}</span><span class="token operator">?</span><span class="token punctuation">)</span><span class="token punctuation">(</span>\d<span class="token punctuation">{<!-- --></span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token number">3</span>   匹配结果：<span class="token number">61762</span>
<span class="token number">4</span>   匹配结果：<span class="token number">2991</span>
<span class="token number">5</span>   匹配结果：<span class="token number">87321</span>
解答：
<span class="token number">1.</span><span class="token string">"61762"</span> 是左边的懒惰匹配出<span class="token number">6</span>，右边的贪婪匹配出<span class="token number">1762</span>
<span class="token number">2.</span><span class="token string">"2991"</span> 是左边的懒惰匹配出<span class="token number">2</span>，右边的贪婪匹配出<span class="token number">991</span>
<span class="token number">3.</span><span class="token string">"87321"</span> 左边的懒惰匹配出<span class="token number">8</span>，右边的贪婪匹配出<span class="token number">7321</span>
</code></pre> 
<p>* 和 *? 的区别：对于字符串aabab，a.*b得到aabab，a.*?b得到aab</p> 
<h3><a id="5_41"></a>5.其他</h3> 
<p>转义符：\<br> 或：|，如 ^(130|131|132|155|156|185|186|145|176)\d{8}$用于匹配联通的号码</p> 
<p>参考:<a href="https://www.zhihu.com/question/48219401/answer/742444326">链接</a></p>
                ]]></description></item><item><title>linux的grep</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522371.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Tue, 26 Jul 2022 11:51:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522371.html</guid><description><![CDATA[
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="1_0"></a>1.基本使用</h3> 
<p>grep：查找哪个文件中有字符串A，并将A对应文件和A所在行打印出来。<br> 如：</p> 
<pre><code class="prism language-cpp"># 查找满足条件的文件
grep include <span class="token operator">*</span>cpp    # 查找以cpp结尾的文件中有哪些文件是包含字符串include，以及打印include所在行
输出如下：
test2<span class="token punctuation">.</span>cpp<span class="token operator">:</span>#include<span class="token operator">&lt;</span>iostream<span class="token operator">&gt;</span>
test<span class="token punctuation">.</span>cpp<span class="token operator">:</span>#include<span class="token operator">&lt;</span>iostream<span class="token operator">&gt;</span>
</code></pre> 
<pre><code class="prism language-cpp"># 查找目录下所有文件
grep <span class="token operator">-</span>r include <span class="token punctuation">.</span><span class="token operator">/</span>	 # 查找当前目录下所有包含字符串include的文件以及打印include所在行 
输出如下：
<span class="token punctuation">.</span><span class="token operator">/</span>test<span class="token punctuation">.</span>i<span class="token operator">:</span># <span class="token string">"/usr/include/c++/9/iostream"</span> 
<span class="token punctuation">.</span><span class="token operator">/</span>test<span class="token punctuation">.</span>i<span class="token operator">:</span># <span class="token string">"/usr/include/c++/9/iostream"</span>
</code></pre> 
<pre><code class="prism language-cpp"># 查找不包含某字符的文件及其对应行
grep <span class="token operator">-</span>v include <span class="token operator">*</span>cpp<span class="token operator">*</span> # 查找文件名包含cpp的文件中不包含include的行
输出如下：
test2<span class="token punctuation">.</span>cpp<span class="token operator">:</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
test2<span class="token punctuation">.</span>cpp<span class="token operator">:</span>	std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"/*"</span><span class="token punctuation">;</span>
test2<span class="token punctuation">.</span>cpp<span class="token operator">:</span>	std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"*/"</span><span class="token punctuation">;</span>
test2<span class="token punctuation">.</span>cpp<span class="token operator">:</span>	<span class="token comment">// std: :cout &lt;&lt; /* "*/" */;</span>
test2<span class="token punctuation">.</span>cpp<span class="token operator">:</span>	<span class="token comment">// std: :cout &lt;&lt; /* "*/" /* "/*" */;</span>
test2<span class="token punctuation">.</span>cpp<span class="token operator">:</span>	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
test2<span class="token punctuation">.</span>cpp<span class="token operator">:</span><span class="token punctuation">}</span>
test<span class="token punctuation">.</span>cpp<span class="token operator">:</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
test<span class="token punctuation">.</span>cpp<span class="token operator">:</span>	std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"/*"</span><span class="token punctuation">;</span>
test<span class="token punctuation">.</span>cpp<span class="token operator">:</span>	std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"*/"</span><span class="token punctuation">;</span>
test<span class="token punctuation">.</span>cpp<span class="token operator">:</span>	<span class="token comment">// std: :cout &lt;&lt; /* "*/" */;</span>
test<span class="token punctuation">.</span>cpp<span class="token operator">:</span>	<span class="token comment">// std: :cout &lt;&lt; /* "*/" /* "/*" */;</span>
test<span class="token punctuation">.</span>cpp<span class="token operator">:</span>	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
test<span class="token punctuation">.</span>cpp<span class="token operator">:</span><span class="token punctuation">}</span>
</code></pre> 
<pre><code class="prism language-cpp"># 总结：
$ grep <span class="token string">"被查找的字符串"</span> 文件名 # 从文件内容查找匹配指定字符串的行
$ grep –r <span class="token string">"被查找的字符串"</span> 目录名 # 查找目录下所有文件有哪些文件的哪些行满足条件
$ grep –e <span class="token string">"正则表达式"</span> 文件名 # 从文件内容查找与正则表达式匹配的行
$ grep –i <span class="token string">"被查找的字符串"</span> 文件名 # 查找时不区分大小写
$ grep <span class="token operator">-</span>c <span class="token string">"被查找的字符串"</span> 文件名 # 查找匹配的行数
$ grep –v <span class="token string">"被查找的字符串"</span> 文件名 从文件内容查找不匹配指定字符串的行
</code></pre> 
<h3><a id="2__47"></a>2. |的使用</h3> 
<p>某查询命令｜grep “被查找的字符串”：中间的|功能是把上一条命令的输出，作为下一条命令的参数，如：</p> 
<pre><code class="prism language-cpp">ps <span class="token operator">-</span>ef <span class="token operator">|</span>grep java
其中ps <span class="token operator">-</span>ef输出所有进程的状态
grep java代表在ps <span class="token operator">-</span>ef输出的文本中查找java这个字段
如果连续使用 <span class="token operator">|</span> grep xxx ，就相当于 一层层的过滤筛选。 比如 ps <span class="token operator">-</span>ef <span class="token operator">|</span> grep java <span class="token operator">|</span>grep jenkins <span class="token operator">|</span>grep httpPort

再如：
ls <span class="token punctuation">.</span><span class="token operator">/</span> <span class="token operator">|</span> grep bash
查找ls输出的信息中是否含有带字符串bash
</code></pre> 
<h3><a id="3_59"></a>3.其他</h3> 
<p>sudo grep -r -i pypi.douban.com / # 从根目录开始找含有pypi.douban.com的文件</p> 
<p>参考：https://blog.csdn.net/auccy/article/details/79376680</p>
                ]]></description></item><item><title>杂乱的经验</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522372.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Tue, 26 Jul 2022 11:51:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522372.html</guid><description><![CDATA[
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>1.看书之前，去搜一搜这本书在豆瓣的评分<br> 2.看论文和学英语一样，需要连续持久，做不到一口吃成一个胖子<br> 3.将问题清晰地写出来。一般只要问题能够足够清晰地写出来，解决方法也就很容易出来了<br> 4.经典的书或知识点，网上总是有大量的笔记和资料，可供你参考<br> 5.搜索经验网站：知乎、b站、豆瓣、leecode、牛客、搜索引擎</p> 
<p>其他：<br> 1.硕士论文创新点：（1）神经网络创新 （2）旧网络用到新领域也是一种创新</p>
                ]]></description></item><item><title>SAP安装</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522373.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Tue, 26 Jul 2022 11:51:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522373.html</guid><description><![CDATA[
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><img src="https://img-blog.csdnimg.cn/2ae8a790a14b47ec9b8139a6f692ac0c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAcXFfNDI3NzU5Mzg=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br> <img src="https://img-blog.csdnimg.cn/7c165e58a459465db960d8185be2e36e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAcXFfNDI3NzU5Mzg=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
                ]]></description></item><item><title>size_t类型总结</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522374.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Tue, 26 Jul 2022 11:51:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522374.html</guid><description><![CDATA[
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="1_0"></a>1.不同系统定义不同</h3> 
<p>size_t 的全称应该是size type，就是说size_t是用来记录数据大小无符号整型。size_t的真实类型与操作系统有关。<br> 在32位架构中被普遍定义为：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">typedef</span>   <span class="token keyword">unsigned</span> <span class="token keyword">int</span> size_t<span class="token punctuation">;</span>
</code></pre> 
<p>而在64位架构中被定义为：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">typedef</span>  <span class="token keyword">unsigned</span> <span class="token keyword">long</span> size_t<span class="token punctuation">;</span>
</code></pre> 
<p>size_t在32位架构上是4字节，在64位架构上是8字节，在不同架构上进行编译时需要注意这个问题。而int在不同架构下都是4字节，与size_t不同；且int为带符号数，size_t为无符号数。</p> 
<h2><a id="2size_tsizeof_12"></a>2.size_t常与sizeof配合使用</h2> 
<p>size_t 的全称应该是size type，就是说size_t是用来记录数据大小无符号整型。所以size_t最经常与sizeof配合使用，如：</p> 
<pre><code class="prism language-cpp">size_t size <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> 
</code></pre> 
<p>我的理解是，在64位系统中数据i可能占用字节数会更多，所以需要将size_t定义为unsigned long。在32位系统中数据i可能占用字节数会少一些，所以需要将size_t定义为unsigned int。这样使得，同样都是使用size_t但所表示大小不同，size_t会依据系统的具体定义进行调整，即size_t代表的值会更加地符合系统的实际。</p> 
<h3><a id="3_18"></a>3.注意点</h3> 
<p>在编译的过程中size_t类型的a值会被编译他的补码。所以在使用size_t类型数据的过程中尤其要注意，特别是在逻辑表达式中使用到该类型，稍不注意可能带来很严重的后果。<br> 注：正数的补码：与原码相同；负数的补码：符号位为1，其余位为该数绝对值的原码按位取反，然后整个数加1。</p> 
<p>参考：<br> <a href="https://blog.csdn.net/JIEJINQUANIL/article/details/50981834">链接1</a><br> <a href="https://blog.csdn.net/qq_41598072/article/details/84924997">链接2</a><br> <a href="https://www.zhihu.com/question/24773728">链接3</a></p>
                ]]></description></item><item><title>ubuntu开机卡在/dev/nvme0n1p2: clean 进入不了图形界面</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522375.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Tue, 26 Jul 2022 11:51:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522375.html</guid><description><![CDATA[
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>一般是驱动问题。<br> 需要重新安装驱动。<br> 可以参考<a href="https://blog.csdn.net/AiBigData/article/details/119701227">这篇文章</a></p>
                ]]></description></item><item><title>gcc编译和gdb调试的学习</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522376.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Tue, 26 Jul 2022 11:51:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522376.html</guid><description><![CDATA[
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="gccg_0"></a>gcc与g++基本用法</h3> 
<p>GCC编译流程分为四个步骤： 编译预处理、编译、汇编和链接<br> <img src="https://img-blog.csdnimg.cn/e74e63cd6ae24614bf893b5e1e8192ad.png" alt="在这里插入图片描述"><br> gcc最基本的用法是∶gcc [options] [filenames]<br> 使用gcc可以让源文件编译停在上述四个编译步骤的某一步，具体如下：</p> 
<ul><li> <p>预编译（Pre-Processing）<br> 预编译是在程序被编译之前为编译器所做的一些准备工作，主要是 <strong>拷贝包含的头文件到源程序文件、把宏替换成具体的数</strong>和处理条件编译。我们使用-E选项来使得GCC编译器在完成预处理后停止执行。<br> g++ -E test.cpp -o test.i</p> </li><li> <p>编译（Compiling）<br> 在这个阶段中，GCC编译器首先要 检查代码的规范性，<strong>有无语法错误</strong>，检查无误后再将代码<strong>翻译成汇编语言</strong>。 我们使用-S选项来使得GCC编译器只将输入的文件编译成汇编代码，而不再进一步处理。<br> g++ -S test.cpp -o test.s 或<br> g++ -S test.i -o test.s</p> </li><li> <p>汇编（Assembling）<br> 汇编阶段就是把编译阶段生成的 .s文件转换成<strong>目标文件</strong>。在此可使用选项-c来生成.o的<strong>二进制目标代码</strong>。<br> g++ -c test.cpp -o test.o 或<br> g++ -c test.s -o test.o</p> </li><li> <p>链接（Linking）<br> 在成功编译后，就进入了链接阶段。所谓链接就是把 <strong>前面生成的目标文件及所用到的库函数链接成一个可执行文件</strong>。<br> g++ test.cpp -o test.out 或<br> g++ test.o -o test.out</p> </li><li> <p>编译过程总结：预编译——》代码无错误时，翻译成汇编语言（编译）——》翻译成二进制代码（汇编）——》将汇编得到的目标文件及所用到的库函数链接成一个可执行文件（链接）</p> </li><li> <p>命令总结<br> -o：指定生成的输出文件的名字，默认为a.out；-E：仅执行编译预处理；-S：将C代码转换为汇编代码；- wall：显示警告信息；-c：仅执行编译操作，不进行连接操作。</p> </li></ul> 
<p>g++使用规则和gcc一样。gcc和g++两者都可以编译c和cpp文件，但存在差异。gcc在编译cpp时语法按照c来编译但默认不能链接到c++的库（gcc默认链接c库，g++默认链接c++库）。g++编译.c和.cpp文件都统一按cpp的语法规则来编译。所以一般编译c用gcc，编译c++用g++。</p> 
<h3><a id="gdb_26"></a>gdb调试</h3> 
<p>编译：g++ -g test.cpp -o test.out<br> 调试：gdb test.out<br> 调试命令说明：<br> 以后再来补充。。。。。。。<br> https://blog.csdn.net/u013525455/article/details/52813637</p> 
<p>调试方法好像有查看调用栈，这时什么意思？C++查看调用栈？？<br> 怎么查看呢？<br> C++调试方法？？》</p> 
<h3><a id="_38"></a>其他</h3> 
<p>1.如果没有给出可执行文件的名字，gcc将生成一个名为a.out的文件<br> 2. 在Linux系统中，可执行文件没有统一的后缀，系统从文件的属性来区分可执行文件和不可执行文件。而gcc则通过后缀来区别输入文件的类别。</p> 
<p>参考：<br> gcc和g++：<br> https://blog.csdn.net/yang_quan_yang/article/details/80996032<br> https://blog.csdn.net/qq_42475711/article/details/85224010<br> gdb调试：<br> https://blog.csdn.net/u013525455/article/details/52813637</p>
                ]]></description></item><item><title>搜索引擎使用技巧</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522377.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Tue, 26 Jul 2022 11:51:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522377.html</guid><description><![CDATA[
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>1 “” 双引号表示完全匹配，结果中必须出现与搜索文本完全相同的内容。<br> 2 A -B 搜索包含A但不包含B的结果（请注意A后面的空格不能省略）<br> 3 filetype：指定文件类型搜索，只显示符合关键词的特点类型文件，比如我想找朝闻道的文本版，就可以[filetype:txt 朝闻道]，或者[filetype:torrent ろっぽう];（请注意使用英文的冒号）<br> 4 site 在某个网站内搜索，如：site:zhihu.com 巴塞罗那，在搜索引擎中这样搜索可能会比使用知乎自带搜索框更加强大。<br> 5.通配符*：很多时候想搜一个东西但是不确定具体名字，可以用星号代替忘了的字，如：长城防*墙</p> 
<p>作者：小面包<br> 链接：https://www.zhihu.com/question/28013848/answer/62475371<br> 来源：知乎</p>
                ]]></description></item><item><title>矩阵论总结</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522378.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Tue, 26 Jul 2022 11:51:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522378.html</guid><description><![CDATA[
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>1.线性空间：</p> 
<p>加法具有封闭性和唯一性——结合律、交换律、零元、任意元素都存在负元。唯一性代表相加起来，不会既等于a，又等于b。零元指的是和x相加还等于x的元素，而不是指普通的数零。</p> 
<p>数乘具有封闭性和唯一性——结合律、两个分配率（将常数或向量分配）、恒等率（1指的是普通的数一）</p> 
<p>ps：理解线性空间的时候，可以假设线性空间中的每个元素都是一个向量</p> 
<p>线性空间性质：零元和负元都是唯一的</p> 
<p>2.基：极大线性无关组的个数称为线性空间的维数，dimV。极大线性无关组就是基。证明是基：1）证明线性无关 2）证明任意元素都可以由基进行表示。</p> 
<p>坐标：用基表示某个向量时，基旁边数字的组成的向量就是坐标。</p> 
<p>过渡矩阵：Y=XC代表Y中的每个分量都是由X中分量的线性组合而成的，称C为从基X到基Y的过渡矩阵。若在X上的坐标为a，则在Y上的坐标b=<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        
         C
        
        
         
          −
         
         
          1
         
        
       
      
      
       C^{-1}
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.814108em; vertical-align: 0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.07153em;">C</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.814108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span></span>a。</p> 
<p>利用基表示向量时，不同基会对应不同的坐标，但基和坐标的乘积始终是等于所表示的向量的。</p> 
<p>3.线性子空间：某线性空间的子空间满足加法和数乘的封闭性，则此子空间称为线性子空间。（以后没有特殊说明子空间就是线性子空间）</p> 
<p>线性子空间的性质：（1）线性子空间的零元和线性空间的零元是同一个。（2）线性子空间仍为线性空间</p> 
<p>生成子空间：由线性空间中某个元素组<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        
         x
        
        
         1
        
       
       
        、
       
       
        
         x
        
        
         2
        
       
       
        、
       
       
        …
       
       
        …
       
       
        、
       
       
        
         x
        
        
         m
        
       
      
      
       x_1、x_2、……、x_m
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.58056em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mord cjk_fallback">、</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mord cjk_fallback">、</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord cjk_fallback">、</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.151392em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>中的元素的线性组合得到空间，叫做由此元素组生成的子空间，记作L(<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        
         x
        
        
         1
        
       
       
        、
       
       
        
         x
        
        
         2
        
       
       
        、
       
       
        …
       
       
        …
       
       
        、
       
       
        
         x
        
        
         m
        
       
      
      
       x_1、x_2、……、x_m
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.58056em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mord cjk_fallback">、</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mord cjk_fallback">、</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord cjk_fallback">、</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.151392em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>)</p> 
<p>基扩定理：给<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        
         V
        
        
         n
        
       
      
      
       V^n
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.22222em;">V</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.664392em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span></span>的线性子空间<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        
         V
        
        
         1
        
        
         m
        
       
      
      
       V_1^m
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.931438em; vertical-align: -0.248108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.664392em;"><span class="" style="top: -2.45189em; margin-left: -0.22222em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.248108em;"><span class=""></span></span></span></span></span></span></span></span></span></span>的基添加n-m个向量就变成了<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        
         V
        
        
         n
        
       
      
      
       V^n
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.22222em;">V</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.664392em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span></span>的基，这nm？？？</p> 
<p>线性子空间的交：集合的交，即元素相同的拿出来</p> 
<p>线性子空间的和：两个集合中分别任意拿一个元素出来进行相加。线性子空间的交与和还是线性子空间。</p> 
<p><span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        
         V
        
        
         1
        
       
       
        和
       
       
        
         V
        
        
         2
        
       
       
        是
       
       
        同
       
       
        一
       
       
        线
       
       
        性
       
       
        空
       
       
        间
       
       
        的
       
       
        线
       
       
        性
       
       
        子
       
       
        空
       
       
        间
       
       
        ，
       
       
        则
       
       
        d
       
       
        i
       
       
        m
       
       
        (
       
       
        
         V
        
        
         1
        
       
       
        +
       
       
        V
       
       
        2
       
       
        )
       
       
        +
       
       
        d
       
       
        i
       
       
        m
       
       
        (
       
       
        V
       
       
        1
       
       
        ∩
       
       
        
         V
        
        
         2
        
       
       
        )
       
       
        =
       
       
        d
       
       
        i
       
       
        m
       
       
        (
       
       
        
         V
        
        
         1
        
       
       
        )
       
       
        +
       
       
        d
       
       
        i
       
       
        m
       
       
        (
       
       
        
         V
        
        
         2
        
       
       
        )
       
      
      
       V_1和V_2是同一线性空间的线性子空间，则dim(V_1+V2)+dim(V1 \cap V_2)=dim(V_1)+dim(V_2)
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: -0.22222em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mord cjk_fallback">和</span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: -0.22222em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">同</span><span class="mord cjk_fallback">一</span><span class="mord cjk_fallback">线</span><span class="mord cjk_fallback">性</span><span class="mord cjk_fallback">空</span><span class="mord cjk_fallback">间</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">线</span><span class="mord cjk_fallback">性</span><span class="mord cjk_fallback">子</span><span class="mord cjk_fallback">空</span><span class="mord cjk_fallback">间</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">则</span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault">m</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: -0.22222em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.22222em;">V</span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault">m</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.22222em;">V</span><span class="mord">1</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: -0.22222em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault">m</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: -0.22222em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault">m</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: -0.22222em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span>，dim代表维度（基中向量的个数）</p> 
<p>线性子空间的直和：线性子空间的直和还是线性子空间的和，只是要求元素的和都是不相同的。</p> 
<p>和为直和的三种等价形式：1）交为零 2）<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        d
       
       
        i
       
       
        m
       
       
        (
       
       
        
         V
        
        
         1
        
       
       
        +
       
       
        
         V
        
        
         2
        
       
       
        )
       
       
        =
       
       
        d
       
       
        i
       
       
        m
       
       
        
         V
        
        
         1
        
       
       
        +
       
       
        d
       
       
        i
       
       
        m
       
       
        
         V
        
        
         2
        
       
      
      
       dim(V_1+V_2)=dimV_1+dimV_2
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault">m</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: -0.22222em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: -0.22222em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.84444em; vertical-align: -0.15em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault">m</span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: -0.22222em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.84444em; vertical-align: -0.15em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault">m</span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: -0.22222em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span> 3) <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        
         V
        
        
         1
        
       
      
      
       V_1
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.83333em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: -0.22222em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>的基和<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        
         V
        
        
         2
        
       
      
      
       V_2
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.83333em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: -0.22222em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>的基组成的集合为<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        
         V
        
        
         1
        
       
       
        +
       
       
        
         V
        
        
         2
        
       
       
        的
       
       
        基
       
      
      
       V_1+V_2的基
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.83333em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: -0.22222em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.83333em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: -0.22222em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">基</span></span></span></span></span></p> 
<p>4.Tx=y，y叫做象，x叫做原象</p> 
<p>线性变换：T(kx+ly)=kT(x)+lT(y)。线性变换的运算：加、数乘、乘法、逆、多项式。</p> 
<p>线性变换的矩阵表示：T(x)=xA，A代表变换T对应的矩阵，x代表基组成的向量组。任意向量可以表示成<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        x
       
       
        ξ
       
      
      
       x\xi
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="mord mathdefault">x</span><span class="mord mathdefault" style="margin-right: 0.04601em;">ξ</span></span></span></span></span>，则有<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        T
       
       
        (
       
       
        x
       
       
        ξ
       
       
        )
       
       
        =
       
       
        x
       
       
        A
       
       
        ξ
       
      
      
       T(x\xi)=xA\xi
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mord mathdefault" style="margin-right: 0.04601em;">ξ</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="mord mathdefault">x</span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right: 0.04601em;">ξ</span></span></span></span></span>。线性变换的运算：加、数乘、乘法、逆、多项式。</p> 
<p>相似：T在同一线性空间下的不同基下的矩阵之间是相似的。</p> 
<p>矩阵的值域R： Ax的集合。矩阵的核N：Ax为零时的x的集合。</p> 
<p>定理：1) dimR+dimN=dimV=n，n为A的列数 2) dimR=rankA，rank代表秩</p> 
<p>5.特征值与特征向量：通过det(<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        λ
       
       
        I
       
       
        −
       
       
        A
       
      
      
       \lambda I-A
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.77777em; vertical-align: -0.08333em;"></span><span class="mord mathdefault">λ</span><span class="mord mathdefault" style="margin-right: 0.07847em;">I</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathdefault">A</span></span></span></span></span>)=0<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        求
       
       
        λ
       
      
      
       求\lambda
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord cjk_fallback">求</span><span class="mord mathdefault">λ</span></span></span></span></span>，<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        将
       
       
        λ
       
       
        代
       
       
        入
       
      
      
       将\lambda代入
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord cjk_fallback">将</span><span class="mord mathdefault">λ</span><span class="mord cjk_fallback">代</span><span class="mord cjk_fallback">入</span></span></span></span></span><span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        λ
       
       
        I
       
       
        −
       
       
        A
       
       
        =
       
       
        0
       
      
      
       \lambda I-A=0
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.77777em; vertical-align: -0.08333em;"></span><span class="mord mathdefault">λ</span><span class="mord mathdefault" style="margin-right: 0.07847em;">I</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">0</span></span></span></span></span>中求基础解系（特征值）</p> 
<p>四个定理：1）tr(AB)=tr(BA) 2）AB与BA的特征值只差零特征值的个数，非零特征值相同 3）n阶方阵可通过相似变换对角化的充要条件是它具有n 个线性无关的特征向量。 4）任意n阶方阵A与上三角矩阵相似</p> 
<p>Euclid空间（欧氏空间）：交换律、分配律、齐次律、非负律（等零才为零）</p> 
<p>度量矩阵（Gram矩阵）：一个由欧氏空间的基中向量的内积组成的正定对称矩阵</p> 
<p>酉空间：除了交换律和Euclid空间不一样外，其他都是一样的。是Euclid空间在复数中的推广。</p> 
<p>柯西－施瓦茨不等式：<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        &lt;
       
       
        a
       
       
        ,
       
       
        b
       
       
        
         &gt;
        
        
         2
        
       
       
        ≤
       
       
        &lt;
       
       
        a
       
       
        ,
       
       
        a
       
       
        &gt;
       
       
        &lt;
       
       
        b
       
       
        ,
       
       
        b
       
       
        &gt;
       
      
      
       &lt;a,b&gt;^2 \leq &lt;a,a&gt;&lt;b,b&gt;
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.5782em; vertical-align: -0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1.00855em; vertical-align: -0.19444em;"></span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel"><span class="mrel">&gt;</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.814108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="base"><span class="strut" style="height: 0.77194em; vertical-align: -0.13597em;"></span><span class="mrel">≤</span></span><span class="base"><span class="strut" style="height: 0.5782em; vertical-align: -0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.73354em; vertical-align: -0.19444em;"></span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height: 0.5782em; vertical-align: -0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.88888em; vertical-align: -0.19444em;"></span><span class="mord mathdefault">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">&gt;</span></span></span></span></span></p> 
<p>施密特正交化（单位化和正交化）：待正交化的向量a-其他已正交化向量b的k倍，k为a和b的内积除以b的模的平方</p> 
<p>6.A的共轭转置<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        
         A
        
        
         H
        
       
      
      
       A^H
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.841331em; vertical-align: 0em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.841331em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right: 0.08125em;">H</span></span></span></span></span></span></span></span></span></span></span></span>：<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        
         A
        
        
         T
        
       
      
      
       A^T
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.841331em; vertical-align: 0em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.841331em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right: 0.13889em;">T</span></span></span></span></span></span></span></span></span></span></span></span>中所有复数的虚部都变号就得到A的共轭转置</p> 
<p>厄米矩阵（Hermite 矩阵）：满足<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        A
       
       
        =
       
       
        
         A
        
        
         H
        
       
      
      
       A=A^H
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.841331em; vertical-align: 0em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.841331em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right: 0.08125em;">H</span></span></span></span></span></span></span></span></span></span></span></span>的A矩阵</p> 
<p>正规矩阵：<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        
         A
        
        
         H
        
       
       
        A
       
       
        =
       
       
        A
       
       
        
         A
        
        
         H
        
       
      
      
       A^HA=AA^H
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.841331em; vertical-align: 0em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.841331em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right: 0.08125em;">H</span></span></span></span></span></span></span></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.841331em; vertical-align: 0em;"></span><span class="mord mathdefault">A</span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.841331em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right: 0.08125em;">H</span></span></span></span></span></span></span></span></span></span></span></span>、<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        
         A
        
        
         T
        
       
       
        A
       
       
        =
       
       
        A
       
       
        
         A
        
        
         T
        
       
      
      
       A^TA=AA^T
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.841331em; vertical-align: 0em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.841331em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right: 0.13889em;">T</span></span></span></span></span></span></span></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.841331em; vertical-align: 0em;"></span><span class="mord mathdefault">A</span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.841331em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right: 0.13889em;">T</span></span></span></span></span></span></span></span></span></span></span></span></p> 
<p>正交矩阵：<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        A
       
       
        
         A
        
        
         T
        
       
       
        =
       
       
        
         A
        
        
         T
        
       
       
        A
       
       
        =
       
       
        I
       
       
        ，
       
       
        
         A
        
        
         T
        
       
       
        =
       
       
        
         A
        
        
         
          −
         
         
          1
         
        
       
      
      
       AA^T=A^TA=I，A^T=A^{-1}
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.841331em; vertical-align: 0em;"></span><span class="mord mathdefault">A</span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.841331em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right: 0.13889em;">T</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.841331em; vertical-align: 0em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.841331em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right: 0.13889em;">T</span></span></span></span></span></span></span></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.841331em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.07847em;">I</span><span class="mord cjk_fallback">，</span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.841331em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right: 0.13889em;">T</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.814108em; vertical-align: 0em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.814108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span></span>。<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        
         P
        
        
         
          −
         
         
          1
         
        
       
       
        A
       
       
        P
       
      
      
       P^{-1}AP
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.814108em; vertical-align: 0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.13889em;">P</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.814108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right: 0.13889em;">P</span></span></span></span></span>为对A的正交相似变换</p> 
<p>酉矩阵：<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        A
       
       
        
         A
        
        
         H
        
       
       
        =
       
       
        
         A
        
        
         H
        
       
       
        A
       
       
        =
       
       
        I
       
       
        ，
       
       
        
         A
        
        
         H
        
       
       
        =
       
       
        
         A
        
        
         
          −
         
         
          1
         
        
       
      
      
       AA^H=A^HA=I，A^H=A^{-1}
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.841331em; vertical-align: 0em;"></span><span class="mord mathdefault">A</span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.841331em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right: 0.08125em;">H</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.841331em; vertical-align: 0em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.841331em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right: 0.08125em;">H</span></span></span></span></span></span></span></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.841331em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.07847em;">I</span><span class="mord cjk_fallback">，</span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.841331em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right: 0.08125em;">H</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.814108em; vertical-align: 0em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.814108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span></span>。<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        
         U
        
        
         H
        
       
       
        A
       
       
        U
       
      
      
       U^{H}AU
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.841331em; vertical-align: 0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.10903em;">U</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.841331em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right: 0.08125em;">H</span></span></span></span></span></span></span></span></span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right: 0.10903em;">U</span></span></span></span></span>为对A的酉相似变换</p> 
<p>schur定理：任何方阵A都可以通过某个酉矩阵U化为上三角矩阵。<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        
         U
        
        
         
          −
         
         
          1
         
        
       
       
        A
       
       
        U
       
       
        =
       
       
        
         U
        
        
         H
        
       
       
        A
       
       
        U
       
      
      
       U^{-1}AU=U^HAU
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.814108em; vertical-align: 0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.10903em;">U</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.814108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right: 0.10903em;">U</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.841331em; vertical-align: 0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.10903em;">U</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.841331em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right: 0.08125em;">H</span></span></span></span></span></span></span></span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right: 0.10903em;">U</span></span></span></span></span>=上三角矩阵（如何化呢？？）</p> 
<p>酉相似于对角阵：n阶方阵 A，酉相似于对角阵（就是通过酉相似变换可以化成对角阵）的充要条件是： A为正规阵（实或复)。</p> 
<p>不变子空间：Tx还在V1中</p> 
<p>线性空间可以分解为不变子空间的直和，线性空间的基等于不变子空间的基合并起来</p> 
<p>T在某基下的矩阵A为对角矩阵的充要条件线性空间可以分解为不变子空间的直和</p> 
<p>7.jordan标准型：化出很多个jordan块。jordan块：主对角线有元素，副对角线只可能有元素1</p> 
<p>1）笨方法求jordan标准型：求矩阵<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        (
       
       
        A
       
       
        −
       
       
        λ
       
      
      
       (A-\lambda
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathdefault">λ</span></span></span></span></span>)中所有非零的i阶的行列式（任意取i行和i列组成的行列式），然后这些行列式的最大公因式记为<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        
         D
        
        
         i
        
       
      
      
       D_i
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.83333em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.311664em;"><span class="" style="top: -2.55em; margin-left: -0.02778em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>，如果<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        
         D
        
        
         i
        
       
      
      
       D_i
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.83333em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.311664em;"><span class="" style="top: -2.55em; margin-left: -0.02778em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>的最高幂次项的系数不为1，要除一个数让其变为一。<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        
         d
        
        
         i
        
       
       
        (
       
       
        λ
       
       
        )
       
       
        =
       
       
        
         
          
           D
          
          
           i
          
         
         
          (
         
         
          λ
         
         
          )
         
        
        
         
          
           D
          
          
           
            i
           
           
            −
           
           
            1
           
          
         
         
          (
         
         
          λ
         
         
          )
         
        
       
      
      
       d_i(\lambda)=\frac{D_i(\lambda)}{D_{i-1}(\lambda)}
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.311664em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">λ</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1.53em; vertical-align: -0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.01em;"><span class="" style="top: -2.655em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right: 0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.328086em;"><span class="" style="top: -2.357em; margin-left: -0.02778em; margin-right: 0.0714286em;"><span class="pstrut" style="height: 2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.202521em;"><span class=""></span></span></span></span></span></span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">λ</span><span class="mclose mtight">)</span></span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.485em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right: 0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.328086em;"><span class="" style="top: -2.357em; margin-left: -0.02778em; margin-right: 0.0714286em;"><span class="pstrut" style="height: 2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.143em;"><span class=""></span></span></span></span></span></span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">λ</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.52em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span>，<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        
         d
        
        
         i
        
       
       
        (
       
       
        λ
       
       
        )
       
      
      
       d_i(\lambda)
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.311664em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">λ</span><span class="mclose">)</span></span></span></span></span>中的每个相乘的式子都是一个初等因子。2）每个初等因子形成一个jordan块</p> 
<p>初等变换求jordan标准型：经过初等变换得到一个关于<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        λ
       
      
      
       \lambda
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathdefault">λ</span></span></span></span></span>的对角阵（初等 变换不改变行列式因子），然后根据“笨方法求jordan标准型”就容易了</p> 
<p>多项式矩阵的初等变换：互换、<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        乘
       
       
        λ
       
      
      
       乘\lambda
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord cjk_fallback">乘</span><span class="mord mathdefault">λ</span></span></span></span></span>的多项式加到行（列）（不能除以<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        λ
       
      
      
       \lambda
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathdefault">λ</span></span></span></span></span>的多项式）、乘以非零\非<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        λ
       
      
      
       \lambda
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathdefault">λ</span></span></span></span></span>的多项式的常数。</p> 
<p><span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        
         D
        
        
         i
        
       
       
        叫
       
       
        行
       
       
        列
       
       
        式
       
       
        因
       
       
        子
       
       
        ，
       
       
        
         d
        
        
         i
        
       
       
        叫
       
       
        不
       
       
        变
       
       
        因
       
       
        子
       
       
        ，
       
       
        
         d
        
        
         i
        
       
      
      
       D_i叫行列式因子，d_i叫不变因子，d_i
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.84444em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.311664em;"><span class="" style="top: -2.55em; margin-left: -0.02778em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mord cjk_fallback">叫</span><span class="mord cjk_fallback">行</span><span class="mord cjk_fallback">列</span><span class="mord cjk_fallback">式</span><span class="mord cjk_fallback">因</span><span class="mord cjk_fallback">子</span><span class="mord cjk_fallback">，</span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.311664em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mord cjk_fallback">叫</span><span class="mord cjk_fallback">不</span><span class="mord cjk_fallback">变</span><span class="mord cjk_fallback">因</span><span class="mord cjk_fallback">子</span><span class="mord cjk_fallback">，</span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.311664em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>中的每个相乘的式子都叫初等因子</p> 
<p>8.<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        
         P
        
        
         
          −
         
         
          1
         
        
       
       
        A
       
       
        P
       
       
        =
       
       
        J
       
       
        ，
       
       
        即
       
       
        A
       
       
        P
       
       
        =
       
       
        P
       
       
        J
       
      
      
       P^{-1}AP=J，即AP=PJ
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.814108em; vertical-align: 0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.13889em;">P</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.814108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right: 0.13889em;">P</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.09618em;">J</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">即</span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right: 0.13889em;">P</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.13889em;">P</span><span class="mord mathdefault" style="margin-right: 0.09618em;">J</span></span></span></span></span></p> 
<p>jordan 标准型的变换矩阵P求法：1）用每一个Jordan块，求出P中对应的几个列组成的矩阵<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        
         P
        
        
         i
        
       
      
      
       P_i
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.83333em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.311664em;"><span class="" style="top: -2.55em; margin-left: -0.13889em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span> 2）求<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        
         P
        
        
         i
        
       
      
      
       P_i
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.83333em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.311664em;"><span class="" style="top: -2.55em; margin-left: -0.13889em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>中对应列的方法是，分别求<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        
         P
        
        
         i
        
       
      
      
       P_i
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.83333em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.311664em;"><span class="" style="top: -2.55em; margin-left: -0.13889em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>每一个列。求<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        
         P
        
        
         i
        
       
      
      
       P_i
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.83333em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.311664em;"><span class="" style="top: -2.55em; margin-left: -0.13889em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>每一个列的方法如下</p> 
<ul><li>通过“<span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         (
        
        
         A
        
        
         −
        
        
         λ
        
        
         
          )
         
         
          j
         
        
       
       
        (A-\lambda)^j
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1.07466em; vertical-align: -0.25em;"></span><span class="mord mathdefault">λ</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.824664em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right: 0.05724em;">j</span></span></span></span></span></span></span></span></span></span></span></span>乘于<span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         
          P
         
         
          i
         
        
       
       
        P_i
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.83333em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.311664em;"><span class="" style="top: -2.55em; margin-left: -0.13889em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>的第j列等于零”求<span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         
          P
         
         
          i
         
        
       
       
        P_i
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.83333em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.311664em;"><span class="" style="top: -2.55em; margin-left: -0.13889em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>的第j列，此时求出的第j列一般是一个通解，从通解中取一个解（j为<span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         
          P
         
         
          i
         
        
       
       
        P_i
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.83333em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.311664em;"><span class="" style="top: -2.55em; margin-left: -0.13889em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>的阶数）</li><li>要求取出来的这个解满足：<span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         (
        
        
         A
        
        
         −
        
        
         λ
        
        
         
          )
         
         
          
           j
          
          
           −
          
          
           1
          
         
        
       
       
        (A-\lambda)^{j-1}
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1.07466em; vertical-align: -0.25em;"></span><span class="mord mathdefault">λ</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.824664em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right: 0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span></span>乘以这个解不等于零，保证求解过程中不出现零向量</li><li>通过“<span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         (
        
        
         A
        
        
         −
        
        
         λ
        
        
         )
        
       
       
        (A-\lambda)
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault">λ</span><span class="mclose">)</span></span></span></span></span>乘于<span class="katex--inline"><span class="katex"><span class="katex-mathml">
     
      
       
        
         
          P
         
         
          i
         
        
       
       
        P_i
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.83333em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.311664em;"><span class="" style="top: -2.55em; margin-left: -0.13889em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>的第j列等于j-1列”求j-1列</li></ul> 
<p>原理：<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        (
       
       
        A
       
       
        −
       
       
        λ
       
       
        
         )
        
        
         j
        
       
      
      
       (A-\lambda)^j
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1.07466em; vertical-align: -0.25em;"></span><span class="mord mathdefault">λ</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.824664em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right: 0.05724em;">j</span></span></span></span></span></span></span></span></span></span></span></span>乘于<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        
         P
        
        
         i
        
       
      
      
       P_i
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.83333em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.311664em;"><span class="" style="top: -2.55em; margin-left: -0.13889em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>的第j列等于零，<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        (
       
       
        A
       
       
        −
       
       
        λ
       
       
        )
       
      
      
       (A-\lambda)
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault">λ</span><span class="mclose">)</span></span></span></span></span>乘于<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        
         P
        
        
         i
        
       
      
      
       P_i
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.83333em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.311664em;"><span class="" style="top: -2.55em; margin-left: -0.13889em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>的第j列等于j-1列。特别的，当Jordan标准型是一个对角阵的时候，每个<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        
         P
        
        
         i
        
       
      
      
       P_i
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.83333em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.311664em;"><span class="" style="top: -2.55em; margin-left: -0.13889em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>都只含有一列，此时就是计算<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        (
       
       
        A
       
       
        −
       
       
        λ
       
       
        )
       
       
        x
       
       
        =
       
       
        0
       
      
      
       (A-\lambda)x=0
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault">λ</span><span class="mclose">)</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">0</span></span></span></span></span>的解。</p> 
<p>注意：同一特征值的不同jordan块求出列向量要线性无关（应该是，我也没看懂）？？？？？</p> 
<p>9.利用Jordan标准形求矩阵函数f(A)：（此方法一般不用，除非A本身就是Jordan标准型）</p> 
<p>1）Jordan标准型：通过求<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        (
       
       
        A
       
       
        −
       
       
        λ
       
      
      
       (A-\lambda
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathdefault">λ</span></span></span></span></span>)的各阶非零行列式的公因式，进而求出Jordan标准型。</p> 
<p>2）求变换矩阵P</p> 
<p>2）分别求每一个jordan块的矩阵函数，即<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        f
       
       
        (
       
       
        
         J
        
        
         i
        
       
       
        )
       
      
      
       f(J_i)
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.09618em;">J</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.311664em;"><span class="" style="top: -2.55em; margin-left: -0.09618em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span>。可证明<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        f
       
       
        (
       
       
        
         J
        
        
         i
        
       
       
        )
       
      
      
       f(J_i)
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.09618em;">J</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.311664em;"><span class="" style="top: -2.55em; margin-left: -0.09618em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span>为类似的上三角形条带矩阵（条带矩阵：在与主对角线平行的斜线上各元素相等）。从对角线为第一个条带开始，第j个条带上的值为<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        f
       
       
        (
       
       
        
         λ
        
        
         i
        
       
       
        )
       
      
      
       f(\lambda_i)
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.311664em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span>的j-1次导，除以j-1的阶乘。3）f(A)=<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        P
       
       
        f
       
       
        (
       
       
        J
       
       
        )
       
       
        
         P
        
        
         
          −
         
         
          1
         
        
       
      
      
       Pf(J)P^{-1}
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.06411em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.13889em;">P</span><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.09618em;">J</span><span class="mclose">)</span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.13889em;">P</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.814108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span></span>。</p> 
<p>10.矩阵序列<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        
         A
        
        
         
          (
         
         
          k
         
         
          )
         
        
       
      
      
       A^{(k)}
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.888em; vertical-align: 0em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.888em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight" style="margin-right: 0.03148em;">k</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span></span></span></span></span>：矩阵中的元素都是由k表示。当k趋于无穷大的时候，矩阵中的元素都趋于某一个数时，则称序列的极限是存在。</p> 
<p>收敛矩阵序列<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        
         A
        
        
         
          (
         
         
          k
         
         
          )
         
        
       
      
      
       A^{(k)}
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.888em; vertical-align: 0em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.888em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight" style="margin-right: 0.03148em;">k</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span></span></span></span></span>的性质：线性组合、相乘、取逆、乘任意矩阵</p> 
<p>收敛矩阵：设A为方阵,且当<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        k
       
       
        →
       
       
        ∞
       
      
      
       k\rightarrow \infty
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.03148em;">k</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord">∞</span></span></span></span></span>时<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        
         A
        
        
         k
        
       
       
        →
       
       
        0
       
      
      
       A^k\rightarrow0
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.849108em; vertical-align: 0em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.849108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right: 0.03148em;">k</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">0</span></span></span></span></span> , 则称A为收敛矩阵</p> 
<p>矩阵级数：序列中所有无穷个矩阵相加，即<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        
         ∑
        
        
         
          k
         
         
          =
         
         
          1
         
        
        
         ∞
        
       
       
        
         A
        
        
         
          (
         
         
          k
         
         
          )
         
        
       
      
      
       \sum_{k=1}^\infty A^{(k)}
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.18771em; vertical-align: -0.29971em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position: relative; top: -5e-06em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.804292em;"><span class="" style="top: -2.40029em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right: 0.03148em;">k</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span class="" style="top: -3.2029em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">∞</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.29971em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.888em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight" style="margin-right: 0.03148em;">k</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span></span></span></span></span>。<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        
         ∑
        
        
         
          k
         
         
          =
         
         
          1
         
        
        
         ∞
        
       
       
        
         A
        
        
         
          (
         
         
          k
         
         
          )
         
        
       
      
      
       \sum_{k=1}^\infty A^{(k)}
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.18771em; vertical-align: -0.29971em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position: relative; top: -5e-06em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.804292em;"><span class="" style="top: -2.40029em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right: 0.03148em;">k</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span class="" style="top: -3.2029em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">∞</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.29971em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.888em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight" style="margin-right: 0.03148em;">k</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span></span></span></span></span>中所有元素收敛，则该级数收敛。先求<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        
         ∑
        
        
         
          k
         
         
          =
         
         
          1
         
        
        
         ∞
        
       
       
        
         A
        
        
         
          (
         
         
          k
         
         
          )
         
        
       
      
      
       \sum_{k=1}^\infty A^{(k)}
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.18771em; vertical-align: -0.29971em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position: relative; top: -5e-06em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.804292em;"><span class="" style="top: -2.40029em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right: 0.03148em;">k</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span class="" style="top: -3.2029em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">∞</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.29971em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.888em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight" style="margin-right: 0.03148em;">k</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span></span></span></span></span>的前N项和S，然后让<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        N
       
       
        →
       
       
        ∞
       
      
      
       N\rightarrow \infty
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.10903em;">N</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord">∞</span></span></span></span></span>。</p> 
<p>绝对收敛矩阵：<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        
         ∑
        
        
         
          k
         
         
          =
         
         
          1
         
        
        
         ∞
        
       
       
        
         A
        
        
         
          (
         
         
          k
         
         
          )
         
        
       
      
      
       \sum_{k=1}^\infty A^{(k)}
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.18771em; vertical-align: -0.29971em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position: relative; top: -5e-06em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.804292em;"><span class="" style="top: -2.40029em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right: 0.03148em;">k</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span class="" style="top: -3.2029em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">∞</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.29971em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.888em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight" style="margin-right: 0.03148em;">k</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span></span></span></span></span>中所有元素绝对收敛，则该级数绝对收敛。（绝对收敛：各项的绝对值所构成的级数收敛）</p> 
<p>绝对收敛矩阵的性质：调换项的顺序、每个项的左边乘P，右边乘Q、相乘（相乘没看懂）</p> 
<p>11.Neumann级数：<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        
         ∑
        
        
         
          k
         
         
          =
         
         
          1
         
        
        
         ∞
        
       
       
        
         A
        
        
         k
        
       
      
      
       \sum_{k=1}^\infty A^k
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.14882em; vertical-align: -0.29971em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position: relative; top: -5e-06em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.804292em;"><span class="" style="top: -2.40029em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right: 0.03148em;">k</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span class="" style="top: -3.2029em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">∞</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.29971em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.849108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right: 0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span></span>称为A的Neumann级数。Neumann级数收敛的充要条件为A为收敛。并且Neumann级数收敛于<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        (
       
       
        1
       
       
        −
       
       
        A
       
       
        
         )
        
        
         
          −
         
         
          1
         
        
       
      
      
       (1-A)^{-1}
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1.06411em; vertical-align: -0.25em;"></span><span class="mord mathdefault">A</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.814108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span></span></p> 
<p>矩阵函数：以矩阵为自变量，如求<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        
         e
        
        
         A
        
       
      
      
       e^A
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.841331em; vertical-align: 0em;"></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.841331em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">A</span></span></span></span></span></span></span></span></span></span></span></span>，首先将<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        
         e
        
        
         x
        
       
      
      
       e^x
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.664392em; vertical-align: 0em;"></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.664392em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span></span></span></span></span></span></span></span></span>进行泰勒展开，然后用A代x得到<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        
         e
        
        
         A
        
       
      
      
       e^A
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.841331em; vertical-align: 0em;"></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.841331em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">A</span></span></span></span></span></span></span></span></span></span></span></span></p> 
<p>三大矩阵函数：指数、正弦、余弦、以及它们的性质和注意点</p> 
<p>Hamilton-Cayley定理：n阶矩阵A是其特征多项式的零点，也就是说根据特征多项式可以得出一个关于A的等式。</p> 
<p>零化多项式：多项式f(z),若f(A)=0,则称其为A的零化多项式。方阵A的特征多项式为A的零化多项式。</p> 
<ol start="12"><li> <p>利用Jordan标准形求矩阵函数f(A)：（此方法一般不用，除非A本身就是Jordan标准型）</p> <p>1）Jordan标准型：通过求<span class="katex--inline"><span class="katex"><span class="katex-mathml">
      
       
        
         
          (
         
         
          A
         
         
          −
         
         
          λ
         
        
        
         (A-\lambda
        
       
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathdefault">λ</span></span></span></span></span>)的各阶非零行列式的公因式，进而求出Jordan标准型。</p> <p>2）求变换矩阵P</p> <p>2）分别求每一个jordan块的矩阵函数，即<span class="katex--inline"><span class="katex"><span class="katex-mathml">
      
       
        
         
          f
         
         
          (
         
         
          
           J
          
          
           i
          
         
         
          )
         
        
        
         f(J_i)
        
       
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.09618em;">J</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.311664em;"><span class="" style="top: -2.55em; margin-left: -0.09618em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span>。可证明<span class="katex--inline"><span class="katex"><span class="katex-mathml">
      
       
        
         
          f
         
         
          (
         
         
          
           J
          
          
           i
          
         
         
          )
         
        
        
         f(J_i)
        
       
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.09618em;">J</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.311664em;"><span class="" style="top: -2.55em; margin-left: -0.09618em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span>为类似的上三角形条带矩阵（条带矩阵：在与主对角线平行的斜线上各元素相等）。从对角线为第一个条带开始，第j个条带上的值为<span class="katex--inline"><span class="katex"><span class="katex-mathml">
      
       
        
         
          f
         
         
          (
         
         
          
           λ
          
          
           i
          
         
         
          )
         
        
        
         f(\lambda_i)
        
       
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.311664em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span>的j-1次导，除以j-1的阶乘。3）f(A)=<span class="katex--inline"><span class="katex"><span class="katex-mathml">
      
       
        
         
          P
         
         
          f
         
         
          (
         
         
          J
         
         
          )
         
         
          
           P
          
          
           
            −
           
           
            1
           
          
         
        
        
         Pf(J)P^{-1}
        
       
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.06411em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.13889em;">P</span><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.09618em;">J</span><span class="mclose">)</span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.13889em;">P</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.814108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span></span>。</p> </li></ol> 
<p>13.利用零化多项式求解矩阵函数<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        f
       
       
        (
       
       
        A
       
       
        )
       
      
      
       f(A)
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">A</span><span class="mclose">)</span></span></span></span></span>：（总结：求最小多项式得待定系数多项式，求代入不同特征值求系数）</p> 
<p>1）求出最小多项式，n阶方阵A的最小多项式等于它的特征矩阵的第n个不变因子<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        
         d
        
        
         n
        
       
       
        (
       
       
        λ
       
       
        )
       
      
      
       d_n(\lambda)
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.151392em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">λ</span><span class="mclose">)</span></span></span></span></span></p> 
<p>最小多项式就是满足<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        f
       
       
        (
       
       
        A
       
       
        )
       
       
        =
       
       
        0
       
      
      
       f(A)=0
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">A</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">0</span></span></span></span></span>的最小次数的多项式</p> 
<p>2）如果<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        
         d
        
        
         n
        
       
       
        (
       
       
        λ
       
       
        )
       
      
      
       d_n(\lambda)
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.151392em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">λ</span><span class="mclose">)</span></span></span></span></span>中<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        λ
       
      
      
       \lambda
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathdefault">λ</span></span></span></span></span>的最高次为m+1，则形式上写出待定系数的m次多项式<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        g
       
       
        (
       
       
        λ
       
       
        )
       
      
      
       g(\lambda)
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault">λ</span><span class="mclose">)</span></span></span></span></span></p> 
<p>3）看最小多项式中<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        
         λ
        
        
         i
        
       
      
      
       \lambda_i
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.84444em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.311664em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>对应的次数为k，最后利用<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        
         g
        
        
         
          (
         
         
          j
         
         
          )
         
        
       
       
        (
       
       
        
         λ
        
        
         i
        
       
       
        )
       
       
        =
       
       
        
         f
        
        
         
          (
         
         
          j
         
         
          )
         
        
       
       
        (
       
       
        
         λ
        
        
         i
        
       
       
        )
       
      
      
       g^{(j)}(\lambda_i)=f^{(j)}(\lambda_i)
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.138em; vertical-align: -0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.888em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight" style="margin-right: 0.05724em;">j</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.311664em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1.138em; vertical-align: -0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.888em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight" style="margin-right: 0.05724em;">j</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.311664em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span>求解<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        g
       
       
        (
       
       
        λ
       
       
        )
       
      
      
       g(\lambda)
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault">λ</span><span class="mclose">)</span></span></span></span></span> 中的待定系数，(j=0~k-1，j代表求导次数，<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        
         λ
        
        
         i
        
       
      
      
       \lambda_i
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.84444em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.311664em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>代表最小多项式中的一个特征值)，从而求解<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        g
       
       
        (
       
       
        λ
       
       
        )
       
      
      
       g(\lambda)
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault">λ</span><span class="mclose">)</span></span></span></span></span>。<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        f
       
       
        (
       
       
        A
       
       
        )
       
       
        =
       
       
        g
       
       
        (
       
       
        A
       
       
        )
       
      
      
       f(A)=g(A)
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">A</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault">A</span><span class="mclose">)</span></span></span></span></span></p> 
<p>14.矩阵的微分和积分及其性质</p> 
<p>矩阵的求导规则：</p> 
<p>一阶线性齐次常系数常微分方程组<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        
         
          d
         
         
          x
         
        
        
         
          d
         
         
          t
         
        
       
       
        =
       
       
        A
       
       
        x
       
       
        (
       
       
        t
       
       
        )
       
      
      
       \frac{dx}{dt}=Ax(t)
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.22511em; vertical-align: -0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.880108em;"><span class="" style="top: -2.655em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight">t</span></span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.394em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.345em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault">t</span><span class="mclose">)</span></span></span></span></span>，则其解为<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        x
       
       
        (
       
       
        t
       
       
        )
       
       
        =
       
       
        
         e
        
        
         
          (
         
         
          t
         
         
          −
         
         
          
           t
          
          
           0
          
         
         
          )
         
         
          A
         
        
       
       
        x
       
       
        (
       
       
        
         t
        
        
         0
        
       
       
        )
       
       
        =
       
       
        
         e
        
        
         
          t
         
         
          A
         
        
       
       
        x
       
       
        (
       
       
        0
       
       
        )
       
      
      
       x(t)=e^{(t-t_0)A}x(t_0)=e^{tA}x(0)
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault">t</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1.138em; vertical-align: -0.25em;"></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.888em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight">t</span><span class="mbin mtight">−</span><span class="mord mtight"><span class="mord mathdefault mtight">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.317314em;"><span class="" style="top: -2.357em; margin-left: 0em; margin-right: 0.0714286em;"><span class="pstrut" style="height: 2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.143em;"><span class=""></span></span></span></span></span></span><span class="mclose mtight">)</span><span class="mord mathdefault mtight">A</span></span></span></span></span></span></span></span></span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1.09133em; vertical-align: -0.25em;"></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.841331em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span><span class="mord mathdefault mtight">A</span></span></span></span></span></span></span></span></span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord">0</span><span class="mclose">)</span></span></span></span></span>。就是求矩阵函数<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        
         e
        
        
         
          (
         
         
          t
         
         
          −
         
         
          
           t
          
          
           0
          
         
         
          )
         
         
          A
         
        
       
      
      
       e^{(t-t_0)A}
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.888em; vertical-align: 0em;"></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.888em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight">t</span><span class="mbin mtight">−</span><span class="mord mtight"><span class="mord mathdefault mtight">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.317314em;"><span class="" style="top: -2.357em; margin-left: 0em; margin-right: 0.0714286em;"><span class="pstrut" style="height: 2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.143em;"><span class=""></span></span></span></span></span></span><span class="mclose mtight">)</span><span class="mord mathdefault mtight">A</span></span></span></span></span></span></span></span></span></span></span></span></span>或 <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        
         e
        
        
         
          t
         
         
          A
         
        
       
      
      
       e^{tA}
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.841331em; vertical-align: 0em;"></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.841331em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span><span class="mord mathdefault mtight">A</span></span></span></span></span></span></span></span></span></span></span></span></span></p> 
<p>一阶线性非齐次常系数常微分方程组<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        
         
          d
         
         
          x
         
        
        
         
          d
         
         
          t
         
        
       
       
        =
       
       
        A
       
       
        x
       
       
        (
       
       
        t
       
       
        )
       
       
        +
       
       
        b
       
       
        (
       
       
        t
       
       
        )
       
      
      
       \frac{dx}{dt}=Ax(t)+b(t)
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.22511em; vertical-align: -0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.880108em;"><span class="" style="top: -2.655em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight">t</span></span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.394em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.345em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault">t</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault">b</span><span class="mopen">(</span><span class="mord mathdefault">t</span><span class="mclose">)</span></span></span></span></span>，则其解为<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        x
       
       
        (
       
       
        t
       
       
        )
       
       
        =
       
       
        
         e
        
        
         
          t
         
         
          A
         
        
       
       
        [
       
       
        x
       
       
        (
       
       
        0
       
       
        )
       
       
        +
       
       
        
         ∫
        
        
         0
        
        
         t
        
       
       
        
         e
        
        
         
          −
         
         
          s
         
         
          A
         
        
       
       
        b
       
       
        (
       
       
        s
       
       
        )
       
       
        d
       
       
        s
       
       
        ]
       
      
      
       x(t)=e^{tA}[x(0)+\int_{0}^{t}e^{-sA}b(s)ds]
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault">t</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1.09133em; vertical-align: -0.25em;"></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.841331em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span><span class="mord mathdefault mtight">A</span></span></span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1.34428em; vertical-align: -0.35582em;"></span><span class="mop"><span class="mop op-symbol small-op" style="margin-right: 0.19445em; position: relative; top: -0.00056em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.988456em;"><span class="" style="top: -2.34418em; margin-left: -0.19445em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span><span class="" style="top: -3.2579em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.35582em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.841331em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">A</span></span></span></span></span></span></span></span></span><span class="mord mathdefault">b</span><span class="mopen">(</span><span class="mord mathdefault">s</span><span class="mclose">)</span><span class="mord mathdefault">d</span><span class="mord mathdefault">s</span><span class="mclose">]</span></span></span></span></span></p> 
<p>高阶线性非齐次常系数常微分方程组化为一阶(应该不考吧)</p> 
<p>15.矩阵的三角分解（让计算机可以实现矩阵分解）：</p> 
<p>Gauss消元法的矩阵形式：</p> 
<p><span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        
         A
        
        
         
          (
         
         
          1
         
         
          )
         
        
       
       
        =
       
       
        
         L
        
        
         1
        
        
         
          −
         
         
          1
         
        
       
       
        A
       
      
      
       A^{(1)}=L_1^{-1}A
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.888em; vertical-align: 0em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.888em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1.12055em; vertical-align: -0.266308em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.854239em;"><span class="" style="top: -2.43369em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span><span class="" style="top: -3.10313em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.266308em;"><span class=""></span></span></span></span></span></span><span class="mord mathdefault">A</span></span></span></span></span>的结果为A的第一列只剩了第一个元素。这里<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        
         L
        
        
         1
        
        
         
          −
         
         
          1
         
        
       
      
      
       L_1^{-1}
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.12055em; vertical-align: -0.266308em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.854239em;"><span class="" style="top: -2.43369em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span><span class="" style="top: -3.10313em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.266308em;"><span class=""></span></span></span></span></span></span></span></span></span></span>的作用是将第一行分别乘以某个数然后加到其他行上，从而消掉A的第一列中除第一个元素外的其他元素。</p> 
<p>A的Frobenius矩阵<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        
         L
        
        
         1
        
       
      
      
       L_1
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.83333em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>的构造方式：主对角线为一，<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        
         c
        
        
         
          i
         
         
          1
         
        
       
       
        =
       
       
        
         
          a
         
         
          
           i
          
          
           1
          
         
        
        
         
          a
         
         
          11
         
        
       
       
        ,
       
       
        (
       
       
        i
       
       
        =
       
       
        2
       
       
        ,
       
       
        3
       
       
        ,
       
       
        …
       
       
        n
       
       
        )
       
      
      
       c_{i1}=\frac{a_{i1}}{a_{11}},(i=2,3,…n)
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.58056em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.311664em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1.1951em; vertical-align: -0.4451em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.711492em;"><span class="" style="top: -2.655em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.317314em;"><span class="" style="top: -2.357em; margin-left: 0em; margin-right: 0.0714286em;"><span class="pstrut" style="height: 2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.143em;"><span class=""></span></span></span></span></span></span></span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.4101em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.328086em;"><span class="" style="top: -2.357em; margin-left: 0em; margin-right: 0.0714286em;"><span class="pstrut" style="height: 2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.143em;"><span class=""></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.4451em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></span>，其余位置都为零。<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        
         L
        
        
         1
        
        
         
          −
         
         
          1
         
        
       
      
      
       L_1^{-1}
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.12055em; vertical-align: -0.266308em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.854239em;"><span class="" style="top: -2.43369em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span><span class="" style="top: -3.10313em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.266308em;"><span class=""></span></span></span></span></span></span></span></span></span></span>为<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        
         L
        
        
         1
        
       
      
      
       L_1
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.83333em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>中的<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        
         c
        
        
         
          i
         
         
          1
         
        
       
      
      
       c_{i1}
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.58056em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.311664em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>变号。<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        
         c
        
        
         
          i
         
         
          1
         
        
       
      
      
       c_{i1}
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.58056em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.311664em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>就是A的第一列的所有元素都除以第一个元素</p> 
<p>按照类似的原理构造<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        
         L
        
        
         2
        
       
      
      
       L_2
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.83333em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>：主对角线为一，<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        
         c
        
        
         
          i
         
         
          2
         
        
       
       
        =
       
       
        
         
          a
         
         
          
           i
          
          
           2
          
         
         
          
           (
          
          
           1
          
          
           )
          
         
        
        
         
          a
         
         
          22
         
         
          
           (
          
          
           1
          
          
           )
          
         
        
       
       
        ,
       
       
        (
       
       
        i
       
       
        =
       
       
        3
       
       
        ,
       
       
        4
       
       
        ,
       
       
        ,
       
       
        …
       
       
        n
       
       
        )
       
      
      
       c_{i2}=\frac{a_{i2}^{(1)}}{a_{22}^{(1)}},(i=3,4,,…n)
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.58056em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.311664em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 2.04638em; vertical-align: -0.76942em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.27696em;"><span class="" style="top: -2.44864em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.05909em;"><span class="" style="top: -2.2242em; margin-left: 0em; margin-right: 0.0714286em;"><span class="pstrut" style="height: 2.53571em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">2</span></span></span></span><span class="" style="top: -3.05909em; margin-right: 0.0714286em;"><span class="pstrut" style="height: 2.53571em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.311514em;"><span class=""></span></span></span></span></span></span></span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.5356em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.05909em;"><span class="" style="top: -2.21343em; margin-left: 0em; margin-right: 0.0714286em;"><span class="pstrut" style="height: 2.53571em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mtight">2</span></span></span></span><span class="" style="top: -3.05909em; margin-right: 0.0714286em;"><span class="pstrut" style="height: 2.53571em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.322286em;"><span class=""></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.76942em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></span>，其余位置都为零。</p> 
<p>最后得到<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        A
       
       
        =
       
       
        
         L
        
        
         1
        
       
       
        
         L
        
        
         2
        
       
       
        
         L
        
        
         3
        
       
       
        …
       
       
        
         L
        
        
         
          n
         
         
          −
         
         
          1
         
        
       
       
        
         A
        
        
         
          (
         
         
          n
         
         
          −
         
         
          1
         
         
          )
         
        
       
       
        =
       
       
        L
       
       
        
         A
        
        
         
          (
         
         
          n
         
         
          −
         
         
          1
         
         
          )
         
        
       
      
      
       A=L_1L_2L_3…L_{n-1}A^{(n-1)}=LA^{(n-1)}
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1.09633em; vertical-align: -0.208331em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.208331em;"><span class=""></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.888em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.888em; vertical-align: 0em;"></span><span class="mord mathdefault">L</span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.888em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span></span></span></span></span>，其中L是一个下三角矩阵（Low），<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        
         A
        
        
         
          (
         
         
          n
         
         
          −
         
         
          1
         
         
          )
         
        
       
      
      
       A^{(n-1)}
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.888em; vertical-align: 0em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.888em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span></span></span></span></span>为上三角矩阵（Upper），这叫做LU分解 。</p> 
<p>A可以分解成<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        L
       
       
        
         A
        
        
         
          (
         
         
          n
         
         
          −
         
         
          1
         
         
          )
         
        
       
      
      
       LA^{(n-1)}
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.888em; vertical-align: 0em;"></span><span class="mord mathdefault">L</span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.888em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span></span></span></span></span>，<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        
         A
        
        
         
          (
         
         
          n
         
         
          −
         
         
          1
         
         
          )
         
        
       
      
      
       A^{(n-1)}
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.888em; vertical-align: 0em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.888em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span></span></span></span></span>进一步可以分解成DU，故A可以分解成LDU。L和U分别为单位下三角矩阵和单位上三角矩阵，D为对角阵<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        d
       
       
        i
       
       
        a
       
       
        g
       
       
        [
       
       
        
         d
        
        
         1
        
       
       
        ,
       
       
        
         d
        
        
         2
        
       
       
        ,
       
       
        …
       
       
        
         d
        
        
         n
        
       
       
        ]
       
      
      
       diag[d_1,d_2,…d_n]
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right: 0.03588em;">g</span><span class="mopen">[</span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.151392em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mclose">]</span></span></span></span></span>,而<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        
         d
        
        
         k
        
       
       
        =
       
      
      
       d_k=
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.84444em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.336108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right: 0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span></span></span></span></span>A的k阶主子式除以A的k-1阶主子式。所以能直接求出的为L和D，然后利用DU=<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        
         A
        
        
         
          (
         
         
          n
         
         
          −
         
         
          1
         
         
          )
         
        
       
      
      
       A^{(n-1)}
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.888em; vertical-align: 0em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.888em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span></span></span></span></span>求出U。 因为D是一个对角阵，所以D上面的每行的元素都只是让U中每行元素翻某个倍数而已，所以利用这个原理就可以很容易求出U。【注】若<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        
         d
        
        
         n
        
       
       
        =
       
       
        0
       
      
      
       d_n=0
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.84444em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.151392em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">0</span></span></span></span></span>时，即D的对角线的最后一个元素为零时，此时U的对角线的最后一个元素要设为1，而不是零。</p> 
<p>n阶非奇异矩阵A有三角分解LU或LDU的充要条件是A的顺序主子式不为零</p> 
<p>其他三角分解(相应的视频内容还没看)</p> 
<p>Doolittle分解：$A=L\hat{U}(\hat{U}=DU) $</p> 
<p>Crout分解：$A=\hat{L}U(\hat{L}=LD) $</p> 
<p>Cholesky分解：当A为实对称正定矩阵时，<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        A
       
       
        =
       
       
        L
       
       
        
         
          D
         
         
          ~
         
        
        
         2
        
       
       
        U
       
       
        =
       
       
        (
       
       
        L
       
       
        
         D
        
        
         ~
        
       
       
        )
       
       
        (
       
       
        L
       
       
        
         D
        
        
         ~
        
       
       
        
         )
        
        
         T
        
       
      
      
       A=L\tilde{D}^2U=(L\tilde{D})(L\tilde{D})^T
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.92019em; vertical-align: 0em;"></span><span class="mord mathdefault">L</span><span class="mord"><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.92019em;"><span class="" style="top: -3em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.02778em;">D</span></span></span><span class="" style="top: -3.60233em;"><span class="pstrut" style="height: 3em;"></span><span class="accent-body" style="left: -0.19444em;">~</span></span></span></span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.814108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right: 0.10903em;">U</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1.17019em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">L</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.92019em;"><span class="" style="top: -3em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.02778em;">D</span></span></span><span class="" style="top: -3.60233em;"><span class="pstrut" style="height: 3em;"></span><span class="accent-body" style="left: -0.19444em;">~</span></span></span></span></span></span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathdefault">L</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.92019em;"><span class="" style="top: -3em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.02778em;">D</span></span></span><span class="" style="top: -3.60233em;"><span class="pstrut" style="height: 3em;"></span><span class="accent-body" style="left: -0.19444em;">~</span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.841331em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right: 0.13889em;">T</span></span></span></span></span></span></span></span></span></span></span></span>，其中<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        
         
          D
         
         
          ~
         
        
        
         2
        
       
       
        =
       
       
        d
       
       
        i
       
       
        a
       
       
        g
       
       
        [
       
       
        
         
          d
         
         
          1
         
        
       
       
        ,
       
       
        
         
          d
         
         
          2
         
        
       
       
        ,
       
       
        …
       
       
        
         
          d
         
         
          n
         
        
       
       
        ]
       
      
      
       \tilde{D}^2=diag[\sqrt{ d_1},\sqrt{ d_2},…\sqrt{ d_n}]
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.92019em; vertical-align: 0em;"></span><span class="mord"><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.92019em;"><span class="" style="top: -3em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.02778em;">D</span></span></span><span class="" style="top: -3.60233em;"><span class="pstrut" style="height: 3em;"></span><span class="accent-body" style="left: -0.19444em;">~</span></span></span></span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.814108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1.10722em; vertical-align: -0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right: 0.03588em;">g</span><span class="mopen">[</span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.85722em;"><span class="svg-align" style="top: -3em;"><span class="pstrut" style="height: 3em;"></span><span class="mord" style="padding-left: 0.833em;"><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span><span class="" style="top: -2.81722em;"><span class="pstrut" style="height: 3em;"></span><span class="hide-tail" style="min-width: 0.853em; height: 1.08em;">
           <svg width="400em" height="1.08em" viewBox="0 0 400000 1080" preserveAspectRatio="xMinYMin slice">
            <path d="M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,
-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,
-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,
35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,
-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467
s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422
s-65,47,-65,47z M834 80H400000v40H845z"></path>
           </svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.18278em;"><span class=""></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.85722em;"><span class="svg-align" style="top: -3em;"><span class="pstrut" style="height: 3em;"></span><span class="mord" style="padding-left: 0.833em;"><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span><span class="" style="top: -2.81722em;"><span class="pstrut" style="height: 3em;"></span><span class="hide-tail" style="min-width: 0.853em; height: 1.08em;">
           <svg width="400em" height="1.08em" viewBox="0 0 400000 1080" preserveAspectRatio="xMinYMin slice">
            <path d="M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,
-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,
-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,
35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,
-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467
s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422
s-65,47,-65,47z M834 80H400000v40H845z"></path>
           </svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.18278em;"><span class=""></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="minner">…</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.85722em;"><span class="svg-align" style="top: -3em;"><span class="pstrut" style="height: 3em;"></span><span class="mord" style="padding-left: 0.833em;"><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.151392em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span><span class="" style="top: -2.81722em;"><span class="pstrut" style="height: 3em;"></span><span class="hide-tail" style="min-width: 0.853em; height: 1.08em;">
           <svg width="400em" height="1.08em" viewBox="0 0 400000 1080" preserveAspectRatio="xMinYMin slice">
            <path d="M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,
-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,
-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,
35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,
-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467
s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422
s-65,47,-65,47z M834 80H400000v40H845z"></path>
           </svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.18278em;"><span class=""></span></span></span></span></span><span class="mclose">]</span></span></span></span></span></p> 
<p>16.矩阵的QR分解：将矩阵A分解为正交（酉）矩阵乘以实（复）上三角阵</p> 
<p>Givens矩阵与Givens变换：</p> 
<p>​ 有实数的形式和复数的形式两种。（复数形式应该不考）</p> 
<p>​ 性质：Givens矩阵的转置为Givens矩阵的逆</p> 
<p>​ QR分解：先从所要分解的矩阵A的第一 列开始，利用好多个Givens矩阵（A左乘Givens矩阵。每个Givens矩阵只能消掉一个零）将第一列消成只有第一个元素不为零，其余元素都为零。进行类似的过程，将矩阵消成上三角矩阵。</p> 
<p>Householder矩阵与Householder变换：</p> 
<p>​ QR分解：先求出第一行对应的单位向量u，再求出变换矩阵H，A左乘H矩阵</p> 
<p>施密特正交化实现RQ分解：1）A中各列a1,a2,a3对应的正交化后的向量b1,b2,b3，然后将A中各列用向量b1,b2,b3的 线性组合进行表示，则可得A=BC，B是b1,b2,b3为列向量的矩阵。最后将B中各列进行单位化B=QD，得到A=QDC=QR。</p> 
<p>施密特正交化：待正交化的向量a<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        −
       
      
      
       -
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.66666em; vertical-align: -0.08333em;"></span><span class="mord">−</span></span></span></span></span>其他已正交化向量b的k倍，k为a和b的内积除以b的模的平方</p> 
<p>17.矩阵的满秩分解：将矩阵A分解成一个列满秩矩阵乘行满秩矩阵</p> 
<p>Hermite标准形（行阶梯标准形）：首先需要呈现行阶梯形，然后要求每一行的第一个非零元素为1且此非零元素对应列的其他元素都为零。利用初等行变换就可以将矩阵化为Hermite标准形</p> 
<p>矩阵的满秩分解：1）利用初等变换得到G，利用G得到P，F=AP，最后得到A=FG</p> 
<p>18.酉对角分解与奇异值分解</p> 
<p>非奇异矩阵（行列式不等于零）的酉对角分解：。。。</p> 
<p>。。。</p> 
<p>19.Penrose广义逆矩阵与{1}-逆的性质</p> 
<p>定理：满足四个Penrose方程的广义逆矩阵是唯一的。</p> 
<p>需要掌握：A{1},A{1,2},A{1,3},A{1,4},A{1,2,3,4}=<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        
         A
        
        
         +
        
       
      
      
       A^+
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.771331em; vertical-align: 0em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.771331em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span></span></span></span></span></span></span></span></span></p> 
<p>考试会要求证明某矩阵是否为某矩阵的{1}-逆矩阵。此时用定义即可。{1}-逆的九条性质要学会证明</p>
                ]]></description></item><item><title>C++堆和栈详解（转）</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522379.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Tue, 26 Jul 2022 11:51:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522379.html</guid><description><![CDATA[
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h1><a id="_0"></a>一、预备知识—程序的内存分配</h1> 
<p>一个由C/C++编译的程序占用的内存分为以下几个部分<br> 1、栈区（stack）— 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。<br> 2、堆区（heap） — 一般由程序员分配释放， 若程序员不释放，程序结束时<strong>可能</strong>由OS回收 。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表，呵呵。 如使用new分配的空间，最后需要delete释放空间。<br> 3、全局区（静态区）（static）—，全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。 - 程序结束后由系统释放。<br> 4、文字常量区 —常量字符串就是放在这里的。程序结束后由系统释放<br> 5、程序代码区—存放函数体的二进制代码。</p> 
<h1><a id="_7"></a>二、例子程序</h1> 
<p>这是一个前辈写的，非常详细</p> 
<pre><code class="prism language-cpp"><span class="token comment">//main.cpp    </span>
  <span class="token keyword">int</span>   a   <span class="token operator">=</span>   <span class="token number">0</span><span class="token punctuation">;</span>   <span class="token comment">// 全局初始化区    </span>
  <span class="token keyword">char</span>   <span class="token operator">*</span>p1<span class="token punctuation">;</span>   <span class="token comment">// 全局未初始化区    </span>
  <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    
  <span class="token punctuation">{<!-- --></span>    
  <span class="token keyword">int</span>   b<span class="token punctuation">;</span>   <span class="token comment">// 栈    </span>
  <span class="token keyword">char</span>   s<span class="token punctuation">[</span><span class="token punctuation">]</span>   <span class="token operator">=</span>   <span class="token string">"abc"</span><span class="token punctuation">;</span>   <span class="token comment">// 栈    </span>
  <span class="token keyword">char</span>   <span class="token operator">*</span>p2<span class="token punctuation">;</span>   <span class="token comment">// 栈    </span>
  <span class="token keyword">char</span>   <span class="token operator">*</span>p3   <span class="token operator">=</span>   <span class="token string">"123456"</span><span class="token punctuation">;</span>  <span class="token comment">//  123456/0在常量区，p3在栈上。    </span>
  <span class="token keyword">static</span>   <span class="token keyword">int</span>   c   <span class="token operator">=</span><span class="token number">0</span>；<span class="token comment">// 全局（静态）初始化区    </span>
  p1   <span class="token operator">=</span>   <span class="token punctuation">(</span><span class="token keyword">char</span>   <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    
  p2   <span class="token operator">=</span>   <span class="token punctuation">(</span><span class="token keyword">char</span>   <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 分配得来得10和20字节的区域就在堆区。    </span>
  <span class="token function">strcpy</span><span class="token punctuation">(</span>p1<span class="token punctuation">,</span>   <span class="token string">"123456"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 123456/0放在常量区，编译器可能会将它与p3所指向的"123456" 优化成一个地方。    </span>
  <span class="token punctuation">}</span>    
</code></pre> 
<h1><a id="_25"></a>二、堆和栈的理论知识</h1> 
<h2><a id="21_26"></a>2.1申请方式</h2> 
<p>stack:<br> 由系统自动分配。 例如，声明在函数中一个局部变量 int b; 系统自动在栈中为b开辟空 间<br> heap:<br> 需要程序员自己申请，并指明大小，在c中malloc函数<br> 如p1 = (char *)malloc(10);<br> 在C++中用new运算符<br> 如p2 = new char[10];<br> 但是注意p1、p2本身是在栈中的。</p> 
<h2><a id="22____36"></a>2.2 申请后系统的响应</h2> 
<p>栈：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢 出。<br> 堆：首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时， 会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表 中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的 首地址处记录本次分配的大小，这样，代码中的delete语句才能正确的释放本内存空间。 另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。</p> 
<h2><a id="23__39"></a>2.3 申请大小的限制</h2> 
<p>栈：在Windows下,栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意 思是栈顶的地址和栈的最大容量是系统预先规定好的，在WINDOWS下，栈的大小是2M（也有的说是1M，总之是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将 提示overflow。因此，能从栈获得的空间较小。<br> 堆：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。</p> 
<h2><a id="24__42"></a>2.4 申请效率的比较：</h2> 
<p>栈由系统自动分配，速度较快。但程序员是无法控制的。<br> 堆是由new分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便. 另外，在WINDOWS下，最好的方式是用VirtualAlloc分配内存，他不是在堆，也不是在栈是 直接在进程的地址空间中保留一块内存，虽然用起来最不方便。但是速度快，也最灵活。</p> 
<h2><a id="25__45"></a>2.5 堆和栈中的存储内容</h2> 
<p>栈： 在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。<br> 堆：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容由程序员安排。</p> 
<h2><a id="26__49"></a>2.6 存取效率的比较</h2> 
<pre><code class="prism language-cpp"><span class="token keyword">char</span>   s1<span class="token punctuation">[</span><span class="token punctuation">]</span>   <span class="token operator">=</span>   <span class="token string">"aaaaaaaaaaaaaaa"</span><span class="token punctuation">;</span>    
<span class="token keyword">char</span>   <span class="token operator">*</span>s2   <span class="token operator">=</span>   <span class="token string">"bbbbbbbbbbbbbbbbb"</span><span class="token punctuation">;</span>    
</code></pre> 
<p>aaaaaaaaaaa是在运行时刻赋值的；<br> 而bbbbbbbbbbb是在编译时就确定的；<br> 但是，在以后的存取中，在栈上的数组比指针所指向的字符串(例如堆)快。<br> 比如：</p> 
<pre><code class="prism language-cpp"> <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span>    </span>
  <span class="token keyword">void</span>   <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    
  <span class="token punctuation">{<!-- --></span>    
  <span class="token keyword">char</span>   a   <span class="token operator">=</span>   <span class="token number">1</span><span class="token punctuation">;</span>    
  <span class="token keyword">char</span>   c<span class="token punctuation">[</span><span class="token punctuation">]</span>   <span class="token operator">=</span>   <span class="token string">"1234567890"</span><span class="token punctuation">;</span>    
  <span class="token keyword">char</span>   <span class="token operator">*</span>p   <span class="token operator">=</span><span class="token string">"1234567890"</span><span class="token punctuation">;</span>    
  a   <span class="token operator">=</span>   c<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    
  a   <span class="token operator">=</span>   p<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    
  <span class="token keyword">return</span><span class="token punctuation">;</span>    
  <span class="token punctuation">}</span>    
</code></pre> 
<p>对应的汇编代码<br> 10: a = c[1];<br> 00401067 8A 4D F1 mov cl,byte ptr [ebp-0Fh]<br> 0040106A 88 4D FC mov byte ptr [ebp-4],cl<br> 11: a = p[1];<br> 0040106D 8B 55 EC mov edx,dword ptr [ebp-14h]<br> 00401070 8A 42 01 mov al,byte ptr [edx+1]<br> 00401073 88 45 FC mov byte ptr [ebp-4],al<br> 第一种在读取时直接就把字符串中的元素读到寄存器cl中，而第二种则要先把指针值读到 edx中，再根据edx读取字符，显然慢了。</p> 
<h1><a id="_27__81"></a># 2.7 小结：</h1> 
<table><thead><tr><th>栈</th><th>堆</th></tr></thead><tbody><tr><td>由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。从系统提供的内存区域分配。栈区比较小（2M左右）。在函数调用时，第一个进栈的是主函数中后的下一条指令。</td><td>由程序员分配释放，如使用new分配的空间，最后需要delete释放空间。从记录空闲内存地址的链表中申请。堆的大小受限于计算机系统中有效的虚拟内存。 堆的头部用一个字节存放堆的大小。</td></tr><tr><td>分配速度快。运行时刻赋值，但读取时直接就把数据读到寄存器中。</td><td>分配速度较栈慢。编译时就确定，但读取时先把指针值读到 edx中，再根据edx读取字符。</td></tr></tbody></table>
                ]]></description></item><item><title>word标题编号消失解决</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522381.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Tue, 26 Jul 2022 11:51:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522381.html</guid><description><![CDATA[
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><a href="https://www.cnblogs.com/yczcc/p/9180186.html">链接</a></p>
                ]]></description></item><item><title>矩阵乘法的MPI并行计算</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522382.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Tue, 26 Jul 2022 11:51:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522382.html</guid><description><![CDATA[
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><a href="https://blog.csdn.net/s_sunnyy/article/details/59506412">链接</a></p>
                ]]></description></item><item><title>OpenCL快速入门教程</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522383.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Tue, 26 Jul 2022 11:51:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522383.html</guid><description><![CDATA[
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>参考<a href="https://www.cnblogs.com/leiben/archive/2012/06/05/2536508.html">链接</a></p> 
<h2><a id="OpenCL_1"></a>一、OpenCL中的一些函数</h2> 
<p>OpenCL的Kernel相当于CUDA的device<br> OpenCL的Work-item相当于CUDA的thread<br> OpenCL的Work-group相当于CUDA的block<br> OpenCL的ND-Range相当于CUDA的grid</p> 
<p>get_global_id(dim) ：CUDA中需要计算线程的id，而在opencl中线程id直接通过这个函数直接获取<br> get_global_size(dim)：线程总数量</p> 
<p>get_group_id(dim)：dim可以为0，1，2，分别代表CUDA中的blockIdx.x、blockIdx.y、blockIdx.z<br> get_num_groups(dim)：<br> get_local_id(dim)：dim可以为0，1，2，分别代表CUDA中的threadIdx.x、threadIdx.y、threadIdx.z<br> get_local_size(dim)</p> 
<h2><a id="_15"></a>二、内存模型：</h2> 
<p><img src="https://img-blog.csdnimg.cn/f5a2b0f0294e4634aad616efa9a6b9d8.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAcXFfNDI3NzU5Mzg=,size_9,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br> 箭头表示可以访问。所有的workItem都可以读Global Memory的数据。我们在利用opencl写并行函数的时候，可以看到函数的形参是类似这样定义的：__global int *C，这就代表C所指向的地方是Global Memory。</p> 
<h2><a id="opencl_18"></a>三、opencl编程实践</h2> 
<p>opencl需要包含头文件：#include&lt;CL/cl.h&gt;<br> 这里新建一个Vadd.cl文件，用于保存__kernel函数的相关代码。然后在testOpenCL.cpp中建立环境和调用Vadd.cl文件中的__kernel函数。<br> 实现矩阵乘法（参考：<a href="https://blog.csdn.net/c602273091/article/details/45418129">矩阵乘法</a>）：<br> Vadd.cl中代码如下：</p> 
<pre><code class="prism language-cpp">__kernel <span class="token keyword">void</span> <span class="token function">matrix_mult</span><span class="token punctuation">(</span>
	<span class="token keyword">const</span> <span class="token keyword">int</span> Ndim<span class="token punctuation">,</span>
	<span class="token keyword">const</span> <span class="token keyword">int</span> Mdim<span class="token punctuation">,</span>
	<span class="token keyword">const</span> <span class="token keyword">int</span> Pdim<span class="token punctuation">,</span>
	__global <span class="token keyword">const</span> <span class="token keyword">float</span><span class="token operator">*</span> A<span class="token punctuation">,</span>
	__global <span class="token keyword">const</span> <span class="token keyword">float</span><span class="token operator">*</span> B<span class="token punctuation">,</span>
	__global <span class="token keyword">float</span><span class="token operator">*</span> C<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">get_global_id</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token function">get_global_id</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">int</span> k<span class="token punctuation">;</span>
	<span class="token keyword">float</span> tmp<span class="token punctuation">;</span>

	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> Ndim<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;</span> Mdim<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		tmp <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span>k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> Pdim<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span>
			tmp <span class="token operator">+=</span> A<span class="token punctuation">[</span>i<span class="token operator">*</span>Pdim <span class="token operator">+</span> k<span class="token punctuation">]</span> <span class="token operator">*</span> B<span class="token punctuation">[</span>k<span class="token operator">*</span>Mdim <span class="token operator">+</span> j<span class="token punctuation">]</span><span class="token punctuation">;</span>
		C<span class="token punctuation">[</span>i<span class="token operator">*</span>Mdim <span class="token operator">+</span> j<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>testOpenCL.cpp中代码如下：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;CL/cl.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;time.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fstream&gt;</span></span>

<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">NWITEMS</span> <span class="token expression"><span class="token number">6</span></span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">pragma</span> <span class="token expression"><span class="token function">comment</span> <span class="token punctuation">(</span>lib<span class="token punctuation">,</span></span><span class="token string">"OpenCL.lib"</span><span class="token expression"><span class="token punctuation">)</span></span></span>

<span class="token comment">//把文本文件读入一个 string 中</span>
<span class="token keyword">int</span> <span class="token function">convertToString</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>filename<span class="token punctuation">,</span> std<span class="token operator">::</span>string<span class="token operator">&amp;</span> s<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	size_t size<span class="token punctuation">;</span>
	<span class="token keyword">char</span><span class="token operator">*</span> str<span class="token punctuation">;</span>
	std<span class="token operator">::</span>fstream <span class="token function">f</span><span class="token punctuation">(</span>filename<span class="token punctuation">,</span> <span class="token punctuation">(</span>std<span class="token operator">::</span>fstream<span class="token operator">::</span>in <span class="token operator">|</span> std<span class="token operator">::</span>fstream<span class="token operator">::</span>binary<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>f<span class="token punctuation">.</span><span class="token function">is_open</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		size_t fileSize<span class="token punctuation">;</span>
		f<span class="token punctuation">.</span><span class="token function">seekg</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> std<span class="token operator">::</span>fstream<span class="token operator">::</span>end<span class="token punctuation">)</span><span class="token punctuation">;</span>
		size <span class="token operator">=</span> fileSize <span class="token operator">=</span> <span class="token punctuation">(</span>size_t<span class="token punctuation">)</span>f<span class="token punctuation">.</span><span class="token function">tellg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		f<span class="token punctuation">.</span><span class="token function">seekg</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> std<span class="token operator">::</span>fstream<span class="token operator">::</span>beg<span class="token punctuation">)</span><span class="token punctuation">;</span>
		str <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">char</span><span class="token punctuation">[</span>size <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>str<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			f<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		f<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> fileSize<span class="token punctuation">)</span><span class="token punctuation">;</span>
		f<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		str<span class="token punctuation">[</span>size<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'\0'</span><span class="token punctuation">;</span>
		s <span class="token operator">=</span> str<span class="token punctuation">;</span>
		<span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> str<span class="token punctuation">;</span>
		<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Error: Failed to open file %s\n"</span><span class="token punctuation">,</span> filename<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	cl_uint status<span class="token punctuation">;</span>
	cl_platform_id platform<span class="token punctuation">;</span>

	<span class="token comment">//创建平台对象</span>
	status <span class="token operator">=</span> <span class="token function">clGetPlatformIDs</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>platform<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	cl_device_id device<span class="token punctuation">;</span>
	<span class="token comment">//创建 GPU 设备</span>
	<span class="token function">clGetDeviceIDs</span><span class="token punctuation">(</span>platform<span class="token punctuation">,</span> CL_DEVICE_TYPE_GPU<span class="token punctuation">,</span>
		<span class="token number">1</span><span class="token punctuation">,</span>
		<span class="token operator">&amp;</span>device<span class="token punctuation">,</span>
		<span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//创建context</span>
	cl_context context <span class="token operator">=</span> <span class="token function">clCreateContext</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">,</span>
		<span class="token number">1</span><span class="token punctuation">,</span>
		<span class="token operator">&amp;</span>device<span class="token punctuation">,</span>
		<span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//创建命令队列</span>
	cl_command_queue commandQueue <span class="token operator">=</span> <span class="token function">clCreateCommandQueue</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span>
		device<span class="token punctuation">,</span>
		CL_QUEUE_PROFILING_ENABLE<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">if</span> <span class="token punctuation">(</span>commandQueue <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
		<span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"Failed to create commandQueue for device 0."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">//建立要传入从机的数据</span>
	<span class="token comment">/********  创建内核和内存对象 ********/</span>

	<span class="token keyword">const</span> <span class="token keyword">int</span> Ndim <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>
	<span class="token keyword">const</span> <span class="token keyword">int</span> Mdim <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
	<span class="token keyword">const</span> <span class="token keyword">int</span> Pdim <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> szA <span class="token operator">=</span> Ndim <span class="token operator">*</span> Pdim<span class="token punctuation">;</span>
	<span class="token keyword">int</span> szB <span class="token operator">=</span> Pdim <span class="token operator">*</span> Mdim<span class="token punctuation">;</span>
	<span class="token keyword">int</span> szC <span class="token operator">=</span> Ndim <span class="token operator">*</span> Mdim<span class="token punctuation">;</span>

	<span class="token keyword">float</span> <span class="token operator">*</span>A<span class="token punctuation">;</span>
	<span class="token keyword">float</span> <span class="token operator">*</span>B<span class="token punctuation">;</span>
	<span class="token keyword">float</span> <span class="token operator">*</span>C<span class="token punctuation">;</span>

	A <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">float</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span>szA <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	B <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">float</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span>szB <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	C <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">float</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span>szC <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> szA<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
		A<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>i <span class="token operator">+</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> szB<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
		B<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>i <span class="token operator">+</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">//创建三个 OpenCL 内存对象，并把buf1 的内容通过隐式拷贝的方式</span>
	<span class="token comment">//拷贝到clbuf1, buf2 的内容通过显示拷贝的方式拷贝到clbuf2</span>
	cl_mem memObjects<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
	memObjects<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">clCreateBuffer</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> CL_MEM_READ_ONLY <span class="token operator">|</span> CL_MEM_COPY_HOST_PTR<span class="token punctuation">,</span>
		<span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span><span class="token operator">*</span> szA<span class="token punctuation">,</span> A<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	memObjects<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">clCreateBuffer</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> CL_MEM_READ_ONLY <span class="token operator">|</span> CL_MEM_COPY_HOST_PTR<span class="token punctuation">,</span>
		<span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span><span class="token operator">*</span> szB<span class="token punctuation">,</span> B<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	memObjects<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">clCreateBuffer</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> CL_MEM_READ_WRITE <span class="token operator">|</span> CL_MEM_COPY_HOST_PTR<span class="token punctuation">,</span>
		<span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span><span class="token operator">*</span> szC<span class="token punctuation">,</span> C<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>memObjects<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token constant">NULL</span> <span class="token operator">||</span> memObjects<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token constant">NULL</span> <span class="token operator">||</span> memObjects<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
		<span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"Error in clCreateBuffer.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> filename <span class="token operator">=</span> <span class="token string">"Vadd.cl"</span><span class="token punctuation">;</span>
	std<span class="token operator">::</span>string sourceStr<span class="token punctuation">;</span>
	status <span class="token operator">=</span> <span class="token function">convertToString</span><span class="token punctuation">(</span>filename<span class="token punctuation">,</span> sourceStr<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>status<span class="token punctuation">)</span>
		cout <span class="token operator">&lt;&lt;</span> status <span class="token operator">&lt;&lt;</span> <span class="token string">"  !!!!!!!!"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> source <span class="token operator">=</span> sourceStr<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	size_t sourceSize<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> <span class="token function">strlen</span><span class="token punctuation">(</span>source<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
	<span class="token comment">//创建程序对象</span>
	cl_program program <span class="token operator">=</span> <span class="token function">clCreateProgramWithSource</span><span class="token punctuation">(</span>
		context<span class="token punctuation">,</span>
		<span class="token number">1</span><span class="token punctuation">,</span>
		<span class="token operator">&amp;</span>source<span class="token punctuation">,</span>
		sourceSize<span class="token punctuation">,</span>
		<span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//编译程序对象</span>
	status <span class="token operator">=</span> <span class="token function">clBuildProgram</span><span class="token punctuation">(</span>program<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>device<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>status<span class="token punctuation">)</span>
		cout <span class="token operator">&lt;&lt;</span> status <span class="token operator">&lt;&lt;</span> <span class="token string">"  !!!!!!!!"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>status <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"clBuild failed:%d\n"</span><span class="token punctuation">,</span> status<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">char</span> tbuf<span class="token punctuation">[</span><span class="token number">0x10000</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token function">clGetProgramBuildInfo</span><span class="token punctuation">(</span>program<span class="token punctuation">,</span> device<span class="token punctuation">,</span> CL_PROGRAM_BUILD_LOG<span class="token punctuation">,</span> <span class="token number">0x10000</span><span class="token punctuation">,</span> tbuf<span class="token punctuation">,</span>
			<span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n%s\n"</span><span class="token punctuation">,</span> tbuf<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">//return −1;</span>
	<span class="token punctuation">}</span>

	<span class="token comment">//创建 Kernel 对象</span>
	cl_kernel kernel <span class="token operator">=</span> <span class="token function">clCreateKernel</span><span class="token punctuation">(</span>program<span class="token punctuation">,</span> <span class="token string">"matrix_mult"</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">//设置 Kernel 参数</span>
	cl_int clnum <span class="token operator">=</span> NWITEMS<span class="token punctuation">;</span>
	status <span class="token operator">=</span> <span class="token function">clSetKernelArg</span><span class="token punctuation">(</span>kernel<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>Ndim<span class="token punctuation">)</span><span class="token punctuation">;</span>
	status <span class="token operator">=</span> <span class="token function">clSetKernelArg</span><span class="token punctuation">(</span>kernel<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>Mdim<span class="token punctuation">)</span><span class="token punctuation">;</span>
	status <span class="token operator">=</span> <span class="token function">clSetKernelArg</span><span class="token punctuation">(</span>kernel<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>Pdim<span class="token punctuation">)</span><span class="token punctuation">;</span>
	status <span class="token operator">=</span> <span class="token function">clSetKernelArg</span><span class="token punctuation">(</span>kernel<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>cl_mem<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>memObjects<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	status <span class="token operator">=</span> <span class="token function">clSetKernelArg</span><span class="token punctuation">(</span>kernel<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>cl_mem<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>memObjects<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	status <span class="token operator">=</span> <span class="token function">clSetKernelArg</span><span class="token punctuation">(</span>kernel<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>cl_mem<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>memObjects<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>status<span class="token punctuation">)</span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"参数设置错误"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

	<span class="token comment">//执行 kernel</span>
	size_t global<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
	cl_event prof_event<span class="token punctuation">;</span>
	cl_ulong ev_start_time <span class="token operator">=</span> <span class="token punctuation">(</span>cl_ulong<span class="token punctuation">)</span><span class="token number">0</span><span class="token punctuation">;</span>
	cl_ulong ev_end_time <span class="token operator">=</span> <span class="token punctuation">(</span>cl_ulong<span class="token punctuation">)</span><span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">double</span> rum_time<span class="token punctuation">;</span>
	global<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>size_t<span class="token punctuation">)</span>Ndim<span class="token punctuation">;</span>
	global<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>size_t<span class="token punctuation">)</span>Mdim<span class="token punctuation">;</span>
	status <span class="token operator">=</span> <span class="token function">clEnqueueNDRangeKernel</span><span class="token punctuation">(</span>commandQueue<span class="token punctuation">,</span> kernel<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span>
		global<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>prof_event<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>status<span class="token punctuation">)</span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"执行内核时错误"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token function">clFinish</span><span class="token punctuation">(</span>commandQueue<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">//读取时间</span>
	status <span class="token operator">=</span> <span class="token function">clGetEventProfilingInfo</span><span class="token punctuation">(</span>prof_event<span class="token punctuation">,</span> CL_PROFILING_COMMAND_QUEUED<span class="token punctuation">,</span>
		<span class="token keyword">sizeof</span><span class="token punctuation">(</span>cl_ulong<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>ev_start_time<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	status <span class="token operator">=</span> <span class="token function">clGetEventProfilingInfo</span><span class="token punctuation">(</span>prof_event<span class="token punctuation">,</span> CL_PROFILING_COMMAND_END<span class="token punctuation">,</span>
		<span class="token keyword">sizeof</span><span class="token punctuation">(</span>cl_ulong<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>ev_end_time<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>status<span class="token punctuation">)</span>
		<span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"读取时间的时候发生错误\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	rum_time <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span><span class="token punctuation">(</span>ev_end_time <span class="token operator">-</span> ev_start_time<span class="token punctuation">)</span><span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"执行时间为:"</span> <span class="token operator">&lt;&lt;</span> rum_time <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

	<span class="token comment">//数据拷回 host 内存</span>
	status <span class="token operator">=</span> <span class="token function">clEnqueueReadBuffer</span><span class="token punctuation">(</span>commandQueue<span class="token punctuation">,</span> memObjects<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> CL_TRUE<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span>
		<span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span><span class="token operator">*</span> szC<span class="token punctuation">,</span> C<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>status<span class="token punctuation">)</span>
		<span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"读回数据的时候发生错误\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">//结果显示</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\nArray A:\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> Ndim<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> Pdim<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>
			<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%.3f\t"</span><span class="token punctuation">,</span> A<span class="token punctuation">[</span>i<span class="token operator">*</span>Pdim <span class="token operator">+</span> j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\nArray B:\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> Pdim<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> Mdim<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>
			<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%.3f\t"</span><span class="token punctuation">,</span> B<span class="token punctuation">[</span>i<span class="token operator">*</span>Mdim <span class="token operator">+</span> j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\nArray C:\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> Ndim<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> Mdim<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>
			<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%.3f\t"</span><span class="token punctuation">,</span> C<span class="token punctuation">[</span>i<span class="token operator">*</span>Mdim <span class="token operator">+</span> j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

	<span class="token keyword">if</span> <span class="token punctuation">(</span>A<span class="token punctuation">)</span>
		<span class="token function">free</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>B<span class="token punctuation">)</span>
		<span class="token function">free</span><span class="token punctuation">(</span>B<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>C<span class="token punctuation">)</span>
		<span class="token function">free</span><span class="token punctuation">(</span>C<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">//删除 OpenCL 资源对象</span>
	<span class="token function">clReleaseMemObject</span><span class="token punctuation">(</span>memObjects<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">clReleaseMemObject</span><span class="token punctuation">(</span>memObjects<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">clReleaseMemObject</span><span class="token punctuation">(</span>memObjects<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">clReleaseProgram</span><span class="token punctuation">(</span>program<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">clReleaseCommandQueue</span><span class="token punctuation">(</span>commandQueue<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">clReleaseContext</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">system</span><span class="token punctuation">(</span><span class="token string">"pause"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
                ]]></description></item><item><title>CUDA编程入门</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522384.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Tue, 26 Jul 2022 11:51:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522384.html</guid><description><![CDATA[
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>参考：<a href="https://zhuanlan.zhihu.com/p/34587739">CUDA编程原理1</a><br> <a href="https://www.cnblogs.com/skyfsm/p/9673960.html">CUDA编程原理2</a><br> <a href="https://www.cnblogs.com/wildkid1024/p/14878125.html#:~:text=%5BCUDA%5DCUDA%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E5%9B%9B%E2%80%94%E2%80%94%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95,%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95%E6%98%AF%E6%9C%80%E5%B8%B8%E8%A7%81%E7%9A%84%E6%93%8D%E4%BD%9C%EF%BC%8C%E7%8E%B0%E4%BB%A3%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E5%9F%BA%E7%A1%80%E4%BE%BF%E6%98%AF%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95%E3%80%82%20%E4%B8%80%E4%B8%AAN*M%E7%9A%84%E7%9F%A9%E9%98%B5%EF%BC%8C%E4%B9%98%E4%BB%A5%E4%B8%80%E4%B8%AAM*P%E7%9A%84%E7%9F%A9%E9%98%B5%EF%BC%8C%E5%BE%97%E5%88%B0N*P%E7%9A%84%E7%9F%A9%E9%98%B5%EF%BC%8C%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95%E5%8D%B3%E4%B8%BA%E5%B0%86%E6%AF%8F%E4%B8%80%E8%A1%8C%E4%B8%8E%E8%A2%AB%E4%B9%98%E7%9F%A9%E9%98%B5%E5%AF%B9%E5%BA%94%E5%88%97%E8%BF%9B%E8%A1%8C%E4%B9%98%E5%8A%A0%EF%BC%8C%E6%9C%80%E5%90%8E%E5%B0%86%E6%89%80%E6%9C%89%E7%BB%93%E6%9E%9C%E8%BF%9B%E8%A1%8C%E6%B1%87%E6%80%BB%E3%80%82">矩阵乘法</a></p> 
<p>我们用host指代CPU及其内存，而用device指代GPU及其内存。</p> 
<ul><li><strong>global</strong>：在device上执行，从host中调用（一些特定的GPU也可以从device上调用），返回类型必须是void，不支持可变参数参数，不能成为类成员函数。注意用__global__定义的kernel是异步的，这意味着host不会等待kernel执行完就执行下一步。</li><li><strong>device</strong>：在device上执行，单仅可以从device中调用，不可以和__global__同时用。</li><li><strong>host</strong>：在host上执行，仅可以从host上调用，一般省略不写，不可以和__global__同时用，但可和__device__，此时函数会在device和host都编译。</li></ul> 
<p>1.CUDA的整体结构<br> kernel是在device上线程中并行执行的函数，核函数用__global__符号声明，在调用时需要用&lt;&lt;&lt;grid, block&gt;&gt;&gt;来指定kernel要运行的线程，在CUDA中，每一个线程都要执行核函数。kernel在device上执行时实际上是启动很多线程，一个kernel所启动的所有线程称为一个网格（grid），同一个网格上的线程共享相同的全局内存空间。每一个grid由多个block组成，每一个block由多个线程组成。<br> <img src="https://img-blog.csdnimg.cn/191a12e86d854fbea3a6cce059786631.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAcXFfNDI3NzU5Mzg=,size_10,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br> 从上图可以看出每一个block可以组织成三维的，但其实block可以1维、2维或3维组织。Grid可以1维、2维组织。<br> 2.CUDA内存模型<br> 如下图所示。可以看到，每个线程有自己的私有本地内存（Local Memory），而每个线程块有包含共享内存（Shared Memory）,可以被线程块中所有线程共享，其生命周期与线程块一致。此外，所有的线程都可以访问全局内存（Global Memory）。还可以访问一些只读内存块：常量内存（Constant Memory）和纹理内存（Texture Memory）。<br> <img src="https://img-blog.csdnimg.cn/c17932f84c5343c7bcacd865720571f9.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAcXFfNDI3NzU5Mzg=,size_18,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br> 3. Streaming Multiprocessor，SM<br> SM是GPU的处理器，SM可以并发地执行数百个线程。</p> 
<ul><li>当一个kernel被执行时，它的gird中的线程块被分配到SM上，一个线程块只能在一个SM上被调度。</li><li>SM一般可以调度多个线程块，一个kernel的各个线程块可能被分配多个SM。</li><li>当线程块被划分到某个SM上时，它将被进一步划分为多个线程束（一个线程束包含32个线程），因为这才是SM的基本执行单元，但是一个SM同时并发的线程束数是有限的</li><li>由于SM的基本执行单元是包含32个线程的线程束，所以block大小一般要设置为32的倍数。</li></ul> 
<p>SM中包含多个SP，一个GPU可以有多个SM（比如16个），最终一个GPU可能包含有上千个SP。<br> 每个线程由每个线程处理器（SP）执行<br> 线程块由多核处理器（SM）执行<br> 一个kernel其实由一个grid来执行，一个kernel一次只能在一个GPU上执行<br> <img src="https://img-blog.csdnimg.cn/90530edb1a8b4899a2be5d21956b2a9c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAcXFfNDI3NzU5Mzg=,size_8,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br> block是软件概念，一个block只会由一个sm调度，程序员在开发时，通过设定block的属性，告诉GPU硬件，我有多少个线程，线程怎么组织。而具体怎么调度由sm的warps scheduler负责，block一旦被分配好SM，该block就会一直驻留在该SM中，直到执行结束。一个SM可以同时拥有多个blocks，但需要序列执行</p> 
<p>4.cuda编程的相关函数</p> 
<ul><li>在device上申请一定字节大小的显存:</li></ul> 
<pre><code class="prism language-cpp"> <span class="token function">cudaMalloc</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token operator">*</span> devPtr<span class="token punctuation">,</span> size_t size<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 在device上申请一定字节大小的显存</span>
 <span class="token comment">// devPtr是指向所分配内存的指针 </span>
 <span class="token comment">// 与cudaFree函数配合使用</span>
</code></pre> 
<ul><li>内存和显存之间的数据拷贝：</li></ul> 
<pre><code class="prism language-cpp"><span class="token function">cudaMemcpy</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> dst<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span><span class="token operator">*</span> src<span class="token punctuation">,</span> size_t count<span class="token punctuation">,</span> cudaMemcpyKind kind<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>src指向数据源，而dst是目标区域，count是复制的字节数，其中kind控制复制的方向：cudaMemcpyHostToHost, cudaMemcpyHostToDevice, cudaMemcpyDeviceToHost及cudaMemcpyDeviceToDevice，如cudaMemcpyHostToDevice将host上数据拷贝到device上。</p> 
<ul><li>获取线程的id<br> 我们可以用dim3类来表示网格和线程块的组织方式，网格grid可以表示为一维和二维格式，线程块block可以表示为一维、二维和三维的数据格式。</li></ul> 
<pre><code class="prism language-cpp">dim3 <span class="token function">DimGrid</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//5000个线程块，维度是100*50</span>
dim3 <span class="token function">DimBlock</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//每个线层块内包含256个线程，线程块内的维度是4*8*8**</span>
</code></pre> 
<p>最常见的组织方式如下：</p> 
<pre><code class="prism language-cpp">dim3 <span class="token function">dimGrid</span><span class="token punctuation">(</span>M<span class="token punctuation">,</span> N<span class="token punctuation">)</span><span class="token punctuation">;</span>
dim3 <span class="token function">dimBlock</span><span class="token punctuation">(</span>P<span class="token punctuation">,</span> Q<span class="token punctuation">)</span><span class="token punctuation">;</span>
threadId<span class="token punctuation">.</span>x <span class="token operator">=</span> blockIdx<span class="token punctuation">.</span>x<span class="token operator">*</span>blockDim<span class="token punctuation">.</span>x<span class="token operator">+</span>threadIdx<span class="token punctuation">.</span>x<span class="token punctuation">;</span> <span class="token comment">// x轴方向上的id号</span>
threadId<span class="token punctuation">.</span>y <span class="token operator">=</span> blockIdx<span class="token punctuation">.</span>y<span class="token operator">*</span>blockDim<span class="token punctuation">.</span>y<span class="token operator">+</span>threadIdx<span class="token punctuation">.</span>y<span class="token punctuation">;</span> <span class="token comment">// y轴方向上的id号</span>
</code></pre> 
<p>5.实现矩阵乘法</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"cuda_runtime.h"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"device_launch_parameters.h"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;ctime&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;ctime&gt;</span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;math.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"malloc.h"</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>


<span class="token keyword">const</span> <span class="token keyword">int</span> Row <span class="token operator">=</span> <span class="token number">512</span><span class="token punctuation">;</span> <span class="token comment">// 行数</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> Col <span class="token operator">=</span> <span class="token number">512</span><span class="token punctuation">;</span> <span class="token comment">// 列数</span>

__global__
<span class="token keyword">void</span> <span class="token function">matrix_mul_gpu</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>M<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">*</span> N<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">*</span> P<span class="token punctuation">,</span> <span class="token keyword">int</span> width<span class="token punctuation">)</span> <span class="token comment">// width代表列数</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> i <span class="token operator">=</span> threadIdx<span class="token punctuation">.</span>x <span class="token operator">+</span> blockDim<span class="token punctuation">.</span>x <span class="token operator">*</span> blockIdx<span class="token punctuation">.</span>x<span class="token punctuation">;</span> <span class="token comment">// 第i列的线程</span>
	<span class="token keyword">int</span> j <span class="token operator">=</span> threadIdx<span class="token punctuation">.</span>y <span class="token operator">+</span> blockDim<span class="token punctuation">.</span>y <span class="token operator">*</span> blockIdx<span class="token punctuation">.</span>y<span class="token punctuation">;</span> <span class="token comment">// 第j行的线程</span>

	<span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> width<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">int</span> a <span class="token operator">=</span> M<span class="token punctuation">[</span>j<span class="token operator">*</span>width <span class="token operator">+</span> k<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 第j行的某一个值</span>
		<span class="token keyword">int</span> b <span class="token operator">=</span> N<span class="token punctuation">[</span>k<span class="token operator">*</span>width <span class="token operator">+</span> i<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 第i列的某一个值</span>
		sum <span class="token operator">+=</span> a <span class="token operator">*</span> b<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	P<span class="token punctuation">[</span>j<span class="token operator">*</span>width <span class="token operator">+</span> i<span class="token punctuation">]</span> <span class="token operator">=</span> sum<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">matrix_mul_cpu</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>M<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">*</span> N<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">*</span> P<span class="token punctuation">,</span> <span class="token keyword">int</span> width<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> width<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> width<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span>
			<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> width<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				<span class="token keyword">int</span> a <span class="token operator">=</span> M<span class="token punctuation">[</span>i<span class="token operator">*</span>width <span class="token operator">+</span> k<span class="token punctuation">]</span><span class="token punctuation">;</span>
				<span class="token keyword">int</span> b <span class="token operator">=</span> N<span class="token punctuation">[</span>k<span class="token operator">*</span>width <span class="token operator">+</span> j<span class="token punctuation">]</span><span class="token punctuation">;</span>
				sum <span class="token operator">+=</span> a <span class="token operator">*</span> b<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
			P<span class="token punctuation">[</span>i<span class="token operator">*</span>width <span class="token operator">+</span> j<span class="token punctuation">]</span> <span class="token operator">=</span> sum<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	clock_t GPUstart<span class="token punctuation">,</span> GPUend<span class="token punctuation">,</span> GPUresult<span class="token punctuation">;</span>

	<span class="token keyword">int</span> <span class="token operator">*</span>A <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">*</span> Row <span class="token operator">*</span> Col<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> <span class="token operator">*</span>B <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">*</span> Row <span class="token operator">*</span> Col<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> <span class="token operator">*</span>C <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">*</span> Row <span class="token operator">*</span> Col<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//malloc device memory</span>
	<span class="token keyword">int</span> <span class="token operator">*</span>d_dataA<span class="token punctuation">,</span> <span class="token operator">*</span>d_dataB<span class="token punctuation">,</span> <span class="token operator">*</span>d_dataC<span class="token punctuation">;</span>
	<span class="token function">cudaMalloc</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>d_dataA<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">*</span>Row<span class="token operator">*</span>Col<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">cudaMalloc</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>d_dataB<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">*</span>Row<span class="token operator">*</span>Col<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">cudaMalloc</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>d_dataC<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">*</span>Row<span class="token operator">*</span>Col<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//set value</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> Row<span class="token operator">*</span>Col<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		A<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">90</span><span class="token punctuation">;</span>
		B<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	GPUstart <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">cudaMemcpy</span><span class="token punctuation">(</span>d_dataA<span class="token punctuation">,</span> A<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">*</span> Row <span class="token operator">*</span> Col<span class="token punctuation">,</span> cudaMemcpyHostToDevice<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">cudaMemcpy</span><span class="token punctuation">(</span>d_dataB<span class="token punctuation">,</span> B<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">*</span> Row <span class="token operator">*</span> Col<span class="token punctuation">,</span> cudaMemcpyHostToDevice<span class="token punctuation">)</span><span class="token punctuation">;</span>
	dim3 <span class="token function">threadPerBlock</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// (Col + threadPerBlock.x - 1)/threadPerBlock.x=Col/threadPerBlock.x+1，即多拿一个block来装不能整除的部分</span>
	dim3 <span class="token function">blockNumber</span><span class="token punctuation">(</span><span class="token punctuation">(</span>Col <span class="token operator">+</span> threadPerBlock<span class="token punctuation">.</span>x <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> threadPerBlock<span class="token punctuation">.</span>x<span class="token punctuation">,</span> <span class="token punctuation">(</span>Row <span class="token operator">+</span> threadPerBlock<span class="token punctuation">.</span>y <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> threadPerBlock<span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Block(%d,%d)   Grid(%d,%d).\n"</span><span class="token punctuation">,</span> threadPerBlock<span class="token punctuation">.</span>x<span class="token punctuation">,</span> threadPerBlock<span class="token punctuation">.</span>y<span class="token punctuation">,</span> blockNumber<span class="token punctuation">.</span>x<span class="token punctuation">,</span> blockNumber<span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 每一个线程进行某行乘某列的计算，得到结果中的一个元素。也就是d_dataC中的每一个计算结果都和GPU中线程的布局&lt;blockNumber, threadPerBlock &gt;一致</span>
	matrix_mul_gpu <span class="token operator">&lt;&lt;</span> <span class="token operator">&lt;</span>blockNumber<span class="token punctuation">,</span> threadPerBlock <span class="token operator">&gt;&gt;</span> <span class="token operator">&gt;</span> <span class="token punctuation">(</span>d_dataA<span class="token punctuation">,</span> d_dataB<span class="token punctuation">,</span> d_dataC<span class="token punctuation">,</span> Col<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//拷贝计算数据-一级数据指针</span>
	<span class="token function">cudaMemcpy</span><span class="token punctuation">(</span>C<span class="token punctuation">,</span> d_dataC<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">*</span> Row <span class="token operator">*</span> Col<span class="token punctuation">,</span> cudaMemcpyDeviceToHost<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">//释放内存</span>
	<span class="token function">free</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">free</span><span class="token punctuation">(</span>B<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">free</span><span class="token punctuation">(</span>C<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">cudaFree</span><span class="token punctuation">(</span>d_dataA<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">cudaFree</span><span class="token punctuation">(</span>d_dataB<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">cudaFree</span><span class="token punctuation">(</span>d_dataC<span class="token punctuation">)</span><span class="token punctuation">;</span>

	GPUend <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> GPUtime <span class="token operator">=</span> GPUend <span class="token operator">-</span> GPUstart<span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"GPU运行时间：%d\n"</span><span class="token punctuation">,</span> GPUtime <span class="token punctuation">)</span><span class="token punctuation">;</span>

	
	<span class="token comment">// CPU计算</span>
	clock_t CPUstart<span class="token punctuation">,</span> CPUend<span class="token punctuation">,</span> CPUresult<span class="token punctuation">;</span>

	<span class="token keyword">int</span> <span class="token operator">*</span>A2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">*</span> Row <span class="token operator">*</span> Col<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> <span class="token operator">*</span>B2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">*</span> Row <span class="token operator">*</span> Col<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> <span class="token operator">*</span>C2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">*</span> Row <span class="token operator">*</span> Col<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">//set value</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> Row<span class="token operator">*</span>Col<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		A2<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">90</span><span class="token punctuation">;</span>
		B2<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	CPUstart <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">matrix_mul_cpu</span><span class="token punctuation">(</span>A2<span class="token punctuation">,</span> B2<span class="token punctuation">,</span> C2<span class="token punctuation">,</span> Col<span class="token punctuation">)</span><span class="token punctuation">;</span>
	CPUend <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> CPUtime <span class="token operator">=</span> CPUend <span class="token operator">-</span> CPUstart<span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"CPU运行时间：%d\n"</span><span class="token punctuation">,</span> CPUtime<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"加速比为：%lf\n"</span><span class="token punctuation">,</span><span class="token keyword">double</span><span class="token punctuation">(</span>CPUtime<span class="token punctuation">)</span><span class="token operator">/</span>GPUtime<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>【注】.cu文件好像只能以英文命名，不然可能出错</p>
                ]]></description></item><item><title>ubuntu pycharm无法输入中文</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522385.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Tue, 26 Jul 2022 11:51:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522385.html</guid><description><![CDATA[
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>参考：https://bbs.csdn.net/topics/397173456<br> 现象：当全拼输入2~3个汉字时，会被强行打断，然后就无法继续输入(也无法切换中英文)，并且汉字下会有下划线。<br> 解决方法：<br> 1.点击菜单 “Help | Edit Custom VM options…”<br> 2.添加 -Drecreate.x11.input.method=true 到最后一行<br> 3.重启IDEA</p>
                ]]></description></item><item><title>ubuntu 拨号上网</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522386.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Tue, 26 Jul 2022 11:51:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522386.html</guid><description><![CDATA[
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>终端输入：nm-connection-editor，出现如下界面<br> <img src="https://img-blog.csdnimg.cn/720c1d25bf704e67a7685c27bc794df5.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcXFfNDI3NzU5Mzg=,size_17,color_FFFFFF,t_70,g_se,x_16" alt="请添加图片描述"><br> 点击左下角的添加按钮，出现如下界面，选择DSL/PPPoE</p> 
<p><img src="https://img-blog.csdnimg.cn/9294400e633149f4a4eae7c96b79db4c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcXFfNDI3NzU5Mzg=,size_16,color_FFFFFF,t_70,g_se,x_16" alt="请添加图片描述"><br> 点击创建，出现如下界面<br> <img src="https://img-blog.csdnimg.cn/91275a7219c044e5b404ba44055cce00.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcXFfNDI3NzU5Mzg=,size_13,color_FFFFFF,t_70,g_se,x_16" alt="请添加图片描述"><br> Parent interface:只要不选lo，好像都行<br> Username:用户名<br> Password：密码<br> 其他不用填<br> 最好将connection name改成英文的</p> 
<p>最后双击如下位置：<br> <img src="https://img-blog.csdnimg.cn/d4b48be2939b4897b5c3790170385037.png" alt="在这里插入图片描述"></p>
                ]]></description></item><item><title>ubuntu源码安装pytorch——源码编译（包含驱动，cuda，cudnn安装）</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522387.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Tue, 26 Jul 2022 11:51:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522387.html</guid><description><![CDATA[
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h1><a id="_0"></a>遇到的错误</h1> 
<p>在源码安装pytorch时，我的cuda的版本时11.4，所以按照官方的安装指南是需要magma-cuda114，而此时magma-cuda114还没发布。<br> 所以我的方法是<br> 卸载驱动、CUDA和CUDNN（具体自己百度）。然后选择对应cuda版本为11.3的显卡驱动，然后安装cuda11.3和相应的CUDNN。<br> 说明：显卡的驱动可以用较低版本的。</p> 
<h1><a id="1_6"></a>1.安装驱动</h1> 
<p>参考：https://www.mlzhilu.com/archives/ubuntu2004%E5%AE%89%E8%A3%85nvidia%E6%98%BE%E5%8D%A1%E9%A9%B1%E5%8A%A8</p> 
<h2><a id="11__8"></a>1.1 驱动下载</h2> 
<p>我需要安装cuda11.3，所以需要选择相应版本的驱动<br> 从<a href="https://docs.nvidia.com/cuda/cuda-toolkit-release-notes/index.html">这里</a>可以看到cuda和驱动之间的版本对应关系<br> 从<a href="https://www.nvidia.com/en-us/geforce/drivers/">这里</a>可以下载各种版本的驱动<br> 最好将下载完的驱动放在~目录下，别问为什么，听我的就对了</p> 
<h2><a id="12__13"></a>1.2 安装前的准备</h2> 
<p>1.安装lightdm</p> 
<pre><code>sudo apt-get update
sudo apt install -y lightdm
</code></pre> 
<p>弹出来一个选项，选择lightdm就行<br> 2.停止lightdm桌面服务</p> 
<pre><code>sudo service lightdm stop
</code></pre> 
<p>3.设置一下root账户密码</p> 
<pre><code>sudo passwd root
</code></pre> 
<p>然后输入密码<br> 4.首先查看你有没有安装gcc</p> 
<pre><code>gcc --version
</code></pre> 
<p>如果没有安装gcc一般make也没安装，这时需要安装一下gcc和make</p> 
<pre><code>sudo apt install gcc 
sudo apt install make
</code></pre> 
<p>5.删除自带驱动</p> 
<pre><code>sudo apt purge nvidia*
sudo apt-get autoremove
</code></pre> 
<p>6.禁用自带的nouveau nvidia驱动</p> 
<pre><code>sudo gedit /etc/modprobe.d/blacklist.conf 
</code></pre> 
<p>在最后添加如下内容</p> 
<pre><code>blacklist nouveau  
options nouveau modeset=0 
</code></pre> 
<p>然后保存退出。</p> 
<pre><code>sudo update-initramfs -u	# 更新
sudo reboot	# 重启
</code></pre> 
<p>重启之后显示是黑屏，此时按ctrl+alt+F1或ctrl+alt+F2,进入命令行，然后登录<br> 7.重启后查看是否已经将自带的驱动屏蔽了，输入以下代码</p> 
<pre><code>lsmod | grep nouveau
</code></pre> 
<p>没有结果输出，则表示屏蔽成功</p> 
<h2><a id="13__69"></a>1.3 安装驱动</h2> 
<p>cd到你下载的显卡驱动的目录<br> 执行：</p> 
<pre><code>sudo chmod a+x NVIDIA-Linux-x86_64-465.31.run
sudo ./NVIDIA-Linux-x86_64-465.31.run -no-x-check -no-nouveau-check -no-opengl-files
# -no-x-check:安装时关闭X服务
# -no-nouveau-check: 安装时禁用nouveau
# -no-opengl-files:只安装驱动文件，不安装OpenGL文件
</code></pre> 
<p>然后会弹出来一个窗口，根据提示进行操作<br> 最后重启，然后输入nvidia-smi会显示驱动和cuda的版本信息，说明驱动安装成功</p> 
<h1><a id="2_cuda_82"></a>2 安装cuda</h1> 
<p>参考：https://bbs.huaweicloud.com/blogs/detail/210271<br> 1.cuda下载安装<br> 从<a href="https://developer.nvidia.com/cuda-toolkit-archive">这里</a>下载对应版本的cuda，这里选择runfile(local)进行安装<br> <img src="https://img-blog.csdnimg.cn/9437586afce049779f6ec21f9003ba46.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcXFfNDI3NzU5Mzg=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br> 运行如下命令：</p> 
<pre><code>wget https://developer.download.nvidia.com/compute/cuda/11.3.1/local_installers/cuda_11.3.1_465.19.01_linux.run
sudo sh cuda_11.3.1_465.19.01_linux.run
</code></pre> 
<p>然后会弹出来一个窗口，按空格取消第一个选项，因为我们安装过驱动了，不要安装了。最后选择安装即可<br> 2.环境配置（两种方式）</p> 
<pre><code>修改home目录下的.bashrc文件（ 修改home目录下的.bashrc文件，只针对当前用户）

cd ~          # 切换回home目录
gedit .bashrc      # 修改.bashrc文件

# add cuda path    # 在文件末尾添加路径
export PATH="/usr/local/cuda-11.0/bin:$PATH"
export LD_LIBRARY_PATH="/usr/local/cuda-11.0/lib64:$LD_LIBRARY_PATH"  

:wq   # 退出保存
</code></pre> 
<pre><code>修改profile文件，针对所有用户

sudo vim /etc/profile    # 修改/etc/profile文件

# add cuda path  # 文件末尾增加以下两行代码
export PATH="/usr/local/cuda-11.0/bin:$PATH"
export LD_LIBRARY_PATH="/usr/local/cuda-11.0/lib64:$LD_LIBRARY_PATH" 

:wq   # 退出保存
</code></pre> 
<p>目录注意改成自己的</p> 
<pre><code>立即生效（或重启服务器生效）

source .bashrc   
 
或

source /etc/profile
</code></pre> 
<p>3.验证安装成功 nvcc -V (注意 是大V)，结果如下<br> <img src="https://img-blog.csdnimg.cn/fd623c6031f445faac8034c980f50680.png" alt="在这里插入图片描述"></p> 
<h1><a id="3_cudnn_133"></a>3. cudnn安装</h1> 
<p>下载cudnn：https://developer.nvidia.com/zh-cn/cudnn<br> 在链接中选择“Library for Linux”<br> 然后执行以下命令</p> 
<pre><code>sudo cp cuda/include/cudnn*.h    /usr/local/cuda/include      注意，解压后的文件夹名称为cuda ,将对应文件复制到 /usr/local中的cuda内
sudo cp cuda/lib64/libcudnn*    /usr/local/cuda/lib64
sudo chmod a+r /usr/local/cuda/include/cudnn.h   /usr/local/cuda/lib64/libcudnn*

</code></pre> 
<p>判断是否安装成功：</p> 
<pre><code>cat /usr/local/cuda-11.3/include/cudnn_version.h | grep CUDNN_MAJOR -A 2
</code></pre> 
<p>如果没有反应就说明安装失败</p> 
<h1><a id="4pytorch_149"></a>4.源码安装pytorch</h1> 
<p>直接参考pytorch.org中的源码安装就行</p>
                ]]></description></item><item><title>Windows CMD 终端使用代理</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522388.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Tue, 26 Jul 2022 11:51:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522388.html</guid><description><![CDATA[
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>https://www.cnblogs.com/duchaoqun/p/11854744.html</p> 
<pre><code># 使用 http 类型代理
set http_proxy=http://127.0.0.1:8484
set https_proxy=http://127.0.0.1:8484

# 使用 socks 类型代理
netsh winhttp set proxy proxy-server="socks=127.0.0.1:8484" bypass-list="localhost"
netsh winhttp show proxy
netsh winhttp reset proxy

# 使用 socks 类型代理
set http_proxy=socks5://127.0.0.1:8484
set https_proxy=socks5://127.0.0.1:8484
</code></pre>
                ]]></description></item><item><title>ubuntu20.04安装anaconda</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522389.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Tue, 26 Jul 2022 11:51:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522389.html</guid><description><![CDATA[
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>1.下载anaconda：https://www.anaconda.com/products/individual#linux<br> 2.使用以下命令安装</p> 
<pre><code>bash Anaconda3-5.3.1-Linux-x86_64.sh
</code></pre> 
<p>一路yes就行。<br> 在~/.bashrc中添加</p> 
<pre><code>export PATH=/home/usrname/anaconda3/bin:$PATH
</code></pre> 
<p>然后输入以下命令</p> 
<pre><code>source ~/.bashrc
</code></pre> 
<p>3.判断是否安装成功</p> 
<pre><code>conda info		
</code></pre> 
<p>4.激活anaconda，出现base前缀。想要去掉(base)，参考这个连接https://blog.csdn.net/Just_youHG/article/details/104686642#commentBox</p>
                ]]></description></item><item><title>python 修饰器@</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522390.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Tue, 26 Jul 2022 11:51:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522390.html</guid><description><![CDATA[
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>参考：https://www.liaoxuefeng.com/wiki/1016959663602400/1017451662295584<br> 装饰器让函数在不需要做任何代码变动的前提下增加额外功能</p> 
<pre><code># 不带参数的修饰器
import functools

def log(func):
    @functools.wraps(func) # 防止依赖函数签名的代码执行出错
    def wrapper(*args, **kw): # 这两个参数代表任意参数
        print('call %s():' % func.__name__) # 日志
        return func(*args, **kw)
    return wrapper
    
@log		# 给now添加打印日志的修饰符
def now():
    print('2015-3-25')	
</code></pre> 
<p>log函数的功能是给now函数添加一个日志。</p> 
<pre><code># 带参数的修饰器
import functools

def log(text):
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kw):
            print('%s %s():' % (text, func.__name__))
            return func(*args, **kw)
        return wrapper
    return decorator
</code></pre>
                ]]></description></item><item><title>python的类、私有变量和多态</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522391.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Tue, 26 Jul 2022 11:51:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522391.html</guid><description><![CDATA[
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>参考：https://www.liaoxuefeng.com/wiki/1016959663602400/1017497232674368</p> 
<h2><a id="1__1"></a>1 类</h2> 
<p>在python中类其实就是一种数据类型，和int，list等没有区别，如每一个list对象都有方法append()。</p> 
<h2><a id="2_4"></a>2.私有变量</h2> 
<p>属性的名称前加上两个下划线__，就变成了一个私有变量（private），只有内部可以访问，外部不能访问。而外部要通过函数对私有变量进行访问，而此函数一般会对私有变量进行一定的保护，如：</p> 
<pre><code>class Student(object):
    ...

    def set_score(self, score):
        if 0 &lt;= score &lt;= 100:
            self.__score = score
        else:
            raise ValueError('bad score')
</code></pre> 
<p>本代码中修改私有变量__score时有一个判断“0 &lt;= score &lt;= 100”，这保证了私有变量的安全。<br> 有些时候，你会看到以一个下划线开头的实例变量名，比如_name，这样的实例变量外部是可以访问的，但是，按照约定俗成的规定，当你看到这样的变量时，意思就是，“虽然我可以被访问，但是，请把我视为私有变量，不要随意访问”</p> 
<h2><a id="3_19"></a>3.多态</h2> 
<p>要理解多态，首先我们先看一段代码：</p> 
<pre><code>class Animal(object):
    def run(self):
        print('Animal is running...')

class Dog(Animal):
    def run(self):
        print('Dog is running...')

class Cat(Animal):
    def run(self):
        print('Cat is running...')

class Timer(object):
    def run(self):
        print('Start...')

def run_twice(animal):
    animal.run()
    animal.run()
    
run_twice(Animal())			###1
run_twice(Cat()) 				###2
run_twice(Timer())			###3
</code></pre> 
<p>多态：从###1和###2可以看出来，多态就是依赖Animal的对象作为参数的函数，可以输入Animal的子类的对象作为参数进行运行，而不需要修改函数中的代码。而Animal的子类中的方法run的实现细节可以千变万化，子类的实现可以千变万化这就是多态的功能。</p> 
<p>多态的原因：子类的对象之所以可以作为参数输入到run_twice()中，是因为Animal中有的东西，子类Cat也有（子类继承父类的所有东西，并且部分可以进行重写）。而在python中函数run_twice的形参animal是不用说明数据类型的，所以任何有run方法的类的对象，都可以输入到run_twice中，如###3。Java中函数run_twice的形参animal是需要说明数据类型的，所以只能输入形参对应的类的对象或子类的对象。</p> 
<p>Animal中的方法可以具体没有实现，只是return或print了适当的内容，具体的实现都留给了它的子类。</p> 
<h2><a id="4_52"></a>4.类与函数相比的优点</h2> 
<p>类的特点时封装、继承和多态。<br> 封装：将一个事物的属性和方法定义在一个类里<br> 继承：可以重写类中的方法，对方法的实现细节进行自定义或增加方法，如对数据库的读操作，就可以通过修改方法的实现细节从读取不同的数据库。<br> 多态：以父类作为形参的函数，子类也可以作为这个函数的形参，虽然子类中方法的实现细节与父类可能有所不同。</p> 
<h2><a id="5_58"></a>5.与类相关的方法</h2> 
<ol><li>isinstance(h, Husky) # 判断对象h是否为类Husky。即用来判断类型是否正确</li><li>类中定义的类似“<strong>xxx</strong>”这样的函数，都是有特殊用途的，如</li></ol> 
<pre><code>&gt;&gt;&gt; class MyDog(object):
...     def __len__(self):
...         return 100
...
&gt;&gt;&gt; dog = MyDog()
&gt;&gt;&gt; dog.__len__()		# 和len(dog)是等价的
100
&gt;&gt;&gt; len(dog)				# 在len()函数内部，它自动去调用该对象的__len__()方法
100
</code></pre> 
<p>3.hasattr(fp, ‘read’) # 判断fp对象中是否有方法或属性‘read’</p> 
<h2><a id="6_74"></a>6.类变量</h2> 
<pre><code>class Student(object):
    name = 'Student'
</code></pre> 
<p>name就是类变量</p> 
<pre><code>class Student(object):
    def __init__(self, name):
        self.name = name

s = Student()		
s.age = 18			# 为对象s创建了一个变量age，而不是为类创建了一个变量age
</code></pre> 
<p>self.name就是对象的变量。</p> 
<h2><a id="7_89"></a>7.类的高级用法</h2> 
<p>1.__slots__:允许实例添加的属性</p> 
<pre><code>class Student(object):
    __slots__ = ('name', 'age') # 只允许对Student实例添加name和age属性。
</code></pre> 
<p>__slots__定义的属性仅对当前类实例起作用，对继承的子类是不起作用.除非在子类中也定义__slots__，这样，子类实例允许定义的属性就是自身的__slots__加上父类的__slots__<br> 2.@property:给属性值的设置添加限制</p> 
<pre><code>class Student(object):

    @property
    def score(self):
        return self._score

    @score.setter
    def score(self, value): # 给属性值的设置添加限制.没有@score.setter时self._score就是只读变量
        if not isinstance(value, int):
            raise ValueError('score must be an integer!')
        if value &lt; 0 or value &gt; 100:
            raise ValueError('score must between 0 ~ 100!')
        self._score = value

# 但是获取和设置属性值的时候用的是如下:
&gt;&gt;&gt; s = Student()
&gt;&gt;&gt; s.score = 60 # OK，实际转化为s.set_score(60)
&gt;&gt;&gt; s.score # OK，实际转化为s.get_score()
60
</code></pre> 
<p>这样我们就既对属性值的设置做了限制,同时也没有让属性值的获取和设置变得困难.<br> 3.元类</p>
                ]]></description></item><item><title>python画柱状图</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522392.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Tue, 26 Jul 2022 11:51:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522392.html</guid><description><![CDATA[
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <pre><code># 利用条形图展示各个置信度区间的框数
def show_bar(bbox_lists, TP_lists, gt_folder):
    # plt中需要输入list
    bbox_lists = bbox_lists.tolist()
    TP_lists = TP_lists.tolist()

    gts = gt_num(gt_folder)

    for i, (bbNum, tpNum) in enumerate(zip(bbox_lists, TP_lists)):
        if i==0:
            sub_show_bar(bbNum, tpNum,gts['gtPersonNum']+gts['gtLifeJacketNum'])
        elif i==1:
            sub_show_bar(bbNum, tpNum, gts['gtPersonNum'])
            print("Recall:",np.sum(tpNum)/gts['gtPersonNum'])
        elif i ==2:
            sub_show_bar(bbNum, tpNum, gts['gtLifeJacketNum'])

def sub_show_bar(bbNum, tpNum, gtNum):
    # 这两行代码解决 plt 中文显示的问题
    plt.rcParams['font.sans-serif'] = ['SimHei']
    plt.rcParams['axes.unicode_minus'] = False

    # 输入统计数据
    conf_lists = ('0.3~0.35', '0.35~0.4', '0.4~0.45', '0.45~0.5.',
                  '0.5~0.55', '0.55~0.6', '0.6~0.65', '0.65~0.7',
                  '0.7~0.75', '0.75~0.8', '0.8~0.85', '0.85~0.9',
                  '0.9~0.95', '0.95~1', 'gt', 'tp_bb')

    bar_width = 0.45  # 条形宽度
    index_bbox_lists = np.arange(len(conf_lists))  # 预测的所有框的条形图的横坐标
    index_TP_lists = index_bbox_lists + bar_width  # 预测正确框的条形图的横坐标

    plt.barh(index_TP_lists, width=tpNum + [gtNum, np.sum(tpNum)], # np.sum(tpNum)不是总数，只是IOU大于0.3的总数
             height=bar_width, color='g', label='预测正确的框')
    plt.barh(index_bbox_lists, width=bbNum + [gtNum, np.sum(bbNum)],
             height=bar_width, color='b', label='预测出的框')

    plt.legend()  # 显示图例
    plt.yticks(index_bbox_lists + bar_width / 2,
               conf_lists)  # 让横坐标轴刻度显示 waters 里的饮用水， index_male + bar_width/2 为横坐标轴刻度的位置
    plt.xlabel('框数')  # 纵坐标轴标题

    # 在图像上添加文字

    for a, b in zip(index_bbox_lists, bbNum + [gtNum, np.sum(bbNum)]):
        plt.text(b + 0.1, a - 0.1, str(b), size=8, ha='center')

    for a, b in zip(index_TP_lists,tpNum + [gtNum, np.sum(tpNum)]):
        plt.text(b + 0.1, a - 0.1, str(b), size=8, ha='center')

    plt.show()

</code></pre>
                ]]></description></item><item><title>python对json的操作</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522393.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Tue, 26 Jul 2022 11:51:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522393.html</guid><description><![CDATA[
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <ol><li>将字典转为json</li></ol> 
<pre><code>def delete_imgData(folder):
    files = os.listdir(folder)
    for file in files:
        obj = {}
        obj["version"] = "4.5.7"
        obj["flags"] = {}
        obj["shapes"]=[]


        bbs_xyxy = get_bbs(os.path.join(folder,file))

        for bb in bbs_xyxy:
            obj["shapes"].append({"label":bb[0],
                                  "points":[
                                            [
                                              bb[1],
                                              bb[2]
                                            ],
                                            [
                                              bb[3],
                                              bb[4]
                                            ]
                                          ],
                                  "group_id": None,
                                  "shape_type": "rectangle",
                                  "flags": {}
                                  })

        obj["imagePath"] = "..\\" + file[:-3]+"bmp"
        obj["imageData"] = None
        obj["imageHeight"] = 2160
        obj["imageWidth"] = 3840

        print("json" + "\\" + file[:-3]+"json")
        open("json" + "\\" + file[:-3]+"json", "w").write(
            json.dumps(obj, indent=2, separators=(',', ': '))
        )

</code></pre> 
<p>2.读取json文件</p> 
<pre><code>def delete_imgData(folder):
    # subFolders = os.listdir(folder)

    # for subFolder in subFolders:
    # files = os.listdir(os.path.join(folder, subFolder))

    files = os.listdir(folder)
    for file in files:
        obj = json.load(open(os.path.join(folder, file)))
        print(type(obj["flags"]))
        if obj["imageData"]==None:
            continue
        obj["imageData"]=None
        print("running.....")
        open(os.path.join(folder, file), "w").write(
            json.dumps(obj,indent=2, separators=(',', ': '))
        )
</code></pre>
                ]]></description></item><item><title>tkinter 选择一个视频并展示出来</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522394.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Tue, 26 Jul 2022 11:51:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522394.html</guid><description><![CDATA[
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="1_0"></a>1.选择视频文件</h3> 
<pre><code>from tkinter.filedialog import askdirectory,askopenfilename
from tkinter import *

def selectPath():
    path_ = askopenfilename()
    path.set(path_)

root = Tk()
path = StringVar()
Label(root,text = "目标路径:").grid(row = 0, column = 0)
Entry(root, textvariable = path).grid(row = 0, column = 1) 
Button(root, text = "路径选择", command = selectPath).grid(row = 0, column = 2)

root.mainloop()
</code></pre> 
<h3><a id="2_18"></a>2、展示视频</h3> 
<pre><code>from tkinter import *

import camera as camera
import cv2
from PIL import Image, ImageTk

def video_play():
    while video.isOpened():
        ret, frame = video.read()  # 读取照片
        # print('读取成功')
        if ret == True:
            img = cv2.cvtColor(frame, cv2.COLOR_BGR2RGBA)  # 转换颜色使播放时保持原有色彩
            current_image = Image.fromarray(img).resize((540, 320))  # 将图像转换成Image对象
            imgtk = ImageTk.PhotoImage(image=current_image)
            movieLabel.imgtk = imgtk
            movieLabel.config(image=imgtk)
            movieLabel.update()  # 每执行以此只显示一张图片，需要更新窗口实现视频播放

video = cv2.VideoCapture('1.mp4')  # 使用opencv打开本地视频文件
root = Tk()
root.title('视频播放案例')
Label(root,text = "视频播放案例'").grid(row = 0, column = 0)
movieLabel = Label(root)  # 创建一个用于播放视频的label容器

movieLabel.grid(row = 1, column = 0,padx=10, pady=10)

video_play()  # 调用video_play实现视频播放

mainloop()
camera.release()
cv2.destroyAllWindonws()
</code></pre> 
<h3><a id="3__53"></a>3、 选择一个视频并展示出来</h3> 
<pre><code>from tkinter.filedialog import askdirectory,askopenfilename
from tkinter import *

import camera as camera
import cv2
from PIL import Image, ImageTk



def selectPath():
    path_ = askopenfilename()
    path.set(path_)

    video_path = path_
    if video_path[-3:] == "mp4":
        video = cv2.VideoCapture(video_path)
        while video.isOpened():
            ret, frame = video.read()  # 读取照片
            # print('读取成功')
            if ret == True:
                img = cv2.cvtColor(frame, cv2.COLOR_BGR2RGBA)  # 转换颜色使播放时保持原有色彩
                current_image = Image.fromarray(img).resize((540, 320))  # 将图像转换成Image对象
                imgtk = ImageTk.PhotoImage(image=current_image)
                movieLabel.imgtk = imgtk
                movieLabel.config(image=imgtk)
                movieLabel.update()  # 每执行以此只显示一张图片，需要更新窗口实现视频播放

root = Tk()
path = StringVar()

# layout
Label(root,text = "目标路径:").grid(row = 0, column = 0)
Entry(root, textvariable = path).grid(row = 0, column = 1)
Button(root, text = "路径选择", command = selectPath).grid(row = 0, column = 2)

movieLabel = Label(root)  # 创建一个用于播放视频的label容器
movieLabel.grid(row = 1, column = 0,padx=10, pady=10)


mainloop()
camera.release()
cv2.destroyAllWindonws()
</code></pre>
                ]]></description></item><item><title>yolov5使用TensorRT进行加速</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522395.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Tue, 26 Jul 2022 11:51:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522395.html</guid><description><![CDATA[
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>https://www.mdnice.com/writing/328959e2439045849a06933c6380e148</p>
                ]]></description></item><item><title>安装ubuntu时的注意点</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522396.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Tue, 26 Jul 2022 11:51:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522396.html</guid><description><![CDATA[
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>安装完ubuntu之后，最好立刻去“软件和更新”的“附加驱动”中选择一个驱动进行安装。然后输入“nvidia-smi”，如果打印出显卡的版本等信息就说明驱动安装成功。<br> 成功安装驱动，可以确保“pip3 install torch”时安装的是GPU版本的torch</p>
                ]]></description></item><item><title>固态和机械，ubuntu分区</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522397.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Tue, 26 Jul 2022 11:51:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522397.html</guid><description><![CDATA[
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>swap 和内存相同 逻辑分区 交换空间<br> \ 全部固态 主分区 ext4<br> \home 全部机械 逻辑分区 ext4</p>
                ]]></description></item><item><title>图像读取方法</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522398.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Tue, 26 Jul 2022 11:51:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522398.html</guid><description><![CDATA[
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h1><a id="2__0"></a>2 读取图像数据</h1> 
<h3><a id="221_matplotlib_2"></a>2.2.1 <strong>使用<code>matplotlib</code>库进行图像的读取</strong></h3> 
<p><code>matplotlib</code>中的函数跟Matlab很像。</p> 
<p>我们需要使用<code>matplotlib.pyplot</code>中的函数：</p> 
<p><code>imread（文件地址）</code>：进行读取图像的操作（参数为读取图像文件的路径）</p> 
<p><code>imshow（数组）</code>：进行图像的显示操作（显示图像的数组）</p> 
<p><code>show（）</code>：显示一个窗口，用于显示图像（很多时候，不显示图像的话，是忘记使用这个函数）</p> 
<p><strong>我们尝试探讨，图像被读取后的数据类型，大小形状</strong></p> 
<pre><code class="prism language-python"><span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt

img <span class="token operator">=</span> plt<span class="token punctuation">.</span>imread<span class="token punctuation">(</span><span class="token string">'002.jpg'</span><span class="token punctuation">)</span>
<span class="token comment">#图片的高H为460，宽W为346，颜色通道C为3</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>img<span class="token punctuation">.</span>shape<span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>img<span class="token punctuation">.</span>dtype<span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">type</span><span class="token punctuation">(</span>img<span class="token punctuation">)</span><span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span>img<span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> 
<p>输出为：</p> 
<pre><code class="prism language-python"><span class="token punctuation">(</span><span class="token number">460</span><span class="token punctuation">,</span> <span class="token number">346</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>
uint8
<span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token string">'numpy.ndarray'</span><span class="token operator">&gt;</span>
</code></pre> 
<p><strong>结论：<code>imread</code>读取的图片为<code>numpy.ndarry</code>的数组，数组的大小排列为：高×宽×通道数，数组的数据类型是<code>uint8</code>，即每个数据的大小为[0,255]</strong></p> 
<p>如果不想手动进行多图像的读取，需要使用到Python的文件，路径操作等。暂不介绍</p> 
<p>手动添加的话，就是用<code>[array1,array2]</code>这种形式，将数组进行连接</p> 
<pre><code class="prism language-python"><span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt

img1 <span class="token operator">=</span> plt<span class="token punctuation">.</span>imread<span class="token punctuation">(</span><span class="token string">'002.jpg'</span><span class="token punctuation">)</span>
img2 <span class="token operator">=</span> plt<span class="token punctuation">.</span>imread<span class="token punctuation">(</span><span class="token string">'003.jpg'</span><span class="token punctuation">)</span>
img <span class="token operator">=</span> <span class="token punctuation">[</span>img1<span class="token punctuation">,</span> img2<span class="token punctuation">]</span>
<span class="token keyword">for</span> i <span class="token keyword">in</span> img<span class="token punctuation">:</span>
    plt<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span>i<span class="token punctuation">)</span>
    plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> 
<hr> 
<h3><a id="222_cv2_55"></a>2.2.2 <strong>cv2</strong></h3> 
<p>在<code>cv2</code>库中，需要用到的函数有：</p> 
<p><code>imread（文件地址）</code>：读取地址处的文件图像</p> 
<p><code>imshow('窗口名称', 图像数组)</code>：将图像数组显示出来，但必须结合<code>waitKey()</code>使用，否则无法显示图像</p> 
<p><code>waitKey(延迟时间)</code>：需要设置延迟时间，当延迟时间≤0时，窗口将会一直延迟，延迟无穷长时间，按下任一按键，可以继续执行下面程序。当延迟时间＞0，即窗口图像会显示对应毫秒后，自动消失。</p> 
<pre><code class="prism language-python"><span class="token keyword">import</span> cv2
img1 <span class="token operator">=</span> cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span><span class="token string">'002.jpg'</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>img1<span class="token punctuation">.</span>shape<span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>img1<span class="token punctuation">.</span>dtype<span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">type</span><span class="token punctuation">(</span>img1<span class="token punctuation">)</span><span class="token punctuation">)</span>
cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">'img'</span><span class="token punctuation">,</span> img1<span class="token punctuation">)</span>
cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment"># 当延迟时间≤0时，窗口将会一直延迟</span>
</code></pre> 
<p>输出为：</p> 
<pre><code class="prism language-python"><span class="token punctuation">(</span><span class="token number">460</span><span class="token punctuation">,</span> <span class="token number">346</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>
uint8
<span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token string">'numpy.ndarray'</span><span class="token operator">&gt;</span>
</code></pre> 
<p><strong>结论：imread<code>读取的图片为</code>numpy.ndarry<code>的数组，数组的大小排列为：高×宽×通道数，数组的数据类型是</code>uint8`，即每个数据的大小为[0,255]</strong></p> 
<p>Matplotlib与cv2对图像的数据格式的处理是相似的，但是也是有区别的：</p> 
<p><strong>对于通道的读取，cv2是按BGR的顺序读入，而matplotlib按RGB的顺序读入</strong></p> 
<h3><a id="223_PIL_89"></a>2.2.3 PIL</h3> 
<p><code>PIL</code>全称为<code>Python Image Library</code>。是给Python提供图像处理相关的库。</p> 
<p>需要使用到的函数：</p> 
<p><code>open（文件地址）</code>：打开文件，注意是打开，并没有读取。主要作用是保持检查文件地址，同时保证文件是打开的状态。当对图像处理的时候，会自动加载。</p> 
<p><code>show()</code>：使用系统自带的图像查看器，查看图像</p> 
<pre><code class="prism language-python"><span class="token keyword">from</span> PIL <span class="token keyword">import</span> Image
img1 <span class="token operator">=</span> Image<span class="token punctuation">.</span><span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">'002.jpg'</span><span class="token punctuation">)</span>
<span class="token comment"># 因为PIL有自己的数据结构，所以没有shape,dtype属性</span>
<span class="token comment"># print(img1.shape)</span>
<span class="token comment"># print(img1.dtype)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">type</span><span class="token punctuation">(</span>img1<span class="token punctuation">)</span><span class="token punctuation">)</span>
img1<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> 
<p>输出为：</p> 
<pre><code class="prism language-python"><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token string">'PIL.JpegImagePlugin.JpegImageFile'</span><span class="token operator">&gt;</span>
</code></pre> 
<p>我们可以使用<code>numpy.array()</code>函数，将<code>PIL</code>结构的数据转换成<code>numpy</code>数组。</p> 
<pre><code class="prism language-python"><span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt
<span class="token keyword">from</span> PIL <span class="token keyword">import</span> Image
<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np

img1 <span class="token operator">=</span> Image<span class="token punctuation">.</span><span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">'002.jpg'</span><span class="token punctuation">)</span>
img1 <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span>img1<span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>img1<span class="token punctuation">.</span>shape<span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>img1<span class="token punctuation">.</span>dtype<span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span>img1<span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> 
<p>输出：</p> 
<pre><code class="prism language-python"><span class="token punctuation">(</span><span class="token number">460</span><span class="token punctuation">,</span> <span class="token number">346</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>
uint8
</code></pre> 
<p>可以看到，PIL转换成numpy后，数据类型是uint8的。</p> 
<p>总结：</p> 
<p>主要介绍了使用<code>matplotlib</code>,<code>cv2</code>,<code>PIL</code>库进行图像文件的读取</p> 
<ul><li><code>matplotlib</code>中的<code>imread</code>,<code>imshow</code>,<code>show</code>函数</li><li><code>cv2</code>中的<code>imread</code>,<code>imshow</code>,<code>waitKey</code>函数</li><li><code>PIL</code>中的<code>open</code>,<code>show</code>函数</li></ul>
                ]]></description></item><item><title>tensorboard的使用</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522399.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Tue, 26 Jul 2022 11:51:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522399.html</guid><description><![CDATA[
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>TensorBoard 是 TensorFlow提供的一组可视化工具（a suite of visualization tools），可以帮助开发者方便的理解、调试、优化TensorFlow 程序</p> 
<pre><code>from torch.utils.tensorboard import SummaryWriter
import numpy as np
from PIL import Image

writer = SummaryWriter("logs")
image_path = "img.png"
img_PIL = Image.open(image_path)
img_array = np.array(img_PIL)
print(type(img_array))
print(img_array.shape)

writer.add_image("train", img_array, 1, dataformats='HWC')
# y = 2x
for i in range(100):
    writer.add_scalar("y=2x", 3*i, i)

writer.close()
</code></pre> 
<pre><code># 命令行中执行以下代码，启动tensorboard
tensorboard --logdir=logs # logs是运行上面程序后生成的
</code></pre>
                ]]></description></item><item><title>python的其他知识</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522400.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Tue, 26 Jul 2022 11:51:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522400.html</guid><description><![CDATA[
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="1_0"></a>1.帮助</h3> 
<p>dir()和help()</p> 
<pre><code>import torch
dir(torch.cuda) #查看torch.cuda下有那些东西
help(torch.cuda.is_available) # 查看torch.cuda.is_available的使用
</code></pre> 
<h3><a id="2__call___8"></a>2.__call__()</h3> 
<p>__call__()的功能类似于在类中重载 () 运算符，使得类实例对象可以像调用普通函数那样，以“对象名()”的形式使用。<br> 参考：<a href="http://c.biancheng.net/view/2380.html">链接</a></p> 
<p>3.items()<br> Python 字典(Dictionary) items() 函数以列表返回可遍历的(键, 值) 元组数组。</p>
                ]]></description></item><item><title>pycharm使用</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522401.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Tue, 26 Jul 2022 11:51:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522401.html</guid><description><![CDATA[
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>ctrl+点击：查看原函数</p> 
<p>ctrl+p：查看函数所需的参数</p>
                ]]></description></item><item><title>白嫖GPU</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522402.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Tue, 26 Jul 2022 11:51:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522402.html</guid><description><![CDATA[
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>这里首选免费深度学习平台——colab。</p> 
<p>Colab的使用：https://blog.csdn.net/qq_36890370/article/details/106160805</p> 
<p>Colab的使用的补充：https://zhuanlan.zhihu.com/p/54389036</p>
                ]]></description></item><item><title>ffmpeg剪辑视频</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522403.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Tue, 26 Jul 2022 11:51:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522403.html</guid><description><![CDATA[
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>参考：https://www.jianshu.com/p/695412050540</p> 
<pre><code>ffmpeg -ss 00:03:00 -i main0488.mp4 -to 00:02:00 -c copy cut.mp4 	# 参数顺序不要改
</code></pre> 
<p>从00:03:00开始，剪辑两分钟，即00:03:00到00:05:00</p>
                ]]></description></item><item><title>Virtualenv和conda建立python虚拟环境</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522405.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Tue, 26 Jul 2022 11:51:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522405.html</guid><description><![CDATA[
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="1_Virtualenv_0"></a>1. Virtualenv创建虚拟环境</h2> 
<h3><a id="11_1"></a>1.1创建环境:</h3> 
<pre><code>sudo apt install python3-virtualenv    	# 安装 virtualenv 
virtualenv -p /usr/bin/python3.5 myVENV 
</code></pre> 
<ul><li>/usr/bin/python3.5：是python语言版本的路径。在window下python语言版本的路径要加上后缀exe，如E:\studySoftware\python39\python.exe</li><li>myVENV：是虚拟环境的名称。</li></ul> 
<h3><a id="12__8"></a>1.2 激活环境：</h3> 
<pre><code>myVENV\Scripts\activate  			# windows下激活
source myVENV\bin\activate		# linux下激活			
</code></pre> 
<p>然后我们可以看到命令行多了一个前缀“myVENV”，如下图所示：<br> <img src="https://img-blog.csdnimg.cn/64c5f9d84875421da4c4447735150068.png" alt="在这里插入图片描述"><br> 此后我们执行pip install xx等操作都只是对我们建立的虚拟环境产生影响。</p> 
<h2><a id="2_conda_16"></a>2. conda创建虚拟环境</h2> 
<p>参考视频：https://www.bilibili.com/video/av74281036/<br> 打开anaconda Prompt</p> 
<pre><code>conda create -n pytorch python=3.6 # 创建名为pytorch的虚拟环境
conda activate pytorch # 激活环境
conda remove -n pytorch --all # 移除环境
</code></pre> 
<p>激活以后前缀改变了：<br> <img src="https://img-blog.csdnimg.cn/img_convert/32ebb7934d2417d1c77d20aaa14b63f8.png" alt="image-20210506085306549"><br> 以上安装的环境会出现在anaconda安装目录的envs目录下：<br> <img src="https://img-blog.csdnimg.cn/img_convert/c75ffcaf50454d0d41799e9c008fe084.png" alt="image-20210506091818386"></p>
                ]]></description></item><item><title>linux的sh脚本</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522406.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Tue, 26 Jul 2022 11:51:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522406.html</guid><description><![CDATA[
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>1.for循环：</p> 
<pre><code>for i in $(ls ./zz) 				# 列出zz目录下的所有文件 
do
		echo hello${i%.*}  	# ${}让变量i可以和字符串hello进行拼接
										# %后面跟需要截取掉的部分，其他截取方法请参考https://blog.csdn.net/zzddada/article/details/120739198
										# .*代表截取掉.和.后面的所有部分
done	
</code></pre>
                ]]></description></item><item><title>windows远程连接ubuntu18.04</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522407.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Tue, 26 Jul 2022 11:51:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522407.html</guid><description><![CDATA[
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>直接使用向日葵<br> 其他方法：<br> 参考：https://www.cxyzjd.com/article/fuck_hang/104368007</p>
                ]]></description></item><item><title>cv的评价指标</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522408.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Tue, 26 Jul 2022 11:51:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522408.html</guid><description><![CDATA[
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <hr> 
<h2><a id="typoracopyimagesto__img_1"></a>typora-copy-images-to: 评价指标_img</h2> 
<h1><a id="1MAP_4"></a><strong>1.MAP</strong></h1> 
<p>参考：https://www.bilibili.com/video/BV1ez4y1X7g2</p> 
<p>https://www.zhihu.com/search?type=content&amp;q=map</p> 
<p>https://www.bilibili.com/video/BV1zE411u7Vw?from=search&amp;seid=10424710946648558529</p> 
<h2><a id="11__12"></a><strong>1.1 一些名词的解释</strong></h2> 
<ul><li>TP: IoU&gt;0.5的检测框数量（同一Ground Truth只计算一次）。（检测出来且正确的框）</li><li>FP: IoU&lt;=0.5的检测框，或者是检测到同一个GT的多余检测框的数量。（误检的框）</li><li>FN: 没有检测到的GT的数量。（没检测出来的真实框）</li></ul> 
<p>P代表检测出的框，T代表后面哪个字母是否正确。</p> 
<p>bbox中IOU最大且大于0.5的那个框是TP；在bbox中的其他框为FP；</p> 
<p>Precision： TP / (TP + FP)，TP除以检测到的所有框，查准率（1-误检率）。检测到的所有框中，检测正确的有多少。</p> 
<p>Recall：TP / (TP + FN)，TP除以GT的总数量，查全率（1-漏检率）。真实框中被检测到的有多少。</p> 
<h2><a id="12_MAP_26"></a><strong>1.2 MAP</strong></h2> 
<h3><a id="121_AP_28"></a><strong>1.2.1 AP产生的原因</strong></h3> 
<p>置信度：除了IOU外，如果框的置信度小于设定的置信度的TP和FP，我们是不考虑进去的。</p> 
<p>随着置信度的变化，precision和recall的变化。如果precision和recall一直都很大，那么P-R的曲线所围成的面积就会趋于一。所以可以通过P-R的曲线所围成的面积来评价模型的好坏。而AP就是P-R的曲线所围成的面积</p> 
<p>mAP：mean Average Precision, 即各类别 AP 的平均值。</p> 
<h3><a id="122_PrecisionRecall_36"></a><strong>1.2.2 计算Precision和Recall</strong></h3> 
<p>假设我们有 7 张图片（Images1-Image7），这些图片共有 15 个GT（绿色的框）以及 24 个预测边框（红色的框，A-Y 编号表示，并且有一个置信度值）</p> 
<p><img src="https://img-blog.csdnimg.cn/img_convert/61645c1a3cfdeb0d9872ea53526162d5.png" alt="image-20210904165334795"></p> 
<p>IOU_thred=0.3，结果如下：</p> 
<p><img src="https://img-blog.csdnimg.cn/img_convert/dede726a9e0fc809c1153485f03943d6.png" alt="image-20210904165426912"></p> 
<p>​ 根据置信度从大到小排序所有的预测框，然后就可以计算 Precision 和 Recall 的值，见下表。（需要记住一个叫<strong>累加的概念，就是下图的 ACC TP 和 ACC FP</strong>）</p> 
<p><img src="https://img-blog.csdnimg.cn/img_convert/182d5d643519b807918d7e8236e41bbb.png" alt="image-20210904165509442"></p> 
<p>不同置信度下的Precision和Recall：</p> 
<ul><li>标号为 1 的 Precision 和 Recall 的计算方式：Precision=TP/(TP+FP)=1/(1+0)=1，Recall=TP/(TP+FN)=TP/(all ground truths)=1/15=0.0666</li><li>标号 2：Precision=TP/(TP+FP)=1/(1+1)=0.5，Recall=TP/(TP+FN)=TP/(all ground truths)=1/15=0.0666</li><li>标号 3：Precision=TP/(TP+FP)=2/(2+1)=0.6666，Recall=TP/(TP+FN)=TP/(all ground truths)=2/15=0.1333</li><li>其他的依次类推</li></ul> 
<p>然后就可以绘制出 P-R 曲线</p> 
<p><img src="https://img-blog.csdnimg.cn/img_convert/f76e49d2b9d0c68b1461fd92684e0166.png" alt="image-20210904183050249"></p> 
<h3><a id="123_AP_63"></a><strong>1.2.3 计算AP的两种方法</strong></h3> 
<p>1.VOC2010及以后的方法计算AP的方法</p> 
<p>上图中，Recall相同时，只取Precision最大的那一个点，其他的删掉。</p> 
<p><img src="https://img-blog.csdnimg.cn/img_convert/442daae909264a49ee21f6dc60758173.png" alt="image-20210904183131789"></p> 
<p>AP为红色区域，AP=(0.0666-0)*1+(0.1333-0.0666)*0.6666+(0.2-0.1333)*0.3+(0.2666-0.2)*0.3333+(0.3333-0.2666)*0.3846+(0.4-0.3333)*0.4285+(0.4666-0.4)*0.3043</p> 
<p>2.VOC2010之前的方法</p> 
<p><strong>Recall</strong>取 11 个点 <strong>[0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1]，然后分别取每个点以后最大的Precision，如Recall=&gt;0.4中最大的Precision为0.4285</strong></p> 
<p><img src="https://img-blog.csdnimg.cn/img_convert/e8e8f455d828c813cbe593080597cc36.png" alt="image-20210904183424480"></p> 
<p><img src="https://img-blog.csdnimg.cn/img_convert/84fd264006dc7b477bede4ef31ec4ce4.png" alt="image-20210904183248662"></p> 
<h3><a id="124_COCO_83"></a><strong>1.2.4 COCO中的评价指标：</strong></h3> 
<p><img src="https://img-blog.csdnimg.cn/img_convert/2470d16fe98d2593681096b11b46f6da.png" alt="image-20210904183742716"></p> 
<p>在这个表中，COCO设置了不同的IOU、max和大小得出不同的MAP值，下面是一个实例：</p> 
<p><img src="https://img-blog.csdnimg.cn/img_convert/6b92abe41ede429c76d8edf23d0d1027.png" alt="image-20210904183931434"></p>
                ]]></description></item><item><title>tensorflow官方提供的目标检测与分类API</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522409.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Tue, 26 Jul 2022 11:51:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522409.html</guid><description><![CDATA[
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><strong>1.tensorflow官方提供的目标检测与分类API</strong></p> 
<p>在https://github.com/tensorflow/models中的research文件中有各种各样的API，</p> 
<p>在research文件夹中，slim文件夹是图像分类API，object_detection是目标检测API，就是拿来就能用的API</p> 
<p>最好看文件夹中提供的官方文档来使用这些API，也可参考以下两篇CSDN（优先看官方教程）：</p> 
<p>https://blog.csdn.net/qq_37541097/article/details/101306759</p> 
<p>https://blog.csdn.net/qq_37541097/article/details/101711261</p>
                ]]></description></item><item><title>PASCAL VOC2012数据集与制作自己的数据集</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522410.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Tue, 26 Jul 2022 11:51:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522410.html</guid><description><![CDATA[
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><strong>PASCAL VOC2012数据集与制作自己的数据集</strong></p> 
<p>官网：https://host.robots.ox.ac.uk/pascal/VOC/voc2012/index.html#devkit</p> 
<p>官网进不去的话，这个博客https://host.robots.ox.ac.uk/pascal/VOC/voc2012/index.html#devkit中提到用这个镜像下载数据集https://pjreddie.com/projects/pascal-voc-dataset-mirror/</p> 
<p>PASCAL VOC2012数据集的具体介绍，可以google</p> 
<p>PASCAL VOC挑战赛，包括图像分类、目标识别、目标分割、动作识别这几个类别</p> 
<p>制作自己的数据集的软件主要有两种，分别为labelme和labellmg两种，labelme的标注文件json格式保存的，labellmg的标注文件是用xml格式保存的，labellmg中还有一个此照片标注难易的属性。labellmg的标注文件和PASCAL VOC数据集的格式完全一致。</p> 
<p>通过pip install labelme或pip install labellmg，即可安装对应的软件。它们的使用说明可以上github上查找进行查看</p>
                ]]></description></item><item><title>MOT数据集格式</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522411.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Tue, 26 Jul 2022 11:51:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522411.html</guid><description><![CDATA[
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>参考：https://blog.csdn.net/yuanlulu/article/details/79818599</p> 
<p>https://blog.csdn.net/sinat_17196995/article/details/57946708</p> 
<p>https://zhuanlan.zhihu.com/p/391396206</p> 
<p>两个标注文件：</p> 
<h2><a id="det_8"></a><strong>det目录:</strong></h2> 
<p>det目录下只有一个det.txt文件，每行一个标注，代表一个检测的物体。</p> 
<p>内容摘抄为：</p> 
<pre><code>1,-1,1359.1,413.27,120.26,362.77,2.3092,-1,-1,-1
1,-1,571.03,402.13,104.56,315.68,1.5028,-1,-1,-1
1,-1,650.8,455.86,63.98,193.94,0.33276,-1,-1,-1
1,-1,721.23,446.86,41.871,127.61,0.27401,-1,-1,-1
1,-1,454.06,434.36,97.492,294.47,0.20818,-1,-1,-1
1,-1,1254.6,446.72,33.822,103.47,0.14776,-1,-1,-1
1,-1,1301.1,237.38,195.98,589.95,0.051818,-1,-1,-1
.....
</code></pre> 
<p>其格式为：</p> 
<pre><code>&lt;frame&gt;, &lt;id&gt;, &lt;bb_left&gt;, &lt;bb_top&gt;, &lt;bb_width&gt;, &lt;bb_height&gt;, &lt;conf&gt;, &lt;x&gt;, &lt;y&gt;, &lt;z&gt; 
</code></pre> 
<p>每行10个数字，第一个代表第几帧，第二个代表轨迹编号（在这个文件里总是为-1）</p> 
<p>bb开头的4个数代表物体框的左上角坐标及长宽。conf代表置信度，最后3个是MOT3D用到的内容，2D检测总是为-1.</p> 
<p>总结：有用的字段主要是frame， bb_left, bb_top, bb_width, bb_height, conf</p> 
<h2><a id="gt_37"></a><strong>gt目录:</strong></h2> 
<p>这个目录下有一个gt.txt文件，内容和上面的det.txt很像。内容摘抄如下：</p> 
<pre><code>1,1,912,484,97,109,0,7,1
2,1,912,484,97,109,0,7,1
3,1,912,484,97,109,0,7,1
4,1,912,484,97,109,0,7,1
5,1,912,484,97,109,0,7,1
6,1,912,484,97,109,0,7,1
7,1,912,484,97,109,0,7,1
.......
</code></pre> 
<p>第一个值含义同上，第二个值为目标运动轨迹的ID号，第三个到第六个值的同上，第七个值为目标轨迹是否进入考虑范围内的标志，0表示忽略，1表示active。第八个值为该轨迹对应的目标种类，第九个值为box的visibility ratio，表示目标运动时被其他目标box包含/覆盖或者目标之间box边缘裁剪情况。</p> 
<h2><a id="seqinfoini_54"></a><strong>seqinfo.ini文件</strong></h2> 
<p>内容摘抄如下：</p> 
<pre><code>[Sequence]
name=MOT16-02
imDir=img1
frameRate=30
seqLength=600
imWidth=1920
imHeight=1080
imExt=.jpg
</code></pre> 
<p>主要介绍视频的帧率、分辨率等基本信息。</p>
                ]]></description></item><item><title>目标检测综述</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522412.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Tue, 26 Jul 2022 11:51:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522412.html</guid><description><![CDATA[
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>目前主流的目标检测算法主要是基于深度学习模型，其可以分成两大类：（1）two-stage检测算法，其将检测问题划分为两个阶段，首先产生候选区域（region proposals），然后对候选区域分类（一般还需要对位置精修），这类算法的典型代表是基于region proposal的R-CNN系算法，如R-CNN，Fast R-CNN，Faster R-CNN等；（2）one-stage检测算法，其不需要region proposal阶段，直接产生物体的类别概率和位置坐标值，比较典型的算法如YOLO和SSD。</p>
                ]]></description></item><item><title>yolo实战资源</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522413.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Tue, 26 Jul 2022 11:51:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522413.html</guid><description><![CDATA[
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><a href="https://www.bilibili.com/video/BV1cp4y1k7xd">YOLOv5+DeepSort+Pytorch实现目标跟踪（b站）</a></p> 
<p><a href="https://blog.csdn.net/weixin_41010198/article/details/106785253">YOLOv5的详细使用教程(csdn)</a></p>
                ]]></description></item><item><title>yolov1~v5的介绍</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522414.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Tue, 26 Jul 2022 11:51:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522414.html</guid><description><![CDATA[
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h1><a id="0__1"></a><strong>0. 计算机视觉</strong></h1> 
<p>参考：https://zhuanlan.zhihu.com/p/94986199</p> 
<p>https://zhuanlan.zhihu.com/p/32525231</p> 
<p>https://www.bilibili.com/video/BV1yi4y1g7ro?from=search&amp;seid=15480272248284580243</p> 
<p>计算机视觉，图像分类是计算机视觉最基本的任务之一，但是在图像分类的基础上，还有更复杂和有意思的任务，如目标检测，图像分割等，见下图所示。其中目标检测是一件比较实际的且具有挑战性的计算机视觉任务，其可以看成图像分类与定位的结合，给定一张图片，目标检测系统要能够识别出图片的目标并给出其位置。</p> 
<p><img src="https://img-blog.csdnimg.cn/img_convert/ff3067ee102fd6692ea0838c77e966c1.png" alt="image-20210904213046347"></p> 
<p>比较流行的目标检测算法可以分为两类，一类是基于Region Proposal的R-CNN系算法（R-CNN，Fast R-CNN, Faster R-CNN），它们是two-stage的，需要先使用启发式方法（selective search）或者CNN网络（RPN）产生Region Proposal，然后再在Region Proposal上做分类与回归。而另一类是Yolo和SSD，这类是one-stage算法，其仅仅使用一个CNN网络直接预测不同目标的类别与位置。第一类方法是准确度高一些，但是速度慢，但是第二类算法是速度快，但是准确性要低一些。</p> 
<h1><a id="1yolov1_17"></a><strong>1.yolov1</strong></h1> 
<h2><a id="11__19"></a><strong>1.1 原理以及参数的计算方法</strong></h2> 
<h3><a id="111__21"></a><strong>1.1.1 原理：</strong></h3> 
<p>yolo是将图像分割成不重叠的几个部分，每一部分称为一个grid cell。对于每一个grid，预测其中的某一点作为物体的中心（x,y），以此中心形成一个框，所以还必须预测此框的宽(w)和高(h)，还必须预测的框框住物体的可能性confidence（置信度）。</p> 
<p>故一个框包括五个属性，分别为x,y,w,h,confidence。而每一个grid一般包含几个这样的框。这样的框称为bounding box。</p> 
<p>Yolo采用卷积网络来提取特征，然后使用全连接层来得到预测值。</p> 
<h3><a id="112__29"></a><strong>1.1.2 参数的计算方法：</strong></h3> 
<p>confidence = P*IOU，表示该bounding box中目标属于各个类别的可能性大小以及边界框匹配目标的好坏</p> 
<p>P 是一个grid有物体的概率，在有物体的时候为1，没有物体的时候为0.（置信度在某些情况，似乎不是这么计算的）</p> 
<p>IOU：这个IOU的全称是intersection over union，也就是交并比，它反应了两个框的相似度。IOU预测的是bounding box和真实的物体位置的交并比，如下图所示：</p> 
<p><img src="https://img-blog.csdnimg.cn/img_convert/bdabf461e80effced7bc54fd5af79e90.png" alt="image-20210904213129875"></p> 
<p>x,y,w,h的计算方法：</p> 
<p>如下图，中间框的左上角坐标为(a,b)，物体中心坐标(x0,y0)，grid的大小为(m,m)，红色框的大小为(j,k)，整个图片的大小为(p,q)。</p> 
<p>则x=(x0-a)/m, y=(y0-b)/m, w=j/p,h=k/q，如此归一化的目的是为了计算的简单。具体如下图右侧：</p> 
<p><img src="https://img-blog.csdnimg.cn/img_convert/c33c4c074cc57f702caff2b5e83ae81a.png" alt="image-20210904213152038"></p> 
<p>通过(x,y)就可以还原出(x0,y0)，这是因为此中心点在哪个框中是已知的。通过(w,h)就可以还原出(j,k)，这是因为图片的大小是已知的。</p> 
<h3><a id="113__49"></a><strong>1.1.3 一些其他参数</strong></h3> 
<p>1.设每一个单元格要给出预测出C类，每个单元格有B个bounding box，而每个bounding box都有五个属性（x,y,w,h,confidence），则每个单元格需要预测(B<em>5+C)个值。如果图片被分为S</em>S个网格，那么最终需要预测(B*5+C)<em>S</em>S个值。</p> 
<p>测试的时候，每一个目标的概率confidence*P©，confidence代表框住物体的概率、P©代表物体为C类的概率</p> 
<p>2.ground truth是人为标注的框住物体的框。</p> 
<p>3.每个框有多个bounding box，只取IOU最大的。</p> 
<p>\4. 缺点：大家可能会想如果一个单元格内存在多个目标怎么办，其实这时候Yolo算法就只能选择其中一个来训练，这也是Yolo算法的缺点之一。</p> 
<h2><a id="12__61"></a><strong>1.2 损失函数：</strong></h2> 
<p><img src="https://img-blog.csdnimg.cn/img_convert/620bdf6bcfb4ff7732ce7886e63b6719.png" alt="image-20210904213228944"></p> 
<p>bounding box损失代表中心点(x,y)和框的(w,h)与实际的差距，confidence损失代表预测的框与实际的框的差距，</p> 
<p>classes损失代表预测的分类与实际分类的差距。</p> 
<p>让w加上平方根再相减的原因如下图：</p> 
<p><img src="https://img-blog.csdnimg.cn/img_convert/7884e5831965cbf9462b06d914ae4687.png" alt="image-20210904213801619"></p> 
<p>在图中我们可以看到，同样的偏移，对小图的影响会比较大，对大图的影响比较小。而“给w加上平方根再相减”才会使得：大图需要更大的偏移才能达到小图较小偏移的效果。</p> 
<h1><a id="2yolov2_77"></a><strong>2.yolov2</strong></h1> 
<p>参考：https://zhuanlan.zhihu.com/p/35325884</p> 
<h2><a id="21_yolov2_81"></a><strong>2.1 yolov2的七种优化</strong></h2> 
<p>1.Batch Normalization：通过计算机像素点的平均值和方差，将像素点的值归一化。</p> 
<p>2.High Resolution Classifier：我不懂，好像是用高分辨率的图像进行训练</p> 
<p>3.Convolutional With Anchor Boxes：YOLOv2借鉴了Faster R-CNN中RPN网络的先验框（anchor boxes，prior boxes，SSD也采用了先验框）策略。RPN对CNN特征提取器得到的特征图（feature map）进行卷积来预测每个位置的边界框以及置信度（是否含有物体），并且各个位置设置不同尺度和比例的先验框，所以RPN预测的是边界框相对于先验框的offsets值（其实是transform值，详细见<a href="https://link.zhihu.com/?target=https%3A//arxiv.org/abs/1506.01497">Faster R_CNN论文</a>），采用先验框使得模型更容易学习。所以YOLOv2移除了YOLOv1中的全连接层而采用了卷积和anchor boxes来预测边界框。为了使检测所用的特征图分辨率更高，移除其中的一个pool层。</p> 
<p>4.Dimension Clusters：在Faster R-CNN和SSD中，先验框的维度（长和宽）都是手动设定的，YOLOv2采用k-means聚类方法对训练集中的边界框做了聚类分析。因为设置先验框的主要目的是为了使得预测框与ground truth的IOU更好，所以聚类分析时选用box与聚类中心box之间的IOU值作为距离指标：</p> 
<p><img src="https://img-blog.csdnimg.cn/img_convert/a5a43ff84005d0740e6949e119484f2f.png" alt="image-20210904213849401"></p> 
<p>5.Multi-Scale Training：模型只有卷积层和池化层，所以模型可以输入的图像的尺寸可以不同。所以输入不同尺寸的图片进行训练也是可行的。这样同一个模型其实就可以适应多种大小的图片了。</p> 
<p>6.Direct location prediction：我不懂，可能是使得anchor在一个cell中，（需要去看 Faster RCNN，看anchor是什么）</p> 
<p>7.Fine-Grained Features：像残差网络一样，将底层的信息和高层的信息进行融合</p> 
<p>yolov2的骨干网络：Darknet-19</p> 
<h1><a id="3yolov3_103"></a><strong>3.yolov3</strong></h1> 
<p>问题：Faster R-CNN中RPN网络的先验框（anchor boxes，prior boxes）是什么？？</p>
                ]]></description></item><item><title>ffmpeg将视频转图片，图片转视频</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522415.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Tue, 26 Jul 2022 11:51:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522415.html</guid><description><![CDATA[
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>1.视频转图片:</p> 
<pre><code>ffmpeg -i 1.mp4 -r 5 -f image2 .\output\1_frame_%05d.bmp
</code></pre> 
<p>"-r 5"代表一秒中抽取五帧<br> “ image2”代表图片的类型，<br> “%05d”代表五位的数，如“00001”<br> 输出图片的后缀不一定要为bmp，也可以为png，这都是无损提取。而输出的图片为jpg时，输出的图片就是压缩过后的。</p> 
<p>2.图片转视频：</p> 
<pre><code>ffmpeg -f image2 -framerate 25 -i "img%05d.bmp" -b:v 25313k C:\123\222.mp4
</code></pre> 
<p>“ -framerate 25”：代表一秒25帧，<br> “-b:v 25313k ”：代表视频所需的码率为25313k</p> 
<p>码率的获取：<br> 在利用ffmpeg将视频变为图片完成的时候，会得到bitrate，如下图：<img src="https://img-blog.csdnimg.cn/d3f3a6063c4f4b71bdd7a4b27a871119.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcXFfNDI3NzU5Mzg=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br> 将码率设为和原视频一致，那么由图片得到的视频也会和原视频的播放效果类似。</p> 
<p>3.批量重命名<br> 在图片转视频时，图片的命名应该是一样的，只有编号不一样，如aa1.bmp，所以需要对所有图片进行重命名。依次键入下面命令<br> CTRL+A：全选<br> F2：重命名为aa.bmp<br> CTRL+enter：将所有图片按顺序命名成"aa (1).bmp"、“aa (2).bmp”…………<br> 此时图片转视频的命令变为：</p> 
<pre><code>ffmpeg -f image2 -framerate 25 -i "aa (%d).bmp" -b:v 25313k C:\123\222.mp4
</code></pre> 
<p>因为批量重命名后aa与后面的编号之间有空格，所以命令中的aa (%d).bmp必须用双引号括起来。</p> 
<p>注意：这里不管是视频转图片，还是图片转视频，都会导致画质少量的损失。</p>
                ]]></description></item><item><title>window下的“脚本”——bat</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522416.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Tue, 26 Jul 2022 11:51:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522416.html</guid><description><![CDATA[
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <pre><code>for %%i in (*.mp4) do ffmpeg -i %%i -r 2 -f image2 output^\%%i_frame_%%010d.bmp
pause
</code></pre> 
<p>本代码循环执行命令“ffmpeg -i %%i -r 2 -f image2 output^%%i_frame_%%010d.bmp”<br> 上面这个命令存储在名为“run.bat”的文件中</p>
                ]]></description></item><item><title>RCNN、Fast RCNN和Faster RCNN总结</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522417.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Tue, 26 Jul 2022 11:51:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522417.html</guid><description><![CDATA[
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>参考：https://www.bilibili.com/video/BV1af4y1m7iL?p=1</p> 
<h1><a id="1RCNNRegionCNN_4"></a>1.RCNN（Region-CNN）</h1> 
<h2><a id="11_RCNN_5"></a>1.1 RCNN的总述</h2> 
<p>1.得到候选框：通过Selective Search算法在每张图片中生成1k~2k的候选区域。<font color="red">ss算法具体如何实现？</font><br> 2.特征提取：将候选框中的图片缩放成227x227，然后通过包含CNN的神经网络对每个候选区域进行特征提取，并拉直成一维向量<br> 3.SVM分类：将一维向量送入SVM分类器中预测属于各个类的概率，然后利用非极大值抑制剔除一些建议框<br> 4.修正候选区域：利用回归器修正候选区域位置</p> 
<h2><a id="12_RCNN_11"></a>1.2 RCNN的细节详述</h2> 
<h3><a id="121__13"></a>1.2.1 特征提取</h3> 
<p>​ 将2000个候选区域都缩放到227x227pixel，接着将每个候选区域输入事先训练好的AlexNet CNN网络，每个候选区域获取4096维的特征，从而得到2000×4096维矩阵。 <font color="red">如何缩放？</font></p> 
<p><img src="https://img-blog.csdnimg.cn/img_convert/71a3513a44586e9e9d12d349a6c41f87.png" alt="image-20210819102205544"></p> 
<h3><a id="122_SVM_19"></a>1.2.2 <strong>SVM分类</strong></h3> 
<p>​ 将2000×4096维特征与20个SVM组成的权值矩阵4096×20相乘（<font color="red">不需要映射到高维上面的吗？</font>）， 获得2000×20维矩阵表示每个建议框是某个目标类别的得分。分别对上述2000×20维矩阵中每一列即每一类进行<strong>非极大值抑制</strong>剔除一些建议框，得到该列即该类中得分最高的一些建议框。</p> 
<p><img src="https://img-blog.csdnimg.cn/img_convert/56bfb974e2bfdb7ba9dc458116d374f4.png" alt="image-20210819111426165"></p> 
<p>使用20个SVM的原因：这里是假设有二十个类别。而SVM是一个二分类，所以20个SVM就可以进行20个分类.</p> 
<h3><a id="123__27"></a>1.2.3 非极大值抑制剔除建议框</h3> 
<p>​ 选出每一类（列）中SVM得分最高的建议框A，然后计算A和其他建议框的IOU值。假设A和B的IOU值大于给定阈值，这就说明A和B重合过多，就剔除B。因为重合过多就说明A和B实际框住的是同一个物体，但是A的得分高，效果更好，故保留A剔除B。当阈值的设置合适时，就可以保证每个物体上只有一个框。每一行只保留得分最高的类别，此类别就是框住的类别。</p> 
<p>存在的问题：</p> 
<ul><li>当两物体之间的距离很近且给定的阈值太小时，那么容易导致两个物体中有一个物体的框被剔除掉（漏检）</li><li>不能保证每个物体都有框（漏检）</li><li>如果A框到没有物体的地方或A与其他框的重合不多，就会导致A被保留下来(误检)</li></ul> 
<h3><a id="124__37"></a>1.2.4 修正候选区域</h3> 
<p>​ 对NMS处理后剩余的建议框进一步筛选。接着分别用20个回归器对上述20个类别中剩余的建议框进行回</p> 
<p>归操作，最终得到每个类别的修正后的得分最高的 bounding box。 <font color="red">如何进行回归操作呢</font>？</p> 
<p>如下图，黄色框口P表示建议框Region Proposal， 绿色窗口G表示实际框Ground Truth，红色窗口</p> 
<p>表示Region Proposal进行回归后的预测窗口，可以用 最小二乘法解决的线性回归问题。</p> 
<p><img src="https://img-blog.csdnimg.cn/img_convert/4f4f44a9f000a0a2200fe5f999a4ba56.png" alt="image-20210819153520861"></p> 
<h2><a id="13_RCNN_51"></a>1.3 RCNN存在的问题</h2> 
<p>1.测试速度慢： 测试一张图片约53s(CPU)。用Selective Search算法 提取候选框用时约2秒，一张图像内<strong>候选框之间存在大</strong> <strong>量重叠</strong>，提取特征操作冗余。</p> 
<p>2.训练速度慢： 过程及其繁琐</p> 
<p>3.训练所需空间大： 对于SVM和bbox（bounding box）回归训练，需要从每个图像中的每个目标候选框提取特征，并写入磁盘。对于非常深的网络（ <font color="red">和网络深浅有什么关系？</font>），如VGG16，从VOC07 训练集上的5k张图像上提取的特征需要数百GB的存储空间。</p> 
<h1><a id="2Fast_RCNN_59"></a>2.Fast RCNN</h1> 
<h2><a id="21_Fast_RCNN_61"></a>2.1 Fast RCNN的总述</h2> 
<p>1.得到候选框：利用ss算法（Selective Search）在一张图像生成1K~2K个候选区域，随机选取64个候选区域</p> 
<p>2.特征提取：将整张图像输入网络得到相应的<strong>特征图</strong>，将SS算法生成的候选框投影到特征图上获得相应的<strong>特征矩阵</strong></p> 
<p>3.一个神经网络进行分类和生成bbox的回归参数：将每个特征矩阵通过ROI pooling层缩放到<strong>7x7大小的特征图</strong>，接着将特征图展平通过一系列全连接层得到目标所属的类别和bbox的回归参数 。（ROI:Region of Interest）</p> 
<p>Fast RCNN与RCNN区别：RCNN中是输入特征区域对应的图像（227x227）得到相应的特征向量，然后将特征向量输入到SVM进行分类、利用回归器修正候选区域位置</p> 
<h2><a id="22_Fast_RCNN_71"></a>2.2 Fast RCNN的细节详述</h2> 
<h3><a id="221__73"></a>2.2.1 候选区域选取</h3> 
<p>​ 随机选取候选区域：在Fast RCNN中并没有使用所有的候选框，而是随机从正样本和负样本拿出总共64个。正样本是指候选框与真实值之间的IOU值大于0.5。负样本是指候选框与真实值之间的IOU值在[0.1,0.5)，且是从IOU最大的开始采样（先采样正样本，其余的从负样本的最大IOU开始取，总共取64个）。</p> 
<h3><a id="222_ROI_pooling_77"></a>2.2.2 ROI pooling层缩放</h3> 
<p>​ 首先将每个候选框的特征图分割成7*7，总共49块，然后对每一块进行max pooling（每块中取像素最大的点）。</p> 
<p><img src="https://img-blog.csdnimg.cn/img_convert/5594e392cc7edac9dae907d2541610ed.png" alt="image-20210820010149951"></p> 
<p>注：特征图肯定不是上图那个样子，这里只是为了方便而这么画的</p> 
<h3><a id="223bbox_85"></a>2.2.3.分类器和bbox回归器</h3> 
<p><img src="https://img-blog.csdnimg.cn/img_convert/d0e5a05c7aa9b0e34d40561dd46c4686.png" alt="image-20210820011003487"></p> 
<p>上图中除了上面标注FCs以外的所有长方体块都是表示图像的矩阵。</p> 
<p>从上图可知，</p> 
<ul><li> <p>首先将整张图片输入进行特征提取的到特征图。</p> </li><li> <p>然后将候选框在特征图中框出的区域输入到ROI pooling层中，得到7*7的矩阵。</p> </li><li> <p>再将7*7矩阵展平以后输入到两个全连接层中得到ROI feature vector。</p> </li><li> <p>然后将ROI feature vector分别输入到两个不同的全连接层得到分类的结果和bbox的回归参数。输出分类结果的部分就叫分类器，输出bbox回归参数的就叫做bbox回归器。</p> </li></ul> 
<p><strong>分类器</strong>：输出N+1个类别的概率（N为检测目标的种类, 1为背景）共N+1个节点 。N+1个概率相加的结果为1。</p> 
<p><strong>bbox回归器</strong>：输出对应N+1个类别的候选边界框回归参数(d<sub>x</sub>, d<sub>y</sub>, d<sub>w</sub>, d<sub>h</sub>),即输出共(N+1)x4个节点。利用这些参数就可以计算出最终的预测框，计算公式如下：<font color="red">一个候选框预测出N+1个预测框吗？答：分类器得出此候选框属于哪一类，bbox回归器得出此候选框的此类的最终预测框</font></p> 
<p><img src="https://img-blog.csdnimg.cn/img_convert/f0f3ff5ae3ef0c0aa2e9c77b90eb6264.png" alt="image-20210824152026231"></p> 
<p>这里的d<sub>x</sub>§是d<sub>x</sub>的意思。</p> 
<p>解释以下第一个公式<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        
         
          G
         
         
          x
         
        
        
         ^
        
       
       
        =
       
       
        
         P
        
        
         w
        
       
       
        
         d
        
        
         x
        
       
       
        (
       
       
        P
       
       
        )
       
       
        +
       
       
        
         P
        
        
         x
        
       
      
      
       \widehat{G_x}=P_wd_x(P)+P_x
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.07333em; vertical-align: -0.15em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.92333em;"><span class="" style="top: -3em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.151392em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span><span class="svg-align" style="top: -3.68333em;"><span class="pstrut" style="height: 3em;"></span><span class="" style="height: 0.24em;">
           <svg width="100%" height="0.24em" viewBox="0 0 1062 239" preserveAspectRatio="none">
            <path d="M529 0h5l519 115c5 1 9 5 9 10 0 1-1 2-1 3l-4 22
c-1 5-5 9-11 9h-2L532 67 19 159h-2c-5 0-9-4-11-9l-5-22c-1-6 2-12 8-13z"></path>
           </svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.151392em;"><span class="" style="top: -2.55em; margin-left: -0.13889em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right: 0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.151392em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.13889em;">P</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.83333em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.151392em;"><span class="" style="top: -2.55em; margin-left: -0.13889em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>：这里的就是利用参数<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        
         d
        
        
         x
        
       
       
        (
       
       
        P
       
       
        )
       
      
      
       d_x(P)
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.151392em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.13889em;">P</span><span class="mclose">)</span></span></span></span></span>和<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        
         P
        
        
         w
        
       
      
      
       P_w
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.83333em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.151392em;"><span class="" style="top: -2.55em; margin-left: -0.13889em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right: 0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>来调节<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        
         P
        
        
         x
        
       
      
      
       P_x
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.83333em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.151392em;"><span class="" style="top: -2.55em; margin-left: -0.13889em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>使其变得更加准确。可以更加准确的原因是最终的预测框会与真实框进行比较，然后调节参数<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        
         d
        
        
         x
        
       
      
      
       d_x
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.84444em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.151392em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>，使得这个参数可以调节预测框去接近真实框。<font color="red">是这个公式，而不是其他的，作者是怎么得出这个公式的？？</font></p> 
<h3><a id="224__115"></a>2.2.4 损失函数</h3> 
<p><img src="https://img-blog.csdnimg.cn/img_convert/16a5cf58faf3898d26bba913a76518a3.png" alt="image-20210824155245323"></p> 
<p><font color="red">这里的v是是什么意思，我不太明白?</font></p> 
<p>L<sub>cls</sub>(p,u) = - logp<sub>u</sub>，这里的P<sub>u</sub>代表预测类别为u的概率</p> 
<p><span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml">
     
      
       
        
         
          L
         
         
          l
         
        
        
         o
        
        
         c
        
        
         (
        
        
         
          t
         
         
          u
         
        
        
         ,
        
        
         v
        
        
         )
        
        
         =
        
        
         
          ∑
         
         
          
           i
          
          
           ∈
          
          
           
            {
           
           
            x
           
           
            ,
           
           
            y
           
           
            ,
           
           
            w
           
           
            ,
           
           
            h
           
           
            }
           
          
         
        
        
         s
        
        
         m
        
        
         o
        
        
         o
        
        
         t
        
        
         
          h
         
         
          
           L
          
          
           1
          
         
        
        
         (
        
        
         
          t
         
         
          i
         
         
          u
         
        
        
         −
        
        
         
          v
         
         
          i
         
        
        
         )
        
       
       
         L_loc(t^u,v) = \sum_{i\in {\{x,y,w,h\}}}smooth_{L_1}(t_i^u-v_i)
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.336108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right: 0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mord mathdefault">o</span><span class="mord mathdefault">c</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.714392em;"><span class="" style="top: -3.113em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">u</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 2.56601em; vertical-align: -1.51601em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.05001em;"><span class="" style="top: -1.80899em; margin-left: 0em;"><span class="pstrut" style="height: 3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">∈</span><span class="mord mtight"><span class="mopen mtight">{<!-- --></span><span class="mord mathdefault mtight">x</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right: 0.03588em;">y</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right: 0.02691em;">w</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">h</span><span class="mclose mtight">}</span></span></span></span></span><span class="" style="top: -3.05em;"><span class="pstrut" style="height: 3.05em;"></span><span class=""><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 1.51601em;"><span class=""></span></span></span></span></span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">o</span><span class="mord mathdefault">t</span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.328331em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.317314em;"><span class="" style="top: -2.357em; margin-left: 0em; margin-right: 0.0714286em;"><span class="pstrut" style="height: 2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.143em;"><span class=""></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2501em;"><span class=""></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.714392em;"><span class="" style="top: -2.453em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span><span class="" style="top: -3.113em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">u</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.247em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.311664em;"><span class="" style="top: -2.55em; margin-left: -0.03588em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></span>：就是两框之间的差距</p> 
<p><span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        s
       
       
        m
       
       
        o
       
       
        o
       
       
        t
       
       
        
         h
        
        
         
          L
         
         
          1
         
        
       
       
        (
       
       
        x
       
       
        )
       
       
        =
       
       
        
         {
        
        
         
          
           
            
             
              0.5
             
             
              
               x
              
              
               2
              
             
             
              ,
             
            
           
          
          
           
            
             
              i
             
             
              f
             
             
              ∣
             
             
              x
             
             
              ∣
             
             
              &lt;
             
             
              1
             
            
           
          
         
         
          
           
            
             
              ∣
             
             
              x
             
             
              ∣
             
             
              −
             
             
              0.5
             
             
              ,
             
            
           
          
          
           
            
             
              o
             
             
              t
             
             
              h
             
             
              e
             
             
              r
             
             
              w
             
             
              i
             
             
              s
             
             
              e
             
            
           
          
         
        
       
      
      
       smooth_{L_1}(x)= \left\{ \begin{array}{lr} 0.5x^2, &amp; if |x|&lt;1 \\ |x|-0.5, &amp; otherwise \end{array} \right.
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.0001em; vertical-align: -0.2501em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">o</span><span class="mord mathdefault">t</span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.328331em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.317314em;"><span class="" style="top: -2.357em; margin-left: 0em; margin-right: 0.0714286em;"><span class="pstrut" style="height: 2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.143em;"><span class=""></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2501em;"><span class=""></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 2.40003em; vertical-align: -0.95003em;"></span><span class="minner"><span class="mopen delimcenter" style="top: 0em;"><span class="delimsizing size3">{<!-- --></span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width: 0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.45em;"><span class="" style="top: -3.61em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">.</span><span class="mord">5</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.814108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mpunct">,</span></span></span><span class="" style="top: -2.41em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord">∣</span><span class="mord mathdefault">x</span><span class="mord">∣</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">5</span><span class="mpunct">,</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.95em;"><span class=""></span></span></span></span></span><span class="arraycolsep" style="width: 0.5em;"></span><span class="arraycolsep" style="width: 0.5em;"></span><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.45em;"><span class="" style="top: -3.61em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span><span class="mord">∣</span><span class="mord mathdefault">x</span><span class="mord">∣</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mord">1</span></span></span><span class="" style="top: -2.41em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathdefault">o</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right: 0.02778em;">r</span><span class="mord mathdefault" style="margin-right: 0.02691em;">w</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.95em;"><span class=""></span></span></span></span></span><span class="arraycolsep" style="width: 0.5em;"></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p> 
<p><span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        
         v
        
        
         x
        
       
       
        =
       
       
        
         
          
           G
          
          
           x
          
         
         
          −
         
         
          
           P
          
          
           x
          
         
        
        
         
          P
         
         
          w
         
        
       
      
      
       v_x=\frac{G_x-P_x}{P_w}
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.58056em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.151392em;"><span class="" style="top: -2.55em; margin-left: -0.03588em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1.33353em; vertical-align: -0.4451em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.888431em;"><span class="" style="top: -2.655em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right: 0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.164543em;"><span class="" style="top: -2.357em; margin-left: -0.13889em; margin-right: 0.0714286em;"><span class="pstrut" style="height: 2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right: 0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.143em;"><span class=""></span></span></span></span></span></span></span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.4101em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.164543em;"><span class="" style="top: -2.357em; margin-left: 0em; margin-right: 0.0714286em;"><span class="pstrut" style="height: 2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.143em;"><span class=""></span></span></span></span></span></span><span class="mbin mtight">−</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right: 0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.164543em;"><span class="" style="top: -2.357em; margin-left: -0.13889em; margin-right: 0.0714286em;"><span class="pstrut" style="height: 2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.143em;"><span class=""></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.4451em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span>：<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        
         G
        
        
         x
        
       
      
      
       G_x
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.83333em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.151392em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>为真实框对应的x</p> 
<p>[u=&gt;1]：方括号内的条件满足则为1，不满足则为0。当u=0时表示背景，而当u为其他大于一的数时表示类别标签。也就是说当框内的东西为背景时，是没有边界框回归损失，因为背景可没有被框住。</p> 
<p><a href="https://www.cnblogs.com/wangguchangqing/p/12021638.html">损失函数的理解可以参考这个</a></p> 
<h2><a id="23_Fast_RCNNRCNN_141"></a>2.3 Fast RCNN与RCNN框架之间的对比</h2> 
<p><img src="https://img-blog.csdnimg.cn/img_convert/489ddff9bc684add9224b21d38cc71fa.png" alt="image-20210824194543724"></p> 
<p><img src="https://img-blog.csdnimg.cn/img_convert/d0c921600ade60591eab5d9a2426310b.png" alt="image-20210824194507042"></p> 
<p>Fast RCNN特征提取、分类、参数回归都融合成在了一个CNN网络中了，而RCNN分成了三个部分。</p> 
<h1><a id="3Faster_RCNN_151"></a>3.Faster RCNN</h1> 
<p>​ 同样使用VGG16作为网络的backbone(主干)，推理速度在GPU上达到5fps(包括候选区域的生成)，准确率也有进一步的提升。</p> 
<p>Faster RCNN=Fast RCNN+RPN</p> 
<h2><a id="31_Faster_RCNN_157"></a>3.1 Faster RCNN的总述</h2> 
<p>1.得到候选框：将整张图像输入conv层得到特征图，将特征图输入到RPN中得到候选框</p> 
<p>2.特征提取：将RPN生成的候选框投影到特征图上获得相应的<strong>特征矩阵</strong></p> 
<p>3.一个神经网络进行分类和生成bbox的回归参数：将每个特征矩阵通过ROI pooling层缩放到<strong>7x7大小的特征图</strong>，接着将特征图展平通过一系列全连接层得到目标所属的类别和bbox的回归参数 。（ROI:Region of Interest）</p> 
<p>Faster RCNN与Fast RCNN的区别：Faster RCNN利用RPN获取候选框。Fast RCNN利用ss算法获取候选框。</p> 
<p>下图是Faster RCNN的整体架构</p> 
<p><img src="https://img-blog.csdnimg.cn/img_convert/1e4558424a77f750de73c88b8e0c4969.png" alt="image-20210824210043488"></p> 
<h2><a id="32_RPNRegion_Proposal_Network_173"></a>3.2 RPN(Region Proposal Network)</h2> 
<h3><a id="321_RPN_175"></a>3.2.1 RPN的构成</h3> 
<p>​ RPN的作用是筛选出可能会有目标的框”。RPN是用一个全卷积网络来实现的，可以与检测网络共享整幅图像的卷积特征，从而产生几乎无代价的区域推荐。</p> 
<p><img src="https://img-blog.csdnimg.cn/img_convert/910fc8802fea1182d41050c74679f2b1.png" alt="image-20210824210323801"></p> 
<p>​ <strong>图中右边的解释</strong>：sliding window（滑动窗口）在 conv feature map（特征图）滑动。每滑动到一个区域，输出一个一维的向量（256个元素）。将这个一维向量分别输入到两个全连接层中，分别产生2k个score和4k个coordinate。下面对上面这句话进行补充解释：</p> 
<p>​ <strong>一维向量的生成</strong>：一维向量有256个元素，这是因为特征图是由ZF生成的，ZF生成的特征图有256个channel。如果特征图是由VGG16生成的话，特征图就有512个channel，此时一维向量就有512个元素。一维向量的生成过程为：利用256或512个3*3的conv（步长为1，padding为全零填充）在特征图上滑动，从而生成一个和特征图shape一致的图，这个图的每一个像素点下的256或512个channel都代表一个上面提到的一维向量。每个一维向量都预测出k个anchor box（论文种k=9）。</p> 
<p>​ <strong>9个anchor box</strong>：k代表k个anchor box，anchor boxes指的是以滑动窗口中心点对应原始图像上的中心点为中心的一些框。k一般为9，即9种anchor box。9种anchor box：anchor box的大小有{<!-- --><span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        12
       
       
        
         8
        
        
         2
        
       
       
        ,
       
       
        25
       
       
        
         6
        
        
         2
        
       
       
        ,
       
       
        51
       
       
        
         2
        
        
         2
        
       
      
      
       128^2,256^2,512^2
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.00855em; vertical-align: -0.19444em;"></span><span class="mord">1</span><span class="mord">2</span><span class="mord"><span class="mord">8</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.814108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord">2</span><span class="mord">5</span><span class="mord"><span class="mord">6</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.814108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord">5</span><span class="mord">1</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.814108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span>}三种，anchor box的宽高比例有{1:1,1:2,2:1}三种。所以在每个位置（每个滑动窗口）在原图上都对应3*3=9个anchor（作者说这些是经验所得）。下面是9个anchor的示意图：</p> 
<p><img src="https://img-blog.csdnimg.cn/img_convert/fa28b9e42dd8a548a952249acef7e7ed.png" alt="image-20210825095139040"></p> 
<p>​ 那么问题来了！ZF感受野是 171 ，VGG感受野是 228 （感受野：特征图的一个像素点对应原图多大一块），对于VGG来说，输入网络的一维向量只能代表原图中<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        22
       
       
        
         8
        
        
         2
        
       
      
      
       228^2
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.814108em; vertical-align: 0em;"></span><span class="mord">2</span><span class="mord">2</span><span class="mord"><span class="mord">8</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.814108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span>大小的面积，而在预测到的anchor中有两种面积是大于<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        22
       
       
        
         8
        
        
         2
        
       
      
      
       228^2
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.814108em; vertical-align: 0em;"></span><span class="mord">2</span><span class="mord">2</span><span class="mord"><span class="mord">8</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.814108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span>，分别为：{<!-- --><span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        25
       
       
        
         6
        
        
         2
        
       
       
        ,
       
       
        51
       
       
        
         2
        
        
         2
        
       
      
      
       256^2,512^2
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.00855em; vertical-align: -0.19444em;"></span><span class="mord">2</span><span class="mord">5</span><span class="mord"><span class="mord">6</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.814108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord">5</span><span class="mord">1</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.814108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span>}。为什么可以通过面积小的预测出面积大的区域呢？答：比如你看到一个物体的一部分就可以猜出这个物体是什么。</p> 
<p>​ <strong>anchor box的两个预测值</strong>：每个anchor box有两个score，分别表示anchor box中为背景的概率和anchor box中为目标的概率，两个score相加不一定为一。每个anchor box有四个coordinate，这四个coordinate是anchor box的回归参数(d<sub>x</sub>, d<sub>y</sub>, d<sub>w</sub>, d<sub>h</sub>)，通过(d<sub>x</sub>, d<sub>y</sub>, d<sub>w</sub>, d<sub>h</sub>)将anchor box调整成proposal（候选框）。</p> 
<p>​ score和coordinate的形成：利用2k个1*1的卷积核对256-d进行卷积，从而使得每一个像素点对应的一维向量都输出2k个score。利用4k个1*1的卷积核对256-d进行卷积，从而使得每一个像素点对应的一维向量都输出4k个coordinate。<font color="red">这里的score核coordinate为什么是对应的？明明是通过两个不同的全连接层生成的？</font></p> 
<p><img src="https://img-blog.csdnimg.cn/img_convert/1749f113620cadfe7252bcbeff0fca26.png" alt="image-20210825152538419"></p> 
<p>​ <strong>候选框最终的确定（举例）</strong>：对于一张1000x600x3的图像，大约有60x40x9=20k个anchor，忽略跨越边界的anchor以后，剩下约6k个anchor。将6k个anchor通过(d<sub>x</sub>, d<sub>y</sub>, d<sub>w</sub>, d<sub>h</sub>)调整成6k个proposal（候选框）。候选框之间存在大量重叠，基于候选框的<em>cls</em>得分，采用非极大值抑制剔除重叠框，IoU设为0.7，这样每张图片只剩2k个候选框。</p> 
<h3><a id="322_RPN_199"></a>3.2.2 RPN的训练与损失函数</h3> 
<p><strong>训练RPN过程中的数据采样</strong>：在一张图片中所有的anchor中采样256个anchor，这256个anchor中有128个正样本和128个负样本。如果正样本不足128个，就用负样本填充，如正样本有100个，那负样本就有156个。</p> 
<p>正样本：i)样本与gt的IOU大于0.7。ii)样本是与gt相交中IOU最大的</p> 
<p>负样本：与所有的gt的IOU都小于0.3的样本</p> 
<p><strong>RPN的损失函数</strong>：</p> 
<p><img src="https://img-blog.csdnimg.cn/img_convert/fadab1d5a8f3da950f69fd3c7779a789.png" alt="image-20210825162314584"></p> 
<p><span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        
         p
        
        
         i
        
       
      
      
       p_i
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.311664em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>表示第i个anchor中真实标签的score，如某一个anchor的目标和背景的score分别为0.9和0.2，若anchor中是背景，那么<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        
         p
        
        
         i
        
       
       
        =
       
       
        −
       
       
        l
       
       
        n
       
       
        0.2
       
      
      
       p_i=-ln0.2
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.311664em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.77777em; vertical-align: -0.08333em;"></span><span class="mord">−</span><span class="mord mathdefault" style="margin-right: 0.01968em;">l</span><span class="mord mathdefault">n</span><span class="mord">0</span><span class="mord">.</span><span class="mord">2</span></span></span></span></span>。</p> 
<p>各个参数的意义：</p> 
<p><span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        
         p
        
        
         i
        
        
         ∗
        
       
      
      
       p^*_i
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.94736em; vertical-align: -0.258664em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.688696em;"><span class="" style="top: -2.44134em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.258664em;"><span class=""></span></span></span></span></span></span></span></span></span></span>当为正样本时为 1，当为负样本时为 0。</p> 
<p><span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        
         t
        
        
         i
        
       
      
      
       t_i
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.76508em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.311664em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>表示预测第 i个anchor的边界框回归参数。</p> 
<p><span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        
         t
        
        
         i
        
        
         ∗
        
       
      
      
       t^*_i
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.94736em; vertical-align: -0.258664em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.688696em;"><span class="" style="top: -2.44134em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.258664em;"><span class=""></span></span></span></span></span></span></span></span></span></span>表示第i个anchor对应的gt的边界框回归参数。</p> 
<p><span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        
         N
        
        
         
          c
         
         
          l
         
         
          s
         
        
       
      
      
       N_{cls}
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.83333em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.336108em;"><span class="" style="top: -2.55em; margin-left: -0.10903em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight" style="margin-right: 0.01968em;">l</span><span class="mord mathdefault mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>表示一个min-batch中的所有样本数量，即一次采样的数量，即256。</p> 
<p><span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        
         N
        
        
         
          r
         
         
          e
         
         
          g
         
        
       
      
      
       N_{reg}
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.969438em; vertical-align: -0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.151392em;"><span class="" style="top: -2.55em; margin-left: -0.10903em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right: 0.02778em;">r</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight" style="margin-right: 0.03588em;">g</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.286108em;"><span class=""></span></span></span></span></span></span></span></span></span></span>表示特征图上像素点的个数，约2400个。</p> 
<p>补充解释：</p> 
<p>为了简单，经常将<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        λ
       
       
        
         1
        
        
         
          N
         
         
          
           r
          
          
           e
          
          
           g
          
         
        
       
      
      
       \lambda\frac{1}{N_{reg}}
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.38743em; vertical-align: -0.54232em;"></span><span class="mord mathdefault">λ</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.845108em;"><span class="" style="top: -2.655em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right: 0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.164543em;"><span class="" style="top: -2.357em; margin-left: -0.10903em; margin-right: 0.0714286em;"><span class="pstrut" style="height: 2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right: 0.02778em;">r</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight" style="margin-right: 0.03588em;">g</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.281886em;"><span class=""></span></span></span></span></span></span></span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.394em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.54232em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span>令成<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        
         1
        
        
         
          N
         
         
          
           c
          
          
           l
          
          
           s
          
         
        
       
      
      
       \frac{1}{N_{cls}}
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.29597em; vertical-align: -0.45086em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.845108em;"><span class="" style="top: -2.655em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right: 0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3448em;"><span class="" style="top: -2.34877em; margin-left: -0.10903em; margin-right: 0.0714286em;"><span class="pstrut" style="height: 2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight" style="margin-right: 0.01968em;">l</span><span class="mord mathdefault mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.151229em;"><span class=""></span></span></span></span></span></span></span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.394em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.45086em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span>，因为两者差不多。</p> 
<p><span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        
         L
        
        
         
          c
         
         
          l
         
         
          s
         
        
       
      
      
       L_{cls}
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.83333em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.336108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight" style="margin-right: 0.01968em;">l</span><span class="mord mathdefault mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>为softmax cross entropy，而不是BInary cross entropy，即某一个anchor的目标和背景的score分别为0.9和0.2。若anchor中是目标，那么<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        
         p
        
        
         i
        
       
       
        =
       
       
        −
       
       
        l
       
       
        n
       
       
        0.9
       
      
      
       p_i=-ln0.9
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.311664em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.77777em; vertical-align: -0.08333em;"></span><span class="mord">−</span><span class="mord mathdefault" style="margin-right: 0.01968em;">l</span><span class="mord mathdefault">n</span><span class="mord">0</span><span class="mord">.</span><span class="mord">9</span></span></span></span></span>。</p> 
<p>如果这里<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        
         L
        
        
         
          c
         
         
          l
         
         
          s
         
        
       
      
      
       L_{cls}
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.83333em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.336108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight" style="margin-right: 0.01968em;">l</span><span class="mord mathdefault mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>为BInary cross entropy时，每个anchor只需要一个score而不是两个。假设当背景的score为0.2时，就可以推断出目标的score为0.8。若anchor中是目标，则<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        
         p
        
        
         i
        
       
       
        =
       
       
        −
       
       
        l
       
       
        n
       
       
        0.8
       
      
      
       p_i=-ln0.8
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.311664em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.77777em; vertical-align: -0.08333em;"></span><span class="mord">−</span><span class="mord mathdefault" style="margin-right: 0.01968em;">l</span><span class="mord mathdefault">n</span><span class="mord">0</span><span class="mord">.</span><span class="mord">8</span></span></span></span></span>。</p> 
<p>这里的边界框回归损失和Fast RCNN中的是一样的。</p> 
<h2><a id="33_Faster_RCNN_237"></a>3.3 Faster RCNN的损失函数</h2> 
<p><img src="https://img-blog.csdnimg.cn/img_convert/f054257bb75b0ba8938305a86be630df.png" alt="image-20210825192047433"></p> 
<p>与Fast RCNN的损失函数完全一致。</p> 
<h2><a id="34_Faster_RCNN_243"></a>3.4 Faster R-CNN的训练过程</h2> 
<p>原论文中采用分别训练RPN以及Fast R-CNN的方法 <font color="red">看不懂！！</font>：</p> 
<p>(1)利用ImageNet预训练分类模型初始化前置卷积网络层参数，并开始单独训练RPN网络参数；</p> 
<p>(2)固定RPN网络独有的卷积层以及全连接层参数，再利用ImageNet预训练分类模型初始化前置卷积网络参数，并利用RPN 网络生成的目标建议框去训练Fast RCNN网络参数。</p> 
<p>(3)固定利用Fast RCNN训练好的前置卷积网络层参数，去微调RPN网络独有的卷积层以及全连接层参数。</p> 
<p>(4)同样保持固定前置卷积网络层参数，去微调Fast RCNN网络的全连接层参数。最后RPN网络与Fast RCNN网络共享前置卷积网络层参数，构成一个统一网络。</p> 
<p>现在一般不采用原论文的方式，而直接采用RPN Loss+ Fast R-CNN Loss的联合训练方法 。</p> 
<h2><a id="35_Faster_RCNNFast_RCNNRCNN_257"></a>3.5 Faster RCNN、Fast RCNN与RCNN框架之间的对比</h2> 
<p><img src="https://img-blog.csdnimg.cn/img_convert/0cb919096639eb2b1a793180e822da8b.png" alt="image-20210825193050416"></p> 
<p>Fast RCNN特征提取、分类、参数回归都融合成在了一个CNN网络中了，而RCNN分成了三个部分。</p> 
<p>Faster RCNN进一步将所有过程都融入了CNN中。</p> 
<h2><a id="_267"></a>小知识补充：</h2> 
<h3><a id="_269"></a>计算感受野</h3> 
<p>计算Faster RCNN中ZF网络feature map 中3x3滑动窗口在原图中感受野的大小。<font color="red">为什么这么计算呢？</font></p> 
<p><img src="https://img-blog.csdnimg.cn/img_convert/168b7721a4faf75bac8f55788610822d.png" alt="image-20210825103950358"></p> 
<h3><a id="1x1_275"></a>1x1卷积核</h3> 
<p>1x1卷积核改变输出通道数（channels），而不改变输出的宽度和高度。1x1卷积的作用是减少或增加channel的数量（降维\升维、跨通道信息交互。（<a href="https://zhuanlan.zhihu.com/p/40050371">参考此链接</a>）</p> 
<h1><a id="4_FPNFeature_Pyramid_Networks_279"></a>4. FPN(Feature Pyramid Networks)</h1> 
<p><img src="https://img-blog.csdnimg.cn/img_convert/d20ba222afb15d9327ece00b1eb869d9.png" alt="image-20210828141402246"></p> 
<p>（a）将图片缩放到不同的大小，并将对不同大小的图片进行预测。此种方法要进行多次预测，效率很低。</p> 
<p>（b）通过backbone（主干网络）得到最终的特征图，然后在特征图上进行预测，此种方法就是Fast RCNN中用到的方法。此种方法对小目标的预测效果不佳，这是因为大目标占有的像素点比较多，小目标占有的像素点比较少，即小目标对特征图的形成起到的作用比较小，即特征图中包含较少的小目标的信息。</p> 
<p>（c）对每一层产生的特征图进行预测，和SDD算法类似</p> 
<p>（d）对不同的特征图进行融合，也就是FPN。下图是FPN网络的一些细节。</p> 
<p><img src="https://img-blog.csdnimg.cn/img_convert/9a25383c68cf8eaec112af6eeeb8657f.png" alt="image-20210828143249233"></p> 
<p>​ 可以看到，FPN将每一层的特征图都经过256个1*1的卷积核变成channel为256的特征图。然后上层的特征图通过上采样使得特征图的shape和下层的特征图的shape一样，最后两特征图的对应位置直接相加，从而实现融合。P2到P5的特征图用于Fast RCNN，P2到P6用于RPN。（Faster RCNN=Fast RCNN+RPN）</p> 
<p>​ Fast RCNN进行预测：对不同大小的目标采用不同的特征图进行预测，目标较小就使用较底层的特征图。因为较底层的特征图中小目标的信息损失没那么严重。这里的目标指的就是RPN得到候选框。通过以下公式得到此目标（候选框里的内容）需要利用哪个特征图进行预测：</p> 
<p>​ <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        k
       
       
        =
       
       
        ⌊
       
       
        
         k
        
        
         0
        
       
       
        +
       
       
        l
       
       
        o
       
       
        
         g
        
        
         2
        
       
       
        (
       
       
        
         
          
           w
          
          
           h
          
         
        
        
         244
        
       
       
        )
       
       
        ⌋
       
      
      
       k=\lfloor k_0+log_2(\frac{\sqrt {wh}}{244}) \rfloor
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.03148em;">k</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">⌊</span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: -0.03148em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1.39549em; vertical-align: -0.345em;"></span><span class="mord mathdefault" style="margin-right: 0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: -0.03588em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.05049em;"><span class="" style="top: -2.655em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">4</span><span class="mord mtight">4</span></span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.394em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord sqrt mtight"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.937845em;"><span class="svg-align" style="top: -3em;"><span class="pstrut" style="height: 3em;"></span><span class="mord mtight" style="padding-left: 0.833em;"><span class="mord mathdefault mtight" style="margin-right: 0.02691em;">w</span><span class="mord mathdefault mtight">h</span></span></span><span class="" style="top: -2.89785em;"><span class="pstrut" style="height: 3em;"></span><span class="hide-tail mtight" style="min-width: 0.853em; height: 1.08em;">
                   <svg width="400em" height="1.08em" viewBox="0 0 400000 1080" preserveAspectRatio="xMinYMin slice">
                    <path d="M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,
-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,
-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,
35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,
-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467
s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422
s-65,47,-65,47z M834 80H400000v40H845z"></path>
                   </svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.102155em;"><span class=""></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.345em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span><span class="mclose">⌋</span></span></span></span></span></p> 
<p>​ <span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        
         k
        
        
         0
        
       
       
        =
       
       
        4
       
      
      
       k_0=4
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.84444em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: -0.03148em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">4</span></span></span></span></span>,w和h是候选框的宽和高，k指的是特征图P的下标。</p> 
<p>​ RPN生成候选框：上一章中的Faster RCNN是在一个特征图上预测不同大小的anchor，但是在FPN中是在不同的特征图上预测不同大小的anchor，即P2到P6分别预测{<!-- --><span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        3
       
       
        
         2
        
        
         2
        
       
       
        ,
       
       
        6
       
       
        
         4
        
        
         2
        
       
       
        ,
       
       
        12
       
       
        
         8
        
        
         2
        
       
       
        ,
       
       
        25
       
       
        
         6
        
        
         2
        
       
       
        ,
       
       
        51
       
       
        
         2
        
        
         2
        
       
      
      
       32^2,64^2,128^2,256^2,512^2
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.00855em; vertical-align: -0.19444em;"></span><span class="mord">3</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.814108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord">6</span><span class="mord"><span class="mord">4</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.814108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord">1</span><span class="mord">2</span><span class="mord"><span class="mord">8</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.814108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord">2</span><span class="mord">5</span><span class="mord"><span class="mord">6</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.814108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord">5</span><span class="mord">1</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.814108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span>}，就是P2对应<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        3
       
       
        
         2
        
        
         2
        
       
      
      
       32^2
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.814108em; vertical-align: 0em;"></span><span class="mord">3</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.814108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span>、P3对应<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        6
       
       
        
         4
        
        
         2
        
       
      
      
       64^2
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.814108em; vertical-align: 0em;"></span><span class="mord">6</span><span class="mord"><span class="mord">4</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.814108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span>……。每一尺寸都对应三个比例，即{1:2,1:1,2:1}，如P2对应<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        3
       
       
        
         2
        
        
         2
        
       
      
      
       32^2
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.814108em; vertical-align: 0em;"></span><span class="mord">3</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.814108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span>，<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        3
       
       
        
         2
        
        
         2
        
       
      
      
       32^2
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.814108em; vertical-align: 0em;"></span><span class="mord">3</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.814108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span>又分为{1:2,1:1,2:1}。</p> 
<h1><a id="_307"></a>思考题</h1> 
<p>我对为什么这些人能想到这些优化和方法的理解？？</p>
                ]]></description></item><item><title>python和android通过MQTT通信（阿里云）</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522418.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Tue, 26 Jul 2022 11:51:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522418.html</guid><description><![CDATA[
                    <p>链接：https://pan.baidu.com/s/1VaDvLJXyJHzogcMFZOgPGA&nbsp;<br> 提取码：6666&nbsp;<br> &nbsp;</p>
                ]]></description></item><item><title>错误</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522419.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Tue, 26 Jul 2022 11:51:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522419.html</guid><description><![CDATA[
                    <pre> C:\projects\opencv-python\opencv\modules\highgui\src\window.cpp:356: error: (-215) size.width&gt;0 &amp;&amp; size.height&gt;0 in function cv::imshow</pre> 
<p>出现上面的错误说明，说明你读取的图片路径写错了</p>
                ]]></description></item><item><title>C8051单片机：外部引脚与功能、内部结构与单元</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522420.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Tue, 26 Jul 2022 11:51:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522420.html</guid><description><![CDATA[
                    <p>一，外部引脚与功能</p> 
<p>1，首先一个小圆坑或小标记指示第1引脚，然后逆时针数下去直到最后一个引脚第40引脚，典型51单片机有40个引脚（或管脚） 4组8个I/O口引脚，加8个特殊引脚，共40个。</p> 
<p>2，40个引脚按其功能分为三类：</p> 
<p>（1）I/O端口引脚，如P0，P1，P2，P3，4组8位并行I/O端口（32个）</p> 
<p>（2）电源和时钟引脚，如Vcc，GND，XTAL1，XTAL2（4个）</p> 
<p>（3）编程控制引脚，如RST，PSEN，ALE/PROG，EA/Vpp（4个）</p> 
<p>注意：/ 表示第二功能！</p> 
<p>3，各个外部引脚的功能</p> 
<p>（1）Vcc（第40脚）为电源正端 GND或Vss（第20脚）为接地端 。Vcc典型值值为+5V，最低+3.3V</p> 
<p>（2）XTAL1，XTAL2：8051时钟有两种方式：第一种是片内时钟振荡方式；第二种是外部时钟方式。</p> 
<p>片内时钟振荡方式：XTAL1为片内振荡电路输入端，XTAL2为内振荡电路输出端 。</p> 
<p>外部时钟方式：XTAL2接外时钟信号，&nbsp;XTAL1接地（或悬空）</p> 
<p>补充：1，一个机器周期 = 12个振荡周期 =6个状态周期；指令周期：即从取指、分析、到执行完所需时间</p> 
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2，AT89S51单片机的XTAL1端（第19管脚）、XTAL2（第18管脚）内部有一个片内振荡器结构，但仍然需要在XTAL1和XTAL2之间连接一个晶振Y1，并加上两个容量介于20~40pF的电容C1、C2组成自激振荡器时钟电路</p> 
<p>（3）RST/VPD（第9脚）为单片机复位引脚/备用电源输入端 。当连续出现两个机器周期以上高电平时为有效，单片机复位，完成复位初始化操作 ：PC=0000H，即从存储器第0000H单元读取指令，P0—P3端口输出高电平；SP寄存器为07H；其它寄存器全部清0</p> 
<p>（4）EA/Vpp（第31脚）为内部/外部ROM存储器选择端 。接高电平时，单片机先读取内部存储器，当有外部扩展ROM时，当读完内部ROM后自动读取外部ROM。 接低电平时，单片机直接读取外部ROM 。因为单片机都有内部ROM，所以设计电路时一般此引脚始终接高电平</p> 
<p>（5）PSEN（第29脚）为外部ROM程序存储器的读选通信号端 。接低电平有效，实现读取外部程序存储器单元，当读内部ROM时，第29脚不动作 由于现有单片机内部ROM足够大，几乎不再去扩展外部ROM，该引脚了解即可</p> 
<p>（6）ALE/PROG（30脚）为地址锁存信号输出端/EPROM编程脉冲输入端 。有外部访问时，ALE用于控制P0口的输出低8位地址送锁存器锁存起来，实现地址和数据隔离 。无外部访问时，提供1/6 fosc振荡频率，可做外部时钟或定时脉冲 当对内部RAM编写程序时，提供编程脉冲，现在较少用到</p> 
<p>（7）P0口：P0.0—P0.7（第32—39引脚）。 双向8位三态I/O端口，每个端口或引脚可独立控制，内部无上拉电阻，为高阻态，所以不能正常输出高/低电平。 使用时一般外接10K上拉电阻。P0口（第32—39引脚）是一个8位的开漏型双向I/O端口。P0口在作输入/输出口使用时需要添加外部上拉电阻</p> 
<p>第二功能访问外部RAM/ROM，分时发送低8位地址或读写数据；编程/校验8751时，输入输出片内ROM数据和代码</p> 
<p>（8）P1口：P1.0—P1.7（1—8脚）。 准双向8位通用I/0口，每个引脚可独立控制，内带上拉电阻，无高阻态，也不能锁存，故不是真正的双向I/O口，成为“准双向”</p> 
<p>第二功能，编程/校验8751时，接收低八位地址信号</p> 
<p>（9）P2口：P2.0—P2.7（第21—28引脚）。 准双向8位I/0口，每个引脚可独立控制，内带上拉电阻，与P1口类似</p> 
<p>P2端口的第二功能： 访问外部RAM/ROM，分时发送高8位地址或读写数据。 编程/校验8751时，接收高四位地址/控制信号</p> 
<p>（10）P3口：P3.0—P3.7（第10—17引脚）。 准双向8位多用途I/0口，每个引脚可独立控制，内带上拉电阻，作为第一功能使用时就作普通I/O口，与P1口类似。 作为第二功能使用时，定义如下表：</p> 
<p><img alt="" class="has" height="368" src="https://img-blog.csdnimg.cn/2019110310453189.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzc1OTM4,size_16,color_FFFFFF,t_70" width="824"></p> 
<p>&nbsp;</p> 
<p>二，内部结构与单元</p> 
<p>1，总线分为外部总线和内部总线</p> 
<p>（1）内部总线是CPU内部之间的连线</p> 
<p>（2）外部总线是指CPU与其它部件之间的连线，包括数据总线DB（Data &nbsp;Bus），地址总线 AB（Address &nbsp;Bus）和控制总线 CB（Control &nbsp; Bus）</p> 
<p>2，三条外部总线与单片机引脚的对应关系</p> 
<p>（1）地址总线—— AB：P0口提供（A7 ~ A0）； &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</p> 
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; P2口提供（A15 ~ A8），共16位</p> 
<p>（2）数据总线—— DB：P0口提供（D7 ~ D0），共8位。</p> 
<p>（3）控制总线—— CB：ALE 、EA、等</p> 
<p>3，单片机的内部单元</p> 
<p>（1）中央处理单元CPU（8位）：用于数据处理、位操作（位测试、置位、复位）</p> 
<p>（2）.只读存储器ROM（4KB）：用于永久性存储应用程序，掩膜ROM、EPROM、EEPROM、 &nbsp; &nbsp; &nbsp;Flash Memory(闪存)</p> 
<p>（3）随机存取存取器RAM（256B）：&nbsp;用于程序运行中存储工作变量和数据</p> 
<p>（4）并行输入/输出口 &nbsp; I / O（32线）：用作系统总线、扩展外存、I / O接口芯片</p> 
<p>（5）串行输入/输出口 &nbsp; UART &nbsp;（二线）：&nbsp;串行通信、扩展I / O接口芯片</p> 
<p>（6）定时/计数器 &nbsp;T（16位增量可编程）： 它与CPU之间各自独立工作，当它计数满时向CPU中断</p> 
<p>（7）时钟电路 &nbsp;fosc &nbsp;：&nbsp;分为内部振荡器、外接振荡电路</p> 
<p>（8）中断系统 ： 五源中断、两级优先，可编程进行控制</p> 
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<p>&nbsp;</p>
                ]]></description></item><item><title>windows常用快捷键</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522421.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Tue, 26 Jul 2022 11:51:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522421.html</guid><description><![CDATA[
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="windows%E5%BF%AB%E6%8D%B7%E9%94%AE-toc" style="margin-left:0px;"><a href="#windows%E5%BF%AB%E6%8D%B7%E9%94%AE">windows快捷键</a></p> 
<hr id="hr-toc">
<h1>windows快捷键</h1> 
<p>1，打开文件管理器（Win+ E）：文件夹</p> 
<p>2，打开云剪贴板（Win + V）：把你复制过的东西都放在这</p> 
<p>3，显示桌面（ Win+D）：返回桌面</p> 
<p>4，召唤Windows截图（Win + Shift + S）：</p> 
<p>5，虚拟桌面：</p> 
<p>win10中加入了对虚拟桌面的支持。虚拟桌面简单得说：就是保留现有桌面全部设置的情况下。打开一个全新的空白桌面供用户使用。适合在做现有工作的间中临时插入一套新工作进行。</p> 
<p>比如说你打开一堆表格和文档时，突然接到老板的加急任务。就可以打开一个新的虚拟桌面处理，完事以后还可以切换到原先打开的那堆表格中。又或者接了“私活”不想让老板发现，就可以创建一个虚拟桌面“藏在电脑中”随时可以切换出来。</p> 
<p>Win + Ctrl + D 创建虚拟桌面</p> 
<p>Win + Ctrl + F4 关闭当前虚拟桌面，虚拟桌面关闭后，虚拟桌面的内容会跑到邻近的桌面中</p> 
<p>Win + Ctrl + ← 向左切换虚拟桌面</p> 
<p>Win + Ctrl + → 向右切换虚拟桌面</p> 
<p>Win+Tab 唤起时间线：可以看到各个虚拟桌面，并编辑虚拟桌面名字</p> 
<p>6，Win+Tab 唤起时间线、Ctrl + Tab 切换窗口、Win+R 运行对话框、win:搜索</p> 
<p>7，win+↑:全屏、win+↓:退出全屏、win+←:靠左、win+→ :靠右</p> 
<p>8，Ctrl”+“Shift”+“N”：新建文件夹</p> 
<p>返回上一个文件夹可以按<a href="https://www.baidu.com/s?wd=backspace%E9%94%AE&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" title="backspace键">backspace键</a>或者Alt+←、↑键</p> 
<h1>chrome浏览器快捷键</h1> 
<p>1，切换页面：Ctrl+1&nbsp;到&nbsp;Ctrl+8&nbsp;切换到标签栏中指定位置编号所对应的标签页。<br> 没人会去数数。Ctrl+9&nbsp;切换到最后一个标签页。&nbsp;</p> 
<p>Ctrl+Tab&nbsp;：切换到下一个标签页。&nbsp;<br> Ctrl+Shift+Tab：切换到上一个标签页。&nbsp;<br> 2，<strong>Ctrl+T</strong>&nbsp;打开新标签页。</p> 
<p>.<strong>Ctrl+W</strong>&nbsp;关闭当前标签页或弹出式窗口</p> 
<p><strong>Ctrl+N</strong>&nbsp;打开新窗口。&nbsp;</p> 
<p>.<strong>Ctrl+Shift+N</strong>&nbsp;在隐身模式下打开新窗口。&nbsp;</p> 
<p><strong>Ctrl+Shift+W</strong>&nbsp;关闭当前窗口。&nbsp;</p> 
<p>4，按 Alt 和向左箭头键。 转到当前标签页浏览历史记录中的上一页。&nbsp;<br> 按 Alt 和向右箭头键。 转到当前标签页浏览历史记录中的下一页。&nbsp;</p> 
<p>5，输入网址：xxx，按Ctrl+Enter，就会在网址xxx的两边自动加上www.xxx.com</p> 
<p>Ctrl+L:定位到输入框；Alt+Enter在新窗口中打开页面</p>
                ]]></description></item><item><title>python django 错误</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522422.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Tue, 26 Jul 2022 11:51:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522422.html</guid><description><![CDATA[
                    <pre class="has"><code class="language-html"> 1，“ { % if verified %}
        &lt;em&gt;你通过了验证&lt;/em&gt;
    { % else % }
        &lt;em&gt;密码或账号打错了&lt;/em&gt;
    { % endif % }” 被直接打印出来？
解决方法：将“{”和“%”的之间的空格去掉</code></pre>
                ]]></description></item><item><title>安卓开发：ListView</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522423.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Tue, 26 Jul 2022 11:51:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522423.html</guid><description><![CDATA[
                    <p>一，listView简介</p> 
<p>1，listView的功能：显示列表</p> 
<p>2，创建ListView的三要素：（1）布局（决定每一行可以显示什么东西）（2）<span style="color:#323232;">数据：填入View的文字、图片等内容，或者是某些基本组件； （3）适配器：布局和数据都是先放在这里面的，然后再用ListView1.setAdapter(适配器）来设置ListView1中显示什么东西，即将ListView绑定到适配器上。</span></p> 
<div>
 <span style="color:#000000;">3，适配器有几种呢？</span>
</div> 
<div>
 <span style="color:#000000;">（1）ArrayAdapter</span>
 <span style="color:#000000;">，用来绑定一个数组，显 示一行文字； </span>
</div> 
<div>
 <span style="color:#000000;">（2）SimpleAdapter</span>
 <span style="color:#000000;">，在</span>
 <span style="color:#000000;">xml</span>
 <span style="color:#000000;">中定义的布局 ，绑定所对应的数据； </span>
</div> 
<div>
 <span style="color:#000000;">（3）&nbsp;</span>
 <span style="color:#000000;">SimpleCursorAdapter</span>
 <span style="color:#000000;">，用来绑定游标指向的数据，主要用于绑定数据库； </span>
</div> 
<div>
 <span style="color:#000000;">（4） </span>
 <span style="color:#000000;">BaseAdapter</span>
 <span style="color:#000000;">，通用的基础适配器；</span>
</div> 
<div>
 &nbsp;
</div> 
<p>二，ArrayAdapter介绍</p> 
<p>1，ArrayAdapter(Context contenxt, int resource, List&lt;T&gt; objects)</p> 
<p>(1)Context:一个activity或Service都是一个Context。</p> 
<p>（2）resource：布局的ID</p> 
<p>（3）object：通常是一个字符串数组</p> 
<p>2，在UI界面显示ListView</p> 
<p><span style="color:#000000;">（1</span><span style="color:#000000;">）在</span><span style="color:#000000;">Layout</span><span style="color:#000000;">中添加</span><span style="color:#000000;">ListView</span><span style="color:#000000;">控件； </span></p> 
<div>
 <span style="color:#000000;">（</span>
 <span style="color:#000000;">2</span>
 <span style="color:#000000;">）用</span>
 <span style="color:#000000;">setContentView</span>
 <span style="color:#000000;">加载</span>
 <span style="color:#000000;">ListView</span>
 <span style="color:#000000;">，无需设置</span>
 <span style="color:#000000;">Layout</span>
 <span style="color:#000000;">文件； </span>
</div> 
<div>
 <span style="color:#000000;">（</span>
 <span style="color:#000000;">3</span>
 <span style="color:#000000;">）直接继承系统自带的</span>
 <span style="color:#000000;">ListAcitivity</span>
 <span style="color:#000000;">，该</span>
 <span style="color:#000000;">ListActivity</span>
 <span style="color:#000000;">实现了</span>
 <span style="color:#000000;">ListView</span>
 <span style="color:#000000;">，显示ListView的时候做了优化，不需要使用</span>
 <span style="color:#000000;">setContentView</span>
 <span style="color:#000000;">了。</span>
</div> 
<p>3，具体实例：</p> 
<pre class="has"><code>import androidx.appcompat.app.AppCompatActivity;

import android.os.Bundle;
import android.widget.ListView;
import android.widget.ArrayAdapter;

public class MainActivity extends AppCompatActivity {
    private String[] mListStr = {"学校：江苏大学","地址：江苏省镇江市","邮编：212013","前身：江苏理工大学"};
    private ListView listView1;
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
//setContentView(R.layout.activity_main);
        listView1=new ListView(this);
        listView1.setAdapter(new
                ArrayAdapter&lt;String&gt;(this,android.R.layout.simple_expandable_list_item_1,mListStr));
        setContentView(listView1);
    }
}</code></pre> 
<p><span style="color:#000000;">实例说明：</span></p> 
<p><span style="color:#000000;">android.R.layout.</span><span style="color:#660e7a;"><strong><em>simple_expandable_list_item_1为系统自带的布局文件。系统自带的布局一般以</em></strong></span><span style="color:#000000;">android.R.layout.开头，而用户定义的布局文件一般以R.layout.开头。而系统自带的布局文件在哪呢？</span></p> 
<p><span style="color:#000000;">答：</span><span style="color:#474747;">Android\sdk\platforms\</span><span style="color:#ff0000;">android-24</span><span style="color:#474747;">\data\res\layout。而这些布局的参考说明在</span></p> 
<div>
 <span style="color:#474747;">https://developer.android.google.cn/reference/android/R.layout.html </span>
</div> 
<div>
 <span style="color:#474747;">由此我们引出一个问题，那就是那几个系统自带的布局文件是比较常用的呢？</span>
</div> 
<div>
 <span style="color:#474747;">下面介绍一个常用的几个系统自带的布局</span>
</div> 
<div>
 <span style="color:#474747;">4，常用系统自带的布局</span>
</div> 
<div>
 <span style="color:#323232;">（1）通过指定</span>
 <span style="color:#323232;">android.R.layout.simple_list_item_checked</span>
 <span style="color:#323232;">这个资源，实现带选择（打勾）的ListView</span>
 <span style="color:#323232;">。需要用 </span>
</div> 
<div>
 <span style="color:#323232;">setChoiceMode()</span>
 <span style="color:#323232;">方法设定选择为多选还是单选； </span>
</div> 
<div>
 <span style="color:#323232;">（2）</span>
 <span style="color:#323232;">通过指</span>
 <span style="color:#323232;">android.R.layout.simple_list_item_multiple_choice这个资源实现带CheckBox</span>
 <span style="color:#323232;">的</span>
 <span style="color:#323232;">ListView</span>
 <span style="color:#323232;">。同样需要用setChoiceMode()方法来设置单选或者多选； </span>
</div> 
<div>
 <span style="color:#323232;">（3）</span>
 <span style="color:#323232;">通过指定</span>
 <span style="color:#323232;">android.R.layout.simple_list_item_single_choice这个资源实现带RadioButton</span>
 <span style="color:#323232;">的</span>
 <span style="color:#323232;">ListView</span>
 <span style="color:#323232;">，是多选还是单选 要通过setChoiceMode()</span>
 <span style="color:#323232;">方法来指定；</span>
</div> 
<p>具体例子：</p> 
<pre class="has"><code>import androidx.appcompat.app.AppCompatActivity;

import android.os.Bundle;
import android.view.View;
import android.widget.AdapterView;
import android.widget.ListView;
import android.widget.ArrayAdapter;
import android.widget.AdapterView.OnItemClickListener;
public class Main3Activity extends AppCompatActivity {
    private String[] mListStr = {"学校：江苏大学","地址：江苏省镇江市","邮编：212013","前身：江苏理工大学","电话：0511-88780030"};
    private ListView listView3;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        listView3=(ListView)findViewById(R.id.list3);
//listView3.setAdapter(newArrayAdapter&lt;String&gt;(this,android.R.layout.simple_list_item_1,mListStr));
//listView3.setAdapter(newArrayAdapter&lt;String&gt;(this,android.R.layout.simple_list_item_checked,mListStr) );
//listView3.setAdapter(newArrayAdapter&lt;String&gt;(this,android.R.layout.simple_list_item_multiple_choice,mListStr) );
//listView3.setChoiceMode(ListView.CHOICE_MODE_MULTIPLE);
        listView3.setAdapter(new
                ArrayAdapter&lt;String&gt;(this,android.R.layout.simple_list_item_single_choice,mListStr) );
        listView3.setChoiceMode(ListView.CHOICE_MODE_SINGLE);
        listView3.setOnItemClickListener(new OnItemClickListener() {
            @Override
            public void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id)
            {
                setTitle("你点击了第"+position+"行");
            }
        });
    } }</code></pre> 
<p>三，SimpleAdapter：每行显示有图片和文字时用</p> 
<p>1，SimpleAdapter（Context context， List&lt;? extends Map&lt;String,?&gt;&gt; data, int resource ,String[] from, int[] to)</p> 
<p>context：一个activity或Service都是一个Context。</p> 
<p>data:是Map类型的列表，每一行是一个Map类型的数据，<span style="color:#000000;">每一行要与from中指定条目一致</span>（说明：<span style="color:#323232;">使用SimpleAdapter的数据一般都是用</span><span style="color:#323232;">HashMap</span><span style="color:#323232;">构成的列表（hashMap在后面介绍），列表的每一节对应ListView的每一行。通过</span><span style="color:#323232;">SimpleAdapter</span><span style="color:#323232;">的构造函数，将</span><span style="color:#323232;">HashMap</span><span style="color:#323232;">每个键的数据映射到布局文件中对应控件上。这个布局文件一般根据自己的需要来自己定义。</span>）</p> 
<p>resource：布局的ID</p> 
<p>from：<span style="color:#000000;">data的列名</span></p> 
<p>to：<span style="color:#000000;">是一个int</span><span style="color:#000000;">数组，数组里面的</span><span style="color:#000000;">id</span><span style="color:#000000;">是自定义布局中各个控件的id</span><span style="color:#000000;">，需要与上面的</span><span style="color:#000000;">from</span><span style="color:#000000;">对应</span></p> 
<p>2，SimpleAdapter的使用步骤</p> 
<p>（1）定义ListView每行要显示什么东西（如你要显示图片加文字）</p> 
<p>（2）<span style="color:#323232;">定义一个</span><span style="color:#323232;">HashMap</span><span style="color:#323232;">构成的列表，将数据以键值对的方式存放在里面。 </span></p> 
<div>
 <span style="color:#323232;">（</span>
 <span style="color:#323232;">3</span>
 <span style="color:#323232;">）构造</span>
 <span style="color:#323232;">SimpleAdapter</span>
 <span style="color:#323232;">对象。 </span>
</div> 
<div>
 <span style="color:#323232;">（</span>
 <span style="color:#323232;">4</span>
 <span style="color:#323232;">）将</span>
 <span style="color:#323232;">LsitView</span>
 <span style="color:#323232;">绑定到</span>
 <span style="color:#323232;">SimpleAdapter</span>
 <span style="color:#323232;">上</span>
</div> 
<div>
 &nbsp;
</div> 
<div>
 <span style="color:#323232;">3，HashMap</span>
</div> 
<pre class="has"><code>//List基本上都是以Array为基础; 
//Map放键值对的，一个Map可以放很多个键值对
        ArrayList&lt;HashMap&lt;String, Object&gt;&gt; listItem = new ArrayList&lt;HashMap&lt;String, Object&gt;&gt;();
        for (int i=0;i&lt;10;i++){
            HashMap&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();
            map.put("Itemimage",R.drawable.test);//加入图片
            map.put("ItemtextView", "第"+i+"行");
            map.put("ItemtextView2", "这是第"+i+"行");
            listItem.add(map);
        }</code></pre> 
<p>用上面的listItem去建立ListView，则每行显示的就是一张图片和两个文字信息</p> 
<p>4，SimpleAdapter具体实例</p> 
<p><img alt="" class="has" height="229" src="https://img-blog.csdnimg.cn/20191127094618396.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzc1OTM4,size_16,color_FFFFFF,t_70" width="726"></p> 
<pre class="has"><code>public class MainActivity extends AppCompatActivity {
    private ListView listView;
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        listView = (ListView)findViewById(R.id.list);
        ArrayList&lt;HashMap&lt;String, Object&gt;&gt; listItem = new ArrayList&lt;HashMap&lt;String, Object&gt;&gt;();
        for (int i=0;i&lt;10;i++){
            HashMap&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();
            map.put("Itemimage",R.drawable.test);//加入图片
                                           //请把名为“test.png”的图片放在res/drawable内
            map.put("ItemtextView", "第"+i+"行");
            map.put("ItemtextView2", "这是第"+i+"行");
            listItem.add(map);
        }
        SimpleAdapter simpleAdapter = new SimpleAdapter(this, listItem, R.layout.item,
                new String[]{"Itemimage", "ItemtextView", "ItemtextView2"},
                new int[] {R.id.Itemimage, R.id.ItemtextView, R.id.ItemtextView2});
        listView.setAdapter(simpleAdapter);
    }
}</code></pre> 
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<p>&nbsp;</p>
                ]]></description></item><item><title>HLDC到底是个什么鬼东西？</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522424.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Tue, 26 Jul 2022 11:51:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522424.html</guid><description><![CDATA[
                    <p>1，&nbsp; HDLC，它是一种ISO标准数据链路层协议，用于封装同步串行链路上的数据。（同步串行链路什么意思，封装有是什么意思？封装什么）。</p> 
<p>2,HDLC传送的信息单位为帧（帧是什么意思？？）。它是面向比特的同步数据链路层协议（？？面向比特流？？）。其最大的特点是不需要数据必须是规定的字符集，对任何一种比特流，均可以实现透明的传输。</p> 
<p>3，HDLC具有如下特点（HDLC是什么都不知道，下面这些话一句都不理解）：</p> 
<p style="margin-left:0pt;">1、协议不依赖于任何一种字符编码集；</p> 
<p style="margin-left:0pt;">2、数据报文可透明传输，用于透明传输的“0比特插入法”易于硬件实现；</p> 
<p style="margin-left:0pt;">3、全双工通讯，不必等待确认可连续发送数据，有较高的数据链路传输效率；</p> 
<p style="margin-left:0pt;">4、所有帧均采用CRC校验，对信息帧进行顺序编号，可防止漏收或重收，传输可靠性高；</p> 
<p style="margin-left:0pt;">5、传输控制功能与处理功能分离，具有较大的灵活性和较完善的控制功能。</p> 
<p style="margin-left:0pt;">标准HDLC协议族中的协议都是运行于同步串行线路之上。</p> 
<p>&nbsp;</p> 
<p>4，下面对HDLC帧的介绍（什么狗屁不通，我都不知道HDLC是什么鬼）</p> 
<p style="margin-left:0pt;">HDLC的完整的帧由标志字段（F）、地址字段（A）、控制字段（C）、信息字段（I）、帧校验序列字段（FCS）等组成。</p> 
<p style="margin-left:0pt;">标志字段（F）</p> 
<p style="margin-left:0pt;">标志字段为01111110的比特模式，用以标志帧的开始与结束，也可以作为帧与帧之间的填充字符。</p> 
<p style="margin-left:0pt;">地址字段（A）</p> 
<p style="margin-left:0pt;">地址字段携带的是地址信息。</p> 
<p style="margin-left:0pt;">控制字段（C）</p> 
<p style="margin-left:0pt;">控制字段用于构成各种命令及响应，以便对链路进行监视与控制。发送方主节点或组合节点利用控制字段来通知被寻址的从节点或组合节点执行约定的操作；相反，从节点用该字段作为对命令的响应，报告已经完成的操作或状态的变化。</p> 
<p style="margin-left:0pt;">信息字段（I）</p> 
<p style="margin-left:0pt;">&nbsp;&nbsp;信息字段可以是任意的二进制比特串，长度未作限定，其上限由FCS字段或通讯节点的缓冲容量来决定，目前国际上用得较多的是1000-2000比特，而下限可以是0，即无信息字段。但是监控帧中不能有信息字段。</p> 
<p style="margin-left:0pt;">帧校验序列字段（FCS）</p> 
<p style="margin-left:0pt;">&nbsp;帧检验序列字段可以使用16位CRC，对两个标志字段之间的整个帧的内容进行校验。</p> 
<p>5，？？？？什么鬼啊</p> 
<p style="margin-left:0pt;">&nbsp;HDLC有信息帧（I帧）、监控帧（S帧）和无编号帧（U帧）3种不同类型的帧。</p> 
<p style="margin-left:0pt;">&nbsp;</p> 
<p style="margin-left:0pt;">信息帧（I帧）</p> 
<p style="margin-left:0pt;">信息帧用于传送有效信息或数据，通常简称为I帧。</p> 
<p style="margin-left:0pt;">监控帧（S帧）</p> 
<p style="margin-left:0pt;">监控帧用于差错控制和流量控制，通常称为S帧。S帧的标志是控制字段的前两个比特位为“10”。S帧不带信息字段，只有6个字节即48个比特。</p> 
<p style="margin-left:0pt;">无编号帧（U帧）</p> 
<p style="margin-left:0pt;">无编号帧简称U帧。U帧用于提供对链路的建立、拆除以及多种控制功能。</p> 
<p style="margin-left:0pt;">&nbsp;</p> 
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<p><img alt="" class="has" height="153" src="https://img-blog.csdnimg.cn/20191118203248954.png" width="799"></p> 
<p>1，PPP提供了一个在点到点链路上传输多协议数据包的标准方法，是目前广泛应用的数据链路层点到点通信协议。</p> 
<p>（我对这句话的理解：ppp是广域网协议，而广域网协议使用来连接不通的局域网的，而不同的局域网采用的协议可能是不同的，而“PPP提供了一个在点到点链路上传输多协议数据包的标准方法”的意思就是让使用不同协议的局域网相互通信）</p> 
<p>&nbsp;</p> 
<p>2，PPP协议在TCP/IP协议栈中位于数据链路层，是目前应用最广泛的点到点链路层协议。 PPP协议通常用于串行链路、ATM链路和SDH链路上，封装和发送IP数据包。</p> 
<p>（我对这句话的理解：数据链路层就是对网络层数据的封装，屏蔽网络层之间的差异。从这个意义上我们就可以理解ppp的帧与mac帧的区别，ppp帧屏蔽了局域网之间的差异，使得数据可以无差异地在局域网间传输，而Mac帧是帮助数据更好地在局域网间传输。在这个结论下，我们理解下面的ppp的三个组件就比较容易了）</p> 
<p>2.1PPP的三个协议组件：</p> 
<table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td> <p>组件名称</p> </td><td> <p>作用</p> </td></tr><tr><td> <p>数据封装方式</p> </td><td> <p>定义封装多协议数据包的方法</p> </td></tr><tr><td> <p>链路控制协议</p> <p>Link&nbsp;Control&nbsp;Protocol</p> </td><td> <p>定义建立、协商和测试数据链路层连接的方法</p> </td></tr><tr><td> <p>网络层控制协议</p> <p>Network&nbsp;Control&nbsp;Protocol</p> </td><td> <p>包含一组协议，用于对不同的网络层协议进行连接建立和参数协商</p> </td></tr></tbody></table>
<p style="margin-left:0pt;">PPP共定义了三个协议组件，分别是数据封装方式，链路控制协议（Link Control Protocol，LCP）和网络层控制协议（Network Control Protocol，NCP）。</p> 
<p style="margin-left:0pt;">数据封装方式定义了如何封装多种类型的上层协议数据包。</p> 
<p style="margin-left:0pt;">为了能适应多种多样的链路类型，PPP定义了链路控制协议LCP。LCP可以自动检测链路环境，如是否存在环路；协商链路参数，如最大数据包长度，使用何种认证协议等等。与其他数据链路层协议相比，PPP协议的一个重要特点是可以提供认证功能，链路两端可以协商使用何种认证协议并实施认证过程，只有认证成功才会建立连接。这个特点使PPP协议适合运营商用来接入分散的用户。</p> 
<p style="margin-left:0pt;">PPP定义了一组网络层控制协议NCP，每一个协议对应一种网络层协议，用于协商网络层地址等参数，例如IPCP用于协商控制IP，IPXCP用于协商控制IPX协议等。</p> 
<p style="margin-left:0pt;">&nbsp;</p> 
<p style="margin-left:0pt;">&nbsp;</p> 
<p style="margin-left:0pt;">2.2&nbsp; PPP数据帧的封装方式用于区别不同上层协议的数据包。PPP封装方式非常简单，只包含三个字段。</p> 
<p style="margin-left:0pt;">Protocol：协议域，长度为两个字节，标识此PPP数据帧中封装的协议类型，如IP数据包，LCP，NCP等等。常用取值示例如图所示。</p> 
<p style="margin-left:0pt;">Information：信息域，被PPP封装的数据，例如LCP数据，NCP数据，网络层数据包等。此字段的长度是可变的。</p> 
<p style="margin-left:0pt;">Padding：填充域。用于填充信息域。</p> 
<p style="margin-left:0pt;">Padding字段和Information字段两个字段的最大总长度称为PPP的最大接收单元（Maximum Receive Unit，MRU），MRU默认为1500字节。</p> 
<p style="margin-left:0pt;">当Information字段的长度小于MRU时，可以使用Padding字段将长度填充至MRU以方便发送和接收，也可以不进行填充，即Padding字段是可选的。</p> 
<p style="margin-left:0pt;">3，</p> 
<p style="margin-left:0pt;"><img alt="" class="has" height="311" src="https://img-blog.csdnimg.cn/20191118203338781.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNzc1OTM4,size_16,color_FFFFFF,t_70" width="790"></p> 
<p style="margin-left:0pt;">PPP数据帧不能直接在链路上传输，在不同的链路上传输PPP数据帧需要不同的额外封装和控制机制。</p> 
<p style="margin-left:0pt;">在串行链路上传送PPP数据帧遵循HDLC标准。</p> 
<p style="margin-left:0pt;">Flag：数据帧开始和结束的界定标志，取值为二进制“01111110”。</p> 
<p style="margin-left:0pt;">Address：地址，固定为全“1”。由于PPP设计为点到点通信协议，因此不需要寻址机制，只是使用全“1”表示接收端。</p> 
<p style="margin-left:0pt;">Control：控制字段。HDLC可以使用此字段实现数据传输和控制命令的有序传输。在PPP中，此字段取值为0x03，表示使用不计数数据传输，是最简单的一种工作机制。</p> 
<p style="margin-left:0pt;">&nbsp;</p> 
<p>&nbsp;</p>
                ]]></description></item><item><title>错误</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522425.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Tue, 26 Jul 2022 11:51:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522425.html</guid><description><![CDATA[
                    <p>1，要监听必须先：findViewById(R.id.button).setOnClickListener(this);</p> 
<p>2，配置默认路由的时候，我ip route-static 0.0.0.0 24 10.0.12.2导致错误，正确做法：ip route-static 0.0.0.0 0 10.0.12.2<br> 3，设ftp时，错误Error: Failed to run this command because the connection was closed by remote host.<br> ：我在设set default ftp-directory sd1:/的时候，没有用dir看一下路由器的文件夹是什么，后来发现实际的文件夹是flash:/，所以应该是set defualt ftp-directory flash:/</p>
                ]]></description></item><item><title>ensp：静态和默认路由配置</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522426.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Tue, 26 Jul 2022 11:51:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522426.html</guid><description><![CDATA[
                    <p>用到的命令：</p> 
<ol><li>静态路由设置，形如：ip route-static 10.0.13.0 24 10.0.23.3</li><li>备用静态路由设置，形如：ip route-static 10.0.13.0 24 10.0.12.1 preference 80</li><li>跟踪数据包，所经过的路径，形如：Tracet 10.0.13.3</li><li>默认路由配置，形如：ip route-static 0.0.0.0 24 10.0.13.3</li><li>查看路由表：display ip routing-table</li><li>查看端口的简要情况：display ip interface brief</li><li>查看当前的配置情况：display current-configuration</li><li>关闭端口：shutdown</li><li>删除配置的静态路由，形如：undo ip route-static 10.0.13.0 24 10.0.23.3</li><li>删除所有静态路由：undo ip route-static all</li><li>返回上一级：quit；返回用户视图：return</li><li>配置回环接口：interface loopback 0</li></ol>
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<p>&nbsp;</p>
                ]]></description></item><item><title>requires_grad，grad_fn，grad的含义及使用2</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522337.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Tue, 26 Jul 2022 11:50:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522337.html</guid><description><![CDATA[
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>对<a href="https://blog.csdn.net/zphuangtang/article/details/112788037">requires_grad，grad_fn，grad的含义及使用</a>进行补充说明，请先看此文章。<br> 本文对grad的含义进行补充说明<br> grad为：当执行完了backward()之后，通过x.grad查看x的梯度值。比如z=f(x,y)，那么<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        x
       
       
        .
       
       
        g
       
       
        r
       
       
        a
       
       
        d
       
       
        =
       
       
        
         
          ∂
         
         
          z
         
        
        
         
          ∂
         
         
          x
         
        
       
       
        
         ∣
        
        
         
          x
         
         
          =
         
         
          a
         
        
       
      
      
       x.grad= \frac{\partial z}{\partial x}|_{x=a}
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="mord mathnormal">x</span><span class="mord">.</span><span class="mord mathnormal" style="margin-right: 0.0359em;">g</span><span class="mord mathnormal" style="margin-right: 0.0278em;">r</span><span class="mord mathnormal">a</span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1.2251em; vertical-align: -0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.8801em;"><span class="" style="top: -2.655em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right: 0.0556em;">∂</span><span class="mord mathnormal mtight">x</span></span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.394em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right: 0.0556em;">∂</span><span class="mord mathnormal mtight" style="margin-right: 0.044em;">z</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.345em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord"><span class="mord">∣</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.1514em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="mrel mtight">=</span><span class="mord mathnormal mtight">a</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>，a为x的初始值。</p> 
<p>分析下面代码：</p> 
<pre><code class="prism language-python"><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> x <span class="token operator">=</span> torch<span class="token punctuation">.</span>ones<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> requires_grad<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span> <span class="token comment"># 2x2全为1的tensor</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> y <span class="token operator">=</span> x <span class="token operator">+</span> <span class="token number">2</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> z <span class="token operator">=</span> y <span class="token operator">*</span> y <span class="token operator">*</span> <span class="token number">3</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> out <span class="token operator">=</span> z<span class="token punctuation">.</span>mean<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> <span class="token keyword">print</span><span class="token punctuation">(</span>z<span class="token punctuation">,</span> out<span class="token punctuation">)</span>
tensor<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">27.</span><span class="token punctuation">,</span> <span class="token number">27.</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
        <span class="token punctuation">[</span><span class="token number">27.</span><span class="token punctuation">,</span> <span class="token number">27.</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> grad_fn<span class="token operator">=</span><span class="token operator">&lt;</span>MulBackward0<span class="token operator">&gt;</span><span class="token punctuation">)</span> tensor<span class="token punctuation">(</span><span class="token number">27.</span><span class="token punctuation">,</span> grad_fn<span class="token operator">=</span><span class="token operator">&lt;</span>MeanBackward0<span class="token operator">&gt;</span><span class="token punctuation">)</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> out<span class="token punctuation">.</span>backward<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> <span class="token keyword">print</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>grad<span class="token punctuation">)</span>
tensor<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">4.5000</span><span class="token punctuation">,</span> <span class="token number">4.5000</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
        <span class="token punctuation">[</span><span class="token number">4.5000</span><span class="token punctuation">,</span> <span class="token number">4.5000</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre> 
<p>假设<span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml">
     
      
       
        
         x
        
        
         =
        
        
         
          
           
            
             
              [
             
             
              
               
                
                 
                  
                   x
                  
                  
                   1
                  
                 
                
               
               
                
                 
                  
                   x
                  
                  
                   2
                  
                 
                
               
              
              
               
                
                 
                  
                   x
                  
                  
                   3
                  
                 
                
               
               
                
                 
                  
                   x
                  
                  
                   4
                  
                 
                
               
              
             
             
              ]
             
            
           
          
         
        
        
         =
        
        
         
          
           
            
             
              [
             
             
              
               
                
                 
                  1
                 
                
               
               
                
                 
                  1
                 
                
               
              
              
               
                
                 
                  1
                 
                
               
               
                
                 
                  1
                 
                
               
              
             
             
              ]
             
            
           
          
         
        
       
       
        x=\begin{gathered} \begin{bmatrix} x_1 &amp; x_2 \\ x_3 &amp; x_4 \end{bmatrix} \end{gathered}= \begin{gathered} \begin{bmatrix} 1 &amp; 1 \\ 1 &amp; 1 \end{bmatrix} \end{gathered} 
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 2.7em; vertical-align: -1.1em;"></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.6em;"><span class="" style="top: -3.6em;"><span class="pstrut" style="height: 3.45em;"></span><span class="mord"><span class="minner"><span class="mopen delimcenter" style="top: 0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.45em;"><span class="" style="top: -3.61em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span><span class="" style="top: -2.41em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.95em;"><span class=""></span></span></span></span></span><span class="arraycolsep" style="width: 0.5em;"></span><span class="arraycolsep" style="width: 0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.45em;"><span class="" style="top: -3.61em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span><span class="" style="top: -2.41em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.95em;"><span class=""></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top: 0em;"><span class="delimsizing size3">]</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 1.1em;"><span class=""></span></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 2.7em; vertical-align: -1.1em;"></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.6em;"><span class="" style="top: -3.6em;"><span class="pstrut" style="height: 3.45em;"></span><span class="mord"><span class="minner"><span class="mopen delimcenter" style="top: 0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.45em;"><span class="" style="top: -3.61em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord">1</span></span></span><span class="" style="top: -2.41em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.95em;"><span class=""></span></span></span></span></span><span class="arraycolsep" style="width: 0.5em;"></span><span class="arraycolsep" style="width: 0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.45em;"><span class="" style="top: -3.61em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord">1</span></span></span><span class="" style="top: -2.41em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.95em;"><span class=""></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top: 0em;"><span class="delimsizing size3">]</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 1.1em;"><span class=""></span></span></span></span></span></span></span></span></span></span></span></span><br> 则<span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml">
     
      
       
        
         y
        
        
         =
        
        
         
          
           
            
             
              [
             
             
              
               
                
                 
                  
                   y
                  
                  
                   1
                  
                 
                
               
               
                
                 
                  
                   y
                  
                  
                   2
                  
                 
                
               
              
              
               
                
                 
                  
                   y
                  
                  
                   3
                  
                 
                
               
               
                
                 
                  
                   y
                  
                  
                   4
                  
                 
                
               
              
             
             
              ]
             
            
           
          
         
        
        
         =
        
        
         
          
           
            
             
              [
             
             
              
               
                
                 
                  
                   
                    x
                   
                   
                    1
                   
                  
                  
                   +
                  
                  
                   2
                  
                 
                
               
               
                
                 
                  
                   
                    x
                   
                   
                    2
                   
                  
                  
                   +
                  
                  
                   2
                  
                 
                
               
              
              
               
                
                 
                  
                   
                    x
                   
                   
                    3
                   
                  
                  
                   +
                  
                  
                   2
                  
                 
                
               
               
                
                 
                  
                   
                    x
                   
                   
                    4
                   
                  
                  
                   +
                  
                  
                   2
                  
                 
                
               
              
             
             
              ]
             
            
           
          
         
        
        
         =
        
        
         
          
           
            
             
              [
             
             
              
               
                
                 
                  3
                 
                
               
               
                
                 
                  3
                 
                
               
              
              
               
                
                 
                  3
                 
                
               
               
                
                 
                  3
                 
                
               
              
             
             
              ]
             
            
           
          
         
        
       
       
        y=\begin{gathered} \begin{bmatrix} y_1 &amp; y_2 \\ y_3 &amp; y_4 \end{bmatrix} \end{gathered}= \begin{gathered} \begin{bmatrix} x_1+2 &amp; x_2+2 \\ x_3+2 &amp; x_4+2 \end{bmatrix} \end{gathered}= \begin{gathered} \begin{bmatrix} 3 &amp; 3 \\ 3 &amp; 3 \end{bmatrix} \end{gathered} 
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.1944em;"></span><span class="mord mathnormal" style="margin-right: 0.0359em;">y</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 2.7em; vertical-align: -1.1em;"></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.6em;"><span class="" style="top: -3.6em;"><span class="pstrut" style="height: 3.45em;"></span><span class="mord"><span class="minner"><span class="mopen delimcenter" style="top: 0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.45em;"><span class="" style="top: -3.61em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0359em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em;"><span class="" style="top: -2.55em; margin-left: -0.0359em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span><span class="" style="top: -2.41em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0359em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em;"><span class="" style="top: -2.55em; margin-left: -0.0359em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.95em;"><span class=""></span></span></span></span></span><span class="arraycolsep" style="width: 0.5em;"></span><span class="arraycolsep" style="width: 0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.45em;"><span class="" style="top: -3.61em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0359em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em;"><span class="" style="top: -2.55em; margin-left: -0.0359em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span><span class="" style="top: -2.41em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0359em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em;"><span class="" style="top: -2.55em; margin-left: -0.0359em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.95em;"><span class=""></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top: 0em;"><span class="delimsizing size3">]</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 1.1em;"><span class=""></span></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 2.7em; vertical-align: -1.1em;"></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.6em;"><span class="" style="top: -3.6em;"><span class="pstrut" style="height: 3.45em;"></span><span class="mord"><span class="minner"><span class="mopen delimcenter" style="top: 0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.45em;"><span class="" style="top: -3.61em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mord">2</span></span></span><span class="" style="top: -2.41em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mord">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.95em;"><span class=""></span></span></span></span></span><span class="arraycolsep" style="width: 0.5em;"></span><span class="arraycolsep" style="width: 0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.45em;"><span class="" style="top: -3.61em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mord">2</span></span></span><span class="" style="top: -2.41em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mord">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.95em;"><span class=""></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top: 0em;"><span class="delimsizing size3">]</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 1.1em;"><span class=""></span></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 2.7em; vertical-align: -1.1em;"></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.6em;"><span class="" style="top: -3.6em;"><span class="pstrut" style="height: 3.45em;"></span><span class="mord"><span class="minner"><span class="mopen delimcenter" style="top: 0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.45em;"><span class="" style="top: -3.61em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord">3</span></span></span><span class="" style="top: -2.41em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.95em;"><span class=""></span></span></span></span></span><span class="arraycolsep" style="width: 0.5em;"></span><span class="arraycolsep" style="width: 0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.45em;"><span class="" style="top: -3.61em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord">3</span></span></span><span class="" style="top: -2.41em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.95em;"><span class=""></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top: 0em;"><span class="delimsizing size3">]</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 1.1em;"><span class=""></span></span></span></span></span></span></span></span></span></span></span></span><br> <span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml">
     
      
       
        
         z
        
        
         =
        
        
         
          
           
            
             
              [
             
             
              
               
                
                 
                  
                   z
                  
                  
                   1
                  
                 
                
               
               
                
                 
                  
                   z
                  
                  
                   2
                  
                 
                
               
              
              
               
                
                 
                  
                   z
                  
                  
                   3
                  
                 
                
               
               
                
                 
                  
                   z
                  
                  
                   4
                  
                 
                
               
              
             
             
              ]
             
            
           
          
         
        
        
         =
        
        
         
          
           
            
             
              [
             
             
              
               
                
                 
                  
                   3
                  
                  
                   
                    y
                   
                   
                    1
                   
                   
                    2
                   
                  
                 
                
               
               
                
                 
                  
                   3
                  
                  
                   
                    y
                   
                   
                    2
                   
                   
                    2
                   
                  
                 
                
               
              
              
               
                
                 
                  
                   3
                  
                  
                   
                    y
                   
                   
                    3
                   
                   
                    2
                   
                  
                 
                
               
               
                
                 
                  
                   3
                  
                  
                   
                    y
                   
                   
                    3
                   
                   
                    2
                   
                  
                 
                
               
              
             
             
              ]
             
            
           
          
         
        
        
         =
        
        
         
          
           
            
             
              [
             
             
              
               
                
                 
                  27
                 
                
               
               
                
                 
                  27
                 
                
               
              
              
               
                
                 
                  27
                 
                
               
               
                
                 
                  27
                 
                
               
              
             
             
              ]
             
            
           
          
         
        
       
       
        z=\begin{gathered} \begin{bmatrix} z_1 &amp; z_2 \\ z_3 &amp; z_4 \end{bmatrix} \end{gathered}= \begin{gathered} \begin{bmatrix} 3y_1^2 &amp; 3y_2^2 \\ 3y_3^2 &amp; 3y_3^2 \end{bmatrix} \end{gathered}= \begin{gathered} \begin{bmatrix} 27&amp; 27 \\ 27 &amp; 27 \end{bmatrix} \end{gathered} 
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal" style="margin-right: 0.044em;">z</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 2.7em; vertical-align: -1.1em;"></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.6em;"><span class="" style="top: -3.6em;"><span class="pstrut" style="height: 3.45em;"></span><span class="mord"><span class="minner"><span class="mopen delimcenter" style="top: 0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.45em;"><span class="" style="top: -3.61em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right: 0.044em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em;"><span class="" style="top: -2.55em; margin-left: -0.044em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span><span class="" style="top: -2.41em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right: 0.044em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em;"><span class="" style="top: -2.55em; margin-left: -0.044em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.95em;"><span class=""></span></span></span></span></span><span class="arraycolsep" style="width: 0.5em;"></span><span class="arraycolsep" style="width: 0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.45em;"><span class="" style="top: -3.61em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right: 0.044em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em;"><span class="" style="top: -2.55em; margin-left: -0.044em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span><span class="" style="top: -2.41em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right: 0.044em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em;"><span class="" style="top: -2.55em; margin-left: -0.044em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.95em;"><span class=""></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top: 0em;"><span class="delimsizing size3">]</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 1.1em;"><span class=""></span></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 2.7em; vertical-align: -1.1em;"></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.6em;"><span class="" style="top: -3.6em;"><span class="pstrut" style="height: 3.45em;"></span><span class="mord"><span class="minner"><span class="mopen delimcenter" style="top: 0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.45em;"><span class="" style="top: -3.61em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord">3</span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0359em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.8141em;"><span class="" style="top: -2.4519em; margin-left: -0.0359em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2481em;"><span class=""></span></span></span></span></span></span></span></span><span class="" style="top: -2.41em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord">3</span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0359em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.8141em;"><span class="" style="top: -2.4519em; margin-left: -0.0359em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2481em;"><span class=""></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.95em;"><span class=""></span></span></span></span></span><span class="arraycolsep" style="width: 0.5em;"></span><span class="arraycolsep" style="width: 0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.45em;"><span class="" style="top: -3.61em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord">3</span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0359em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.8141em;"><span class="" style="top: -2.4519em; margin-left: -0.0359em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2481em;"><span class=""></span></span></span></span></span></span></span></span><span class="" style="top: -2.41em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord">3</span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0359em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.8141em;"><span class="" style="top: -2.4519em; margin-left: -0.0359em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2481em;"><span class=""></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.95em;"><span class=""></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top: 0em;"><span class="delimsizing size3">]</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 1.1em;"><span class=""></span></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 2.7em; vertical-align: -1.1em;"></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.6em;"><span class="" style="top: -3.6em;"><span class="pstrut" style="height: 3.45em;"></span><span class="mord"><span class="minner"><span class="mopen delimcenter" style="top: 0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.45em;"><span class="" style="top: -3.61em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord">27</span></span></span><span class="" style="top: -2.41em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord">27</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.95em;"><span class=""></span></span></span></span></span><span class="arraycolsep" style="width: 0.5em;"></span><span class="arraycolsep" style="width: 0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.45em;"><span class="" style="top: -3.61em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord">27</span></span></span><span class="" style="top: -2.41em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord">27</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.95em;"><span class=""></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top: 0em;"><span class="delimsizing size3">]</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 1.1em;"><span class=""></span></span></span></span></span></span></span></span></span></span></span></span><br> <span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml">
     
      
       
        
         o
        
        
         u
        
        
         t
        
        
         =
        
        
         
          
           
            z
           
           
            1
           
          
          
           +
          
          
           
            z
           
           
            2
           
          
          
           +
          
          
           
            z
           
           
            3
           
          
          
           +
          
          
           
            z
           
           
            4
           
          
         
         
          4
         
        
       
       
        out = \frac{z_1+z_2+z_3+z_4}{4}
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6151em;"></span><span class="mord mathnormal">o</span><span class="mord mathnormal">u</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1.9463em; vertical-align: -0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.2603em;"><span class="" style="top: -2.314em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord">4</span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.677em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right: 0.044em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em;"><span class="" style="top: -2.55em; margin-left: -0.044em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.044em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em;"><span class="" style="top: -2.55em; margin-left: -0.044em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.044em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em;"><span class="" style="top: -2.55em; margin-left: -0.044em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.044em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em;"><span class="" style="top: -2.55em; margin-left: -0.044em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.686em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></span></p> 
<p>则<span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml">
     
      
       
        
         x
        
        
         .
        
        
         g
        
        
         r
        
        
         a
        
        
         d
        
        
         =
        
        
         
          
           
            
             
              [
             
             
              
               
                
                 
                  
                   
                    
                     ∂
                    
                    
                     o
                    
                    
                     u
                    
                    
                     t
                    
                   
                   
                    
                     ∂
                    
                    
                     
                      x
                     
                     
                      1
                     
                    
                   
                  
                  
                   
                    ∣
                   
                   
                    
                     
                      x
                     
                     
                      1
                     
                    
                    
                     =
                    
                    
                     1
                    
                   
                  
                 
                
               
               
                
                 
                  
                   
                    
                     ∂
                    
                    
                     o
                    
                    
                     u
                    
                    
                     t
                    
                   
                   
                    
                     ∂
                    
                    
                     
                      x
                     
                     
                      2
                     
                    
                   
                  
                  
                   
                    ∣
                   
                   
                    
                     
                      x
                     
                     
                      2
                     
                    
                    
                     =
                    
                    
                     1
                    
                   
                  
                 
                
               
              
              
               
                
                 
                  
                   
                    
                     ∂
                    
                    
                     o
                    
                    
                     u
                    
                    
                     t
                    
                   
                   
                    
                     ∂
                    
                    
                     
                      x
                     
                     
                      3
                     
                    
                   
                  
                  
                   
                    ∣
                   
                   
                    
                     
                      x
                     
                     
                      3
                     
                    
                    
                     =
                    
                    
                     1
                    
                   
                  
                 
                
               
               
                
                 
                  
                   
                    
                     ∂
                    
                    
                     o
                    
                    
                     u
                    
                    
                     t
                    
                   
                   
                    
                     ∂
                    
                    
                     
                      x
                     
                     
                      4
                     
                    
                   
                  
                  
                   
                    ∣
                   
                   
                    
                     
                      x
                     
                     
                      4
                     
                    
                    
                     =
                    
                    
                     1
                    
                   
                  
                 
                
               
              
             
             
              ]
             
            
           
          
         
        
       
       
        x.grad=\begin{gathered} \begin{bmatrix} \frac{\partial out}{\partial x_1}|_{x_1=1} &amp; \frac{\partial out}{\partial x_2}|_{x_2=1} \\ \frac{\partial out}{\partial x_3}|_{x_3=1} &amp; \frac{\partial out}{\partial x_4}|_{x_4=1} \end{bmatrix} \end{gathered} 
       
      
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="mord mathnormal">x</span><span class="mord">.</span><span class="mord mathnormal" style="margin-right: 0.0359em;">g</span><span class="mord mathnormal" style="margin-right: 0.0278em;">r</span><span class="mord mathnormal">a</span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 2.9504em; vertical-align: -1.2252em;"></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.7252em;"><span class="" style="top: -3.7252em;"><span class="pstrut" style="height: 3.5752em;"></span><span class="mord"><span class="minner"><span class="mopen delimcenter" style="top: 0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.5752em;"><span class="" style="top: -3.6951em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.8801em;"><span class="" style="top: -2.655em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right: 0.0556em;">∂</span><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3173em;"><span class="" style="top: -2.357em; margin-left: 0em; margin-right: 0.0714em;"><span class="pstrut" style="height: 2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.143em;"><span class=""></span></span></span></span></span></span></span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.394em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right: 0.0556em;">∂</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">u</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.4451em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord"><span class="mord">∣</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3173em;"><span class="" style="top: -2.357em; margin-left: 0em; margin-right: 0.0714em;"><span class="pstrut" style="height: 2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.143em;"><span class=""></span></span></span></span></span></span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2501em;"><span class=""></span></span></span></span></span></span></span></span><span class="" style="top: -2.3699em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.8801em;"><span class="" style="top: -2.655em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right: 0.0556em;">∂</span><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3173em;"><span class="" style="top: -2.357em; margin-left: 0em; margin-right: 0.0714em;"><span class="pstrut" style="height: 2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.143em;"><span class=""></span></span></span></span></span></span></span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.394em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right: 0.0556em;">∂</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">u</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.4451em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord"><span class="mord">∣</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3173em;"><span class="" style="top: -2.357em; margin-left: 0em; margin-right: 0.0714em;"><span class="pstrut" style="height: 2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.143em;"><span class=""></span></span></span></span></span></span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2501em;"><span class=""></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 1.0752em;"><span class=""></span></span></span></span></span><span class="arraycolsep" style="width: 0.5em;"></span><span class="arraycolsep" style="width: 0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.5752em;"><span class="" style="top: -3.6951em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.8801em;"><span class="" style="top: -2.655em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right: 0.0556em;">∂</span><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3173em;"><span class="" style="top: -2.357em; margin-left: 0em; margin-right: 0.0714em;"><span class="pstrut" style="height: 2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.143em;"><span class=""></span></span></span></span></span></span></span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.394em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right: 0.0556em;">∂</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">u</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.4451em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord"><span class="mord">∣</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3173em;"><span class="" style="top: -2.357em; margin-left: 0em; margin-right: 0.0714em;"><span class="pstrut" style="height: 2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.143em;"><span class=""></span></span></span></span></span></span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2501em;"><span class=""></span></span></span></span></span></span></span></span><span class="" style="top: -2.3699em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.8801em;"><span class="" style="top: -2.655em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right: 0.0556em;">∂</span><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3173em;"><span class="" style="top: -2.357em; margin-left: 0em; margin-right: 0.0714em;"><span class="pstrut" style="height: 2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.143em;"><span class=""></span></span></span></span></span></span></span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.394em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right: 0.0556em;">∂</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">u</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.4451em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord"><span class="mord">∣</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3173em;"><span class="" style="top: -2.357em; margin-left: 0em; margin-right: 0.0714em;"><span class="pstrut" style="height: 2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.143em;"><span class=""></span></span></span></span></span></span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2501em;"><span class=""></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 1.0752em;"><span class=""></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top: 0em;"><span class="delimsizing size3">]</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 1.2252em;"><span class=""></span></span></span></span></span></span></span></span></span></span></span></span><br> 我们以<span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        
         
          ∂
         
         
          o
         
         
          u
         
         
          t
         
        
        
         
          ∂
         
         
          
           x
          
          
           1
          
         
        
       
       
        
         ∣
        
        
         
          
           x
          
          
           1
          
         
         
          =
         
         
          1
         
        
       
      
      
       \frac{\partial out}{\partial x_1}|_{x_1=1}
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.3252em; vertical-align: -0.4451em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.8801em;"><span class="" style="top: -2.655em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right: 0.0556em;">∂</span><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3173em;"><span class="" style="top: -2.357em; margin-left: 0em; margin-right: 0.0714em;"><span class="pstrut" style="height: 2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.143em;"><span class=""></span></span></span></span></span></span></span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.394em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right: 0.0556em;">∂</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">u</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.4451em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord"><span class="mord">∣</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3173em;"><span class="" style="top: -2.357em; margin-left: 0em; margin-right: 0.0714em;"><span class="pstrut" style="height: 2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.143em;"><span class=""></span></span></span></span></span></span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2501em;"><span class=""></span></span></span></span></span></span></span></span></span></span>为例进行说明：</p> 
<p><span class="katex--inline"><span class="katex"><span class="katex-mathml">
    
     
      
       
        
         
          ∂
         
         
          o
         
         
          u
         
         
          t
         
        
        
         
          ∂
         
         
          
           x
          
          
           1
          
         
        
       
       
        =
       
       
        
         
          ∂
         
         
          o
         
         
          u
         
         
          t
         
        
        
         
          ∂
         
         
          
           z
          
          
           1
          
         
        
       
       
        
         
          ∂
         
         
          
           z
          
          
           1
          
         
        
        
         
          ∂
         
         
          
           y
          
          
           1
          
         
        
       
       
        
         
          ∂
         
         
          
           y
          
          
           1
          
         
        
        
         
          ∂
         
         
          
           x
          
          
           1
          
         
        
       
       
        =
       
       
        
         1
        
        
         4
        
       
       
        6
       
       
        
         y
        
        
         1
        
       
       
        =
       
       
        4.5
       
      
      
       \frac{\partial out}{\partial x_1}=\frac{\partial out}{\partial z_1}\frac{\partial z_1}{\partial y_1}\frac{\partial y_1}{\partial x_1}=\frac{1}{4}6y_1=4.5
      
     
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.3252em; vertical-align: -0.4451em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.8801em;"><span class="" style="top: -2.655em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right: 0.0556em;">∂</span><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3173em;"><span class="" style="top: -2.357em; margin-left: 0em; margin-right: 0.0714em;"><span class="pstrut" style="height: 2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.143em;"><span class=""></span></span></span></span></span></span></span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.394em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right: 0.0556em;">∂</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">u</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.4451em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1.4133em; vertical-align: -0.4811em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.8801em;"><span class="" style="top: -2.655em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right: 0.0556em;">∂</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right: 0.044em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3173em;"><span class="" style="top: -2.357em; margin-left: -0.044em; margin-right: 0.0714em;"><span class="pstrut" style="height: 2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.143em;"><span class=""></span></span></span></span></span></span></span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.394em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right: 0.0556em;">∂</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">u</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.4451em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.8962em;"><span class="" style="top: -2.655em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right: 0.0556em;">∂</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0359em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3173em;"><span class="" style="top: -2.357em; margin-left: -0.0359em; margin-right: 0.0714em;"><span class="pstrut" style="height: 2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.143em;"><span class=""></span></span></span></span></span></span></span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.4101em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right: 0.0556em;">∂</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right: 0.044em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3173em;"><span class="" style="top: -2.357em; margin-left: -0.044em; margin-right: 0.0714em;"><span class="pstrut" style="height: 2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.143em;"><span class=""></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.4811em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.9322em;"><span class="" style="top: -2.655em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right: 0.0556em;">∂</span><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3173em;"><span class="" style="top: -2.357em; margin-left: 0em; margin-right: 0.0714em;"><span class="pstrut" style="height: 2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.143em;"><span class=""></span></span></span></span></span></span></span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.4461em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right: 0.0556em;">∂</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right: 0.0359em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3173em;"><span class="" style="top: -2.357em; margin-left: -0.0359em; margin-right: 0.0714em;"><span class="pstrut" style="height: 2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.143em;"><span class=""></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.4451em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1.1901em; vertical-align: -0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.8451em;"><span class="" style="top: -2.655em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span></span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.394em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.345em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord">6</span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0359em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em;"><span class="" style="top: -2.55em; margin-left: -0.0359em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">4.5</span></span></span></span></span></p> 
<p>从上面我们可以看出来，x的梯度值（x.grad）就是out对x的偏导值。还可以看出，要求out对x的偏导，需要知道out对z的偏导、z对y的偏导、y对x的偏导。我觉得requires_grad设为True的作用就是保存这些偏导信息（也称为梯度信息），比如y的requires_grad设为True，则会保存“y对x的偏导”这个信息。<br> requires_grad()默认为False，但这不意味着我们需要一个一个地去分别给x、y、z、out设置requires_grad=True。因为pytorch中规定：只要某一个输入需要相关梯度值，则输出也需要保存相关梯度信息，这样就保证了这个输入的梯度回传，即我们只需要设置x的requires_grad=True，就可以保证y、z、out的requires_grad=True。</p> 
<p>再看下面一个注意点：</p> 
<pre><code class="prism language-python"><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> <span class="token keyword">print</span><span class="token punctuation">(</span>y<span class="token punctuation">.</span>grad<span class="token punctuation">)</span>
E<span class="token punctuation">:</span>\softwares\anaconda\envs\pytorch\lib\site<span class="token operator">-</span>packages\torch\_tensor<span class="token punctuation">.</span>py<span class="token punctuation">:</span><span class="token number">1013</span><span class="token punctuation">:</span> UserWarning<span class="token punctuation">:</span> The <span class="token punctuation">.</span>grad attribute of a Tensor that <span class="token keyword">is</span> <span class="token keyword">not</span> a leaf Tensor <span class="token keyword">is</span> being accessed<span class="token punctuation">.</span> Its <span class="token punctuation">.</span>grad attribute won't be populated during autograd<span class="token punctuation">.</span>backward<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span> If you indeed want the <span class="token punctuation">.</span>grad field to be populated <span class="token keyword">for</span> a non<span class="token operator">-</span>leaf Tensor<span class="token punctuation">,</span> use <span class="token punctuation">.</span>retain_grad<span class="token punctuation">(</span><span class="token punctuation">)</span> on the non<span class="token operator">-</span>leaf Tensor<span class="token punctuation">.</span> If you access the non<span class="token operator">-</span>leaf Tensor by mistake<span class="token punctuation">,</span> make sure you access the leaf Tensor instead<span class="token punctuation">.</span> See github<span class="token punctuation">.</span>com<span class="token operator">/</span>pytorch<span class="token operator">/</span>pytorch<span class="token operator">/</span>pull<span class="token operator">/</span><span class="token number">30531</span> <span class="token keyword">for</span> more informations<span class="token punctuation">.</span> <span class="token punctuation">(</span>Triggered internally at  aten\src\ATen<span class="token operator">/</span>core<span class="token operator">/</span>TensorBody<span class="token punctuation">.</span>h<span class="token punctuation">:</span><span class="token number">417.</span><span class="token punctuation">)</span>
  <span class="token keyword">return</span> self<span class="token punctuation">.</span>_grad
<span class="token boolean">None</span>
</code></pre> 
<p>无法打印处y.grad，这是因为并不是每个requires_grad()设为True的值都会在backward的时候得到相应的grad。它还必须为leaf。<br> leaf：requires_grad为True的张量(Tensor),如果他们是由用户创建的,则它们是叶张量(leaf Tensor).这意味着它不是运算的结果,因此gra_fn为None。【参考：<a href="https://blog.csdn.net/qq_40206371/article/details/121314373">链接</a>】</p>
                ]]></description></item><item><title>5 git stash</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522338.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Tue, 26 Jul 2022 11:50:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522338.html</guid><description><![CDATA[
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>git stash：将当前工作现场存储起来。工作现场包括工作区和暂存区。git stash将当前工作环境保存起来的同时，将工作环境恢复到上一个提交。<br> 参考：git stash用法小结</p>
                ]]></description></item><item><title>4. git merge简介，以及git merge的参数–ff、–no-ff和–squash的区别？</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522339.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Tue, 26 Jul 2022 11:50:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522339.html</guid><description><![CDATA[
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h1><a id="1git_merge_0"></a>1.git merge原理</h1> 
<pre><code class="prism language-bash">          A---B---C topic
	     /         <span class="token punctuation">\</span>
    D---E-----F------H master
</code></pre> 
<p>在master分支中使用git merge topic，只会将C和H中的文件进行比较，如果没有冲突就会生成H。A、B、C都不会放进master分支中。<br> 但是通过git log --oneline查看提交日志时，会发现A、B、C好像放进master中了，但是其实没有。为了证明这一点，我们可以在H处使用 git reset --hard HEAD^回到上一个版本，此时我们发现我们回到了F，而不是C。<br> 虽然A、B、C都不会放进master分支中，但是分支的信息是保存的，即使topic指针被删除。</p> 
<p>git merge --abort：当发生冲突以后，各个冲突会在readme.txt文件中显示，也就是说readme.txt被重写了。如果想要放弃这次合并，就可以通过git merge --abort。<br> 参考：<a href="https://blog.csdn.net/a409051987/article/details/70665865">git merge 原理</a><br> <a href="https://blog.csdn.net/qq_43827595/article/details/116067242">git删除分支时究竟会删掉哪些东西</a></p> 
<h1><a id="2git_merge_14"></a>2.git merge的过程中，有文件发生冲突，会如何处理？</h1> 
<pre><code class="prism language-bash">          A---B---C topic
	     /         <span class="token punctuation">\</span>
    D---E-----F------H master
</code></pre> 
<p>假设在master分支中使用git merge topic时，C和F中的readme.txt发生冲突。此时git会将冲突的内容放入工作区的readme.txt中，我们可以通过修改工作区的readme.txt文件来处理冲突。当工作区的readme.txt文件里存的是冲突的内容，那么就会出现如下红框中的标识：<br> <img src="https://img-blog.csdnimg.cn/62d0dd5a6edd4b068cf28bb8269348a0.png" alt="在这里插入图片描述"><br> 自动将冲突的具体信息放在workspace中的readme.txt文件中，那如果工作区有readme.txt文件，那不就被覆盖了？<br> 答：如果工作区对readme.txt文件的修改未提交到仓库中，那么会提示你去先进行add和commit或者stash。</p> 
<p>冲突的具体信息放在workspace中的readme.txt文件中，那么readme.txt中是什么信息呢？<br> 答：git会将C和F相对于E的修改分别在readme.txt中列出来。<br> git是按行对比两个冲突文件之间的差异。</p> 
<h1><a id="3git_mergeffnoffsquash_29"></a>3.git merge的参数–ff、–no-ff和–squash的区别？</h1> 
<p>根据<a href="https://git-scm.com/docs/git-merge">官方文档</a>可知，–ff和–no-ff是在“当合并的历史是当前历史的后代”的情况才起作用的，下面具体介绍一下什么是“当合并的历史是当前历史的后代”：</p> 
<pre><code class="prism language-bash">          A---B---C topic
	     /         <span class="token punctuation">\</span>
    D---E-----------H master
</code></pre> 
<p>上面我们可以看出：从E分叉出topic分支，topic分支上提交了A、B、C，但master上从E开始没有进行提交。<br> 当我们处于master分支，想要将topic分支合并到master中时，就涉及到三个不同的选项–ff、–no-ff、–ff-only。也就是说这三个选项只在本情况有效，本情况为：master上从E开始都没有提交，并想要将topic分支合并到master中。这种情况称为“当合并的历史是当前历史的后代”。<br> 节点的tag不存储在refs/tags/中时，默认使用–no-ff。其他情况默认使用–ff<br> –no-ff：创建新的提交H，得到如下结果：</p> 
<pre><code class="prism language-bash">          A---B---C topic
	     /         <span class="token punctuation">\</span>
    D---E-----------H master
</code></pre> 
<p>–ff：不创建新的提交H，将指针mater指向C，得到如下结果：</p> 
<pre><code class="prism language-bash">D---E---A---B---C master
</code></pre> 
<p>–squash：将待合并分支的最后一个提交放到当前分支的工作区。如A、B、C对readme.txt进行了修改，那么–squash的作用就是将经过A、B、C修改的readme.txt文件复制到工作区中。然后我们就可以进行add和commit来生成一个提交。生成的这个提交，就相当于对A、B、C工作的总结。<br> 如果复制到工作区的readme.txt文件与工作区中的readme.txt文件有冲突？？答：出现这种冲突时的处理办法就是将冲突内容全部展示在readme.txt中。<br> –squash只是为让提交的日志看起来简洁一些。</p>
                ]]></description></item><item><title>git与vscode的使用</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522340.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Tue, 26 Jul 2022 11:50:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522340.html</guid><description><![CDATA[
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>直接看https://blog.csdn.net/sinat_16643223/article/details/111713296</p> 
<h3><a id="311gitlens_8"></a>3.1.1.gitlens</h3> 
<p>在vscode中安装插件gitlens</p> 
<p><strong>1.进入welcome进行快速设置</strong><br> 通过以下选项可以进行快速地设置：<br> <img src="https://img-blog.csdnimg.cn/cb57703c977a43d0b5e348d9213af747.png" alt="在这里插入图片描述"><br> 进入welcome之后， 就可以选择需要的功能。【英文看不懂，用xtranslator不就行了】</p> 
<p><strong>2.比较两个commit之间修改了什么</strong><br> 分别点击两个commit中的select for compare，就可以比较两个commit之间修改了什么</p> 
<p><img src="https://img-blog.csdnimg.cn/dac685a1d26740adbf55209de2274293.png" alt="在这里插入图片描述"></p> 
<p>问题：gitlens中还有很多符号，我是看不懂的<br> 比较中的+和-号，<br> 一边可以是修改，一边不可以修改？<br> vscode中的working tree代表工作区？<br> 如果员工的分支中修改了很多个文件，那么如何进行比较？？</p> 
<p>参考：https://www.bilibili.com/video/BV1AS4y1V7PG<br> interactive rebase是什么意思？？</p> 
<p>视频https://www.bilibili.com/video/BV1AS4y1V7PG还没看完，因为很多内容看不懂，，，待补充，<br> https://www.bilibili.com/video/BV1AS4y1V7PG中的几个视频都可以看看。。。。。<br> <img src="https://img-blog.csdnimg.cn/349389d58f6d41aebabe9637a7a0b363.png" alt="在这里插入图片描述"></p> 
<p>.gitignore文件中写入需要忽视的不提交的文件。</p> 
<p>参考：<br> https://note.youdao.com/s/PaPkixpc<br> http://rogerdudler.github.io/git-guide/index.zh.html<br> https://rogerdudler.github.io/git-guide/index.zh.html</p> 
<p>https://www.runoob.com/git/git-basic-operations.html</p>
                ]]></description></item><item><title>3. git一份代码提交多个git远程库中</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522341.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Tue, 26 Jul 2022 11:50:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/26/16522341.html</guid><description><![CDATA[
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="1__1"></a>1. 添加两个远程库</h2> 
<p>通过git remote add可以添加远程库，如下：</p> 
<pre><code class="prism language-bash"><span class="token function">git</span> init 
<span class="token function">git</span> <span class="token function">add</span> README.md 
<span class="token function">git</span> commit -m <span class="token string">"first commit"</span>

<span class="token function">git</span> remote <span class="token function">add</span> Ceres https://tokenA@github.com/mynameA/repository.git
<span class="token function">git</span> push  Ceres master

<span class="token function">git</span> remote <span class="token function">add</span> Mars https://tokenB@github.com/mynameB/repository.git
<span class="token function">git</span> push  Mars master 

说明1：
<span class="token function">git</span> push -u origin master  
相当于以下两个：
<span class="token function">git</span> branch --set-upstream-to<span class="token operator">=</span>origin/master master // 将远程仓库origin的master分支与本地仓库master分支绑定
<span class="token function">git</span> push origin master
由于我们需要将一份已经写好的代码提交到两个git远端，所以不用-u参数进行绑定。

说明2：
我们常见的远程名origin，也只不过是个通过git remote add添加的远程库的名字，只是习惯写成origin。

说明3：
<span class="token function">git</span> remote -v 	<span class="token comment">#  可以看到已存在的远程库</span>
</code></pre> 
<p>上面命令创建了名为Mars和Ceres的远程库，并通过push命令将一份已经写好的代码提交到两个git远端。</p> 
<h1><a id="2_tokenAtokenB_32"></a>2 ：tokenA和tokenB的获取</h1> 
<p>查找access_token的步骤如下：<br> 1、在github页面的右上角，单击您的个人资料照片，然后单击 Settings（设置） 。<br> <img src="https://img-blog.csdnimg.cn/be7bfe5f814b4b1aa4a8763142677607.png" alt="image.png"><br> 2、在左侧边栏中，单击 Developer settings。<br> <img src="https://img-blog.csdnimg.cn/32ee14de55534d538bc59b6918eec95b.png" alt="image.png"><br> 3、在左侧边栏中，单击 Personal access tokens（个人访问Tokens） 。<br> <img src="https://img-blog.csdnimg.cn/a8fa2f84b8b6438681557f5038054a36.png" alt="image.png"><br> 4、点击 Generate new token（生成新Tokens） 。<br> <img src="https://img-blog.csdnimg.cn/f9bbd0f6941c471d85d7a98718424d65.png" alt="image.png"><br> 5、设置名称，token过期日期，以及权限。<br> <img src="https://img-blog.csdnimg.cn/c06ace7fc0ff4786a46064e6922972d0.png" alt="image.png"><br> 6、点击生成即可。<br> <img src="https://img-blog.csdnimg.cn/3d7537379ee743239f45f22ed8509d42.png" alt="image.png"><br> 7、记得将生成的token复制并且存储下来，因为处于安全原因当您离开该页面之后，token将不再显示。</p> 
<p>参考：<a href="https://blog.csdn.net/qq_25458977/article/details/87875641">将一份已经写好的代码提交到两个git远端 </a><br> <a href="https://blog.csdn.net/qq_31055729/article/details/121800703">链接1</a><br> <a href="https://blog.csdn.net/m0_56184347/article/details/124304029">链接2</a></p> 
<h1><a id="3_52"></a>3.一个远端用来周期备份，一个远端用来版本管理</h1> 
<p>还没弄完，以后再说。。。<br> 使用git开发时，一般分为四种分支，请参考：<a href="https://blog.csdn.net/leinminna/article/details/111351942">git四种分支 及其使用</a>。为了方便我这里只设置三种分支：main(也可以叫master)、dev和其他。<br> 平时就在“其他分支”上进行修复bug、功能添加等操作，使用脚本每隔一天将“其他分支”上传到github一次。<br> 编写脚本autoupdate.sh用来周期性执行备份操作：</p> 
<pre><code class="prism language-bash"><span class="token shebang important">#! /bin/bash</span>
<span class="token function">git</span> switch feature-balabala
<span class="token function">git</span> <span class="token function">add</span> <span class="token builtin class-name">.</span>
<span class="token function">git</span> commit -m <span class="token string">"<span class="token variable"><span class="token variable">`</span><span class="token function">date</span> <span class="token string">'+%D'</span><span class="token variable">`</span></span>"</span>
<span class="token function">git</span> push  Mars feature-balabala:feature-balabala

说明：
<span class="token function">git</span> push 命用于从将本地的分支版本上传到远程并合并。
命令格式如下：
<span class="token function">git</span> push <span class="token operator">&lt;</span>远程主机名<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>本地分支名<span class="token operator">&gt;</span>:<span class="token operator">&lt;</span>远程分支名<span class="token operator">&gt;</span>
如果本地分支名与远程分支名相同，则可以省略冒号：
<span class="token function">git</span> push <span class="token operator">&lt;</span>远程主机名<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>本地分支名<span class="token operator">&gt;</span>
</code></pre> 
<p>2&gt;autoupdate.err？</p> 
<p>再用 crontab 软件来设定定时运行程序</p> 
<pre><code class="prism language-bash"><span class="token function">crontab</span> -e     <span class="token comment"># 进入编辑器编辑代码</span>
<span class="token number">0</span> <span class="token number">0</span> * * * /bin/bash /path/to/bkcode/autoupdate.sh <span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span>autoupdate.err  <span class="token comment"># 每天凌晨12点执行autoupdate.sh这个代码</span>
</code></pre> 
<p><img src="https://img-blog.csdnimg.cn/91ae3098ebd1485bab84f1137e4ce02c.png" alt="在这里插入图片描述"></p> 
<p>利用Ubuntu发邮件失败。。。。。</p> 
<p><a href="https://zhuanlan.zhihu.com/p/76906272">链接</a><br> <a href="https://www.runoob.com/linux/linux-comm-crontab.html">crontab使用 菜鸟教程</a><br> <a href="https://blog.csdn.net/leinminna/article/details/111351942">git四种分支 及其使用</a><br> <a href="https://blog.csdn.net/longgeaisisi/article/details/90477975">Ubuntu下crontab的安装和使用</a></p>
                ]]></description></item><item><title>C++ 正则表达式 string替换</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/25/16516545.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Mon, 25 Jul 2022 02:21:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/25/16516545.html</guid><description><![CDATA[```
time_t curr_time;
time(&curr_time);
char *curr_time2 = asctime(localtime(&curr_time));
regex pattern1(" "); // 规则一：匹配空格
regex pattern2("\n"); // 规则二：匹配换行
string s1 = regex_replace(regex_replace(curr_time2, pattern1, "_"), pattern2, "");
```]]></description></item><item><title>string转化成const char *：.c_str()</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/25/16516505.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Mon, 25 Jul 2022 02:15:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/25/16516505.html</guid><description><![CDATA[string result_path = "images/" + labels + "/image" + s1 + ".jpg";
FILE *file = fopen(result_path.c_str(), "r")]]></description></item><item><title>宏变量</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/24/16515334.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Sun, 24 Jul 2022 12:06:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/24/16515334.html</guid><description><![CDATA[```
#include <iostream>
#include <stdexcept>
#include<bitset>
#define CheckBuffer(x) { if ((nBufSize-nOffset)<(x)) { nUsedLen = nOffset; return 0;} } 

using namespace std;

int main(void)
{
    int nBufSize=1;
    int nOffset=1;
    int nUsedLen =1;
    CheckBuffer(9);  // 上面三个局部变量会传进宏CheckBuffer中。
    return 0;
}
```]]></description></item><item><title>使用fopen打开文件时，如果文件不存在，就不需要执行fclose，否则会产生段错误</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/24/16514423.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Sun, 24 Jul 2022 05:59:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/24/16514423.html</guid><description><![CDATA[使用fopen打开文件时，如果文件不存在，就不需要执行fclose，否则会产生段错误，如下：
```
// test.cpp  
#include <stdio.h>

int main() {
    FILE *outfp_ = NULL;
    outfp_ = fopen("output.h264", "rb");
    if (outfp_ == NULL ){
      fclose(outfp_);
    }
}
```
由于output.h264文件不存在，那么上述代码就会产生段错误，执行过程如下：
```
g++ test.cpp 
./a.out 
Segmentation fault (core dumped)
```]]></description></item><item><title>python调用C++程序，C++程序调用python程序：pybind11简单使用</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/23/16512831.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Sat, 23 Jul 2022 11:28:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/23/16512831.html</guid><description><![CDATA[本博客只是对[链接](https://blog.csdn.net/henuyh/article/details/119341884)进行补充说明。

通过git clone https://github.com/pybind/pybind11.git 下载源码，可以发现源码中并没有cpp文件，只有.h文件，也就是说pybind11将实现的代码都放进了.h文件中了。所以pybind11其实是不用进行编译安装，就可以使用的，直接通过include相关头文件就可以。

# python调用C++程序的实例：
pyadd.cpp：
```
#include <pybind11/pybind11.h>

/***********************调用普通函数***********************/
template <typename T>
T add(T a, T b) {
  return a + b;
}

PYBIND11_MODULE(pyadd, m) {
  m.doc() = "test for add()";
  m.def("add", &add<int>, "add two number.");
  m.def("add", &add<double>, "add two number.");
  m.def("add", &add<long long>, "add two number.");
  m.attr("__version__") = "dev";
}
```
将pyadd编译成动态库：
```
g++ pyadd.cpp -I ./ -I /home/ubuntu1/anaconda3/envs/test/include/python3.9 -L /home/ubuntu1/anaconda3/envs/test/lib -l python3.9  -fPIC -shared  -o pyadd.so 
```
第一个-I用于指明头文件pybind11.h位置，第二个-I指明Python.h所在位置。
这里动态库的名字为pyadd.so，那么在python程序中使用“import pyadd”进行导入，如：
pytest.py
```
import pyadd
print(pyadd.__version__)
# 'dev' 
print(pyadd.add(1.1, 2.2))  
# 3.3000000000000003 
```
由于pyadd.so是由虚拟环境“test” 中python生成的，所以需要使用虚拟环境test中的python执行脚本pytest.py:
```
conda activate test
python3 pytest.py
```
]]></description></item><item><title>C++ primer总结</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/22/16506475.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Fri, 22 Jul 2022 09:21:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/22/16506475.html</guid><description><![CDATA[可以用少量字总结的就总结一下，如果不行，就只写一下有什么知识

练习答案：https://github.com/applenob/Cpp_Primer_Practice



1.main()函数return的是0，则表示成功；非零表示各种错误类型

不同编译器规定c++源文件的后缀不同，可能是cc,cpp,cp等

UNIX可执行文件后缀为.out，可以没有后缀；windows可执行文件后缀为.exe

ubuntu中直接输入a.out是无法找到可执行文件，需要执行./a.out通过“./”告诉系统可执行文件所在目录。

在命令行中运行完可执行文件后，可以使用echo输出main函数返回的值





2.cin和cout是两个对象，<<是一个运算符。

cerr和clog也是两个输出对象，分别用于输出错误和日志

程序员常常在调试时添加打印语句。这类语句应该保证“一直”刷新流，即cout都应该以<<std::endl结尾。否则，如果程序崩溃，输出可能还留在缓冲区中，此时我们以为某位置没有输出，其实是输出了，只是留在了缓冲区中。这就会导致导致关于程序崩溃位置的错误推断。

<<可以输出不同类型数据，是因为定义了不同版本的<<运算符来处理不同类型的数据。





3.while(std::cin>>value)中std::cin>>value返回的是一个std::cin对象，当对象是文件结束符（或输入错误）时while循环结束。

文件结束符：windows下为ctrl+z或Enter，linux（或MAC os x）下为ctrl+d。

常见错误类型：syntax error（如忘写分号）、type error（int型被字符串进行赋值）、declaration error（名字拼写错误、忘写std::）

修改一部分代码就重新编译调试一次，因为后面很多错误可能只是由前面修改的错误引起的。

类就是一种自定义的数据类型

**标准库的头文件使用#include<>**，非标准库的头文件（自己写的头文件）使用include""。

./test.out <text.txt> text2.txt：代表使用cin的地方从text.txt中读取内容，使用cout的地方将内容输出到text2.txt中





4.空类型（void）：当函数不返回任何值时使用空类型作为返回类型。

不同机器上数据类型（又称算术类型）占用的比特不同，但c++规定了各类型的最小尺寸。

wchar：存放扩展字符；char16_t、char32_t：存放Unicode字符

每个地址上可以存放的比特数称为字节，一个字节一般是八个比特；CPU一次性处理的数据大小称为字，**64位计算机指的是字的大小为8个字节。**

char用signed char或unsigned char来实现，不同的编译器实现的方式不同；所以如果实在必须将char当成整型来用，指明使用的是signed char还是unsigned char。

数值范围int无法表示，一般直接使用long long；浮点运算一般使用double，不使用float。





5.类型转换

类型转换：如char转int——就是将char变量对应的二进制码解读成int。

给**无符号数**赋值超过表示范围时，结果是初始值对无符号类型可表示的数值的个数取模后的**余数**。给**有符号数赋值**超过表示范围时，结果为**未定义**，此时程序可能出现不可预知的风险。

**int和无符号数相加**时，int变量会被转换成**无符号数**。如果此时int变量是负数，则直接将此负数对应的二进制补码解读成原码；

无符号相减得到的结果如果是负数：如u2-u1为负数，则u2-u1=u2+(-u1)，其中-u1的机器码为补码，这里的补码解读为原码。

**for(unsigned u=10;u>=0;- -u)**中当u=-1时，u实际为4294967295。及其解决方法。

**切勿混用带符号类型和无符号**类型进行运算





6.字面值常量

字面值常量：就是告诉你整数、浮点数、字符串等需要怎么表示

八进制：0开头；十六进制：0x或0X开头

默认情况下，十进制字面值是带符号数，八进制和十六进制字面值既可能是带符号的也可能是无符号的。

十进制字面值是利用“int、long、long long”中一个来装载的。具体选的是可容纳此字面值的最小类型来装载。

八进制和十六进制字面值是利用“int、unsigned int、long、unsigned Iong、Iong long和unsigned long long ”中一个来装载的。具体选的是可容纳此字面值的最小类型来装载。

浮点数默认使用**double**来装载。3.14159E0或3.14159e0中的E0或e0代表乘以10的0次方

我们还可以自己选择利用哪个类型来装载，只需要利用**字面值后添加相应的后缀**即可，如42ULL代表42这个数用unsigned long long来装载。如果指定的装载类型太小，编译器会自动用其他更大的类型来装



由单引号括起来的一个字符称为char型字面值，双引号括起来的零个或多个字符则构成字符串型字面值。

**字符串**字面值是由**字符数组**来装载的，编译器在每个字符串的**结尾**处添加一一个**空字符('\0')**， 因此，**字符串字**
**面值的实际长度要比它的内容多1。**

多行字符串实际会被当成一行字符串。

**给字面值添加前缀**来指明用什么类型装在字符或字符串，如L’a’代表用wchar_t装载字符a





7.变量

变量可以当成内置的对象

string在std命名空间中被定义

初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对象的当前值擦除，而以一个新值来替代。

列表初始化：int a={0}或int a{0}。如果我们使用列表初始化且初始值存在丢失信息的风险，则编译器将报错（如**int a{1.111}中的.111会丢失**）

**函数体外**定义的变量对应的机器码会**默认初始化为零**。**函数体内**定义的变量可能会初始化成**没有意义的数或者为未定义**。
一个未被初始化的内置类型变量的值是**未定义的**（还有，给有符号数赋值超过表示范围时，结果也为未定义），如果试图拷贝或以其他形式访问此未定义变量将引发错误。这句话没看懂？？？

为了安全**建议初始化每一个内置类型的变量**

声明：告诉了程序这个变量的存在，但未申请内存。定义：申请了内存。

声明：在变量前面添加extern，如extern int a;

一个文件如**果想使用别处定义的名字**则必须包含对那个**名字的声明**。

变量能且只能被定义一次。但是**可以被多次声明**。

**函数内部**不能声明变量

**显式初始化的声明即成为定义。**“extern int val = 1; ”为定义

**函数的声明是函数**头，也可以在函数头左边加上extern。函数声明的形参可以只写类型，而不写形参的名称。

c++中**不能使用标识符**：不能**连续**出现**两个下划线**；不能以**下划线紧连大写**字母开头；定义在**函数体外**的标识符**不能以下划线开头**。

**变量名**一般用**小写**字母，如index；用户自定义的**类名**一般以**大写字母开头**，如Sales_item;标识符由多个单词组成时，单词之间用下划线隔开或除第一个单词外的其他单词都大写。

不用把**定义**都放在开头，**放在使用的地方的附近**（注意不要重复定义）

cout<<**::reused**;表示访问**全局变量**reused

8.引用就是别名，**引用上的任何改变都是对原变量的改变**。int &a=b;

引用必须初始化；无法更改绑定对象；引用只能绑定在对象上，不能绑定在字面值上

引用的作用：函数fun(int &a)传入实参a时，不需要复制一份a，而直接传入a本身。函数fun(int a)传入实参a时，需要复制一份a。

指针：存储对象的地址。由于引用不是对象，只是别名，所以没有指向引用的指针。利用取地址符&取引用地址时，取到的是引用指向变量的地址。

无效指针：最常见的是，指针所指的内存单元被释放了，此时指针就变为了无效指针，**不遗留任何无效指针总是最好的实践方式。**

如果p是个指针，则\*p代表访问p所指向对象。

空指针：int *p=nullptr;int *p=0;int *p=NULL;

其中NULL是预处理变量，在预处理阶段会被替换成零

把**int变量直接赋给指针是错误的操作**，**即使int变量的值恰好等于0也不行**

建议**所有指针都要进行初始化**

指针一般写成这样：**int \*p**，而不写成int\* p。再如：int* p1, p2; // **p1是指向int的指针，p2是int**

指向指针的引用：给指针取别名，如int *&r=p，从右往左读，首先读到&，代表r是一个引用，其余部分代表r是什么类型数据的引用，即int指针的引用



9、const int k=9;定义一个不可改变的常量，k必须在定义的时候就**初始化**，任何在k上的操作都**不可以修改k**的值

**非常量引用不可以指向一个常量对象；常量引用可以指向一个非常量对象**

在初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可，如**const int &ri = dval ;其中dval为double类型**，此时ri绑定的是一个临时常量而不是dval。而下面这个却是错误的：**int &ri = dval ;其中dval为double类型**。为什么普通引用不可以绑定到临时常量上呢？答：因为一般需要修改dval时，才会使用普通引用。所以如果普通引用被绑定在临时变量上了，就不可以修改dval了

const int *ri = dval ;其中dval为int类型，即dval可以不是const int。dval为int类型时，应该和上面一样：ri实际是绑定了一个临时变量

const指针：指针本身为常量。

int \*const E=&e;const代表E本身是一个常量，int \*代表这个常量是int类型指针。const double \*const pip=\&pi;const代表pip是一个常量，const double \*代表这个常量是double常量类型指针

指针本身是一个常量并不意味着不能通过指针修改其所指对象的值。

顶层const( top-level const)表示本身是个常量，底层const (low-level const)表示指针或引用所指的对象是一个常量。

常量表达式：值不会改变并且在编译过程就能得到计算结果的表达式。如当表达式中含有函数时，计算结果是在运行的时候才能得到。常量表达式在后面会用到。

C++11中判断是否为常量表达式的方法是将表达式赋给constexpr变量。constexpr变量：constexpr int a = A，编译器会验证A是否为常量表达式。

constexpr指针：只能存放地址固定的对象的地址。如一般函数体内的对象（变量）一般不能由constexpr指向（但有例外，例外是啥呢？？？？），函数体内可以。

constexpr const int  \*p=&i; // p是常量指针，指向整型常量i
constexpr int \*p1=&j;// p1是常量指针，指向整数j

10、

取别名:

​		typedef int *p;  // p为int *的别名

​		typedef int p;   // p为int的别名

​		using SI = Sales_ item;  // SI为Sales_ item的别名

​		typedef char *pstring;
​		const pstring cstr = 0; // cstr是指向char的常量指针

​		const char *cstr = 0; // cstr是指向char类型常量的指针

auto item = val1 + val2; // auto推断出val1+val2为类型A，并将item定义成类型A。等号自然是将val1+val2的值，赋给了item。

auto也能在一条语句中声明多个变量以及其注意点

auto a = i; // i是一个引用。auto获取的是i所指对象的类型，而不是获取到引用类型。

auto会忽略顶层const，底层const会被保留下来。

使用auto获取引用类型和顶层const的方法

不能为非常量引用绑定字面值，可以为常量引用绑定字面值。

设置一个类型为auto的引用时，初始值中的顶层常量属性仍然保留。

auto不能确定基本数据类型是什么而导致的错误



decltype：只返回表达式的类型，返回表达式的值（即不用表达式的值进行初始化）

decltype(ci) x=2; \\\ 获取ci的类型A，将x定义成类型A并初始化为2；

decltype处理项层const和引用的方式与auto有些许不同。如果decltype使用的表达式是一个变量，则decltype返回该变量的类型(包括顶层const和引用在内):

需要指出的是，引用从来都作为其所指对象的同义词出现，只有用在decltype处是一个例外。

如果decltype使用的表达式不是一个变量时，则decltype返回表达式结果对应的类型【具体见原文】

如果表达式的内容是解引用操作，则decltype将得到引用类型。

切记: decltype ( (variable)) (注意是双层括号)的结果永远是引用，而decltype (variable)结果只有当生variable本身就是一个引用时才是引用。



使用struct自定义数据结构（类）【struct使用方法和class相似，不需要再看了 】

C++11新标准规定，可以为数据成员提供一个类内初始值

头文件的编写

类名一般和头文件名一样

头文件通常包含那些只能被定义一次的实体，如类、const和constexpr变量(

通过#ifndef和文件保护符防止头文件的重复引用。通常文件保护符的名字和类名有关





接下来看第三章







重载：相同函数名，不同形参

重写：子类对父类中相同函数（函数名、形参和返回值都相同）的覆盖

空的形参列表的两种表示：void f();或void f(void);。void f(void)是为了和C语言兼容

void函数不返回任何值。函数的返回类型不能是数组类型或函数类型，但可以是指向数组或函数的指针。



goto语句：goto label;代表跳转到代码label:所在的位置

# 异常处理
异常处理：throw在try中抛出异常，根据异常的不同选择不同的catch块。

多层函数调用中，出现异常，程序会一层一层的往上寻找对应的catch语句，找不到就终止程序。
catch块中一般进行内存释放等清理操作。
大多数常见的类都是定义在标准库中的，所以调用的时候，都要带std::，如std::runtime_error。
如果异常类型有一个字符串初始值，则what()返回字符串。
具体见原文和[链接](https://www.cnblogs.com/codingbigdog/p/16505862.html)



# 函数指针
将函数名替换成(*pf)就生成了一个函数指针pf。
函数名当成一个值使用时，该函数名被当成地址。
函数指针作为形参
函数指针作为返回值




# 智能指针
智能指针不用自己释放内存，只要没有指针指向内存了，就会自动释放。
shared ptr允许多个指针指向同一个对象
unique_ ptr则“独占”所指向的对象。
标准库还定义了一个名为weak_ ptr的伴随类，它是一种弱引用，指向shared ptr所管理的对象。这三种类型都定义在memory头文件中。
shared_ptr创建出对象，而对象当然有相应的方法可以调用，如返回对象被引用的次数。
make_shared用于动态分配内存并初始化
接下来看404





# IO库
cout<<：代表向对象cout写入内容，<<代表写入的意思
三大IO类：
- iostream针对IO流
- fstream针对文件
- sstream针对string类型
类型ifstream和istringstream都继承自istream。类型ofstream和ostringstream都继承自ostream。所以对istream和ostream进行的操作，对其他两类型也可以。





# 位运算符












# 其他：

补码运算：正数为原码本身，负数为原码取反加一









# 问题：

2.取模运算？答：[链接](https://blog.csdn.net/qq_42775938/article/details/122696829)

3.int转无符号数的规则是什么？

4.为什么说初始化和赋值是两个完全不同的操作，是因为一个使用构造函数，另一个使用别的东西吗？？

5.constexpr变量的变量到底有什么作用？

6.“2.2.1”中有一个问题？ ]]></description></item><item><title>C++ primer总结：C++异常处理</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/22/16505862.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Fri, 22 Jul 2022 07:15:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/22/16505862.html</guid><description><![CDATA[# 1.简介
异常处理：throw在try中抛出异常，根据异常的不同选择不同的catch块。
多层函数调用中，出现异常，程序会一层一层的往上寻找对应的catch语句，找不到就终止程序。
catch块中一般进行内存释放等清理操作。
大多数常见的类都是定义在标准库中的，所以调用的时候，都要带std::，如std::runtime_error。
如果异常类型有一个字符串初始值，则what()返回字符串。
exception是所有标准 C++ 异常的父类

# 2.实例
**1.抛出runtime_error异常：**
```
#include <iostream>
#include <stdexcept>
using std::cin; using std::cout; using std::endl; using std::runtime_error;

int main(void)
{
    for (int i, j; cout << "Input two integers:\n", cin >> i >> j; )
    {
        try 
        {
            if (j == 0) 
                throw runtime_error("divisor is 0");
            cout << i / j << endl;
        }
        catch (runtime_error err) 
        {
            cout << err.what() << "\nTry again? Enter y or n" << endl;
            char c;
            cin >> c;
            if (!cin || c == 'n')
                break;
        }
    }

    return 0;
}
```
**2.直接抛出字符串**
```
#include <iostream>
using namespace std;
 
double division(int a, int b)
{
   if( b == 0 )
   {
      throw "Division by zero condition!";
   }
   return (a/b);
}
 
int main ()
{
   int x = 50;
   int y = 0;
   double z = 0;
 
   try {
     z = division(x, y);
     cout << z << endl;
   }catch (const char* msg) {
     cerr << msg << endl;
   }
 
   return 0;
}
```

**3.catch(...)处理任何异常的代码**

修改“2.直接抛出字符串”中的代码，如下：
```
#include <iostream>
using namespace std;
 
double division(int a, int b)
{
   if( b == 0 )
   {
      throw "Division by zero condition!";
   }
   return (a/b);
}
 
int main ()
{
   int x = 50;
   int y = 0;
   double z = 0;
 
   try {
     z = division(x, y);
     cout << z << endl;
   }catch (...) {
     cerr << "处理异常。。。" << endl;
   }
 
   return 0;
}
```

# 3.定义新的异常
直接看[菜鸟教程](https://www.runoob.com/cplusplus/cpp-exceptions-handling.html)：就是继承了父类exception，重写了成员函数what()
]]></description></item><item><title>音视频学习总结</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/15/16482992.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Fri, 15 Jul 2022 14:33:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/15/16482992.html</guid><description><![CDATA[# ffmpeg库的使用
可以直接从

# 7
07-01-FFmpeg解封装解码：如解析出mp4中的各种流，音频流、视频流、字幕流等。主要涉及两个结构体AVFormatContext和AVPacket。AVFormatContext存储流信息，AVPacket存储包信息（可以将流当成很多个包的集合）
代码：本代码功能：打印媒体文件中的流信息（打印AVFormatContext结构体中的信息）
               打印流中每个包的信息（打印AVPacket 结构体中的信息）

07-02-AAC ADTS格式（音频格式）分析：ADTS可以在任意帧解码，也就是说它每⼀帧都有头信息。AAC⾳频⽂件（ADTS格式）的每⼀帧由ADTS Header和AAC Audio Data组成。⼀般情况下ADTS的头信息都是7个字节，分为2部分： adts_fixed_header();和adts_variable_header();。ADTS Header存放着采样率、码率、声道数、帧长度等信息。
代码：本代码将媒体文件中的音频利用AAC ADTS格式进行保存。从代码中可以看出，视频流中的AAC数据是没有包含头部的，头部需要自己去写。

07-03-H264 NALU分析：H264简介、IDR为I帧、H264将视频组织成为 序列(GOP)、图⽚(pictrue)、⽚(Slice)、宏块(Macroblock)、⼦块(subblock)五个层次进行网络传输。
NALU （视频流的网络传输单元）：H.264原始码流(裸流)是由⼀个接⼀个NALU组成。每个NALU的开头都是一个StartCode（"00 00 00 01" 或"00 00 01"），用于标识一个NALU的开始。
av_bsf_get_by_name("h264_mp4toannexb")将mp4模式转换为annexb模式
代码：本代码将媒体文件中的视频利用H264格式进行保存。

07-04-FLV格式分析-FLV封装格式剖析：FLV常用于直播。FLV封装格式是由⼀个⽂件头(file header)和 ⽂件体(file Body)组成。其中，FLV body由⼀ 对对的(Previous Tag Size字段 + tag)组成。
⼀个flv⽂件最多只有⼀个⾳频流，⼀个视频流。（mp4中就可能存在多个同种流）
每⼀个Tag也是由两部分组成:tag header和tag data。FLV Header和Tag Header中都有标识数据类型和长度的字段
tag data有三种：script、video、audio

代码：本代码一个bit一个bit地对flv文件进行解析。首先解析flv文件的头部和tag头部，然后分别解析tag data中包含的h264文件和aac文件，解析h264就是解析出一个个NALU并在NALU前面加上startcode，解析aac就是解析出一个个AAC Audio data并加上ADTS header。
本代码利用解析得到的信息，重新封装得到一个新的flv文件。
]]></description></item><item><title>ubuntu20.04进入 advanced options for ubuntu  recovery mode </title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/15/16480410.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Fri, 15 Jul 2022 02:30:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/15/16480410.html</guid><description><![CDATA[开机时，按shift+Esc]]></description></item><item><title>音视频处理常用软件</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/13/16472952.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Wed, 13 Jul 2022 02:31:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/13/16472952.html</guid><description><![CDATA[Beyond Compare：比较两个文件的二进制格式
MediaInfo：查看音视频文件的一些信息
winhex：可查看文件的十六进制格式]]></description></item><item><title>C++ opencv画框以及在框上设置标签</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/11/16466816.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Mon, 11 Jul 2022 08:18:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/11/16466816.html</guid><description><![CDATA[
```
int baseline = 0;
string label_string = "labels....";

// 框出图像中的某个物体。cv::Point(a,b)，其中a是相对于图片左边的距离，b是相对于图片上边的距离
cv::rectangle(image, cv::Point(left, top), cv::Point(right, bottom), cv::Scalar(0, 0, 255));   

// text_size中存储文本的宽高；baseline是基线y-相对于最底部文本的基线坐标【我也看不太懂baseline是什么？】
cv::Size text_size = cv::getTextSize(label_string, FONT_HERSHEY_SIMPLEX, 0.4, 1, &baseline);   

// 给文本填充背景颜色。虽然我也看不太懂baseline是什么，但是你把下面的baseline去掉看看效果，就大概知道baseline是个什么了
cv::rectangle(image, cv::Point(left, top - text_size.height - baseline), cv::Point(left+ text_size.width, top), cv::Scalar(255, 0, 255), -1);  

// 添加文字标签
cv::putText(image, label_string, cv::Point(left, top - baseline), FONT_HERSHEY_SIMPLEX, 0.4, cv::Scalar(0, 255, 255));
```
		]]></description></item><item><title>不同的python程序使用不同的虚拟环境</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/11/16465746.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Mon, 11 Jul 2022 03:07:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/11/16465746.html</guid><description><![CDATA[```
import os

def run():
    os.system('xxx/anaconda3/envs/paddle_ocr/bin/python3 ../src/python_scripts/paddleOcr.py')
```
使用指定虚拟环境下的python运行程序即可。]]></description></item><item><title>./my_cmake_exe: error while loading shared libraries: libswresample.so.4: cannot open shared object file: No such file or directory</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/11/16465317.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Mon, 11 Jul 2022 01:08:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/11/16465317.html</guid><description><![CDATA[我使用的编译命令如下：
```
 gcc  demuxing_decoding.c  -o demuxing_decoding -g -I ./ffmpeg-5.0.1/include -L ./ffmpeg-5.0.1/lib/ \
          -l avcodec -l avutil -l avformat -l swresample  -lm -Wl,-rpath=./ffmpeg-5.0.1/lib/                                    
```  
目录./ffmpeg-5.0.1/lib/下明明就有库 libswresample.so.4，但就是提示找不到这个动态库
最好实在没办法了，只能按照网上常用的方法：/etc/ld.so.conf中添加库 libswresample.so.4所在目录，并执行命令ldconfig。]]></description></item><item><title>使用Clion优雅的完全远程自动同步和远程调试c++</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/10/16462736.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Sun, 10 Jul 2022 02:40:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/10/16462736.html</guid><description><![CDATA[直接操作远程的代码就可以了，弄个Mappings不是多此一举吗？？]]></description></item><item><title>明明-Wl,-rpath指定的目录下有所要求的动态库，但是运行时就是说没有找到·</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/08/16459838.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Fri, 08 Jul 2022 14:41:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/08/16459838.html</guid><description><![CDATA[我的原因：
使用gcc  avframe.c avpacket.c  main.c -o main -I /home/ubuntu1/softwares/ffmpeg/include -L /home/ubuntu1/softwares/ffmpeg/lib/ -l avcodec -l avutil  -lm 生成可执行文件main，然后运行main的时候，发现运行时动态库找不到，原来是我忘记加-Wl,-rpath了。
此时加上-Wl,-rpath：gcc  avframe.c avpacket.c  main.c -o main -I /home/ubuntu1/softwares/ffmpeg/include -L /home/ubuntu1/softwares/ffmpeg/lib/ -l avcodec -l avutil  -lm -Wl,-rpath=/home/ubuntu1/softwares/ffmpeg/lib/，然后重新运行main。此时发现动态库还是找不到。
原因是因为前面运行的可执行文件main没有删除，要删除main以后，再重新进行编译。]]></description></item><item><title>cmake入门</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/08/16459532.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Fri, 08 Jul 2022 12:12:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/08/16459532.html</guid><description><![CDATA[# 1 cmake基础
## 1.1 简介
[CMake 和makefile关系](https://blog.csdn.net/u013827488/article/details/123804786)
不同平台有自己的make标准。如果软件想跨平台，必须要保证能够在不同平台编译。而如果使用上面的 Make 工具，就得为每一种标准写一次 Makefile ，这将是一件让人抓狂的工作。
CMake就是针对上面问题所设计的工具：它首先允许开发者编写一种平台无关的 CMakeList.txt 文件来定制整个编译流程，然后再根据目标用户的平台进一步生成所需的本地化 Makefile 和工程文件，如 Unix 的 Makefile 或 Windows 的 Visual Studio 工程。从而做到“Write once, run everywhere”。



## 1.2 语法特性介绍
基本语法格式：指令(参数 1 参数 2...) 
- 参数使用括弧括起
- 参数之间使用空格或分号分开 

指令是大小写无关的，参数和变量是大小写相关的，如：
```
set(HELLO hello.cpp)
add_executable(hello main.cpp hello.cpp)
ADD_EXECUTABLE(hello main.cpp ${HELLO})
```
变量使用${}方式取值，但是在 IF 控制语句中是直接使用变量名


## 1.3 重要指令和CMake常用变量
**重要指令:**
```
cmake_minimum_required(VERSION versionNumber [FATAL_ERROR]) 指定CMake的最小版本要求
# CMake最小版本要求为2.8.3
cmake_minimum_required(VERSION 2.8.3)

project(projectname [CXX] [C] [Java])   定义工程名称，并可指定工程支持的语言。一般只定义工程名称。
# 指定工程名为HELLOWORLD
project(HELLOWORLD) 

set(VAR [VALUE] [CACHE TYPE DOCSTRING [FORCE]])  显式的定义变量
# 定义SRC变量，其值为sayhello.cpp hello.cpp
set(SRC sayhello.cpp hello.cpp)

include_directories([AFTER|BEFORE] [SYSTEM] dir1 dir2 ...)    向工程添加多个特定的头文件搜索路径 --->相当于指定g++编译器的-I参数
# 将/usr/include/myincludefolder 和 ./include 添加到头文件搜索路径
include_directories(/usr/include/myincludefolder ./include)

link_directories(dir1 dir2 ...) 向工程添加多个特定的库文件搜索路径 --->相当于指定g++编译器的-L参数
# 将/usr/lib/mylibfolder 和 ./lib 添加到库文件搜索路径
link_directories(/usr/lib/mylibfolder ./lib)

add_library(libname [SHARED|STATIC|MODULE] [EXCLUDE_FROM_ALL] source1 source2 ... sourceN) 生成库文件
# 通过变量 SRC 生成 libhello.so 共享库，即将SRC中的文件编译成共享库文件
add_library(hello SHARED ${SRC}) 

add_compile_options(）添加编译参数
# 添加编译参数 -Wall -std=c++11 -O2
add_compile_options(-Wall -std=c++11 -O2)

add_executable(exename source1 source2 ... sourceN)  生成可执行文件
# 编译main.cpp生成可执行文件main
add_executable(main main.cpp)

target_link_libraries(target library1<debug | optimized> library2...)  为 target 添加需要链接的共享库 --->相同于指定g++编译器-l参数
# 将hello动态库文件链接到可执行文件main
target_link_libraries(main hello)

# 当前目录中有一个子项目，子项目中有一个CMakeLists.txt文件，用于构建子项目。此时在主项目的CMakeLists.txt文件中就要
# 使用add_subdirectory说明这个子项目的存在，这样在执行主项目的CMakeLists.txt文件的时候，子项目的CMakeLists.txt也会被执行
add_subdirectory(source_dir [binary_dir] [EXCLUDE_FROM_ALL])  
# 添加src子目录，src中需有一个CMakeLists.txt
add_subdirectory(src)
add_subdirectory的具体使用可参考：https://www.jianshu.com/p/07acea4e86a3
  
aux_source_directory(dir VARIABLE) 发现一个目录下所有的源代码文件并将列表存储在一个变量中，这个指令临时被用来自动构建源文件列表
# 定义SRC变量，其值为当前目录下所有的源代码文件
aux_source_directory(. SRC)
# 编译SRC变量所代表的源代码文件，生成main可执行文件
add_executable(main ${SRC})
```


**CMake常用变量:**
```
CMAKE_C_FLAGS gcc编译选项
CMAKE_CXX_FLAGS g++编译选项
# 在CMAKE_CXX_FLAGS编译选项后追加-std=c++11
set( CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -std=c++11")

CMAKE_BUILD_TYPE 编译类型(Debug, Release)
# 设定编译类型为debug，调试时需要选择debug。相当于gcc中的-g选项
set(CMAKE_BUILD_TYPE Debug)  
# 设定编译类型为release，发布时需要选择release
set(CMAKE_BUILD_TYPE Release)

CMAKE_BINARY_DIR 
PROJECT_BINARY_DIR
_BINARY_DIR
1. 这三个变量指代的内容是一致的。
2. 如果是 in source build，指的就是工程顶层目录。
3. 如果是 out of source 编译,指的是工程编译发生的目录。
4. PROJECT_BINARY_DIR 跟其他指令稍有区别，不过现在，你可以理解为他们是一致的。

CMAKE_SOURCE_DIR
PROJECT_SOURCE_DIR
_SOURCE_DIR
1. 这三个变量指代的内容是一致的,不论采用何种编译方式,都是工程顶层目录。
2. 也就是在 in source build时,他跟 CMAKE_BINARY_DIR 等变量一致。
3. PROJECT_SOURCE_DIR 跟其他指令稍有区别,现在,你可以理解为他们是一致的。

CMAKE_C_COMPILER：指定C编译器
CMAKE_CXX_COMPILER：指定C++编译器
EXECUTABLE_OUTPUT_PATH：可执行文件输出的存放路径
LIBRARY_OUTPUT_PATH：库文件输出的存放路径
```


# 1.4  CMake编译工程
**CMake目录结构：**项目主目录存在一个CMakeLists.txt文件

**两种方式设置编译规则：**
1. 包含源文件的子文件夹包含CMakeLists.txt文件，主目录的CMakeLists.txt通过add_subdirectory添加子目录即可；
2. 包含源文件的子文件夹未包含CMakeLists.txt文件，子目录编译规则体现在主目录的CMakeLists.txt中；

**两种构建方式:**
内部构建(in-source build)【不推荐使用】：内部构建会在同级目录下产生一大堆中间文件，这些中间文件并不是我们最终所需要的，和工程源文件放在一起会显得杂乱无章。
```
## 内部构建
# 在当前目录下，编译本目录的CMakeLists.txt，生成Makefile和其他文件
cmake .
# 执行make命令，生成target
make
```
外部构建(out-of-source build)【推荐使用】：将编译输出文件与源文件放到不同目录中
```
## 外部构建
# 1. 在当前目录下，创建build文件夹
mkdir build 
# 2. 进入到build文件夹
cd build
# 3. 编译上级目录的CMakeLists.txt，生成Makefile和其他文件
cmake ..
# 4. 执行make命令，生成target
make
```



# 2 实例
## 2.1 内部构建和外部构建
helloworld.cpp:
```
#include <iostream>
using namespace std;

int main(int argc, char **argv)
{
    cout << "Hello World!" << endl;
    return 0;
}
```
CMakeLists.txt：
```
cmake_minimum_required(VERSION 3.0) 

project(HELLOWORLD)

add_executable(helloWorld_cmake helloworld.cpp) # 等价于g++ helloworld.cpp -o helloWorld_cmake
```



### 内部构建（in source build）


cmake
```
cmake .
-- The C compiler identification is GNU 9.4.0
-- The CXX compiler identification is GNU 9.4.0
-- Check for working C compiler: /usr/bin/cc
-- Check for working C compiler: /usr/bin/cc -- works
-- Detecting C compiler ABI info
-- Detecting C compiler ABI info - done
-- Detecting C compile features
-- Detecting C compile features - done   #检查c和c++语言编译器
-- Check for working CXX compiler: /usr/bin/c++
-- Check for working CXX compiler: /usr/bin/c++ -- works
-- Detecting CXX compiler ABI info
-- Detecting CXX compiler ABI info - done
-- Detecting CXX compile features
-- Detecting CXX compile features - done
-- Configuring done
-- Generating done
-- Build files have been written to: /home/ubuntu1/projects/test_c++/test2/Class_5/5.3.1 helloWorld
```
cmake命令生成了四个个文件：
```
CMakeCache.txt  
CMakeFiles  
cmake_install.cmake   
# 初学者不需要管上面三个文件
Makefile
```
make:
```
make
Scanning dependencies of target helloWorld_cmake
[50%] Building CXX object CMakeFiles/helloWorld_cmake.dir/helloworld.cpp.o  # 正在生成.o文件
[100%] Linking CXX executable helloWorld_cmake    # 连接
[100%] Built target helloWorld_cmake
```
make命令生成了可执行文件helloWorld_cmake


### 外部构建（out of source）【推荐】

```
mkdir build
cd build
cmake ..
make

```
外部构建就是将cmake生成的中间文件、Makefile和可执行文件都放在build目录中了。


## 2.2 动态库链接和加载
实例2的目录结构如下所示：
```
tree .   # tree .命令获取当前目录的结构
.
├── CMakeLists.txt
├── include
│   └── swap.h
├── main.cpp
└── src
    └── swap.cpp
```
main.cpp:
```
#include "swap.h"

int main(int argc, char **argv)
{
    swap myswap(10, 20);
    std::cout << "Before swap:" << std::endl;
    myswap.printInfo();
    myswap.run();
    std::cout << "After  swap:" << std::endl;
    myswap.printInfo();

    return 0;

}
```
swap.h:
```
#pragma once     // 用于防止头文件的重复包含
#include <iostream>

class swap
{
public:
    swap(int a, int b){
        this->_a = a;
        this->_b = b;
    }
    void run();
    void printInfo();
private:
    int _a;
    int _b;
};
```
swap.cpp:
```
#include "swap.h"

void swap::run()
{
    int temp;
    temp  = _a;
    _a = _b;
    _b = temp;
}

void swap::printInfo()
{
    std::cout << "_a = " << _a << std::endl;
    std::cout << "_b = " << _b << std::endl;
}
```
CMakeLists.txt:
```
cmake_minimum_required(VERSION 3.0)

project(SWAP)

include_directories(include)  # 等价于-I include

add_library(swap SHARED src/swap.cpp) # 生成动态库

add_executable(main_cmake main.cpp)   # 生成可执行文件

target_link_libraries(main_cmake swap) # 链接库文件
```
编译：
```
mkdir build
cd build
cmake ..
make

```





# 3  CMakeLists.txt文件学习

下面是几个实际项目中的CMakeLists.txt文件，可以看看进行学习，遇到没学过的就去查一查。

## 3.1 实例1

CMakeLists.txt:
```
cmake_minimum_required(VERSION 3.0)

project(SOLIDERFIRE)                             # 项目名为SOLIDERFIRE

set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wall")  # -Wall：输出警告的信息
                                                 # "${CMAKE_CXX_FLAGS} -Wall"表示在原有的CMAKE_CXX_FLAGS后添加-Wall
                                                 # ${CMAKE_CXX_FLAGS}是g++编译选项

set(CMAKE_BUILD_TYPE Debug)    # 让输出的可执行文件是可debug的

include_directories(${CMAKE_SOURCE_DIR}/include) # 头文件所在目录

add_executable(my_cmake_exe main.cpp src/Gun.cpp src/Solider.cpp)  # 对main.cpp、src/Gun.cpp和src/Solider.cpp三个cpp文件进行编译
```


## 3.2 实例2
```
cmake_minimum_required(VERSION 3.0)

set(SOURCE_FILES main.c)

project(TEST2)                             # 项目名为TEST2

set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wall")  # -Wall：输出警告的信息
                                                 # "${CMAKE_CXX_FLAGS} -Wall"表示在原有的CMAKE_CXX_FLAGS后添加-Wall

set(CMAKE_BUILD_TYPE Debug)    # 让输出的可执行文件是可debug的

include_directories(${CMAKE_SOURCE_DIR}/ffmpeg/include)

link_directories(
		${CMAKE_SOURCE_DIR}/ffmpeg/lib/    # 指明库文件所在目录
)

add_executable(my_cmake_exe avframe.c avpacket.c  main.c )  # 对avframe.c avpacket.c  main.c 三个cpp文件进行编译

target_link_libraries(my_cmake_exe avcodec avutil m) # 指明具体链接的库的名称
```


## 3.3 实例三
可以对下面实例中，不懂的函数或变量进行百度，并进行注释，从而达到学习的目的。【现在懒得学，以后再说吧。】
```
cmake_minimum_required(VERSION 2.6)
project(pro)
add_definitions(-std=c++11)  # CmakeList支持c++11的方式有两种：
                             # SET(CMAKE_CXX_FLAGS "-std=c++11")
                             # add_definitions(-std=c++11)

option(CUDA_USE_STATIC_CUDA_RUNTIME OFF)
set(CMAKE_CXX_STANDARD 11)
set(CMAKE_BUILD_TYPE Debug)
set(EXECUTABLE_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/workspace)

set(CUDA_GEN_CODE "-gencode=arch=compute_75,code=sm_75")

set(OpenCV_DIR   "/data/datav/expstation/lean/opencv4.2.0/lib/cmake/opencv4/")

set(CUDA_DIR     "/data/sxai/lean/cuda-10.2")
set(CUDNN_DIR    "/data/sxai/lean/cudnn8.2.2.26")
set(TENSORRT_DIR "/data/sxai/lean/TensorRT-8.0.1.6-cuda10.2-cudnn8.2")



find_package(CUDA REQUIRED)
find_package(OpenCV)

include_directories(
    ${PROJECT_SOURCE_DIR}/src
    ${OpenCV_INCLUDE_DIRS}
    ${CUDA_DIR}/include
    ${TENSORRT_DIR}/include
    ${CUDNN_DIR}/include
)


link_directories(
    ${TENSORRT_DIR}/lib
    ${CUDA_DIR}/lib64
    ${CUDNN_DIR}/lib
)

set(CMAKE_CXX_FLAGS  "${CMAKE_CXX_FLAGS} -std=c++11 -Wall -O0 -Wfatal-errors -pthread -w -g")
set(CUDA_NVCC_FLAGS "${CUDA_NVCC_FLAGS} -std=c++11 -O0 -Xcompiler -fPIC -g -w ${CUDA_GEN_CODE}")
file(GLOB_RECURSE cpp_srcs ${PROJECT_SOURCE_DIR}/src/*.cpp)
file(GLOB_RECURSE c_srcs ${PROJECT_SOURCE_DIR}/src/*.c)
file(GLOB_RECURSE cuda_srcs ${PROJECT_SOURCE_DIR}/src/*.cu)
cuda_add_library(cucodes SHARED ${cuda_srcs})

add_executable(pro ${cpp_srcs} ${c_srcs})


target_link_libraries(cucodes nvinfer nvonnxparser)
target_link_libraries(cucodes cuda cublas cudart cudnn)
target_link_libraries(pro ${OpenCV_LIBS})
target_link_libraries(pro cucodes)

add_custom_target(
    run
    DEPENDS pro
    WORKING_DIRECTORY ${PROJECT_SOURCE_DIR}/workspace
    COMMAND ./pro
)
```




参考：https://www.bilibili.com/video/BV1fy4y1b7TC、微信公众号：VSCode、bilibili ：xiaobing1016
]]></description></item><item><title>vscode中配置C/C++调试环境（launch.json和tasks.json）</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/08/16459417.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Fri, 08 Jul 2022 11:09:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/08/16459417.html</guid><description><![CDATA[# 1.launch.json和tasks.json
## 1.1 launch.json


launch.json中存放运行或者调试可执行文件时的配置：
```
{
    // Use IntelliSense to learn about possible attributes.
    // Hover to view descriptions of existing attributes.
    // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387
    "version": "0.2.0",
    "configurations": [
        {
            "name": "g++ - Build and debug active file",  // 名字随便取
            "type": "cppdbg",
            "request": "launch",
            // program 指定调试那个可执行文件，需要绝对路径
            // ${fileDirname} 当前打开的文件所在的绝对路径，不包括文件名
            // ${fileBasenameNoExtension} 当前打开的文件的文件名，不包括路径和后缀名
            "program": "${fileDirname}/${fileBasenameNoExtension}.out", 
            "args": [],
            "stopAtEntry": false,
            "cwd": "${fileDirname}",
            "environment": [],
            "externalConsole": false,
            "MIMode": "gdb",
            "setupCommands": [
                {
                    "description": "Enable pretty-printing for gdb",
                    "text": "-enable-pretty-printing",
                    "ignoreFailures": true
                },
                {
                    "description": "Set Disassembly Flavor to Intel",
                    "text": "-gdb-set disassembly-flavor intel",
                    "ignoreFailures": true
                }
            ],
            "preLaunchTask": "C/C++: g++ build active file",  // 在执行lanuch.json之前要做的任务
            "miDebuggerPath": "/bin/gdb"        // 指定调试工具
        }
    ]
}

```
其他参数解释：
```
${fileBasename}  当前打开的文件名+后缀名，不包括路径
${fileExtname} 当前打开的文件的后缀名
${cwd} the task runner's current working directory on startup
${workspaceFolder} .vscode所在目录的绝对路径
```


【注】文件名launch.json的前后不能有空格。如果你发现launch.json中明明正确的地方竟然都有红色的波浪线，很可能就是你的文件名launch.json有问题。

## 1.2 tasks.json

tasks.json中存放生成可执行文件的命令：
```
{
    "tasks": [
        {
            "type": "cppbuild",
            "label": "C/C++: g++ build active file",  // 任务名，在lanuch.json使用此任务名，从而执行此任务
            "command": "/bin/g++",
            "args": [
                "-fdiagnostics-color=always",
                "-g",
                // "${file}",
                "${fileDirname}/*.cpp",   // 编译当前打开的文件所在目录下的所有.cpp文件
                "-o",
                "${fileDirname}/${fileBasenameNoExtension}.out"  // 目标文件名
            ],
            "options": {
                "cwd": "${fileDirname}"
            },
            "problemMatcher": [
                "$gcc"
            ],
            "group": {
                "kind": "build",
                "isDefault": true
            },
            "detail": "调试器生成的任务。"
        }
    ],
    "version": "2.0.0"
}
```

## 1.3 c_cpp_properties.json
本小节使用cmake生成compile_commands.json，然后在c_cpp_properties.json中配置c_cpp_properties.json文件实现代码的跳转。具体见[vscode使用compile_commands.json配置includePath环境](https://blog.csdn.net/qq_37868450/article/details/105013325).
这里的代码跳转指的是：光标移动到相应函数，然后按“ctrl+点击”就可以进行跳转。如果需要在debug的时候实现代码跳转，直接在launch.json中指定cmake生成的可执行文件就可以。



# 2.测试项目
项目结构：
```
├── include
│   └── Sales_item.h
├── src
│   ├── main.cpp
│   └── Sales_item.cpp
└── .vscode
    ├── launch.json
    └── tasks.json

```
main.cpp
```
#include <iostream>
#include "../include/Sales_item.h"

using namespace std;

int main() {
    Sales_item item1, item2;

    item1.isbn = "0-201-78345-X";
    item1.units_sold = 10;
    item1.revenue = 300.0;

    cout << item1.avg_price() << endl;

    item2.isbn = "0-201-78345-X";
    item2.units_sold = 2;
    item2.revenue = 70;

    cout << item2.avg_price() << endl;

    if (item2.same_isbn(item1)) {
        cout << "same" << endl;
    } else {
        cout << "not same" << endl;
    }

    return 0;
}
````

Sales_item.h
```
#ifndef __SALES_ITEM_H_
#define __SALES_ITEM_H_

#include <string>

class Sales_item {
public:
    // 常量成员函数
    // 由于这个函数不对类的数据成员做任何修改，所以可以定义为常函数【参数列表后面加上const】
    bool same_isbn(const Sales_item &rhs) const {
        // this->isbn = "1";  // 错误，常函数不能修改数据成员
        return this->isbn == rhs.isbn;
    }

    double avg_price() const;

public:
    Sales_item() : units_sold(0), revenue(0) {}

    // 本来应该将成员变量设为private的，但是为了方便，写成public
public:
    std::string isbn;
    unsigned units_sold;
    double revenue;
};

#endif  // !__SALES_ITEM_H_
```
Sales_item.cpp
```
#include "../include/Sales_item.h"

// 类外定义成员函数体，需要加上类作用域，即类的名字
double Sales_item::avg_price() const {
    if (!this->units_sold) {
        return 0;
    } else {
        return this->revenue / this->units_sold;
    }
}
```
直接复制上面提到的lanuch.json和task.json到.vscode文件夹下，然后在main.cpp文件下点击“运行——》启动调试”
]]></description></item><item><title>H264</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/07/16454807.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Thu, 07 Jul 2022 07:19:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/07/16454807.html</guid><description><![CDATA[264和265区别就是后者更高压缩比、占空间小、编码解码更消耗资源，但是现在新的设备对h265做了硬件优化。]]></description></item><item><title>FFmpeg编程入门</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/05/16448954.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Tue, 05 Jul 2022 14:48:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/05/16448954.html</guid><description><![CDATA[# 0.源码编译安装ffmpeg

我安装ffmpeg版本是ffmpeg-4.2.7。
建议直接参考这篇文章[ubuntu20源码编译安装ffmpeg](https://blog.csdn.net/H_Zhang/article/details/123684216)，这篇文档进行的是最简单的安装。如果按照[官方按照教程](https://trac.ffmpeg.org/wiki/CompilationGuide)进行按照可能会由于依赖问题，而无法使用。

如果参考[官方安装教程](https://trac.ffmpeg.org/wiki/CompilationGuide/Ubuntu)进行源码安装。在按照官方安装教程进行安装的时候，需要安装各种库，可以使用命令sudo apt-get install安装库，就尽量使用sudo apt-get install来安装。有些不能使用sudo apt-get install安装的库，就使用教程中的源码编译方式进行安装。


源码安装以后，会生成四个目录，分别为bin、include、lib和share。我们可以将include和lib拷贝到本系统的任何位置进行使用。从share可以学习到ffmpeg的使用实例，可以通过学习这些实例，从而进行进阶学习。

在设置ffmpeg安装配置时，有些库如果你安装失败了或者没有安装，请记得不要在./configure中对这些库进行enable，如：你没有安装库libaom，就要去掉 --enable-libaom。

在安装完ffmpeg后，你需要添加并enable一些库，怎么办？
答：我觉得只能下载这些库，然后重新对ffmpeg进行配置和编译。

参考：[链接](https://www.cnblogs.com/phillee/p/14605815.html)


## 0.1 简单的程序测试
### 0.1.1 c程序测试
测试程序test.c：
```
#include <stdio.h>
 #include "libavutil/avutil.h"
 int main(){
    printf("Hello FFMPEG, version is %s\n", av_version_info());
    return 0;
 }
```
编译和运行：
```
gcc test.c -o test -I /home/ubuntu1/ffmpeg_build/include -L /home/ubuntu1/ffmpeg_build/lib/ -l avutil   # avutil是静态库，所以不需要选项-Wl,-rpath
./test
Hello FFMPEG, version is N-107317-g85bc6b5abf
```


### 0.1.2 c++程序测试
由于 FFmpeg 是用C99标准写成的，有些功能在 C++ 中可能无法直接编译或者使用。
所以需要使用extern "C"显示声明头文件为C格式文件。
测试程序test.cpp：
```
#include <stdio.h>
extern "C" {
#include "libavutil/avutil.h"
}
int main(){
    printf("Hello FFMPEG, version is %s\n", av_version_info());
    return 0;
}
```
编译和运行：
```
g++ test.cpp -o test -I /home/ubuntu1/ffmpeg_build/include -L /home/ubuntu1/ffmpeg_build/lib/ -l avutil -D__STDC_CONSTANT_MACROS   # 没加-D__STDC_CONSTANT_MACROS时，如果不出错，就不加了。
./test
Hello FFMPEG, version is N-107317-g85bc6b5abf
```







# 1 播放器框架
![](https://img2022.cnblogs.com/blog/1617829/202207/1617829-20220705221027151-778735221.png)

图中其实涉及三个数据结构，分别为AVFormatContext、AVPacket和AVFrame。我对这三个数据结构的理解如下：
AVFormatContext可以当成是整个媒体文件，可以从中取出视频流、音频流和字幕流等信息。
而每个流都是由一个一个packet组成的，每个packet使用AVPacket数据结构进行保存。
由于流一般都是被压缩的数据，故AVPacket也是被压缩的数据，AVPacket经过解压就生成了原始数据帧AVFrame


# 2 常用音视频术语
• 容器／文件（Conainer/File）：即特定格式的多媒体文件，比如mp4、flv、mkv等。
• 媒体流（Stream）：表示时间轴上的一段连续数据，如一段声音数据、一段视频数据或一段字幕数据，可以是压缩的，也可以是非压缩的，压缩的数据需要关联特定的编解码器（有些码流音频他是纯PCM，视频流一般不会是未压缩的YUV格式）。
• 数据帧／数据包（Frame/Packet）：通常，一个媒体流是由大量的数据帧组成的，对于压缩数据，帧对应着编解码器的最小处理单元，分属于不同媒体流的数据帧交错存储于容器之中。
• 编解码器：编解码器是以帧为单位实现压缩数据和原始数据之间的相互转换的

# 3 FFmpeg库简介
FFMPEG有8个常用库：
• AVUtil：核心工具库，下面的许多其他模块都会依赖该库做一些基本的音视频处理操作。
• AVFormat：文件格式和协议库，该模块是最重要的模块之一，封装了Protocol层和Demuxer、Muxer层，使得协议和格式对于开发者来说是透明的。
• AVCodec：编解码库，封装了Codec层，但是有一些Codec是具备自己的License的，FFmpeg是不会默认添加像libx264、FDK-AAC等库的，但是FFmpeg就像一个平台一样，可以将其他的第三方的Codec以插件的方式添加进来，然后为开发者提供统一的接口。
• AVFilter：音视频滤镜库，该模块提供了包括音频特效和视频特效的处理，在使用FFmpeg的API进行编解码的过程中，直接使用该模块为音视频数据做特效处理是非常方便同时也非常高效的一种方式。
• AVDevice：输入输出设备库，比如，需要编译出播放声音或者视频的工具ffplay，就需要确保该模块是打开的，同时也需要SDL的预先编译，因为该设备模块播放声音与播放视频使用的都是SDL库。
• SwrRessample：该模块可用于音频重采样，可以对数字音频进行声道数、数据格式、采样率等多种基本信息的转换。
• SWScale：该模块是将图像进行格式转换的模块，比如，可以将YUV的数据转换为RGB的数据，缩放尺寸由1280*720变为800*480。 
• PostProc：该模块可用于进行后期处理，当我们使用AVFilter的时候需要打开该模块的开关，因为Filter中会使用到该模块的一些基础函数

# 4 FFmpeg函数简介
◼ av_register_all()：注册所有组件,4.0已经弃用
◼ avdevice_register_all()对设备进行注册，比如V4L2等。
◼ avformat_network_init();初始化网络库以及网络加密协议相关的库（比如openssl）

# 4.1 封装格式相关
◼ avformat_alloc_context();负责申请一个AVFormatContext结构的内存,并进行简单初始化
◼ avformat_free_context();释放该结构里的所有东西以及该结构本身
◼ avformat_close_input();关闭解复用器。关闭后就不再需要使用avformat_free_context 进行释放。
◼ avformat_open_input();打开输入视频文件
◼ avformat_find_stream_info()：获取音视频文件信息
◼ av_read_frame(); 读取音视频包
◼ avformat_seek_file(); 定位文件，就是起到拉动进度条的作用
◼ av_seek_frame():定位文件

调用流程：
![](https://img2022.cnblogs.com/blog/1617829/202207/1617829-20220705222645225-287401976.png)

# 4.2 解码器相关
• avcodec_alloc_context3(): 分配解码器上下文
• avcodec_find_decoder()：根据ID查找解码器，就是告诉它你要什么解码器，比如你可以告诉它你需要h264解码器
• avcodec_find_decoder_by_name():根据解码器名字，它知道了你需要h264解码器，它还需要知道你需要哪个h264解码器（h264解码器有多个）。不使用avcodec_find_decoder_by_name()时，直接使用第一个h264解码器。
• avcodec_open2()： 打开编解码器
• avcodec_decode_video2()：解码一帧视频数据【不建议使用】
• avcodec_decode_audio4()：解码一帧音频数据【不建议使用】
• avcodec_send_packet(): 发送编码数据包
• avcodec_receive_frame(): 接收解码后数据
• avcodec_free_context():释放解码器上下文，包含了avcodec_close()
• avcodec_close():关闭解码器

解码流程：
![](https://img2022.cnblogs.com/blog/1617829/202207/1617829-20220705224633633-1869952147.png)

# 5 组件注册方式
## 5.1 FFmpeg 3.x 组件注册方式
我们使用ffmpeg，首先要执行av_register_all，把全局的解码器、编码器等结构体注册到各自全局的对象链表里，以便后面查找调用。一个av_register_all函数，做了以下工作：
![](https://img2022.cnblogs.com/blog/1617829/202207/1617829-20220706140056967-1384372148.png)

虽然在FFmpeg 4.x以上的版本没有av_register_all，但是其内部也是经过了上面的注册操作。


## 5.2 Ffmpeg 4.0.2 组件注册方式
av_register_all操作是FFmepg内部去做，不需要用户调用av_register_all去注册。
以codec编解码器为例：
1. 在configure的时候生成要注册的组件
./configure:7203:print_enabled_components libavcodec/codec_list.c 
AVCodec codec_list $CODEC_LIST
这里会生成一个codec_list.c 文件，里面只有static const AVCodec* const codec_list[]数组。
2. 在libavcodec/allcodecs.c将static const AVCodec * const codec_list[]的编解码器用链表的方式组织起来。

对于demuxer/muxer（解复用器，也称容器）则对应：

3. libavformat/muxer_list.c
libavformat/demuxer_list.c 这两个文件也是在configure的时候生成，也就是说直接下载源码是没有这两个文件的。
4. 在libavformat/allformats.c将demuxer_list[]和muexr_list[]以链表的方式组织。
其他组件也是类似的方式。
  
# 6.FFmpeg数据结构简介
AVFormatContext：封装格式上下文结构体，也是统领全局的结构体，保存了视频文件封装格式相关信息。
AVInputFormat demuxer：每种封装格式（例如FLV, MKV, MP4, AVI）对应一个该结构体。
AVOutputFormat muxer
AVStream：视频文件中每个视频（音频）流对应一个该结构体。
AVCodecContext：编解码器上下文结构体，保存了视频（音频）编解码相关信息。
AVCodec：每种视频（音频）编解码器(例如H.264解码器)对应一个该结构体。
AVPacket：存储一帧压缩编码数据。AVPacket 里面也有一个index的字段，通过index就可以区分出不同的码流。
AVFrame：存储一帧解码后像素（采样）数据。

**FFmpeg数据结构之间的关系：**
![](https://img2022.cnblogs.com/blog/1617829/202207/1617829-20220706141810676-1397601431.png)
将音视频包装成AVFormatContext结构的数据，通过访问streams就相当于访问了音视频。音视频中可能存在各种流，通过访问streams就可以得到这些流，然后通过avformat_find_stream_info()获取流的编解码信息。通过avcodec_parameters_to_context()将编解码信息拷贝到上下文AVCodecContext中取。

**AVPacket和AVFrame之间的关系：**
![](https://img2022.cnblogs.com/blog/1617829/202207/1617829-20220706143034067-1488084908.png)
  
**FFmpeg数据结构分析：**
◼ AVFormatContext
• iformat：输入媒体的AVInputFormat，比如指向AVInputFormat ff_flv_demuxer
• nb_streams：输入媒体的AVStream 个数
• streams：输入媒体的AVStream []数组，数组的每一个元素都是一个流。
• duration：输入媒体的时长（以微秒为单位），计算方式可以参考av_dump_format()函数。
• bit_rate：输入媒体的码率
◼ AVInputFormat
• name：封装格式名称
• extensions：封装格式的扩展名
• id：封装格式ID
• 一些封装格式处理的接口函数,比如read_packet()
◼ AVStream
• index：标识该视频/音频流
• time_base：该流的时基，PTS*time_base=真正的时间（秒）
• avg_frame_rate： 该流的帧率
• duration：该视频/音频流长度
• codecpar：编解码器参数属性
◼ AVCodecParameters
• codec_type：媒体类型，比如AVMEDIA_TYPE_VIDEO AVMEDIA_TYPE_AUDIO等
• codec_id：编解码器类型， 比如AV_CODEC_ID_H264 AV_CODEC_ID_AAC等。
◼ AVCodecContext
• codec：编解码器的AVCodec，比如指向AVCodec 
ff_aac_latm_decoder
• width, height：图像的宽高（只针对视频）
• pix_fmt：像素格式（只针对视频）
• sample_rate：采样率（只针对音频）
• channels：声道数（只针对音频）
• sample_fmt：采样格式（只针对音频）
◼ AVCodec
• name：编解码器名称
• type：编解码器类型
• id：编解码器ID
• 一些编解码的接口函数，比如int (*decode)()
◼AVPacket
• pts：显示时间戳
• dts：解码时间戳
• data：压缩编码数据
• size：压缩编码数据大小
• pos:数据的偏移地址
• stream_index：所属的AVStream
◼AVFrame
• data：解码后的图像像素数据（音频采样数据）
• linesize：对视频来说是图像中一行像素的大小；对音频来说是整个音频帧的大小
• width, height：图像的宽高（只针对视频）
• key_frame：是否为关键帧（只针对视频） 。 • pict_type：帧类型（只针对视频） 。例如I， P， B • sample_rate：音频采样率（只针对音频）
• nb_samples：音频每通道采样数（只针对音频）
• pts：显示时间戳


# 7 AVPacket与AVFrame
从下图我们就可以大概看出AVPacket和AVFrame是个什么东西。

![](https://img2022.cnblogs.com/blog/1617829/202207/1617829-20220706153222145-2046250505.png)

AVPacket结构体中有一个AVBufferRef指针，AVBufferRef结构体中有一个AVBuffer指针，AVBuffer指针指向真正的音视频数据。

**AVPacket常用API：**
|   函数原型   |    说明   |    
| ---- | ---- | 
|    AVPacket *av_packet_alloc(void);   |    分配AVPacket。这里没有让AVBuffer指向某一块内存，应该相当于创建一个空的AVPacket  |  
|void av_packet_free(AVPacket **pkt); | 释放AVPacket |
|void av_init_packet(AVPacket *pkt);| 初始化AVPacket，只做了一些简单的初始化操作，没有进行内存分配操作 |
|int av_new_packet(AVPacket *pkt, int size);|引用计数初始化为1，AVBuffer指向某块内存。AVBuffer指向的内存，此内存可能被其他AVBuffer所指向，有多少个AVBuffer指向这一个内存，引用计数就是多少|
|int av_packet_ref(AVPacket *dst, const AVPacket *src);|dst的AVBuffer指向src的AVBuffer所指向的内存，也就是两个指针都指向同一个内存，此时增加此内存的引用计数|
|void av_packet_unref(AVPacket *pkt); |pkt的AVBuffer不再指向内存，此时此内存的引用计数减一|
|void av_packet_move_ref(AVPacket *dst, AVPacket *src); |转移引用计数，即dst继承src的所有东西，然后将src的AVBufferRef置空|
|AVPacket *av_packet_clone(const AVPacket *src); |创建一块新的内存，将src内容拷贝进去|



**AVFrame与AVPacket类似，AVFrame常用API：**
|    函数原型  |  说明    |    
| ---- | ---- | 
|  AVFrame *av_frame_alloc(void);   |   分配AVFrame   |  
|void av_frame_free(AVFrame **frame); |释放AVFrame|
|int av_frame_ref(AVFrame *dst, const AVFrame *src); |增加引用计数|
|void av_frame_unref(AVFrame *frame);|减少引用计数|
|void av_frame_move_ref(AVFrame *dst, AVFrame *src);|转移引用计数|
|int av_frame_get_buffer(AVFrame *frame, int align);|根据AVFrame分配内存|
|AVFrame *av_frame_clone(const AVFrame *src);|等于av_frame_alloc()+av_frame_ref()|
 
## 7.1 AVPacket和AVFrame的测试程序
本测试程序测试了常见的内存泄漏等问题。

目录结构：
```
├── avframe.c
├── avframe.h
├── avpacket.c
├── avpacket.h
└── main.c
```
main.c：
```
#include <stdio.h>
#include "avpacket.h"
#include "avframe.h"
int main()
{
    printf("Hello World!\n");
   av_packet_test();
    // av_frame_test();
    return 0;
}
```
avpacket.h:
```
#ifndef AVPACKET_H
#define AVPACKET_H

#include "libavcodec/avcodec.h"
#include "libavutil/frame.h"

/*
//简单的创建一个AVPacket，将其字段设为默认值（data为空，没有数据缓存空间），data的指针需要另外去赋值。
AVPacket *av_packet_alloc(void);

int av_new_packet(AVPacket *pkt, int size);
//释放使用av_packet_alloc创建的AVPacket，如果该Packet有引用计数（packet->buf不为空），则先调用av_packet_unref(&packet)。
//只有当引用计数为0时，才会在调用av_packet_free()时释放data的缓存。
void av_packet_free(AVPacket **pkt);
// 初始化packet的值为默认值，该函数不会影响buffer引用的数据缓存空间和size，需要单独处理。AVPacket中的buf为空。
// 比如 av_get_packet里调用av_init_packet
void av_init_packet(AVPacket *pkt);

// 使用引用计数的浅拷贝
// 该函数会先拷贝所有非缓存类数据，然后创建一个src->buf的新的引用计数。如果src已经设置了引用计数发（src->buf不为空），则直接将其引用计数+1；
// 如果src没有设置引用计数（src->buf为空），则为dst创建一个新的引用计数buf，并复制src->data到buf->buffer中。
// 最后，复制src的其他字段到dst中。所以av_packet_ref()是将2个AVPacket共用一个缓存的。
int av_packet_ref(AVPacket *dst, const AVPacket *src);

// 使用引用计数清理数据
// 将缓存空间的引用计数-1，并将Packet中的其他字段设为初始值。如果引用计数为0，自动的释放缓存空间。
void av_packet_unref(AVPacket *pkt);

// 把src整个结构体直接赋值给dst，所以引用计数没有发生变化，并且src被av_init_packet重置
void av_packet_move_ref(AVPacket *dst, AVPacket *src);

//其功能是 av_packet_alloc() + av_packet_ref()；
//先创建一个新的AVPacket，然后再进行计数引用+数据拷贝，使得新的AVPacket指向老的AVPacket同一个data。
AVPacket *av_packet_clone(const AVPacket *src);
*/


void av_packet_test();
#endif // AVPACKET_H
```
avpacket.c:
```
#include "avpacket.h"

#define MEM_ITEM_SIZE (20 * 1024 * 102)
#define AVPACKET_LOOP_COUNT 1000
// 测试 内存泄漏
/**
 * @brief 测试av_packet_alloc和av_packet_free的配对使用
 */
void av_packet_test1()
{
    AVPacket *pkt = NULL;
    int ret = 0;

    pkt = av_packet_alloc();
    ret = av_new_packet(pkt, MEM_ITEM_SIZE); // 引用计数初始化为1
    memccpy(pkt->data, (void *)&av_packet_test1, 1, MEM_ITEM_SIZE);
    av_packet_unref(pkt); // 要不要调用。调用av_packet_free，就不需要调用av_packet_unref，因为av_packet_free内部调用了av_packet_unref。但是重复调用也没事，因为av_packet_unref中处理了重复调用的情况
    av_packet_free(&pkt); // 如果不free将会发生内存泄漏,内部调用了 av_packet_unref
}

/**
 * @brief 测试误用av_init_packet将会导致内存泄漏
 */
void av_packet_test2()
{
    AVPacket *pkt = NULL;
    int ret = 0;

    pkt = av_packet_alloc();
    ret = av_new_packet(pkt, MEM_ITEM_SIZE);
    memccpy(pkt->data, (void *)&av_packet_test1, 1, MEM_ITEM_SIZE);
    //    av_init_packet(pkt);        // 这个时候init就会导致内存无法释放。为什么调用av_init_packet，就无法使用 av_packet_free释放内存??
                                        // 答：我觉得：av_init_packet(pkt)将pkt中的buf指向空，但pkt中buf指向的那一块内存还没释放，从而导致了内存泄漏
    av_packet_free(&pkt);
}

/**
 * @brief 测试av_packet_move_ref后，可以av_init_packet
 */
void av_packet_test3()
{
    AVPacket *pkt = NULL;
    AVPacket *pkt2 = NULL;
    int ret = 0;

    pkt = av_packet_alloc();
    ret = av_new_packet(pkt, MEM_ITEM_SIZE);
    memccpy(pkt->data, (void *)&av_packet_test1, 1, MEM_ITEM_SIZE);
    pkt2 = av_packet_alloc();      // 必须先alloc
    av_packet_move_ref(pkt2, pkt); //内部其实也调用了av_init_packet
    av_init_packet(pkt);
    av_packet_free(&pkt); // test2中无法在av_init_packet之后调用av_packet_free，这里为什么又可以了？？
                          // 答：这里pkt中buf指向的内存，由pkt2的buf接管，可以通过pkt2的buf对内存进行释放。【内存泄漏：有内存空间没有释放】
    av_packet_free(&pkt2);
}
/**
 * @brief 测试av_packet_clone
 */
void av_packet_test4()
{
    AVPacket *pkt = NULL;
    // av_packet_alloc()没有必要，因为av_packet_clone内部有调用 av_packet_alloc
    AVPacket *pkt2 = NULL;
    int ret = 0;

    pkt = av_packet_alloc();
    ret = av_new_packet(pkt, MEM_ITEM_SIZE);
    memccpy(pkt->data, (void *)&av_packet_test1, 1, MEM_ITEM_SIZE);
    pkt2 = av_packet_clone(pkt); // av_packet_alloc()+av_packet_ref()
    av_init_packet(pkt);
    av_packet_free(&pkt);
    av_packet_free(&pkt2);
}

/**
 * @brief 多次调用av_packet_ref导致的内存泄漏
 */
void av_packet_test5()
{
    AVPacket *pkt = NULL;
    AVPacket *pkt2 = NULL;
    int ret = 0;

    pkt = av_packet_alloc(); //
    if (pkt->buf)            // 打印referenc-counted，必须保证传入的是有效指针
    {
        printf("%s(%d) ref_count(pkt) = %d\n", __FUNCTION__, __LINE__,
               av_buffer_get_ref_count(pkt->buf));
    }

    ret = av_new_packet(pkt, MEM_ITEM_SIZE);
    if (pkt->buf) // 打印referenc-counted，必须保证传入的是有效指针
    {
        printf("%s(%d) ref_count(pkt) = %d\n", __FUNCTION__, __LINE__,
               av_buffer_get_ref_count(pkt->buf));
    }
    memccpy(pkt->data, (void *)&av_packet_test1, 1, MEM_ITEM_SIZE);

    pkt2 = av_packet_alloc();      // 必须先alloc
    av_packet_move_ref(pkt2, pkt); // av_packet_move_ref
                                   //    av_init_packet(pkt);  //av_packet_move_ref

    av_packet_ref(pkt, pkt2);
    av_packet_ref(pkt, pkt2); // 多次ref如果没有对应多次unref将会内存泄漏。现在此内存的引用计数为3
    if (pkt->buf)             // 打印referenc-counted，必须保证传入的是有效指针
    {
        printf("%s(%d) ref_count(pkt) = %d\n", __FUNCTION__, __LINE__,
               av_buffer_get_ref_count(pkt->buf));
    }
    if (pkt2->buf) // 打印referenc-counted，必须保证传入的是有效指针
    {
        printf("%s(%d) ref_count(pkt) = %d\n", __FUNCTION__, __LINE__,
               av_buffer_get_ref_count(pkt2->buf));
    }
    av_packet_unref(pkt); // 现在引用计数为2
    av_packet_unref(pkt); // 由于pkt的buf已经在前面使用了av_packet_unref(pkt)进行置空，所以再使用一次av_packet_unref(pkt)，将不起到任何作用。内存的引用次数还是2
    if (pkt->buf)
        printf("pkt->buf没有被置NULL\n");
    else
        printf("pkt->buf已经被置NULL\n");
    if (pkt2->buf) // 打印referenc-counted，必须保证传入的是有效指针
    {
        printf("%s(%d) ref_count(pkt) = %d\n", __FUNCTION__, __LINE__,
               av_buffer_get_ref_count(pkt2->buf)); // 为2
    }
    av_packet_unref(pkt2);  // 内存的引用次数为1。由于内存的引用次数无法降低到零，从而导致内存无法释放，从而导致内存泄漏

    av_packet_free(&pkt);  
    av_packet_free(&pkt2);
}

/**
 * @brief 测试AVPacket整个结构体赋值, 和av_packet_move_ref类似
 */
void av_packet_test6()
{
    AVPacket *pkt = NULL;
    AVPacket *pkt2 = NULL;
    int ret = 0;

    pkt = av_packet_alloc();
    ret = av_new_packet(pkt, MEM_ITEM_SIZE);
    memccpy(pkt->data, (void *)&av_packet_test1, 1, MEM_ITEM_SIZE);

    pkt2 = av_packet_alloc(); // 必须先alloc
    *pkt2 = *pkt;             // 有点类似  pkt可以重新分配内存
    av_init_packet(pkt);

    av_packet_free(&pkt);
    av_packet_free(&pkt2);
}

void av_packet_test()
{
    av_packet_test1();
    //    av_packet_test2();
    //    av_packet_test3();
    //    av_packet_test4();
    //    av_packet_test5();
    // av_packet_test6();
}
```
avframe.h:
```
#ifndef AVFRAME_H
#define AVFRAME_H

#include "libavcodec/avcodec.h"

void av_frame_test();
#endif // AVFRAME_H
```

avframe.c:
```
#include "avframe.h"

#define MEM_ITEM_SIZE (20*1024*102)
#define AVPACKET_LOOP_COUNT 1000
// 测试 内存泄漏
void av_frame_test1()
{
    AVFrame *frame = NULL;
    int ret = 0;

    frame = av_frame_alloc();// 没有类似的AVPacket的av_new_packet的API
    // 1024 *2 * (16/8) =
    frame->nb_samples     = 1024;
    frame->format         = AV_SAMPLE_FMT_S16;//AV_SAMPLE_FMT_S16P AV_SAMPLE_FMT_S16
    frame->channel_layout = AV_CH_LAYOUT_STEREO;    //AV_CH_LAYOUT_MONO AV_CH_LAYOUT_STEREO
    ret = av_frame_get_buffer(frame, 0);    // 根据格式分配内存

    // 如果frame->format为AV_SAMPLE_FMT_S16P，这里P是平面的意思，如在双声道中，将两个声道的数据是分开存放的，一个声道存放在一个数组中。
    // 也就是说如果frame->format为AV_SAMPLE_FMT_S16P时，有几个声道，buf就有几个元素。如：双声道时，buf中就有两个元素，即buf[0]和buf[1]
    if(frame->buf && frame->buf[0])
        printf("%s(%d) 1 frame->buf[0]->size = %d\n", __FUNCTION__, __LINE__, frame->buf[0]->size);    //受frame->format等参数影响
    if(frame->buf && frame->buf[1])
        printf("%s(%d) 1 frame->buf[1]->size = %d\n", __FUNCTION__, __LINE__, frame->buf[1]->size);    //受frame->format等参数影响

    
    // 内存引用次数的实验
    if(frame->buf && frame->buf[0])        // 打印referenc-counted，必须保证传入的是有效指针
        printf("%s(%d) ref_count1(frame) = %d\n", __FUNCTION__, __LINE__, av_buffer_get_ref_count(frame->buf[0]));

    ret = av_frame_make_writable(frame);    // 当frame本身为空时不能make writable
    printf("av_frame_make_writable ret = %d\n", ret);

    if(frame->buf && frame->buf[0])        // 打印referenc-counted，必须保证传入的是有效指针
        printf("%s(%d) ref_count2(frame) = %d\n", __FUNCTION__, __LINE__, av_buffer_get_ref_count(frame->buf[0]));

    av_frame_unref(frame);
    if(frame->buf && frame->buf[0])        // 打印referenc-counted，必须保证传入的是有效指针
        printf("%s(%d) ref_count3(frame) = %d\n", __FUNCTION__, __LINE__, av_buffer_get_ref_count(frame->buf[0]));

    av_frame_free(&frame);
}


void av_frame_test()
{
    av_frame_test1();
}
```
















 
 
 
]]></description></item><item><title>对‘TIFFReadDirectory@LIBTIFF_4.0’未定义的引用</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/05/16445936.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Tue, 05 Jul 2022 04:00:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/05/16445936.html</guid><description><![CDATA[
在执行makefile文件时，出现如下错误：
```
/home/zwl/software/opencv4.2/lib/libopencv_imgcodecs.so：对‘TIFFReadDirectory@LIBTIFF_4.0’未定义的引用
/home/zwl/software/opencv4.2/lib/libopencv_imgcodecs.so：对‘TIFFWriteEncodedStrip@LIBTIFF_4.0’未定义的引用
/home/zwl/software/opencv4.2/lib/libopencv_imgcodecs.so：对‘TIFFIsTiled@LIBTIFF_4.0’未定义的引用
/home/zwl/software/opencv4.2/lib/libopencv_imgcodecs.so：对‘TIFFOpen@LIBTIFF_4.0’未定义的引用
/home/zwl/software/opencv4.2/lib/libopencv_imgcodecs.so：对‘TIFFReadEncodedStrip@LIBTIFF_4.0’未定义的引用
/home/zwl/software/opencv4.2/lib/libopencv_imgcodecs.so：对‘TIFFSetField@LIBTIFF_4.0’未定义的引用
/home/zwl/software/opencv4.2/lib/libopencv_imgcodecs.so：对‘TIFFWriteScanline@LIBTIFF_4.0’未定义的引用
/home/zwl/software/opencv4.2/lib/libopencv_imgcodecs.so：对‘TIFFGetField@LIBTIFF_4.0’未定义的引用
/home/zwl/software/opencv4.2/lib/libopencv_imgcodecs.so：对‘TIFFScanlineSize@LIBTIFF_4.0’未定义的引用
/home/zwl/software/opencv4.2/lib/libopencv_imgcodecs.so：对‘TIFFWriteDirectory@LIBTIFF_4.0’未定义的引用
/home/zwl/software/opencv4.2/lib/libopencv_imgcodecs.so：对‘TIFFSetWarningHandler@LIBTIFF_4.0’未定义的引用
/home/zwl/software/opencv4.2/lib/libopencv_imgcodecs.so：对‘TIFFSetErrorHandler@LIBTIFF_4.0’未定义的引用
/home/zwl/software/opencv4.2/lib/libopencv_imgcodecs.so：对‘TIFFReadEncodedTile@LIBTIFF_4.0’未定义的引用
/home/zwl/software/opencv4.2/lib/libopencv_imgcodecs.so：对‘TIFFReadRGBATile@LIBTIFF_4.0’未定义的引用
/home/zwl/software/opencv4.2/lib/libopencv_imgcodecs.so：对‘TIFFClose@LIBTIFF_4.0’未定义的引用
/home/zwl/software/opencv4.2/lib/libopencv_imgcodecs.so：对‘TIFFRGBAImageOK@LIBTIFF_4.0’未定义的引用
/home/zwl/software/opencv4.2/lib/libopencv_imgcodecs.so：对‘TIFFClientOpen@LIBTIFF_4.0’未定义的引用
/home/zwl/software/opencv4.2/lib/libopencv_imgcodecs.so：对‘TIFFReadRGBAStrip@LIBTIFF_4.0’未定义的引用
```
查找libopencv_imgcodecs.so的依赖：
```
ldd /home/zwl/software/opencv4.2/lib/libopencv_imgcodecs.so
        linux-vdso.so.1 (0x00007fff9c1f0000)
        libopencv_imgproc.so.4.2 => /home/zwl/software/opencv4.2/lib/libopencv_imgproc.so.4.2 (0x00007f1a4e0cc000)
        libjpeg.so.8 => /usr/lib/x86_64-linux-gnu/libjpeg.so.8 (0x00007f1a4de64000)
        libpng16.so.16 => /usr/lib/x86_64-linux-gnu/libpng16.so.16 (0x00007f1a4dc32000)
        libtiff.so.5 => /usr/lib/x86_64-linux-gnu/libtiff.so.5 (0x00007f1a4d9ba000)
        libopencv_core.so.4.2 => /home/zwl/software/opencv4.2/lib/libopencv_core.so.4.2 (0x00007f1a4d34f000)
        libz.so.1 => /lib/x86_64-linux-gnu/libz.so.1 (0x00007f1a4d132000)
        libstdc++.so.6 => /usr/lib/x86_64-linux-gnu/libstdc++.so.6 (0x00007f1a4cda9000)
        libm.so.6 => /lib/x86_64-linux-gnu/libm.so.6 (0x00007f1a4ca0b000)
        libgcc_s.so.1 => /lib/x86_64-linux-gnu/libgcc_s.so.1 (0x00007f1a4c7f3000)
        libpthread.so.0 => /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007f1a4c5d4000)
        libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f1a4c1e3000)
        liblzma.so.5 => /lib/x86_64-linux-gnu/liblzma.so.5 (0x00007f1a4bfbd000)
        libjbig.so.0 => /usr/lib/x86_64-linux-gnu/libjbig.so.0 (0x00007f1a4bdaf000)
        libdl.so.2 => /lib/x86_64-linux-gnu/libdl.so.2 (0x00007f1a4bbab000)
        librt.so.1 => /lib/x86_64-linux-gnu/librt.so.1 (0x00007f1a4b9a3000)
        /lib64/ld-linux-x86-64.so.2 (0x00007f1a4ee11000)
```
从libtiff.so.5 => /usr/lib/x86_64-linux-gnu/libtiff.so.5 (0x00007f1a4d9ba000)可看出：libopencv_imgcodecs.so依赖libtiff.so.5，且libtiff.so.5在目录 /usr/lib/x86_64-linux-gnu/下。
也就是说libopencv_imgcodecs.so库会去目录 /usr/lib/x86_64-linux-gnu/下查找依赖libtiff.so.5

然后我发现我用-L指定的目录$(python_path)/lib下也有库libtiff，这就是问题所在：
libopencv_imgcodecs.so首先会去目录$(python_path)/lib下查找库libtiff，然后就找到了libtiff，但是由于版本不一致，就会出现上面的错误。

解决方法：让libopencv_imgcodecs.so先去查找目录 /usr/lib/x86_64-linux-gnu/，而不是目录$(python_path)/lib，即在-L $(python_path)/lib前加上-L /usr/lib/x86_64-linux-gnu/，即：
-L /usr/lib/x86_64-linux-gnu/ -L $(python_path)/lib


出现以上错误，是由于版本不一致导致的。]]></description></item><item><title>30天英语口语训练</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/05/16445333.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Tue, 05 Jul 2022 01:59:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/05/16445333.html</guid><description><![CDATA[# PASSAGE 1: Success in Life
Success means different things for different people. Some may equate it with fame, some with wealth and still some with accomplishments. For me, it means fulfilling one's dreams. Whatever your dreams are, you have a goal there and then focus all your attention on it. 
Dreams bring you hope and happiness. In the process of struggling for it, you cry, sweat, complain or even curse, but the joy of harvesting makes you forget all the pains and troubles you have gone through. So an old proverb says that the sweetest fruit is one that has undergone the bitterest ordeal. 

There are several keys to success. First, your goal must be practical and 
practicable. If you set your goal too high, chances are that you will never 
attain it. Next, you have to make a plan of doing it. You can take some 
steps to realize it. Since the process is quite tough, you need to be 
diligent, patient and persevering.
Even if you meet with some difficulties or frustrations, just take them in 
your stride. You can always tell yourself that there is nothing 
insurmountable. With this will and determination, success is sure to wait 
for you at the end of the tunnel!

**笔记**
equate sth with sth = regard sth as sth
sense of accomplishment：成就感，sense of ……感
fulfill/relize/achieve one's dreams
无论……，whatever,whoever,wherever
spare no effort to do sth/spare no effort in doing sth 全力以赴做

what brings you here?
No sweat 对别人说自己不累，没关系；叫别人不用费事帮我去干嘛了。
'Many thanks.' — 'No sweat. Anything else?' 
'I'll get my purse out of the bedroom.' — 'No sweat, Mrs. Day. We can put it on your tab.'






# 其他
I promise 我保证
your speaking 口语
you have no idea ...你不知道
through thick and thin  经历苦难
I will go on loving James through thick and thin
]]></description></item><item><title>RTMP流媒体服务器</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/01/16435955.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Fri, 01 Jul 2022 12:55:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/01/16435955.html</guid><description><![CDATA[# 0.简介
服务器：SRS(Simple RTMP Server，⽀持RTMP、HTTP-FLV，HLS) 
推流端：ffmpeg + OBS 
拉流端：ffplay +VLC + srs播放器
推流：指的是将视频流推送出去
拉流：指的是将推流端推送出去的视频流拉去下来


# 1.SRS安装和学习
直接参考官方文档，官方文档写得很好：https://github.com/ossrs/srs/wiki/v4_CN_Home


# 
]]></description></item><item><title>使用钉钉提供的工具实现内网穿透</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/01/16435737.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Fri, 01 Jul 2022 11:11:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/01/16435737.html</guid><description><![CDATA[外网访问内网服务器：1.端口映射 2.内网穿透
内网穿透原理是映射端口, 能让外网的电脑找到处于内网的电脑; 简单说就是局域网的服务外网访问不到,通过内网穿透技术来实现外网到内网的端口映射, 进行实现外网访问内网服务.

使用钉钉实现内网穿透：https://github.com/open-dingtalk/pierced
我出现的错误和解决：
[Invalid Host header 服务器域名访问出现的问题](https://blog.csdn.net/Cookysurongbin/article/details/86077241/ )

钉钉已经不能用了，可以使用https://www.cpolar.com/的免费版
]]></description></item><item><title>linux快速查找文件 locate </title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/01/16435688.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Fri, 01 Jul 2022 10:49:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/01/16435688.html</guid><description><![CDATA[locate test.cpp # 定位文件test.cpp所在的目录.
locate是在一个资料库中查找的。若找不到文件，终端执行：updatedb，重新建立整个系统所有文件和目录的资料库，方便以后再查找文件。]]></description></item><item><title>C++ opencv保存mp4文件</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/01/16433421.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Fri, 01 Jul 2022 01:30:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/01/16433421.html</guid><description><![CDATA[C++ opencv保存mp4文件
```
cv::VideoWriter w_cap("re_video.mp4", VideoWriter::fourcc('m', 'p', '4', 'v'), rate, cv::Size(width, height));
// VideoWriter::fourcc('m', 'p', '4', 'v')中的mp4v都要小写才不会报错，操!
```]]></description></item><item><title>在指定 python 版本下运行 pip</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/07/01/16433409.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Fri, 01 Jul 2022 01:26:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/07/01/16433409.html</guid><description><![CDATA[在指定 python 版本下运行 pip：
python3.9 -m pip install numpy]]></description></item><item><title>webRTC</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/06/30/16428200.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Thu, 30 Jun 2022 11:25:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/06/30/16428200.html</guid><description><![CDATA[直接看给的文档就行


sudo tail -f nohup.out # 监听nohup.out文件的变化
**测试stun:**
测试网址：https://webrtc.github.io/samples/src/content/peerconnection/trickle-ice/，进行如下操作：
![](https://img2022.cnblogs.com/blog/1617829/202206/1617829-20220629220139516-1637691158.png)
出现错误：
Note: errors from onicecandidateerror above are not neccessarily fatal. For example an IPv6 DNS lookup may fail but relay candidates can still be gathered via IPv4.
The server stun:10.16.203.4:3478 returned an error with code=701:
STUN server address is incompatible.
可以了解STUN的具体知识以后，在回过来看。

**测试turn：**
![](https://img2022.cnblogs.com/blog/1617829/202206/1617829-20220629220455320-1770216259.png)
点击Gather candidates后，nohup.out文件应该有所变化


# 实现一对一通信
**main.js代码的执行顺序：**
1.创建websocket对象，用于连接信令服务器。并且设置一些回调函数。以上这些通过下面代码实现：
```
zeroRTCEngine = new ZeroRTCEngine("ws://192.168.221.134:8099");
zeroRTCEngine.createWebsocket();
```
2.点击加入房间，获取视频流，并且使用doJoin(roomId)给信令服务器发送加入信息。





# js的一些知识
]]></description></item><item><title>gdb调试</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/06/29/16424650.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Wed, 29 Jun 2022 11:14:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/06/29/16424650.html</guid><description><![CDATA[我认为与IDE相比，GDB没什么好处，如果能用IDE就尽量用IDE。

# 1.gdb常用命令
可参考：[gdb调试](https://freecplus.net/b72113dda88a43b48728e0552fd8a74c.html)
bt：查看函数的调用栈。比如main函数中调用func函数，那么调用栈为：main在栈底，func在main的上方
info b：查看断点的信息
info threads：查看线程信息

# 2.调试core文件
程序运行时由于非法访问内存，程序可能挂掉，但是不返回发生错误的代码的位置。此时在gdb调试的时候引入core文件，就可以查看到发生core dump的位置。
可参考[gdb调试——②调试core文件](https://blog.csdn.net/shi_xiao_xuan/article/details/117402434)调试core文件
参考[Ubuntu下不产生core文件](https://blog.csdn.net/qq_38229124/article/details/123325016)，解决Ubuntu下不产生core文件问题。

# 3.调试正在运行的程序
可参考：[gdb调试——③调试正在运行的程序](https://blog.csdn.net/shi_xiao_xuan/article/details/117454802)



# 4.父子进程调试

我以为调试子进程，直接在子进程中打断点就可以了，但其实还需要输入set follow-fork-mode child。
```
set follow-fork-mode parent(缺省)
set follow-fork-mode child
```
**实例：**
```
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main()
{
    printf("begin\n");

    if (fork() != 0)
    {
        printf("我是父进程:pid=%d.ppid=%d\n", getpid(), getppid());

        int ii = 0;
        for (ii = 0; ii < 10; ii++)
        {
            printf("ii=%d\n",ii);
            sleep(1);
        }
        exit(0);
    }
    else{
        printf("我是子进程:pid=%d.ppid=%d\n", getpid(), getppid());

        int jj = 0;
        for (jj = 0; jj < 10; jj++)
        {
            printf("jj=%d\n",jj);
            sleep(1);
        }
        exit(0);
    }
}
```
运行命令：
```
(gdb) b 24                             # 在第24行（int jj = 0;）设置断点
Breakpoint 1 at 0x12b6: file test.cpp, line 24.
(gdb) set follow-fork-mode child       # 调试子进程
(gdb) r
Starting program: /home/ubuntu1/projects/c++/restful_api/test/test 
begin
[Attaching after process 42641 fork to child process 42645]
[New inferior 2 (process 42645)]
[Detaching after fork from parent process 42641]
我是父进程:pid=42641.ppid=42594
ii=0
[Inferior 1 (process 42641) detached]
我是子进程:pid=42645.ppid=42641
[Switching to process 42645]

Thread 2.1 "test" hit Breakpoint 1, main () at test.cpp:24
24              int jj = 0;          # 子进程在第24行停止运行
(gdb) ii=1
ii=2                                 # 父进程执行完毕
(gdb) n                              # 输入n，一步一步调试子进程
25              for (jj = 0; jj < 3; jj++)
(gdb) 
·
·
·
```

如果需要同时调试父进程和子进程，需要先介绍一下detach-on-fork。
```
set detach-on-fork [on | off]：默认为on，表示调试当前进程的时候，其它的进程继续运行。如果为off, 调试当前进程的时候，其它进程被GDB挂起。
为off时的运行机制：在fork()函数之后，判断follow-fork-mode类型。当follow-fork-mode为parent时，代表调试的是父进程，此时将子进程挂起。
```
detach-on-fork和follow-fork-mode组合起来的效果如下表：

follow-fork-mode|detach-on-fork|效果 
---|---|---
parent|	on|	只调试父进程
child	|on|	只调试子进程
parent	|off|	同时调试两个进程，子进程暂停
child	|off|	同时调试两个进程，父进程暂停

```
info inferiors，查看当前所有进程
inferior <num>，切换当前GDB调试进程，其中num为上一条指令中列出的进程Num
```
若同时调试两个进程，并且切换进程的效果如下:
```
(gdb) set detach-on-fork off 
(gdb) b 13                 # 在第13行（int jj = 0;）设置断点
Breakpoint 1 at 0x1251: file test.cpp, line 13.
(gdb) b24                   # 在第24行（int ii = 0;）设置断点
Undefined command: "b24".  Try "help".
(gdb) r
Starting program: /home/ubuntu1/projects/c++/restful_api/test/test 
begin
[New inferior 2 (process 44543)]
Reading symbols from /home/ubuntu1/projects/c++/restful_api/test/test...
Reading symbols from /usr/lib/debug/lib/x86_64-linux-gnu/libc-2.31.so...
我是父进程:pid=44539.ppid=44462

Thread 1.1 "test" hit Breakpoint 1, main () at test.cpp:13
warning: Source file is more recent than executable.
13              int ii = 0;
(gdb) n                    # 调试父进程
14              for (ii = 0; ii < 3; ii++)
(gdb) info inferiors
  Num  Description       Executable        
* 1    process 44539     /home/ubuntu1/projects/c++/restful_api/test/test 
  2    process 44543     /home/ubuntu1/projects/c++/restful_api/test/test 
(gdb) inferior 2          # 切换到子进程
[Switching to inferior 2 [process 44543] (/home/ubuntu1/projects/c++/restful_api/test/test)]
[Switching to thread 2.1 (process 44543)]
#0  arch_fork (ctid=0x7ffff7fb7810) at ../sysdeps/unix/sysv/linux/arch-fork.h:49
49      ../sysdeps/unix/sysv/linux/arch-fork.h: No such file or directory.
(gdb) n
53      in ../sysdeps/unix/sysv/linux/arch-fork.h
(gdb) n
__libc_fork () at ../sysdeps/nptl/fork.c:78
78      ../sysdeps/nptl/fork.c: No such file or directory.    # 这一堆信息应该是代表进入子进程前要经过的初始化函数
(gdb) n
83      in ../sysdeps/nptl/fork.c # 这一堆信息应该是代表进入子进程前要经过的初始化函数
(gdb) n
100     in ../sysdeps/nptl/fork.c # 这一堆信息应该是代表进入子进程前要经过的初始化函数
(gdb) n
102     in ../sysdeps/nptl/fork.c # 这一堆信息应该是代表进入子进程前要经过的初始化函数
(gdb) n
113     in ../sysdeps/nptl/fork.c # 这一堆信息应该是代表进入子进程前要经过的初始化函数
(gdb) n
126     in ../sysdeps/nptl/fork.c # 这一堆信息应该是代表进入子进程前要经过的初始化函数
(gdb) n
129     in ../sysdeps/nptl/fork.c # 这一堆信息应该是代表进入子进程前要经过的初始化函数，下次切换进程就没这些信息了
(gdb) n
main () at test.cpp:9
9           if ( pid != 0)
(gdb) n
22              printf("我是子进程:pid=%d.ppid=%d\n", getpid(), getppid());
(gdb) 
```
参考：[GDB调试之多进程/线程](https://blog.csdn.net/Augusdi/article/details/118864353)


# 5.多线程调试

调试多线的常用命令：
```
查看线程: info threads
切换线程: thread 线程id
指定某线程执行某gdb命令: thread apply 线程id cmd
全部的线程执行某adb命令: thread apply all cmd

使用 GDB 调试多线程程序时，默认的调试模式为：一个线程暂停运行，其它线程也随即暂停；一个线程启动运行，其它线程也随即启动。要知道，
这种调试机制确实能帮我们更好地监控各个线程的“一举一动”，但并非适用于所有场景。
一些场景中，我们可能只想让某一特定线程运行，其它线程仍维持暂停状态。要想达到这样的效果，就需要借助 set scheduler-locking 命令。
此命令可以帮我们将其它线程都“锁起来”，使后续执行的命令只对当前线程或者指定线程有效，而对其它线程无效。
set scheduler-locking mode，mode可以为：
off：不锁定线程，任何线程都可以随时执行；
on：锁定线程，只有当前线程或指定线程可以运行；
step：当单步执行某一线程时，其它线程不会执行，同时保证在调试过程中当前线程不会发生改变。但如果该模式下执行 continue、until、finish
命令，则其它线程也会执行，并且如果某一线程执行过程遇到断点，则 GDB 调试器会将该线程作为当前线程。
```
实例：
```
#include <stdio.h>
#include <unistd.h>
#include <pthread.h>
int x = 0, y = 0; // x用于线程一，y用于线程二。
pthread_t pthid1, pthid2;
//第一个线程的主函数
void *pth1_main(void *arg);
//第二个线程的主函数
void *pth2_main(void *arg);
int main()
{
    //创建线程一
    if (pthread_create(&pthid1, NULL, pth1_main, (void *)0) != 0)
    {
        printf("pthread_ create pthid1 failed.\n");
        return -1;
    }
    //创建线程二
    if (pthread_create(&pthid2, NULL, pth2_main, (void *)0) != 0)
    {
        printf("pthread_ create pthid2 failed.\n");
        return -1;
    }
    printf(" 111\n");
    pthread_join(pthid1, NULL);
    printf("222\n");
    pthread_join(pthid2, NULL);
    printf("333\n");
    return 0;
}

//第一个线程的主函数
void *pth1_main(void *arg)
{
    for(x = 0; x < 100; x++)
    {
        printf(" x=%d\n", x);
        sleep(1);
    } 
    pthread_exit(NULL);
}

//第二个线程的主函数
void *pth2_main(void *arg)
{
    for (y = 0; y < 100; y++)
    {
        printf(" y=%d\n", y);
        sleep(1) ;
    } 
    pthread_exit(NULL);
}
```
效果如下:
```
**(gdb) b 13    # 在第13行设置断点（if (pthread_create(&pthid1, NULL, pth1_main, (void *)0) != 0)）
Breakpoint 1 at 0x11f1: file test.cpp, line 13.
(gdb) b 35       # 在第35行设置断点（for(x = 0; x < 100; x++)）
Breakpoint 2 at 0x12c9: file test.cpp, line 35.
(gdb) b 46        # 在第46行设置断点（for (y = 0; y < 100; y++)）
Breakpoint 3 at 0x132c: file test.cpp, line 46.
(gdb) r
Starting program: /home/ubuntu1/projects/c++/restful_api/test/test 
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".

Breakpoint 1, main () at test.cpp:13
13          if (pthread_create(&pthid1, NULL, pth1_main, (void *)0) != 0)
(gdb) n
[New Thread 0x7ffff7d9d700 (LWP 48569)]
[Switching to Thread 0x7ffff7d9d700 (LWP 48569)]

Thread 2 "test" hit Breakpoint 2, pth1_main (arg=0x0) at test.cpp:35
35          for(x = 0; x < 100; x++)             # 处于线程1
(gdb) n
[New Thread 0x7ffff759c700 (LWP 48581)]
 111                                            # 主线程输出111
[Switching to Thread 0x7ffff759c700 (LWP 48581)]

Thread 3 "test" hit Breakpoint 3, pth2_main (arg=0x0) at test.cpp:46
46          for (y = 0; y < 100; y++)          # 主线程开启了线程2，并在线程2的断点处停止
(gdb) n                                        # 调试线程2
 x=0                                          # 默认的调试模式为：一个线程暂停运行，其它线程也随即暂停，即这里每输入一个n，
                                              # 线程2都前进一步，线程1就开始运行。线程2运行停止，线程1也跟着停止。
48              printf(" y=%d\n", y);
(gdb) set scheduler-locking on                 # 设定只有当前线程或指定线程可以运行
(gdb) n                    
 y=0            
49              sleep(1) ;**
```

# 6.运行日志
日志：平时经常使用print来进行代码的调试，日志就相当于将print的内容放入一个文件中，这个文件也叫做日志文件。





参考：[C语言gdb调试之精髓](https://www.bilibili.com/video/BV1ei4y1V758)]]></description></item><item><title>动态链接库的隐式加载和显示加载</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/06/26/16414555.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Sun, 26 Jun 2022 14:13:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/06/26/16414555.html</guid><description><![CDATA[
# 1.静态库和动态库、动态库的显式调用和隐式调用
**静态库：**静态链接库在链接时，编译器会将目标文件和静态库文件组织成一个可执行文件，程序运行时，将全部数据加载到内存。
如果程序体积较大，功能较为复杂，那么加载到内存中的时间就会比较长，最直接的一个例子就是双击打开一个软件，要很久才能看到界面。这是静态链接库的一个弊端。
动态库相比静态库的区别是：静态库是编译时就加载到可执行文件中的，而动态库是在程序运行时完成加载的，所以使用动态库的程序的体积要比使用静态库程序的体积小，并且使用动态库的程序在运行时必须依赖所使用的动态库文件(.so文件)，而使用静态库的程序一旦编译好，就不再需要依赖的静态库文件了(.a文件)。


**动态链接库有两种加载方式：隐式加载和显示加载：**
隐式加载又叫载入时加载，指在主程序载入内存时搜索动态库，并将动态库载入内存。隐式加载也会有静态链接库的问题，如果程序稍大，加载时间就会过长，用户不能接受。
显式加载又叫运行时加载，指主程序在运行过程中需要动态库中的函数时再加载。显式加载是将较大的程序分开加载的，程序运行时只需要将主程序载入内存，软件打开速度快，用户体验好。


# 2.extern "C"的作用
C++程序（或库、目标文件）中，所有非静态（non-static）函数在二进制文件中都是以“符号（symbol）”形式出现的。这些符号都是唯一的字符串，从而把各个函数在程序、库、目标文件中区分开来。在C中，符号名正是函数名，两者完全一样。而C++允许重载（不同的函数有相同的名字但不同的参数，甚至const重载），并且有很多C所没有的特性──比如类、成员函数、异常说明──几乎不可能直接用函数名作符号名。为了解决这个问题，C++采用了所谓的name mangling。它把函数名和一些信息（如参数数量和大小）杂糅在一起，改造成奇形怪状，只有编译器才懂的符号名。例如，被mangle后的foo可能看起来像foo@4%6^，或者，符号名里头甚至不包括“foo”。

其中一个问题是，C++标准并没有定义名字必须如何被mangle，所以每个编译器都按自己的方式来进行name mangling。有些编译器甚至在不同版本间更换mangling算法（尤其是g++ 2.x和3.x）。说过，在显示调用动态库中的函数时，需要指明调用的函数名，即使您搞清楚了您的编译器到底怎么进行mangling的，从而知道调用的函数名被C++编译器转换为了什么形式，但可能仅仅限于您手头的这个编译器而已，而无法在下一版编译器下工作。

extern "C"即可以解决这个问题。用 extern "C"声明的函数将使用函数名作符号名，就像C函数一样。因此，只有非成员函数才能被声明为extern "C"，并且不能被重载。尽管限制多多，extern "C"函数还是非常有用，因为它们可以象C函数一样被dlopen动态加载。冠以extern "C"限定符后，并不意味着函数中无法使用C++代码了，相反，它仍然是一个完全的C++函数，可以使用任何C++特性和各种类型的参数。所以extern "C" 只是告诉编译器编译和链接的时候都用c的方式的函数名字，函数里的内容可以为c的代码也可以为c++的。



# 3.显式调用

建立so1.h、so1.cc、so2.h、so2.cc、test.cc五个文件，内容如下：
```
// so1.h：
extern "C" void fcn();

// so1.cc：
#include <iostream>
#include "so1.h"
void fcn()
{
    std::cout << "this is fcn in so1" << std::endl;
}


// so2.h：
extern "C" void fcn();

// so2.cc：
#include <iostream>
#include "so2.h"
void fcn()
{
    std::cout << "this is fcn in so2" << std::endl;
}


// test.cc:
#include <iostream>
#include <cstdlib>
#include <dlfcn.h>

using namespace std;

int main(int argc, char **argv)
{
    if (argc != 2)
    {
        cout << "argument error!" << endl;
        exit(1);
    }

    // pointer to function
    typedef void (*pf_t)();

    char *err = NULL;
    // open the lib
    void *handle = dlopen(argv[1], RTLD_NOW); // 将库装载到内存
                                              // RTLD_NOW表示马上检查是否存在未定义的函数，若存在，则dlopen以失败告终。

    if (!handle)
    {
        cout << "load " << argv[1] << "failed! " << dlerror() << endl;
        exit(1);
    }

    // clear error info
    dlerror();

    pf_t pf = (pf_t)dlsym(handle, "fcn");  // 获得函数fcn在内存中的位置
    err = dlerror();
    if (err)
    {
        cout << "can't find symbol fcn! " << err << endl;
        exit(1);
    }

    // call function by pointer
    pf();

    dlclose(handle);

    return 0;
}
```
将so1.cc和so2.cc编译成动态库，编译命令如下：
```
g++ so1.cc -shared -fPIC -o libso1.so
g++ so2.cc -shared -fPIC -o libso2.so
```
test.cc中使用到了上面生成的动态库，编译命令如下：
```
g++ test.cc -l dl -Wl,-rpath=. -o test
等价于：g++ test.cc  -ldl -Wl,-rpath=. -o test
```
【注】在显式调用方式中，必须加入头文件dlfcn.h，makefile中的链接命令中要加入参数-ldl，否则报错。

运行test:
```
./test libso1.so 
或./test libso2.so 
```
可以看到这里，通过输入不同的参数，调用了不同的共享库中的fcn函数，是一种多态的表现，许多软件的不同插件就是这样实现的。
【注】多态：相同的代码，展现出不同的状态，或者说展现出不同的效果，就叫多态。

**dlfcn.h中提供的API说明如下：**
**1.dlopen**

函数原型：void *dlopen(const char *libname,int flag);
功能描述：dlopen必须在dlerror，dlsym和dlclose之前调用，表示要将库装载到内存，准备使用。如果要装载的库依赖于其它库，必须首先装载依赖库。如果dlopen操作失败，返回NULL值；如果库已经被装载过，则dlopen会返回同样的句柄。

参数中的libname一般是库的全路径，这样dlopen会直接装载该文件；如果只是指定了库名称，在dlopen会按照下面的机制去搜寻：
a.根据环境变量LD_LIBRARY_PATH查找
b.根据/etc/ld.so.cache查找
c.查找依次在/lib和/usr/lib目录查找。

flag参数表示处理未定义函数的方式，可以使用RTLD_LAZY或RTLD_NOW。RTLD_LAZY表示暂时不去处理未定义函数，先把库装载到内存，等用到没定义的函数再说；RTLD_NOW表示马上检查是否存在未定义的函数，若存在，则dlopen以失败告终。

**2.dlerror**

函数原型：char *dlerror(void);
功能描述：dlerror可以获得最近一次dlopen,dlsym或dlclose操作的错误信息，返回NULL表示无错误。dlerror在返回错误信息的同时，也会清除错误信息。

**3.dlsym**

函数原型：void *dlsym(void *handle,const char *symbol);
功能描述：在dlopen之后，库被装载到内存。dlsym可以获得指定函数(symbol)在内存中的位置(指针)。如果找不到指定函数，则dlsym会返回NULL值。但判断函数是否存在最好的方法是使用dlerror函数，

**4.dlclose**

函数原型：int dlclose(void *);
功能描述：将已经装载的库句柄减一，如果句柄减至零，则该库会被卸载。如果存在析构函数，则在dlclose之后，析构函数会被调用。


# 4.隐式调用
隐式调用不需要包含头文件dlfcn.h，只需要包含动态链接库中的头文件，使用动态库中的函数也不需要像显示调用那么复杂。
可以参考：[静态库和动态库的制作](https://www.cnblogs.com/codingbigdog/p/16412416.html)。这个链接中调用动态库的方式就是隐式调用。

根据上面的显式调用和隐式调用的实例，可总结显示和隐式的区别如下：
1、 隐式调用需要调用者写的代码量少，调用起来和使用当前项目下的函数一样直接；而显式调用则要求程序员在调用时，指明要加载的动态库的名称和要调用的函数名称。
2、隐式调用由系统加载完成，对程序员透明；显式调用由程序员在需要使用时自己加载，不再使用时，自己负责卸载。
3、由于显式调用由程序员负责加载和卸载，好比动态申请内存空间，需要时就申请，不用时立即释放，因此显式调用对内存的使用更加合理， 大型项目中应使用显示调用。
4、当动态链接库中只提供函数接口，而该函数没有封装到类里面时，如果使用显式调用的方式，调用方甚至不许要包含动态链接库的头文件（需要调用的函数名是通过dlsym函数的参数指明的），而使用隐式调用时，则调用方必须要加上动态库中的头文件，g++编译时还需要要用参数-I指明包含的头文件的位置。需要注意的是，当动态链接库中的接口函数是作为成员函数封装在类里面时，即使使用显式调用的方式，调用方也必须包含动态库中的相应头文件（详见五、显示调用动态链接中的类成员函数）。
5、显式调用更加灵活，可以模拟多态效果。
6、显式调用的方式，必须加入头文件dlfcn.h，makefile中的链接命令中要加入参数-ldl，需要用dlopen加载库，dlsym取函数符号(函数名应用新定义的)，dlclose卸载库。
7、隐式调用的方式，makefile中的链接命令中要加入参数-l加库名，直接用库里的函数名就可以。


# 5.显式调用动态链接中的类成员函数

显示调用动态链接库的类成员函数，有单独的写法，但比较少用。推荐的写法是为每个要被外部调用的类成员函数设计一个普通的接口函数，在接口函数内部使用类的成员函数。当然这就需要将类设计为单例模式，因为不可能在每个接口函数中都构造一个类的对象。【看不懂，以后再看】

参考：[链接](https://www.cnblogs.com/testlife007/p/10774271.html)
]]></description></item><item><title>静态库和动态库的简介和制作</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/06/25/16412416.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Sat, 25 Jun 2022 13:03:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/06/25/16412416.html</guid><description><![CDATA[# 1.简介
公用函数库的程序文件（.c文件）是源代码，对任何程序员是可见的，没有安全性可言，但是，在实际开发中，出于技术保密或其它方面考虑，开发者并不希望提供公用函数库的源代码。

C/C++提供了一个可以保证代码安全性的方法，把公共的程序文件编译成库文件，库文件是一种可执行代码的二进制形式，可以与其它的源程序一起编译，也可以被操作系统载入内存执行。

库文件分为静态库与动态库，区别如下：

**静态库**：静态链接库在链接时，编译器会将目标文件和静态库文件组织成一个可执行文件，程序运行时，将全部数据加载到内存。
如果程序体积较大，功能较为复杂，那么加载到内存中的时间就会比较长，最直接的一个例子就是双击打开一个软件，要很久才能看到界面。这是静态链接库的一个弊端。

**动态库相比静态库的区别是**：静态库是编译时就加载到可执行文件中的，而动态库是在程序运行时完成加载的，所以使用动态库的程序的体积要比使用静态库程序的体积小，并且使用动态库的程序在运行时必须依赖所使用的动态库文件(.so文件)，而使用静态库的程序一旦编译好，就不再需要依赖的静态库文件了(.a文件)。

动态库源代码修改后，只需要编译动态库文件即可，程序不需要重新编译。
静态库源代码修改后，静态库需要重新编译，程序也要重新编译。
如果在动态库文件和静态库文件同时存在，优先使用动态库编译。

静态库文件名的命名方式是“libxxx.a”,库名前加”lib”，后缀用”.a”，“xxx”为静态库名。windows也这么命名。
动态库与静态库类似，前缀相同，为“lib”，后缀变为“.so” ，如“libxxx.so”。windows下动态库的后缀为.dll

这篇[文章](https://blog.csdn.net/m0_61745661/article/details/123597887)，写得很好，可以看看。


# 2.静态库和动态库的制作

## 2.1 程序
```
// add.h
int add(int i, int j);
 
// add.c
#include "add.h"
 
int add(int i, int j)
{
	return i + j;
}
 
// main.c
#include <stdio.h>
#include <stdlib.h>
#include "add.h"
 
int main(int argc, char *argv[]) 
{
	printf("1 + 2 = %d\n", add(1, 2));
	return 0;
}
```



## 2.2 动态库的制作和使用
```
# 编译共享库
gcc add.c -fPIC -shared -o libadd.so  # -fPIC：生成位置无关目标代码，适用于动态连接；
                                      # -shared：生成一个共享库文件；

# 编译和运行
gcc -Wl,-rpath=`pwd` main.c -L . -l add -o app # pwd代表当前路径
                                             # "-L ."代表链接阶段在当前目录下查找库
                                             # -Wl,-rpath代表运行时，在哪里找库。
# gcc -Wl,-rpath=`pwd` main.c -L. -ladd -o app # 与gcc -Wl,-rpath=`pwd` main.c -L . -l add -o app 等价
./app
输出：
1 + 2 = 3
```
我们可以看到在编译的时候需要使用-L和-l指明动态库的位置，运行时还需要使用-Wl,-rpath指明动态库的位置。这是因为：
动态库在编译的时候只做语法检查， 并没有被编译进目标代码，当程序执行到动态库中的函数时才调用该函数库里的代码。
动态函数库并没有整合进程序，所以程序的运行环境必须提供动态库路径。优点是，如果所使用的动态库发生更新改变，程序不需要重新编译，所以动态库升级比较方便。

所以如果在动态库文件和静态库文件同时存在，优先使用动态库编译。

参考：[C/C++编译以及静态库和动态库的制作和使用](https://blog.csdn.net/qq_37233070/article/details/120544919)
[链接](https://www.cnblogs.com/codingbigdog/p/16320965.html)



# 2.3 静态库的制作和使用
```
gcc -c add.c -o libadd.a       # 静态库的制作

静态库的使用：
方法一：
gcc main.c libadd.a -o app   # 直接把调用者源代码和静态库文件名一起编译。
./app

方法二：
gcc -L . -l add main.c -o app   # 采用L参数指定静态库文件的目录，-l参数指定静态库名。
./app
```
参考：[C/C++编译以及静态库和动态库的制作和使用](https://blog.csdn.net/qq_37233070/article/details/120544919)

可见，静态库和动态库都是通过-L和-l指定路径的。
在静态库制作的过程中使用到了gcc -c，我们可以通过[链接](https://blog.csdn.net/qq_42775938/article/details/122346013)知道它的含义为：将代码编译成二进制文件。




## -fPIC选项

-fPIC选项的生效阶段在编译阶段，使用-fPIC选项编译的.o文件会生成位置无关的代码通常在linux下用gcc编译动态库时都会加上一个-fPIC选项来生成位置无关代码。

【下面说了啥，我也看不懂了，可以不看】
如果你的静态库可能会被动态库使用，那么静态库编译的时候就也需要-fPIC选项，原因如下：
众所周知，静态库其实是一系列.o文件的打包，将.o文件制作成静态库的过程是不会发生链接的。所以链接静态库就约等于将静态库解包后的.o文件一个一个全部链接。
如果一个动态库需要链接一个静态库，那么就相当于动态库去链接一系列的.o文件，而编译动态库所需的.o文件时一般是推荐使用-fPIC编译选项的。


参考：[链接](https://blog.csdn.net/bjrxyz/article/details/121146434)

具体的-fPIC是什么原理可以参考：[动态库基本原理和使用方法，-fPIC选项的来龙去脉](https://blog.csdn.net/cyz_2014/article/details/108920037)。-fPIC大概的原理就是：编译时构造全局偏移表（Global Offset Table, GOT），运行时通过GOT中存储的偏移值访问指令和数据。
]]></description></item><item><title>crontab 常见 /dev/null 2&gt;&amp;1 详解</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/06/24/16409963.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Fri, 24 Jun 2022 10:55:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/06/24/16409963.html</guid><description><![CDATA[
**大部分在 crontab 计划任务中都会年到未尾带 >/dev/null 2>&1,是什么意思呢？**

\>是重定向
/dev/null 代表空设备文件
1 表示stdout标准输出,系统默认值是1,所以 ">/dev/null" 等同于 "1>/dev/null"
2 表示stderr标准错误
& 表示等同于的意思,2>&1,表示2的输出重定向等同于1

整句的意思就是标准输出重定向到空设备文件,也就是不输出任何信息到终端,标准错误输出重定向等同于标准输出,因为之前标准输出已经重定向到了空设备文件,所以标准错误输出也重定向到空设备文件

运行脚本的时候有些错误不想让它显示，就输出到/dev/null
 

**command > file 2>file 与 command > file 2>&1 有什么区别呢?**

command > file 2>file 的意思是将命令所产生的标准输出信息,和错误的输出信息送到file 中.command > file 2>file 这样的写法,stdout和stderr都直接送到file中, file会被打开两次,这样stdout和stderr会互相覆盖,这样写相当使用了FD1和FD2两个同时去抢占file 的管道.
而command >file 2>&1 这条命令就将stdout直接送向file, stderr 继承了FD1管道后,再被送往file,此时,file 只被打开了一次,也只使用了一个管道FD1,它包括了stdout和stderr的内容.
从IO效率上,前一条命令的效率要比后面一条的命令效率要低,所以在编写shell脚本的时候,较多的时候我们会用command > file 2>&1 这样的写法.

**所以在添加crontab命令时，无论命令是否有输出，最好都加上输出重定向到文件或者/dev/null中。如下**

*/5 * * * * /root/XXXX.sh &>/dev/null 2>&1

/dev/null 代表空设备文件

\> 代表重定向到哪里，例如：echo "123" > /home/123.txt

1 表示stdout标准输出，系统默认值是1，所以">/dev/null"等同于"1>/dev/null"

2 表示stderr标准错误

& 表示等同于的意思，2>&1，表示2的输出重定向等同于1

那么>/dev/null 2>&1的意思就是：

标准输出重定向到空设备文件,也就是不输出任何信息到终端,标准错误输出重定向等同于标准输出,因为之前标准输出已经重定向到了空设备文件,所以标准错误输出也重定向到空设备文件。

 

示例:

每天早上6点 
0 6 * * * echo "Good morning." >> /tmp/test.txt //注意单纯echo，从屏幕上看不到任何输出，因为cron把任何输出都email到root的信箱了。

每两个小时 
0 */2 * * * echo "Have a break now." >> /tmp/test.txt 

好文要顶 关注我 收藏该文  


参考：[链接](https://www.cnblogs.com/gyrgyr/p/11367843.html)]]></description></item><item><title>Python调用C++程序，C++调用python</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/06/13/16372215.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Mon, 13 Jun 2022 12:20:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/06/13/16372215.html</guid><description><![CDATA[# 1.Python调用C++程序

1、编写C/C++实现程序。
2、将C/C++程序编译成动态库。
3、在Python中调用编译生成的库。

请参考：[简单的Python调用C++程序（使用ctypes模块）](https://blog.csdn.net/weixin_40313940/article/details/109515357)

python调用C++程序的其他方法：
boost.python：将c/c++的函数接口转换为Python接口有好几种解决方案，不同于C语言的简单直接，C++因使用了大量的面向对象编程的思想导致转换为Python接口时相对比较复杂，boost.python的目标就是为了简单方便地将C++程序转换成Python的接口。

# 2.C++中使用python程序
参考：[在C++中调用Python](https://www.cnblogs.com/dechinphy/p/cpp-python.html)



## 2.1.hello world

```
// cp.cpp
#include <Python.h>
int main(int argc, char *argv[]) {
  Py_Initialize();
  PyRun_SimpleString("print('hello world')\n");
  Py_Finalize();
  return 0;
}
```
执行命令：
```
g++ -o cpy cp.cpp  -I /usr/include/python3.9/ -l python3.9
```
使用-I（大写地i）指定头文件所在路径
虽然编译器会自动地去目录/usr/lib/查找库文件，但我们还是需要使用-l选项指定具体地库python3.9

【问题：/usr/lib/python3.9中几乎都是.py文件，为什么.py文件可以成为库文件】


## 2.2.调用Python函数string.split() 
在C++中如果我们想分割一个字符串，虽然说也是可以实现的，但是应该没有比Python中执行一个string.split()更加方便快捷的方案了，因此我们测试一个用C++调用Python的split函数的功能。

首先编写一个 pysplit.py文件：
```
# pysplit.py

def sp(string):
    return string.split()
```

cp.cpp中将 pysplit.py当成包进行调用。
```
#include <Python.h>
#include <iostream>
using namespace std;
int main(int argc, char *argv[])
{
  Py_Initialize();
  if (!Py_IsInitialized())
	{
		cout << "Initialize failed!" << endl;
		return 0;
	}
  PyObject* pModule = NULL;
  PyObject* pFunc;
  PyRun_SimpleString("import sys");
  PyRun_SimpleString("sys.path.append('./')");
  pModule = PyImport_ImportModule("pysplit");
  if (pModule == NULL)
	{
		cout << "Module Not Found!" << endl;
	}
  pFunc = PyObject_GetAttrString(pModule, "sp");
  PyObject* args1 = Py_BuildValue("s", "Test String");
  PyObject* args2 = Py_BuildValue("s", " Hello Every One !");

  PyObject* pRet = PyObject_CallFunctionObjArgs(pFunc, args1, args2, NULL); // PyObject_CallFunctionObjArgs(函数,参数1,参数2,……,NULL)
  int size = PyList_Size(pRet);
  cout << "List size is: " << size << endl;
  for(int i=0;i<size;i++)
  {
    PyObject* cRet = PyList_GET_ITEM(pRet, i);
    char* s;
    PyArg_Parse(cRet, "s", &s);
    cout << "The " << i << "th term is: " << s << endl;
  }
  Py_Finalize();
  return 0;
}
```
执行命令：
```
g++ -o cpy cp.cpp -lm -std=c++11 -I/usr/include/python3.9/ -lpython3.9 && ./cpy
```
最后，因为从Python中获取的是一个List格式的数据，因此我们首先需要用PyList_GET_ITEM去逐项提取，然后用PyArg_Parse将提取出来的元素保存到一个C++的char字符串中，执行结果如下：
```
dechin@ubuntu2004:~/projects/gitlab/dechin/$ g++ -o cpy cp.cpp -lm -std=c++11 -I/usr/include/python3.9/ -lpython3.9 && ./cpy
List size is: 6
The 0th term is: Test
The 1th term is: String
The 2th term is: Hello
The 3th term is: Every
The 4th term is: One
The 5th term is: !
```

说明：
1.代码中使用了sys.path.append('./')，这是因为：即使是在相同的路径下，也需要通过Python的sys将当前目录添加到系统路径中，才能够识别到这个模块。




tuple格式和**args有什么关系？？
答：[链接](https://www.cnblogs.com/dechinphy/p/args.html)

PyObject_CallFunctionObjArgs和PyObject_CallObject的区别？
答：[链接](https://stackoverflow.com/questions/60487083/passing-array-tuple-from-python-back-to-c)




## 2.5.python中如果有其他模块时





```
#include <Python.h>
#include <iostream>
using namespace std;
int main(int argc, char *argv[])
{
  Py_Initialize();
  if (!Py_IsInitialized())
	{
		cout << "Initialize failed!" << endl;
		return 0;
	}
  PyObject* pModule = NULL;
  PyObject* pFunc;
  PyRun_SimpleString("import sys");
  PyRun_SimpleString("sys.path.append('./')");
  pModule = PyImport_ImportModule("pyYolov5");
  if (pModule == NULL)
	{
		cout << "Module Not Found!" << endl;
	}
  pFunc = PyObject_GetAttrString(pModule, "run");
  PyObject* args = Py_BuildValue("s", "Test String Hello Every One !");
  PyObject* pRet = PyObject_CallFunctionObjArgs(pFunc, args, NULL);

  Py_Finalize();
  return 0;
}
```













使用PyRun_SimpleString，然后在python中调用python程序，从而传入参数
https://blog.csdn.net/qq_30694087/article/details/113748702
https://blog.csdn.net/sspdfn/article/details/62894607




仿照上面例子，调用yolov5，有什么问题再查，
调用成功，再对python.h进行学习。






使用Python.h调用python程序

如何使用C++执行python文件：
https://blog.csdn.net/dingyanxxx/article/details/46949405

https://zhuanlan.zhihu.com/p/80637788
https://zhuanlan.zhihu.com/p/79896193

https://docs.python.org/3/extending/embedding.html#embedding-python-in-c

https://blog.csdn.net/m0_46656879/article/details/124490820

【问题：/usr/lib/python3.9中几乎都是.py文件，为什么.py文件可以成为库文件】
答:主流的用法是把python作为一种文本形式的链接库，在c/c++程序中调用其中定义的函数。什么叫做文本形式的链接库？？
什么类型的文件可以作为C++链接库？？即可以用于-l后？


是不是还有其他在C++里面调用python程序的办法？？


# 其他

void Py_Initialize(void)
初始化Python解释器，如果初始化失败，继续下面的调用会出现各种错误，可惜的是此函数没有返回值来判断是否初始化成功，如果失败会导致致命错误。

int Py_IsInitialized(void)
检查是否已经进行了初始化，如果返回0，表示没有进行过初始化。

void Py_Finalize()
反初始化Python解释器，包括子解释器，调用此函数同时会释放Python解释器所占用的资源。

int PyRun_SimpleString(const char *command)
实际上是一个宏，执行一段Python代码。所以在PyRun_SimpleString中执行的代码，相当于作用于整个代码【我猜的】。




[python与C/C++相互调用](https://www.jianshu.com/p/335253cd688f)



# 1 官方文档
https://docs.python.org/3.9/c-api/

## 1.1 概述
**1.引入头文件：**
```
#define PY_SSIZE_T_CLEAN
#include <Python.h>
```
Python.h中定义的所有函数都是以Py_开头的。

**2.Python.h所处位置**
在 Unix 上，头文件Python.h位于以下目录：prefix/include/pythonversion/ 和 exec_prefix/include/pythonversion/，其中 prefix 和 exec_prefix 是由向 Python 的 configure 脚本传入的对应形参所定义。在 Windows 上，头文件安装于 prefix/include，其中 prefix 是向安装程序指定的安装目录。

我曾经用过的执行命令：
```
g++ -o test test.cpp  -I xx/anaconda3/envs/yolov5Env/include/python3.9/ -L xx/anaconda3/envs/yolov5Env/lib -l python3.9 -Wl,-rpath=xx/anaconda3/envs/yolov5Env/lib
```

**3.C++与C的API**
C++ 用户应该注意，尽管 API 是完全使用 C 来定义的，但头文件正确地将入口点声明为 extern "C"，因此 API 在 C++ 中使用此 API 不必再做任何特殊处理。


**4.有用的宏**
有用的宏：这一小节就是介绍一些有用的函数。


**5.PyObject*类型指针**
PyObject*类型指针，用于指向python的的任意对象，如整型、字符串、列表、函数等。
通过PyObject*，C++程序可以向python函数传递参数，python程序可以给C++程序返回运算结果。
由于几乎所有Python 对象都存在于堆上：所以您不能声明PyObject类型的自动或静态变量，只能声明 PyObject*类型的指针变量。唯一的例外是type objects；因为这些永远不能被释放，它们通常是静态的PyTypeObject对象【看不懂】。

每一种python中常见的类型都对应一个检测类型的宏，如PyList_Check(a)用于检测a是否为python中的list


python程序和c程序在互传变量的时候，注意引用计数的问题。


变量和引用的生命一样长，就不需要考虑增加引用计数。


PyTuple_SetItem()是设置元组的唯一方法；PySequence_SetItem()和PyObject_SetItem()不用于设置元组，因为元组是不可变的数据类型
使用PyTuple_New()和PyTuple_SetItem()创建python tuple  
使用PyList_New()和PyList_SetItem()创建python list
一般不使用上面两种方法，而使用通用的方法Py_BuildValue()来创建元组和列表。



问题：
类似PyImport_ImportModule这样常用的函数怎么都找不到？？
答：PyImport_ImportModule在工具——》导入模块中。


extern "C"中不能创建类和对象吗？？


PyObject_CallFunctionObjArgs如何传递多个参数？
]]></description></item><item><title>网络编程实践视频笔记--陈硕</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/06/12/16368715.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Sun, 12 Jun 2022 11:46:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/06/12/16368715.html</guid><description><![CDATA[参考：https://blog.csdn.net/weixin_43919932/article/details/121308426

第一节 我都没看懂：https://blog.csdn.net/weixin_43919932/article/details/121611027



### 2.1.2 实现 ttcp 程序
SessionMessage(num=1024,len=8192)  // 客户端告诉服务端，接下来要发送1024个数据，每个数据8192个字节




直接看笔记，不懂的，再去看视频。]]></description></item><item><title>unix环境高级编程</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/06/09/16361038.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Thu, 09 Jun 2022 12:25:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/06/09/16361038.html</guid><description><![CDATA[unix环境高级编程主要讲了各种函数和命令的使用。这些函数我在使用C语言进行网络编程的时候经常看到。完全看一遍这本书，我也记不住，所以现在重点不是看这本书。]]></description></item><item><title>ffmpeg、ffplay和ffprobe基础使用</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/06/08/16357163.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Wed, 08 Jun 2022 12:52:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/06/08/16357163.html</guid><description><![CDATA[# 1.ffmpeg、ffplay和ffprobe基础介绍

ffmpeg:Hyper fast Audio and Video encoder 超快音视频编码器
ffplay:Simple media player 简单媒体播放器
ffprobe:Simple multimedia streams analyzer 简单多媒体流分析器

## 1.1.ffmpeg、ffplay和ffprobe帮助文档


**ffmpeg查看帮助文档：**
```
基本信息：ffmpeg -h
高级信息：ffmpeg -h long
所有信息：ffmpeg -h full
若嫌打印过多： ffmepg -h full > ffmpeg_h_full.log，然后再打开ffmpeg_h_full.log文件查看
```

**ffmpeg命令格式：**
```
ffmpeg [options] [[infile options] -i infile]... {[outfile options] outfile}...
options代表全局选项，[infile options]代表离它们最近的输入文件的选项，可以有很多个[[infile options] -i infile]。[outfile options] outfile同理
```

**ffplay与ffprobe：**
```
ffplay -h  # ffplay命令查看帮助文档
ffplay [options] input_file # 命令格式

ffprobe -h  # ffprobe命令查看帮助文档
ffprobe [OPTIONS] [INPUT_FILE] # 命令格式
```
ffmpeg/ffplay/ffprobe部分参数通用，部分参数不通用，在使用时需要注意。



## 1.2.ffmpeg和ffplay基本命令
### 1.2.1.ffmpeg基本查询命令
![](https://img2022.cnblogs.com/blog/1617829/202206/1617829-20220609161007653-2077244425.png)

一些命令的补充解释：
-devices：查询系统中可用摄像头和音频设备
-bsfs：ffmpeg支持处理比特流的信息，此命令用于查询支持哪些比特流。
-protocols：ffmpeg支持处理网络文件，此命令用于查询支持哪些协议
-filters：比如加水印、去水印
-pix_fmts：查询可用哪些格式存储图片
-sample_fmts：使用多少位来存储一个采样，如8位、16位、 32位（浮点型）
-layouts：如双声道、单声道、立体声（三个声道以上称为立体声）

**查询命令的作用：**
比如我们需要将音频输出成mp3格式，那么我们就需要查询mp3对应的编码器：
```
ffmpeg -encoders |grep mp3   # 查询mp3的编码器
# 输出
A....D libmp3lame           libmp3lame MP3 (MPEG audio layer 3) (codec mp3)

# 通过以下命令输出MP3格式的音频文件
ffmpeg -i test.mp4 -b:a 192k -ar 48000 -ac 2 -acodec libmp3lame -aframes 200 out.mp3
```

**下面对各个命令进行介绍：**

ffmpeg -version
![](https://img2022.cnblogs.com/blog/1617829/202206/1617829-20220609134255163-2004387911.png)
除了显示版本信息以外，还显示了一些其他信息。即：
**不管使用ffmeg的什么命令，都会打印ffmpeg是使用什么编译器建立的、建立时采用的配置和库的版本信息。**


ffmpeg -buildconf
![](https://img2022.cnblogs.com/blog/1617829/202206/1617829-20220609134900624-1567606680.png)

ffmpeg -devices
![](https://img2022.cnblogs.com/blog/1617829/202206/1617829-20220609135728924-171704727.png)
**查询命令：一般都会在最开始，说明各种字母代表的意思，比如这里的D和E**


ffmpeg -codecs
![](https://img2022.cnblogs.com/blog/1617829/202206/1617829-20220609161651105-200625492.png)
I代表I帧的编码器



ffmpeg -pix_fmts
![](https://img2022.cnblogs.com/blog/1617829/202206/1617829-20220609141826473-605206373.png)




### 1.2.2.ffmpeg查询类型所支持的参数

```
语法：ffmepg -h type=name
比如： ffmpeg -h muxer=flv
      ffmpeg -h filter=atempo (atempo调整音频播放速率)
      ffmpeg -h encoder=libx264
```
ffmpeg -h encoder=libx264就是查询使用libx264编码器是可以设置什么参数，结果如下
![](https://img2022.cnblogs.com/blog/1617829/202206/1617829-20220609162046942-796875199.png)



### 1.2.3.ffplay播放控制
使用ffplay播放视频时，可以使用下面按键来操作：
![](https://img2022.cnblogs.com/blog/1617829/202206/1617829-20220609163050961-71478533.png)

说明：
/和*不能用，所以这里划掉了

一个音视频文件中，是可能有多个视频流和多个音频流的，可以使用a和v切换。【多个视频流和多个音频流就是指很多个不同的视频和音频】
c就是切换节目，这样能够保持音视频的同步。如果只切换a或v或t一样，会导致音视频不同步。


### 1.2.4.ffplay命令选项
```
◼ -x width 强制显示宽带。
◼ -y height 强制显示高度。
◼ -video_size size 帧尺寸 设置显示帧存储(WxH格式)，仅适用于类似原始YUV等没有包含帧大小(WxH)的视频。
比如: ffplay -pixel_format yuv420p -video_size 320x240 -framerate 5 yuv420p_320x240.yuv
◼ -pixel_format format 格式设置像素格式。
◼ -fs 以全屏模式启动。
◼ -an 禁用音频（不播放声音）
◼ -vn 禁用视频（不播放视频）
◼ -sn 禁用字幕（不显示字幕）
◼ -ss pos：指定从pos位置开始播放视频，下面是几种典型的pos值：
    55：55秒开始 
    12:03:45：12小时03分钟45秒开始
    23.189：23.189秒开始 
◼ -t duration 设置播放视频/音频长度，时间单位如 -ss选项
```

```
◼ -bytes 按字节进行定位拖动（0=off 1=on -1=auto）。【什么叫做按字节进行拖动？？】
◼ -seek_interval interval 自定义左/右键定位拖动间隔（以秒为单位），默认值为10秒（代码没有看到实现） 
◼ -nodisp 关闭图形化显示窗口，视频将不显示
◼ -noborder 无边框窗口
◼ -volume vol 设置起始音量。音量范围[0 ~100]
◼ -f fmt 强制使用设置的格式进行解析。比如-f s16le。主要针对PCM数据进行解析。
◼ -window_title title 设置窗口标题（默认为输入文件名）
◼ -loop number 设置播放循环次数
    -t 5 -loop 2 ：播放五秒，循环两次
◼ -showmode mode 设置显示模式，可用的模式值：0 显示视频，1 显示音频波形，2 显示音频频谱。缺省为0，如果视频不存在则自动选择2 
◼ -vf filtergraph 设置视频滤镜
◼ -af filtergraph 设置音频滤镜
```
```
◼ -stats 打印多个回放统计信息，包括显示流持续时间，编解码器参数，流中的当前位置，以及音频/视频同步差值。默认情况下处于启用状态，要显式禁用它则需要指定-nostats。。
◼ -fast 非标准化规范的多媒体兼容优化。
◼ -genpts 生成pts。 
◼ -sync type 同步类型 将主时钟设置为audio（type=audio），video（type=video）或external（type=ext），默认是audio为主时钟。
    同步类型有以下几种：
      Audio Master：视频跟随音频的播放速度
      Video Master：音频跟随视频的播放速度
      External Clock Master：音频和视频都跟随外部时钟
◼ -ast audio_stream_specifier 指定音频流索引，比如-ast 3，播放流索引为3的音频流
      -ast：就是有很多个音频流，你可以指定播放哪个音频流 
◼ -vst video_stream_specifier指定视频流索引，比如-vst 4，播放流索引为4的视频流
◼ -sst subtitle_stream_specifier 指定字幕流索引，比如-sst 5，播放流索引为5的字幕流
◼ -autoexit 视频播放完毕后退出
```
-stats默认情况下处于启用状态，打印如下信息：
![](https://img2022.cnblogs.com/blog/1617829/202206/1617829-20220609190657984-1489062171.png)

```
◼ -exitonkeydown 键盘按下任何键退出播放
◼ -exitonmousedown 鼠标按下任何键退出播放
◼ -codec:media_specifier codec_name 强制使用设置的多媒体解码器，media_specifier可用值为a（音频）， v（视频）和s字幕。比如-codec:v h264_qsv 强制视频采用h264_qsv解码
◼ -acodec codec_name 强制使用设置的音频解码器进行音频解码
◼ -vcodec codec_name 强制使用设置的视频解码器进行视频解码
    -codec:v h264 等价于 -vcodec h264
◼ -scodec codec_name 强制使用设置的字幕解码器进行字幕解码
◼ -autorotate 根据文件元数据自动旋转视频。值为0或1 ，默认为1。
◼ -framedrop 如果视频不同步则丢弃视频帧。当主时钟非视频时钟时默认开启。若需禁用则使用 -noframedrop
◼ -infbuf 不限制输入缓冲区大小。尽可能快地从输入中读取尽可能多的数据。播放实时流时默认启用，如果未及时读取数据，则可能会丢弃数据。此选项将不限制缓冲区的大小。若需禁用则使用-noinfbuf
```

更多信息请参考：https://ffmpeg.org/ffplay.html



### 1.2.5.ffplay实例
**播放实例：**
```
◼ 播放本地文件
◼ ffplay -window_title "test time" -ss 2 -t 10 -autoexit test.mp4
◼ ffplay buweishui.mp3
◼ 播放网络流
◼ ffplay -window_title "rtmp stream" 
rtmp://202.69.69.180:443/webcast/bshdlive-pc
◼ 强制解码器
◼ mpeg4解码器：ffplay -vcodec mpeg4 test.mp4
◼ h264解码器：ffplay -vcodec h264 test.mp4 
◼ 禁用音频或视频
◼ 禁用音频：ffplay test.mp4 -an
◼ 禁用视频：ffplay test.mp4 -vn
```
```
◼ 播放YUV数据
◼ ffplay -pixel_format yuv420p -video_size 320x240 -framerate 5 yuv420p_320x240.yuv
◼ 播放RGB数据
◼ ffplay -pixel_format rgb24 -video_size 320x240 -i rgb24_320x240.rgb
◼ ffplay -pixel_format rgb24 -video_size 320x240 -framerate 5 -i rgb24_320x240.rgb
◼ 播放PCM数据
◼ ffplay -ar 48000 -ac 2 -f f32le 48000_2_f32le.pcm
-ar set audio sampling rate (in Hz) (from 0 to INT_MAX) (default 0)
-ac set number of audio channels (from 0 to INT_MAX) (default 0)
```

**ffplay简单过滤器**
```
◼ 视频旋转
ffplay -i test.mp4 -vf transpose=1
◼ 视频反转
ffplay test.mp4 -vf hflip
ffplay test.mp4 -vf vflip
◼ 视频旋转和反转
ffplay test.mp4 -vf hflip,transpose=1
◼ 音频变速播放
ffplay -i test.mp4 -af atempo=2
◼ 视频变速播放
ffplay -i test.mp4 -vf setpts=PTS/2
◼ 音视频同时变速
ffplay -i test.mp4 -vf setpts=PTS/2 -af atempo=2
◼ 更多参考
http://www.ffmpeg.org/ffmpeg-filters.html
```

 



# 2.ffmpeg命令
## 2.1.ffmpeg基本参数

主要参数：
```
◼ -i 设定输入流
◼ -f 设定输出格式(format)
◼ -ss 开始时间
◼ -t 时间长度

实例：
ffmpeg -i test.mp4 -codec copy -ss 10 -t 20 -f f1v out.mp4
```

音频参数：
```
◼ -aframes 设置要输出的音频帧数
◼ -b:a 音频码率
◼ -ar 设定采样率
◼ -ac 设定声音的Channel数 
◼ -acodec 设定声音编解码器，如果用copy表示原始编解码数据必须被拷贝。
◼ -an 不处理音频
◼ -af 音频过滤器

实例：
ffmpeg -i test.mp4 -b:a 192k -ar 48000 -ac 2 -acodec libmp3lame -aframes 200 out2.mp3
```

视频参数：
```
◼ -vframes 设置要输出的视频帧数
◼ -b 设定视频码率
◼ -b:v 视频码率。和-b一样。
◼ -r 设定帧速率
◼ -s 设定画面的宽与高
◼ -vn 不处理视频
◼ -aspect aspect 设置横纵比 4:3 16:9 或 1.3333 1.7777。【和-s有什么区别？？】
◼ -vcodec 设定视频编解码器，如果用copy表示原始编解码数据必须被拷贝。
◼ -vf 视频过滤器

实例：
ffmpeg -i test.mp4 -vframes 300 -b:v 300k -r 30 -s 640x480 -aspect 16:9 -vcodec libx265
```

## 2.2.ffmpeg命令提取音视频数据

```
◼ 保留封装格式
ffmpeg -i test.mp4 -acodec copy -vn audio.mp4
ffmpeg -i test.mp4 -vcodec copy -an video.mp4
◼ 提取视频
保留编码格式：ffmpeg -i test.mp4 -vcodec copy -an test_copy.h264
强制格式：ffmpeg -i test.mp4 -vcodec libx264 -an test.h264
◼ 提取音频
保留编码格式：ffmpeg -i test.mp4 -acodec copy -vn test.aac
强制格式：ffmpeg -i test.mp4 -acodec libmp3lame -vn test.mp3
```

## 2.3.ffmpeg命令提取像素格式

```
◼ 提取YUV
◼ 提取3秒数据，分辨率和源视频一致
ffmpeg -i test_1280x720.mp4 -t 3 -pix_fmt yuv420p yuv420p_orig.yuv  # 命名为test_1280x720.mp4就容易看出是1280x720
ffplay -video_size 1280x720 yuv420p_orig.yuv  # 需要指定正确的-video_size才能播放

◼ 提取3秒数据，分辨率转为320x240
ffmpeg -i test_1280x720.mp4 -t 3 -pix_fmt yuv420p -s 320x240  yuv420p_320x240.yuv


◼ 提取RGB
◼ 提取3秒数据，分辨率转为320x240
ffmpeg -i test.mp4 -t 3 -pix_fmt rgb24 -s 320x240 rgb24_320x240.rgb
◼ RGB和YUV之间的转换
ffmpeg -s 320x240 -pix_fmt yuv420p -i yuv420p_320x240.yuv -pix_fmt rgb24 rgb24_320x240_2.rgb
```

## 2.4.ffmpeg命令提取PCM数据
```
ffmpeg -i buweishui.mp3 -ar 48000 -ac 2 -f s16le 48000_2_s16le.pcm # PCM文件的后缀可以是随意的，最好设为pcm。
ffmpeg -i buweishui.mp3 -ar 48000 -ac 2 -sample_fmt s16 out_s16.wav
ffmpeg -i buweishui.mp3 -ar 48000 -ac 2 -codec:a pcm_s16le out2_s16le.wav # out2_s16le.wav与out_s16.wav完全一致
ffmpeg -i buweishui.mp3 -ar 48000 -ac 2 -f f32le 48000_2_f32le.pcm
ffmpeg -i test.mp4 -t 10 -vn -ar 48000 -ac 2 -f f32le 48000_2_f32le_2.p
```
“-f s16le”中的s16le可以通过下面命令查到：
```
ffmpeg -muxers | grep PCM
```



## 2.5.ffmpeg命令转封装

```
◼ 保持编码格式：
ffmpeg -i test.mp4 -vcodec copy -acodec copy test_copy.ts
ffmpeg -i test.mp4 -codec copy test_copy2.ts #  test.mp4中无字幕时，和上面的命令等价
◼ 改变编码格式：
ffmpeg -i test.mp4 -vcodec libx265 -acodec libmp3lame out_h265_mp3.mkv
◼ 修改帧率：
ffmpeg -i test.mp4 -r 15 -codec copy output.mp4 # 由于修改帧率涉及到编解码，所以使用-codec copy将使得帧率没有变化
ffmpeg -i test.mp4 -r 15 output2.mp4
◼ 修改视频码率：
ffmpeg -i test.mp4 -b 400k output_b.mkv # 由于输出为mkv格式，所以音视频会采用mkv格式默认的编码器，故此时音视频可能会被重新编码
◼ 修改视频码率：
ffmpeg -i test.mp4 -b:v 400k output_bv.mkv # 和上述命令完全等价
【注】修改码率只是说修改到400k附近，不一定能修改到400k



```

```
◼ 修改音频码率：
ffmpeg -i test.mp4 -b:a 192k output_ba.mp4
上述命令也会导致video被重新编码，从而导致视频码率的变化。如果不想重新编码video，需要加上-vcodec copy。修改视频码率的时候，音频的码率也有可能发生变化，此时我们可以利用-acodec copy。
◼ 修改音视频码率：
ffmpeg -i test.mp4 -b:v 400k -b:a 192k output_bva.mp4
◼ 修改视频分辨率：
ffmpeg -i test.mp4 -s 480x270 output_480x270.mp4
◼ 修改音频采样率: 
ffmpeg -i test.mp4 -ar 44100 output_44100hz.mp4
```



## 2.6.ffmpeg命令裁剪和合并视频
```
◼ 找三个不同的视频每个视频截取10秒内容
ffmpeg -i 沙海02.mp4 -ss 00:05:00 -t 10 -codec copy 1.mp4
ffmpeg -i 复仇者联盟3.mp4 -ss 00:05:00 -t 10 -codec copy 2.mp4
ffmpeg -i 红海行动.mp4 -ss 00:05:00 -t 10 -codec copy 3.mp4
由于需要将1.mp4、2.mp4和3.mp4合并起来，如果沙海02.mp4、复仇者联盟3.mp4和红海行动.mp4格式不统一时，
则需要强制统一为 -vcodec libx264 -acodec aac。
◼ 将上述1.mp4/2.mp4/3.mp4转成ts格式
ffmpeg -i 1.mp4 -codec copy -vbsf h264_mp4toannexb 1.ts
ffmpeg -i 2.mp4 -codec copy -vbsf h264_mp4toannexb 2.ts
ffmpeg -i 3.mp4 -codec copy -vbsf h264_mp4toannexb 3.ts
◼ 转成flv格式
ffmpeg -i 1.mp4 -codec copy 1.flv
ffmpeg -i 2.mp4 -codec copy 2.flv
ffmpeg -i 3.mp4 -codec copy 3.flv
分离某些封装格式（例如MP4/FLV/MKV等）中的H.264的时候，需要首先写入
SPS和PPS，否则会导致分离出来的数据没有SPS、PPS而无法播放。H.264码流
的SPS和PPS信息存储在AVCodecContext结构体的extradata中。需要使用ffmpeg
中名称为“h264_mp4toannexb”的bitstream filter处理
```

## 2.7.ffmpeg命令图片和视频转换
```
◼ 截取一张图片
ffmpeg -i test.mp4 -y -f image2 -ss 00:00:02 -vframes 1 -s 640x360 test.jpg
ffmpeg -i test.mp4 -y -f image2 -ss 00:00:02 -vframes 1 -s 640x360 test.bmp
    -i 输入
    -y 覆盖
    -f 格式
    image2 一种格式
    -ss 起始值
    -vframes 1：输出一帧。如果大于1，那么输出加%03d，即test%03d.jpg，即输出的图片按testxxx.jpg进行编号，如test001.jpg 
    -s 格式大小size
◼ 转换视频为图片（每帧一张图):
ffmpeg -i test.mp4 -t 5 -s 640x360 -r 15 frame%03d.jpg 
-t 5：对视频的五秒进行操作，每秒十五帧（-r 15）

◼ 图片转换为视频:
ffmpeg -f image2 -i frame%03d.jpg -r 25 video.mp4

◼ 从视频中生成GIF图片
ffmpeg -i test.mp4 -t 5 -r 1 image1.gif
ffmpeg -i test.mp4 -t 5 -r 25 -s 640x360 image2.gif
◼ 将 GIF 转化为 视频
ffmpeg -f gif -i image2.gif image2.mp4
```





视频学习，学到的东西总是基础的。我们还是需要学会使用官方文档
]]></description></item><item><title>jsoncpp使用</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/06/06/16350049.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Mon, 06 Jun 2022 14:44:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/06/06/16350049.html</guid><description><![CDATA[jsoncpp源码位置：https://github.com/open-source-parsers/jsoncpp

# 1.jsoncpp简介
jsoncpp是一个用来存储键值对的库。
键值对的值可以是双引号包起来的字符串、数、布尔类型、null、对象或者数组
上面所说的大家都很熟悉，只有最后两个是比较特殊的：
对象：这里对象的概念和C++中对象的概念不一样，这里的对象指的是用{}括起来的多个键值对组成的集合。一个对象由花括号{}包起来，每一个键：值之间用逗号, 隔开，如 {“name”: Any, “age”:18}
数组：一个数组由中括号[]包起来，每一个键：值之间用逗号, 隔开，如 [“friend1”: William, “friend2”: Austy]
也就是说对象和数组都是键值对的集合，只是一个用{}，一个用[]。

**jsoncpp中含有三种基础类：Value、Write、Reader。**
1. Json::Value：用于存储键值对
2. Json::Writer
这个类负责将内存中的value对象转换为json文档，输出到文件或者字符串中
它有两种主要的方法：FastWriter、StyledWriter
FastWriter：快速无格式的将value转换成json文档
StyledWriter：有格式的将value转换成json文档
3. Json::Reader
用于读取json文档，或者说是用于将字符串或者文件输入流转换为Json::Value对象

**实用函数**
1. 判断某个键是否存在
bool Json::Value::isMember(const char *key) const;
若存在则返回1，反之为0
2. 得到Value中的所有键
Json::Value::getMemberBames() const;
返回一个string类型的vector
3. 删除某个键
Json::Value::removeMember(const char *key);
返回删除的值或者null







# 2.下载安装jsoncpp
首先下载项目https://github.com/open-source-parsers/jsoncpp，我们需要的文件有include/json/和src/lib_json，将这两个文件夹复制到同一目录下，结构如下：
```
lib_json/
  CMakeLists.txt 【这个文件没用，可以删了】
  json_reader.cpp
  json_tool.h
  json_value.cpp
  json_valueiterator.inl
  json_writer.cpp

json/
  allocator.h
  assertions.h
  config.h
  forwards.h
  json.h
  json_features.h
  reader.h
  value.h
  version.h
  writer.h
```

然后在json/目录下创建json.hpp，并include include/json/下所有头文件，内容如下：
```
#ifndef JSON_HPP_INCLUDED
#define JSON_HPP_INCLUDED

#include "allocator.h"
#include "writer.h"
#include "version.h"
#include "value.h"
#include "reader.h"
#include "json.h"
#include "json_features.h"
#include "forwards.h"
#include "config.h"
#include "assertions.h"

#endif // JSON_HPP_INCLUDED
```
然后我们就可以使用jsoncpp。


在lib_json/目录下创建test.cpp，内容如下：
```
#include <iostream>
#include <fstream>
#include "../json/json.hpp"

#if defined(__GNUC__)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#elif defined(_MSC_VER)
#pragma warning(disable : 4996)
#endif

using namespace std;

int createjson()
{
    Json::Value root;
    Json::Value language;
    Json::Value mail;
    Json::StyledWriter writer;
    // Json::FastWriter writer;

    root["Name"] = "pikashu";
    root["Age"] = 18;

    language[0] = "C++";
    language[1] = "Python";
    root["Language"] = language;

    mail["QQ"] = "789123456@qq.com";
    mail["Google"] = "789123456@gmail.com";
    root["E-mail"] = mail;

    string json_file = writer.write(root);

    ofstream ofs;
    ofs.open("test1.json");
    if (!ofs.is_open())
    {
        cout << "open file error." << endl;
        return -1;
    }
    ofs << json_file;
    ofs.close(); 
    return 0;
}

int readjson()
{
    Json::Reader reader;
    Json::Value root;
    Json::Value language;
    Json::Value mail;

    ifstream ifs;
    ifs.open("test1.json");
    if (!ifs.is_open())
    {
        cout << "open file error." << endl;
        return -1;
    }

    if (!reader.parse(ifs, root))
    {
        cout << "parse error" << endl;
        return -1;
    }

    string Name = root["Name"].asString();
    int Age = root["Age"].asInt();  // jsoncpp中获取int类型数据
    cout << "Name: " << Name << endl;
    cout << "Age: " << Age << endl;

    if (root["language"].isArray())
    {
        Json::Value array_l = root["language"];
        cout << "Language: ";
        for (int i = 0; i < array_l.size(); i++)
        {
            cout << array_l[i] << " ";
        }
        cout << endl;
    }

    cout << "Google: " << root["E-mail"].get("Google", "").asString() << endl;
    cout << "QQ: " << root["E-mail"].get("QQ", "").asString() << endl;

    return 1;
}
int main()
{
    createjson();
    readjson();
    return 0;
}
```
运行命令：
```
g++ json_reader.cpp json_value.cpp json_writer.cpp  test.cpp  -o result
./result
```
结果：
```
Name: pikashu
Age: 18
Google: 789123456@gmail.com
QQ: 789123456@qq.com
```
参考：[JSONCPP安装及学习使用](https://blog.csdn.net/qq_44299067/article/details/121929266)
其他jsoncpp安装方法自行百度。
]]></description></item><item><title>c++ mysql使用</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/06/06/16349594.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Mon, 06 Jun 2022 12:31:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/06/06/16349594.html</guid><description><![CDATA[# 1.安装mysql和启动
本人采用源码方式进行安装，请参考：[链接](https://blog.csdn.net/weixin_42973678/article/details/100107986)

一些说明：
**1.用户组与用户**
```
groupadd mysql # 创建用户组
useradd -g mysql mysql # 创建用户mysql，并将用户mysql指定给用户组mysql。-g指定用户组，后面跟着用户名。
mkdir /usr/local/mysql/data
chown -R mysql /usr/local/mysql # 修改文件和目录的所属用户。-R处理指定目录以及其子目录下的所有文件
chgrp -R mysql /usr/local/mysql # chgrp命令:修改文件和目录的所属组
```

**2.oracle与mysql**
oracle数据库中有多个用户，每个用户多张表
MySQL数据库只有一个用户(root), 有多个数据库,每个数据库下有多张表。【这里的root用户不是指linux下的root用户，而是指mysql中有一个称为root的用户】

**3.启动mysql：**
```
systemctl  restart mysqld # 重启MySQL服务

systemctl  status mysqld  # 查看MySQL服务状态

systemctl stop mysqld  # 停止MySQL服务

systemctl start mysqld # 启动MySQL服务

# 登录MySQL数据库有以下两种方法：
sudo mysql 
# 或
mysql -u root -p
```

# 2.CURD 
## 2.1.数据库CURD 

对数据库进行增(Create)、改(Update) 、查(Retrieve) 、删(Delete)操作。

### 2.1.1.创建数据库
```
CREATE {DATABASE | SCHEMA} [IF NOT EXISTS] db_name
    [create_specification [, create_specification] ...]
```
- IF NOT EXISTS 表示只有数据库不存在的时候才创建，如果存在同名就不再执行该语句
- Create specification是建库的一些选项

下面时创建数据库的一些实例：
```
1)创建一个名称为mydb1的数据库。
create database mydb1;
2)创建一个使用utf-8字符集的mydb2数据库。
create database mydb2 character set utf8;
3)创建一个使用utf-8字符集，并带校对规则的mydb3数据库，校对规则会对存入的数据进行检查。
create database mydb3 character set utf8 collate utf8_general_ci;
```

### 2.1.2.查看数据库
```
show databases; # 显示所有数据库
show create database mydb2;  # 显示创建数据库时使用的语句信息
 “ ` ”（ESC键 下面的按键），表示反引号，默认情况下，反引号括起来的字符串，区分大小写。

show create database mydb1;
注意 ：mysql默认语言集是latin1，每次在创建数据库的时候应指定字符集。Oracle是在安装时，即指定了字符集。
```

### 2.1.3.修改和删除数据库
```
alter database mydb1 character set utf8; # 修改mydb1的字符集为utf8(不能修改数据库名) 

drop database mydb3; # 删除数据库mydb3
```



## 2.2.表的CURD
对表本身进行操作：创建，查看，修改，删除

### 2.2.1.创建表
```
use mydb2; # 在mysql中对表操作前，必须先选择所使用的数据库。
show tables; # 查看表的内容
show create table t1; # 查看创建表的语法。ENGINE=InnoDB 默认指定的存储引擎 innoDB。
```

mysql中的数据类型：

![](https://img2022.cnblogs.com/blog/1617829/202206/1617829-20220606201854083-2026900352.png)

- bit     1位　	可以指定位数，如：bit(3)
- int     2字节 	可以指定最大位数，如：int<4>　最大为4位的整数
- float   2个字节　可以指定最大的位数和最大的小数位数，如：float<5,2> 最大为一个5位的数，小数位最多2位 
- double　4个字节　可以指定最大的位数和最大的小数位数，如：float<6,4> 最大为一个6位的数，小数位最多4位
- char　  必须指定字符数,如char(5) 为不可变字符　即使存储的内容为'ab',也是用5个字符的空间存储这个数据
- varchar　必须指定字符数,如varchar(5) 为可变字符　如果存储的内容为'ab',占用2个字符的空间；如果为'abc',则占用3个字符的空间
- text: 大文本(大字符串)
- blob：二进制大数据　如图片，音频文件，视频文件
- date: 日期　如：'1921-01-02'
- datetime: 日期+时间　如：'1921-01-02 12:23:43'
- timeStamp: 时间戳，自动赋值为当前日期时间

创建一个员工表：
```
create table employee(empno int, ename varchar(20), sal int);
show create table employee;  # 查看创建employee表时使用了什么命令
```

### 2.2.2.查看表
```
show tables; # 查看所有的表
show create table employee; # 查看指定表的创建语句 # 注意，mysql表名称区分大小写, 对列名不区分大小写
desc employee; # 显示指定表的结构：
```
### 2.2.3.修改表
```
更改表名：    rename table employee to worker;
增加一个字段： alter table employee add column height double;  （column关键字在Oracle中，添加则语法错误）
修改一个字段：alter table employee modify column height float;
删除一个字段：alter table employee drop column height;
修改表的字符集:alter table employee character set gbk;
show create table employee; # 从这里可以查看修改表的字符集的结果
```

### 2.2.4.删除表
```
删除employee表:
drop table employee;	 (MySQL中不能使用purge，添加会出现语法错误)
```


## 2.3.表数据的CURD	

### 2.3.1.create数据
```
创建一个员工表，新建employee表并向表中添加一些记录：
create table employee(
id int,
name varchar(20),
sex int,
birthday date,
salary double,
entry_date date,
resume text
);
insert into employee values(1,'张三',1,'1983-04-27',15000,'2012-06-24','一个大牛');
insert into employee(id,name,sex,birthday,salary,entry_date,resume) values(2,'李四',1,'1984-02-22',10000,'2012-07-24','一个中牛');
insert into employee(id,name,sex,birthday,salary,entry_date,resume) values(3,'王五',0,'1985-08-28',7000,'2012-08-24','一个小虾');
```

### 2.3.2	update数据 
```
将所有员工薪水都增加500元。
update employee set salary=salary+500;
将王五的员工薪水修改为10000元，resume改为也是一个中牛
update employee set salary=10000, resume='也是一个中牛' where name='王五';
```

### 2.3.3.delete数据 
```
删除表中姓名为王五的记录。
delete from employee where name='王五';		【注意from不能省略】
删除表中所有记录。
delete from employee; 
使用truncate删除表中记录。
truncate table employee;--无条件 效率高
```

### 2.3.4.Retrieve数据
```
查询员工的年收入：
	select id, name as "名字", salary "月薪", salary*12 年薪  from employee where id >=2;
```




# 3. c语言连接mysql数据库
## 3.1.找到所需的头文件和库文件

找到头文件mysql.h和库文件libmysqlclient.a
1. 找到对应的头文件

   >[root@deng ~]# locate mysql.h
   >**/usr/include/mysql/mysql.h**  <---对应的头文件
   >/usr/share/doc/rsyslog-5.8.10/ommysql.html
   >/usr/share/doc/rsyslog-5.8.10/rsyslog_mysql.html

2. 找到对应的库文件

   >[root@deng ~]# locate libmysqlclient.a
   >**/usr/lib64/mysql/libmysqlclient.a**  # .a文件代表静态库    


## 3.2.编程步骤

1. 通过调用mysql_init()初始化连接处理程序，得到句柄
2. 通过调用mysql_real_connect()连接到服务器。
3. 发出SQL语句并处理其结果。
4. 通过调用mysql_close()，关闭与MySQL服务器的连接。



## 3.3.初始化和连接到MySQL

mysql_init函数

```C
MYSQL *mysql_init(MYSQL *mysql) 
功能:
	分配或初始化与mysql_real_connect()相适应的MYSQL对象。如果mysql是NULL指针，该函数将分配、初始化、并返回新对象。
        否则，将初始化对象，并返回对象的地址。如果mysql_init()分配了新的对象，当调用mysql_close()来关闭连接时。将释放该对象。

参数:
	mysql: 一般填写NULL, 会自动分配 初始化和返回对象

返回值:
	初始化的MYSQL*句柄。如果无足够内存以分配新的对象，返回NULL。
	
	
```



mysql_close函数:

```C
void mysql_close(MYSQL *mysql) 
功能:
	关闭前面打开的连接。如果句柄是由mysql_init()或mysql_connect()自动分配的，mysql_close()还将解除分配由mysql指向的连接句柄
	
参数:
	mysql:  是mysql_init的返回值

返回值:
	无
```



mysql_real_connect函数

```C
MYSQL *mysql_real_connect(MYSQL *mysql, const char *host, const char *user, const char *passwd, 
                        const char *db, unsigned int port, const char *unix_socket, unsigned long client_flag) 

功能:
	mysql_real_connect()尝试与运行在主机上的MySQL数据库引擎建立连接。在你能够执行需要有效MySQL连接句柄结构的任何其他API函数
        之前，mysql_real_connect()必须成功完成。

参数:
	mysql: mysql_init返回值, 初始化好的句柄
	host: 主机名或IP地址
	user: 数据库用户名
	passwd: 数据库对应用户名的密码
	db: 数据库名称
	port: 0表示使用默认的端口
	unix_socket: 一般填写NULL
	client_flag: 通常为0

返回值:
	如果连接成功，返回MYSQL*连接句柄。如果连接失败，返回NULL。对于成功的连接，返回值与第1个参数的值相同。

```



测试代码:

```C
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <mysql/mysql.h>

#define _HOST_ "127.0.0.1"
#define _USER_ "root"
#define _PASSWD_ "123456"
#define _DB_ "scott"

//初始化  关闭
int main(void)
{
    MYSQL *mysql = NULL;

    //1. 初始化一个句柄
    mysql = mysql_init(NULL);
    if (NULL == mysql)
    {
        printf("mysql_init failed...\n"); 
        return 1;
    }
    printf("mysql_init ok....\n");

    
    //2. 连接mysql数据库
    mysql = mysql_real_connect(mysql, _HOST_, _USER_, _PASSWD_, _DB_, 0, NULL, 0); 
    if (NULL == mysql)
    {
        printf("连接mysql数据库失败...\n"); 
    }
    else
    {
        printf("连接mysql数据库成功....\n"); 
    }


    //3. 关闭连接
    mysql_close(mysql);    

    return 0;
}

```

编译方法:
```
gcc testMysql.c -I  /home/xxx/software/mysql_5_7/include/ -L  /home/xxx/software/mysql_5_7/lib/ 
        -l mysqlclient -Wl,-rpath=/home/xxx/software/mysql_5_7/lib/
```
/home/xxx/software/mysql_5_7为mysql的安装路径（我使用的是源码安装的方法）




## 3.4.执行SQL语句(增删改查)

mysql_query函数

```C
int mysql_query(MYSQL *mysql, const char *query) 
功能:
	执行由“Null终结的字符串”查询指向的SQL查询。正常情况下，字符串必须包含1条SQL语句，而且不应为语句添加终结分号（‘;’）或
        “\g”。如果允许多语句执行，字符串可包含多条由分号隔开的语句

参数:
	mysql: 是mysql_real_connect连接成功之后的句柄
	query: 对应的SQL语句
	
返回值:
	如果查询成功，返回0。如果出现错误，返回非0值。 

```
执行插入的代码:

```c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <mysql/mysql.h>

#define _HOST_ "192.168.73.36"
#define _USER_ "root"
#define _PASSWD_ "123456"
#define _DB_ "scott"

#define SIZE 128

//初始化  关闭
int main(void)
{
    int ret = -1;

    MYSQL *mysql = NULL;

    char buf[SIZE];

    //1. 初始化一个句柄
    mysql = mysql_init(NULL);
    if (NULL == mysql)
    {
        printf("mysql_init failed...\n"); 
        return 1;
    }
    printf("mysql_init ok....\n");

    
    //2. 连接mysql数据库
    mysql = mysql_real_connect(mysql, _HOST_, _USER_, _PASSWD_, _DB_, 0, NULL, 0); 
    if (NULL == mysql)
    {
        printf("连接mysql数据库失败...\n"); 
    }
    else
    {
        printf("连接mysql数据库成功....\n"); 
    }

    //3. 执行SQL语句
    memset(buf, 0, SIZE);
    strcpy(buf, "insert into dept values(3, '3name', '3loc')");
    ret = mysql_query(mysql, buf);
    if (0 != ret)
    {
        printf("mysql_query failed....\n"); 
    }
    else
    {
        printf("执行SQL语句ok....\n");
    }


    //4. 关闭连接
    mysql_close(mysql);    

    return 0;
}
```
其他操作自己看手册，或者百度。























# C++链接数据库
C++使用Connector/C++连接数据库
[链接](https://blog.csdn.net/hbtj_1216/article/details/51168596)








学会使用官方提供的文档
]]></description></item><item><title>ffmpeg 文档阅读笔记</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/06/05/16344239.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Sun, 05 Jun 2022 08:19:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/06/05/16344239.html</guid><description><![CDATA[# 1.ffmpeg简介
## 1.1.命令格式
```
ffmpeg [global_options] {[input_file_options] -i input_url} ... {[output_file_options] output_url} ...
```
-i：指定输入。输入可以是视频文件、网络流、音视频设备等。可以使用-i指定任意数量的输入。
输出：命令行上任意不能被解释成选项的东西，都被认为是输出。可以有任意数量的输出。
-map：一条ffmpeg命令中，可能有多个输入和输出。-map指定哪个输入对应哪个输出。如果没有使用-map进行指定，那么会使用默认的方法进行指定

-i后面跟索引，索引值从0开始。2:3代表第三个输入文件的第四个流。【不懂？？】

ffmpeg的每个选项按顺序对输入进行操作，即选项对输入进行操作的结果，送给下一个选项进行操作，故ffmpeg的选项的顺序很重要。全局选项（例如 verbosity level）是个例外，全局选项的位置不重要，但是一般放在最前面。

选项都只应用于最先遇到的文件。

## 1.2.ffmpeg的处理流程
```
 _______              ______________
|       |            |              |
| input |  demuxer   | encoded data |   decoder
| file  | ---------> | packets      | -----+
|_______|            |______________|      |
                                           v
                                       _________
                                      |         |
                                      | decoded |
                                      | frames  |
                                      |_________|
 ________             ______________       |
|        |           |              |      |
| output | <-------- | encoded data | <----+
| file   |   muxer   | packets      |   encoder
|________|           |______________|

```
使用libavformat库读取输入文件，获取到encoded data packets。When there are multiple input files, ffmpeg tries to keep them synchronized by tracking lowest timestamp on any active input stream.【这句英文看不懂】
decoder产生未压缩的帧（(raw video/PCM audio/...），然后可以进行filtering




# 2.Filtering

使用libavfilter库中的filter对decoder产生未压缩的帧进行处理，多个filter形成一个filter graph。filter分为simple和complex


## 2.1.Simple filtergraphs
Simple filtergraphs结构如下：
```
 _________                        ______________
|         |                      |              |
| decoded |                      | encoded data |
| frames  |\                   _ | packets      |
|_________| \                  /||______________|
             \   __________   /
  simple     _\||          | /  encoder
  filtergraph   | filtered |/
                | frames   |
                |__________|
```

通过-vf和-af分别指定视频和音频的filter



## 2.2. Complex filtergraphs
Complex filtergraphs结构如下
```
 _________
|         |
| input 0 |\                    __________
|_________| \                  |          |
             \   _________    /| output 0 |
              \ |         |  / |__________|
 _________     \| complex | /
|         |     |         |/
| input 1 |---->| filter  |\
|_________|     |         | \   __________
               /| graph   |  \ |          |
              / |         |   \| output 1 |
 _________   /  |_________|    |__________|
|         | /
| input 2 |/
|_________|

```
通过-lavfi指定Complex filtergraphs，-lavfi是一个全局选项


# 3.Stream copy

-codec copy 复制原始的编码规则，过程如下：
```
 _______              ______________            ________
|       |            |              |          |        |
| input |  demuxer   | encoded data |  muxer   | output |
| file  | ---------> | packets      | -------> | file   |
|_______|            |______________|          |________|

```
可以看到略过了decode和encode阶段



# Stream selection

-map：应该是用于控制哪个输入映射到哪个输出

-vn / -an / -sn / -dn分别使得视频、音频、字幕和数据流不输出


不采取-map时，自动采取什么样的流选择（从哪个输入映射到哪个输出称为流选择）

流包括视频、音频、字幕和数据（video, audio, subtitle and data streams）

没有-map时，默认采取以下措施：
检查输出格式是否包含video, audio，subtitles

选择视频中最高分辨率的视频
选择通道最多的音频
选择第一个字幕，并返回一个警告
参数相同时，选择索引最低的流
数据流不会被自动选择，需要使用-map指定


当-map被使用的时，输出文件就只包含-map指定的流。filtergraph outputs是个例外，

complex filtergraph output streams with unlabeled pads都会被添加到第一个输出文件中。 This will lead to a fatal error if the stream type is not supported by the output format. In the absence of the map option, the inclusion of these streams leads to the automatic stream selection of their types being skipped. If map options are present, these filtergraph streams are included in addition to the mapped streams.（看不懂）

Complex filtergraph output streams with labeled pads必须被map一次且只能一次


Stream handling独立于流选择，除了下面的字幕描述
Stream handling通过设置选项-codec实现`

stream selection之后，进行Stream handling

没有-codec选项，将使用the output file muxer的默认encoder



An exception exists for subtitles. If a subtitle encoder is specified for an output file, the first subtitle stream found of any type, text or image, will be included. ffmpeg does not validate if the specified encoder can convert the selected stream or if the converted stream is acceptable within the output format. This applies generally as well: when the user sets an encoder manually, the stream selection process cannot check if the encoded stream can be muxed into the output file. If it cannot, ffmpeg will abort and all output files will fail to be processed.（看不懂，为什么都没有实例说明，这他妈时官方文档吗？？？）



```bash
假设输入文件如下：
input file 'A.avi'
      stream 0: video 640x360
      stream 1: audio 2 channels

input file 'B.mp4'
      stream 0: video 1920x1080
      stream 1: audio 2 channels
      stream 2: subtitles (text)
      stream 3: audio 5.1 channels
      stream 4: subtitles (text)

input file 'C.mkv'
      stream 0: video 1280x720
      stream 1: audio 2 channels
      stream 2: subtitles (image)

命令：
ffmpeg -i A.avi -i B.mp4 out1.mkv out2.wav -map 1:a -c:a copy out3.mov

out1.mkv是Matroska container file，可以包含视频、音频和字幕文件。
    For video, it will select stream 0 from B.mp4, which has the highest resolution among all the input video streams.
    For audio, it will select stream 3 from B.mp4, since it has the greatest number of channels.
    For subtitles, it will select stream 2 from B.mp4, which is the first subtitle stream from among A.avi and B.mp4.

out2.wav：accepts only audio streams, so only stream 3 from B.mp4 is selected.
    
out3.mov
    -map 1:a   1代表选择第二个输入文件B.mp4;   a代表选择B.mp4中的所有音频文件。

out1.mkv和out2.wav使用了输出格式默认的编码器
out3.mov使用了copy到的编码器
```
]]></description></item><item><title>ffmpeg安装和基本使用</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/06/02/16339225.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Thu, 02 Jun 2022 14:36:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/06/02/16339225.html</guid><description><![CDATA[# 1.FFmpeg简介

# 1.1.FFMPEG下载编译与安装
直接参考这篇文章[ubuntu20源码编译安装ffmpeg](https://blog.csdn.net/H_Zhang/article/details/123684216)。


## 1.2.ffmpeg库文件的说明
libavformat：用于各种音视频封装格式的生成和解析

libavutil：libavutil库是一个工具库，以辅助多媒体编程。

libavcodec：libavcodec 库提供通用编码/解码框架，并包含用于音频，视频和字幕流的多个解码器和编码器，以及多个比特流滤波器。实现了市面上可见的绝大部分解码器的功能， libavcodec 库被其他各大解码器 ffdshow， Mplayer 等所包含或应用。

libavdevice：提供了一个通用框架，用于从许多常见的多媒体输入/输出设备抓取和渲染，并支持多个输入和输出设备，包括 Video4Linux2，VfW，DShow和ALSA，AUDIO_BEOS，JACK,OSS,1394。

libavresample：对音频进进行重采样

libavfilter：通用的音视频后处理库，亦即音频/视频过滤框架（FileIO、 FPS、 DrawText），提供了宽高比 裁剪 格式化 非格式化 伸缩，及噪音处理等处理操作。

libswresample：原始音频格式转码。执行高度优化的音频重采样，重新矩阵化和样本格式转换操作。该libswresample库进行高度优化的音频采样，rematrixing和采样格式转换操作。

libswscale：（原始视频格式转换） 用于视频场景比例缩放、色彩映射转换；图像颜色空间或格式转换，如 rgb565、rgb888 等与 yuv420 等之间转换。

上面对库文件进行了简单的介绍，具体可参考[ffmpeg自学路(三)ffmpeg各项库说明，及build.sh的shell相关命令说明](https://blog.csdn.net/u014436704/article/details/106763235)





## 1.3.工具集
ffmpeg：该项目提供的一个工具，可用于格式转换、解码或电视卡即时编码等。
ffsever：一个 HTTP 多媒体即时广播串流服务器。
ffplay：是一个简单的播放器，使用 ffmpeg 库解析和解码，通过 SDL 显示。
ffprobe：多媒体侦测   






# 2.FFmpeg处理音视频流程

那电影的实质就是N多张图片的集合。事实上，如果一部影片里面的图片，我们原封不动的全部存起来，空间会很大很大很大，但是如果通过一定的算法（这里不讲相关算 法），把每一张图片压缩（编码_encode）一下，变成帧。再把帧连起来变成流，再把不同的流放到某个容器里面，这就是我们平常看见的电影文件了。

FFmpeg处理音视频流程：
![](https://img2022.cnblogs.com/blog/1617829/202206/1617829-20220603140307930-929200316.png)

输入文件：如mp4、flv
编码数据包：从mp4中提取出来的音频和视频等数据
解码后的数据帧：编码数据包中数据都是压缩过的，所以需要进行解码。然后我们就可以对解码后的数据进行各种各样的处理。处理完之后，重新进行encoder和muxer。

实例：
- 720p视频转480p视频：首先将720p视频解码成数据帧，然后对数据帧进行处理，最后再封装成视频。故需要经过FFmpeg处理音视频的全部流程。
- mp4转flv：首先将mp4文件demuxer成编码数据包，然后直接将编码数据包muxer成flv文件。故不需要经过FFmpeg处理音视频的全部流程。从这个例子可以看出，我们不一定需要经过FFmpeg处理音视频的全部流程。

```
ffmpeg -i test_1920x1080.mp4 -acodec copy -vcodec libx264 -s 1280x720 test_1280x720.flv
```
上述命令在ffmpeg基本流程中：
![](https://img2022.cnblogs.com/blog/1617829/202206/1617829-20220609160604039-446838161.png)

libx264代表采用x264进行视频编码，
copy代表音频直接copy原来的，copy命令代表就没有经过decode和encode，只经历的demuxe和muxe






# 3.ffmpeg常用命令
ffmpeg常用命令可以分为八类：
- 基本信息查询命令
- 录制命令
- 分解/复用命令
- 处理原始数据命令
- 裁剪与合并命令
- 图片/视频互转命令
- 直播相关命令
- 各种滤镜命令




## 3.1.基本信息查询命令

![](https://img2022.cnblogs.com/blog/1617829/202206/1617829-20220609155138232-1447170069.png)

结合FFmpeg处理音视频流程来记上面的命令。
一些命令的补充解释：
-devices：查询系统中可用摄像头和音频设备
-bsfs：ffmpeg支持处理比特流的信息，此命令用于查询支持哪些比特流。
-protocols：ffmpeg支持处理网络文件，此命令用于查询支持哪些协议
-filters：比如加水印、去水印
-pix_fmts：查询可用哪些格式存储图片
-sample_fmts：使用多少位来存储一个采样，如8位、16位、 32位（浮点型）
-layouts：如双声道、单声道、立体声（三个声道以上称为立体声）



## 3.2.录制命令
ffmpeg命令结构：
```
ffmpeg [options] [[infile options] -i infile]... {[outfile options] outfile}...
```


录制屏幕：
```
ffmpeg -video_size 1920x1080 -framerate 25 -f x11grab -i :0.0+0,00 output.mp4
```
-f x11grab：使用桌面录制工具x11grab录制桌面
-video_size：指定分辨率，即将屏幕上的多大一块录制下来
-framerate 25：帧率25，即每秒展示25帧图像。
-i :0.0+0,00 ：-i是用来指定输入设备，带冒号的代表是音频设备（:0.0+0），没有冒号的代表是视频设备（00）。 【本段是我猜的】



## 3.3.分解与复用

分解与复用：不同视频格式的转换、音频和视频的分离，分离出来是mp3、H264等未解码的数据。

```
ffmpeg -i out.mp4 -vcodec copy -acodec copy out.flv
ffmpeg -i out.mp4 -vn -acodec copy out.aac  # 如果没有音频就会出现错误
ffmpeg -i out.mp4 -vcodec copy -an out.h264 # 如果没有视频就会出现错误
```
-vcodec copy：复制原来的视频数据
-acodec copy：复制原来的音频数据
-vn：不需要视频
-an：不需要音频




## 3.4.处理原始数据命令
处理原始数据命令：就是指处理PCM和YUV格式的数据
```
# FFmpeg提取YUV数据
ffmpeg -i input.mp4 -an -c:v rawvideo -pix_fmt yuv420p out.yuv
-c:v rawvideo  ： -c:v代表对视频进行编码；rawvideo代表原始视频
-pix_fmt：指定像素格式 
```
以上编码得到的是视频out.yuv根本无法通过ffplay播放，且ffplay根本没有-s选项
















# 其他
项目的目录：
首先利用git建立版本管理，然后创建以下四个目录：
src：源码
bin：可执行文件
lib：库文件
doc：说明文档










为什么我觉得拿git做版本管理很不好用？？？？]]></description></item><item><title>音视频基础知识</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/06/01/16335745.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Wed, 01 Jun 2022 13:16:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/06/01/16335745.html</guid><description><![CDATA[# 1.视频编码

## 1.1.音视频处理流程
1.封装：将音视频读出来并封装成相应的格式
2.解码：将压缩的数据恢复成原始数据
3.重采样：将视频和音频转换成显卡和声卡支持的形式
4.像素格式：视频需要做像素格式的转换

## 1.2.MPEG-4
MPEG-4是一套用于音频、视频信息的压缩编码标准
在MPEG-4标准的Part14中描述了MPEG-4格式，在MPEG-4标准的Part15中描述了AVC格式
MPEG-4使用H264作为压缩算法。


## 1.3.封装格式(也叫容器)

封装格式(也叫容器）就是将已经编码压缩好的视频流、音频流及字幕按照一定的方案放到一个文件中，便于播放软件播放。
一般来说，视频文件的后缀名就是它的封装格式。

封装的格式不一样，后缀名也就不一样。不同的封装格式，应用在不同的场景下，如mp4常用于本地存储，flv常用于网络传输。



常用封装格式:
AVI：压缩标准可任意选择。可以没有压缩，这样会导致文件很大。早期用的比较多。
FLV（直播等）、ts（电视）、ASF：流媒体格式
mp4

H264+AAC封装为FLV或MP4是最为流行的模式。

## 1.4.常用编码格式（压缩算法）
**视频：**
H264 、wmv、XviD：分析前后帧进行运动补偿，从而实现视频的压缩。拖动使用这种压缩方法的视频的进度条的时候，如果停到非关键帧的地方可能会播放失败【我们平常拖动没出问题，是因为播放器已经对这个问题进行了处理。如果我们自己设计播放器的时候，一定要注意这个问题】。
mjpeg：每一帧都是独立的，压缩率比较低。常在摄像机中看到。

**音频：**
acc、MP3、ape、flac、PCM：现在视频中的音频主要使用acc进行编码。acc和MP3是有损压缩，ape和flac是无损压缩，所以ape和flac编码的音频声音质量比较好。PCM是原始音频


因为音频相对视频会比较小，所以音频可以不压缩，但视频一般都需要进行压缩。

常用视频压缩算法：
```
MPEG2	MPEG阵营
H264		MPEG阵营
H265		MPEG阵营
AVS   		中国阵营
VP8    	Google阵营
VP9    	Google阵营
```




## 1.5.封装结构
每一个视频都采取下面这种封装的结构。

![](https://img2022.cnblogs.com/blog/1617829/202206/1617829-20220601203750503-1661202360.png)

不同的封装格式决定了视频帧和音频帧的编码方式。

封装格式(格式头)：mp4、FLV、AVI等。比如mp4中使用box来保存音视频信息(编码和格式、关键帧索引)。FFmpeg可以解码没有格式头的视频文件，FFmpeg会自动进行探测，使用什么方式可解析出帧，就用什么方式。

视频编码帧：视频编码帧中包含压缩的方式，我们可以根据压缩方式进行解码，比如H264一般解码成YUV格式【Y表示灰度（亮度），UV表示色度。黑白电视只传输Y就可以】。我们在将H264转换成YUV格式之后是没有办法显示的，需要将YUV格式的图像转换成RGB才能显示。经过H264——>YUV——>RBG以后得到的图片会比较大。

音频编码帧：这里以aac解码进行说明。
aac解码之后，变成了PCM FLT格式。PCM代表原始音频，FLT代表音频使用float进行保存，使用float保存音频是为了方便编码和解码时候做浮点运算。由于float是四个字节，32位，而一般显卡不支持32位浮点运算（除非显卡超级好），所以需要将PCM FLT格式的音频继续进行转换，转为声卡支持的S16播放（即转成16位）。

视频编码帧解码的开销比音频编码帧解码的开销多很多，以至于音频编码帧解码的开销可以忽略不记。




# 2.图像和音频的存储方式
## 2.1.图像的存储方式
### 2.1.1.RGB与YUV
视频显示的帧都是压缩过的，所以要将帧抽取出来进行显示，就要将帧进行解压。解压出来的图像会比视频中的帧大很多。解压出来的图像可以是下面几种像素格式：RBG、YUV、RGBA。
RGBA：这里的A是透明通道，A我们一般用不到，但是用显卡显示图片的时候，经常要求传入RGBA。
YUV：Y表示灰度（亮度），UV表示色度。我们视频压缩算法都是在YUV图像上进行的。同样存储一个像素点，YUV需要的空间相比RBG更小。

**RBG与YUV的互相转换**
```
// RBG转YUV：
Y = 0.298R + 0.612G + 0.117B;
 
U = -0.168R - 0.330G + 0.498B + 128;
 
V = 0.449R - 0.435G - 0.083B + 128;

// YUV转RBG：
R = Y + 1.4075( V - 128);
 
G = Y - 0.3455( U - 128) - 0.7169( V - 128);
 
B = Y + 1.779( U - 128);
```
libyuv，Google开源的实现各种YUV与RGB间相互转换、旋转、缩放的库。



**3X3RGB图像在内存中的存放方式(连续)：**

![](https://img2022.cnblogs.com/blog/1617829/202206/1617829-20220602095921853-1230503651.png)

注意：为了运算效率，图像的存储可能会采取某些对齐策略。



### 2.1.2.YUV

![](https://img2022.cnblogs.com/blog/1617829/202206/1617829-20220602101703579-1666909601.png)

其中空心圆表示UV（UV是成对出现的），实心圆表示Y。
YUV444：每一个Y都对应一个UV。
YUV422：从图中可以看到YUV和Y间隔出现，这表示每两个亮度共用一个色度。
YUV420：四个Y共用一个UV，这四个Y是上下相邻的四个像素。最常使用的就是YUV420.
YUV420p：这里p是平面的意思，代表Y和UV是分开存放的，比如Y放在一个数组，UV放在一个数组。

YUV格式：有两大类：planar和packed。
- 对于planar的YUV格式，先连续存储所有像素点的Y，紧接着存储所有像素点的U，随后是所有像素点的V。YUV420p属于planar。
- 对于packed的YUV格式，每个像素点的Y,U,V是连续交叉存储的。YUV444、YUV422、YUV420都是属于packed。

![](https://img2022.cnblogs.com/blog/1617829/202206/1617829-20220608144832643-1135271834.png)

除了上面两个大类外，YUV存在多种格式，比如YUV420sp等，不同的YUV格式的数据在存储时的排列顺序是不一样的，在开发的过程中必须非常注意，否则画面会显示不正常。比如花屏，绿屏等现象。

更多介绍请点击:
https://blog.51cto.com/u_7335580/2059670
https://blog.51cto.com/cto521/1944224
https://blog.csdn.net/mandagod/article/details/78605586

计算一张的RGB_888图像的大小，可采用如下方式： 1280×720 * 3 = 2.637 MB，4分钟就达到了15G的容量。 假如是一部90分钟的电影，每秒25帧，则一部电影为 2.637MB90分钟60秒*25FPS= 347.651GB

相较于RGB，我们可以计算一帧为1280×720的视频帧，用YUV420P的格式来表示，其数据量的大小如下：每个像素点需要1.5个YUV来表示，故 1280 * 720 * 1 ＋ 1280 * 720 * 0.5 = 1.318MB 。
如果fps（1秒的视频帧数目）是25，按照一般电影的长度90分钟来计算，那么这部电影用YUV420P的数据格式来表示的话，其数据量的大小就是： 1.318MB * 25fps * 90min * 60s = 173.76GB

故直接将图片存储成视频，那么这样的视频将会是很大，所以一般会按照一定的规则进行压缩。



## 2.2.音频的存储方式

**PCM音频参数：**
- 采样率sample_ rate：采样率越高，采到的数据越多，声音越真实。CD的采样率为44100，一秒采44100次。 
- 通道channels：如左右声道。CD的采样率为44100，两个声道总的采样率为88200
- 样本大小sample_size(采样格式)：一个声音用多少位的格式来存储，有如下两个方式
AV_SAMPLE_FMT_S16：16位
AV_SAMPLE_FMT_FLTP：32位，一般声卡无法播放32位声音需要转换为16位的声音，即进行重采样处理。

AV_SAMPLE_FMT_S16P：这里p是平面的意思，如在双声道中，将两个声道的数据是分开存放的，一个声道存放在一个数组中。




# 3.MP4标准和h264格式的NAL的GOP分析

## 3.1. MP4格式分析
![](https://img2022.cnblogs.com/blog/1617829/202206/1617829-20220602111400350-1703691725.png)



## 3.2. H.264/AVC视频编码标准
**H.264/AVC视频编码标准包括两层：**  
网络抽象层面(NAL)：格式化数据并提供头信息
视频编码层面(VCL)：视频数据的内容


**NAL单元：**
因此我们平时的每帧数据就是一个NAL单元(SPS与PPS除外【SPS与PPS为参数数据，比如分辨率等】)。在实际的H264数据帧中，往往帧前面带有00 00 00 01或0000 01分隔符, 用分隔符来识别数据的开始和结束。一般来说编码器编出的首帧数据为PPS与SPS，接着为I帧。

**GOP**：GOP是一组帧，可以解码出来播放的一组帧。这组帧必然含有关键帧（I帧）。有关键帧似乎才能解码出视频图像，下面是一个GOP：

![](https://img2022.cnblogs.com/blog/1617829/202206/1617829-20220602142138611-1983326405.png)

**I帧**
I帧称为关键帧，B帧和P帧依赖I帧解码出图像。I帧存储着完整的数据，可以单独解码出来完整的图像。
- I帧图像采用帧内编码方式;
- I帧所占数据的信息量比较大;
- I帧图像是周期性出现在图像序列中的，出现频率可由编码器选择;
- I帧是P帧和B帧的参考帧(其质量直接影响到同组中以后各帧的质量);
- I帧是帧组GOP的基础帧(第一帧),在一组中只有一个I帧，且在GOP中处于第一帧
- I帧不需要考虑运动矢量;

**P帧**
P帧根据本帧与前一帧（I帧或P帧）的不同点来压缩本帧数据，同时利用了空间和时间上的相关性。这里的“前一帧”必须是I帧或P帧，如果P帧的前一帧是B帧，则往前找，直到找到I帧或P帧。


**B帧**
B帧参考前一帧和后一帧解码出图像。故GOP的第一个图像必须为I帧，这样就能保证GOP不需要参考其他图像，可以独立解码。如果关键帧丢失，那么关键帧后面的B和P帧将无法正确解码。

播放到B帧时，由于B帧参考前一帧和后一帧解码出图像，所以解码B帧时，不能立刻进行播放，而是将此B帧缓存，在此B帧的下一帧解码成功后，再回过来处理，才能正确地显示此B帧。 









# 4.一些概念
## 4.1.音视频概念

视频码率：kb/s，是指视频文件在单位时间内使用的数据流量，也叫码流率。码率越大，说明单位时间内取样率越大，数据流精度就越高。比如一秒25帧且存储每帧使用了A kb的存储空间，那么视频码率就是25A kb/s，也称25A kbps【ps指的是/s】

视频帧率：fps，通常说一个视频的25帧，指的就是这个视频帧率，即1秒中会显示25帧。帧率越高，给人的视觉就越流畅。

视频分辨率：分辨率就是我们常说的640x480分辨率、1920x1080分辨率，分辨率影响视频图像的大小。


## 4.2.物理概念

声音是由物体的振动产生的，而振动是一个一上一下的过程，那么如何使用数学的方式描述这样一个一上一下的过程？
答：就是通过下面这种曲线表示。一上一下的过程称为一个周期，曲线的高度表示声音的大小，一个周期宽度代表声音的快慢。

![](https://img2022.cnblogs.com/blog/1617829/202206/1617829-20220608151646968-723517335.png)

声音的频率是周期的倒数，它表示的是声音在1秒钟内的周期数，单位是赫兹(Hz)。千赫(kHz),即1000Hz,表示每秒振动1000次。声音按频率可作如下划分:
次声		              	0～20Hz
 人耳能听见的声音 	20Hz～20KHz
 超声					20KHz～1GHz
 特超声					1GHz～10THz 

为什么人听不到次生和超声呢？
答：听不到次声是因为“动的很慢的物体，我们会感觉它没动”。
听不到超声是因为“动的很快的物体，我们也会感觉它没动”。【这是我自己的理解】

## 4.3.数字音频
### 4.3.1.采样频率

PCM脉冲编码调制：PCM(Pulse Code Modulation)，脉冲编码调制。人耳听到的是模拟信号，PCM是把声音从模拟信号转化为数字信号的技术。简单来说，就是不把左图全部存储下来，而是将存储某几个时间点的振幅。
![](https://img2022.cnblogs.com/blog/1617829/202206/1617829-20220608153002736-185713846.png)

根据Nyguist采样定律，要从采样中完全恢复原始信号波形，采样频率必须至少是信号中最高频率的两倍。就是说平均每个周期要采样至少两次。

前面提到人耳能听到的频率范围是[20H~20kHz]，所以采样频率一般为44.1Khz，这样就能保证声音到达20Khz也能被数字化，从而使得经过数字化处理之后，人耳听到的声音质量不会被降低。


### 4.3.2.采样量化

采样量化（采样精度），就是指一个时间点的振幅用几个bit表示，例如8位量化可以表示256个不同值，而CD质量的16位量化可以表示65536个值。

我们可以直观地将振幅理解为声音的大小，如果用比较多的bit表示一个振幅，那么我们可以听到的声音就越丰富。这就像平时我们调节声音大小一样，如果只有那么几个声音可以调整，那么声音就会不丰富。

```
采样频率：每秒钟采样的点的个数。常用的采样频率有：
22000（22kHz）：	无线广播。
44100（44.1kHz）：CD音质。
48000（48kHz）：	数字电视，DVD。
96000（96kHz）：	蓝光，高清DVD。
192000(192kHz):	蓝光，高清DVD。

采样精度（采样深度）：每个“样本点”的大小，
		常用的大小为8bit， 16bit，24bit。

通道数：单声道，双声道，四声道，5.1声道。

```
### 4.3.3.音频里的其他名词
**比特率**：每秒传输的bit数，单位为：bps（Bit Per Second）
没有压缩的音频数据的比特率 = 采样频率 * 采样精度 * 通道数。
通道数:个人理解,就是同时有个几个设备在进行音频的采样,这样对上面的公式更好理解,最少为1,一般通道数越多,音质越好。

**码率：** 压缩后的音频数据的比特率。常见的码率：
96kbps：FM质量
128-160kbps：一般质量音频。
192kbps：CD质量。
256-320Kbps：高质量音频
	
码率越大，压缩效率越低，音质越好，压缩后数据越大。
码率 = 音频文件大小/时长。

**帧**：每次编码的采样单元数，比如MP3通常是1152个采样点作为一个编码单元，AAC通常是1024个采样点作为一个编码单元。

**帧长：**
- 可以指每帧播放持续的时间：每帧持续时间(秒) = 每帧采样点数 / 采样频率（HZ）
	比如：MP3 48k, 1152个采样点,每帧则为 24毫秒
		1152/48000= 0.024 秒 = 24毫秒；
- 也可以指压缩后每帧的数据大小

**非交错模式：**首先记录的是一个周期内所有帧的左声道样本，再记录所有右声道样本
**交错模式：**数字音频信号存储的方式。数据以连续帧的方式存放，即首先记录**帧**1的左声道样本和右声道样本，再开始帧2的记录...










# 5.音视频录制\播放原理
![](https://img2022.cnblogs.com/blog/1617829/202206/1617829-20220608162404514-1517427702.png)



# 6.音频编码原理简介
数字音频压缩编码在保证信号在听觉方面不产生失真的前提下，对音频数据信号进行尽可能大的压缩，降低数据量。数字音频压缩编码采取去除声音信号中冗余成分的方法来实现。所谓冗余成分指的是音频中不能被人耳感知到的信号，它们对确定声音的音色，音调等信息没有任何的帮助。冗余信息：
- 冗余信号包含人耳听觉范围外的音频信号以及被掩蔽掉的音频信号等。例如，人耳所能察觉的声音信号的频率范围为20Hz～20KHz，除此之外的其它频率人耳无法察觉，都可视为冗余信号。
- 此外，根据人耳听觉的生理和心理声学现象，当一个强音信号与一个弱音信号同时存在时，弱音信号将被强音信号所掩蔽而听不见，这样弱音信号就可以视为冗余信号而不用传送。这就是人耳听觉的掩蔽效应，主要表现在**频谱掩蔽效应**和**时域掩蔽效应**。


## 6.1.频谱掩蔽效应

![](https://img2022.cnblogs.com/blog/1617829/202206/1617829-20220608185339344-561360745.png)

上图中的阈值线表示在这条线以下的声音，人是听不到的。当有另外能量较大的声音出现的时候，该声音频率附近的阈值会提高很多，即所谓的掩蔽效应。如上图，虚线代表阈值，当能量较大的声音在0.2kHz附近出现（黑色柱子）时，该声音频率附近的阈值会提高很多（虚线中凸起的实线部分）。

由图中我们可以看出人耳对2KHz～5KHz的声音最敏感，而对频率太低或太高的声音信号都很迟钝，当有一个频率为0.2KHz、强度为60dB的声音出现时，其附近的阈值提高了很多。由图中我们可以看出在0.1KHz以下、1KHz以上的部分,由于离0.2KHz强信号较远，不受0.2KHz强信号影响,阈值不受影响；而在0.1KHz～1KHz范围，由于0.2KHz强音的出现,阈值有较大的提升，人耳在此范围所能感觉到的最小声音强度大幅提升。如果0.1KHz～1KHz范围内的声音信号的强度在被提升的阈值曲线之下，由于它被0.2KHz强音信号所掩蔽，那么此时我们人耳只能听到0.2KHz的强音信号而根本听不见其它弱信号，这些与0.2KHz强音信号同时存在的弱音信号就可视为冗余信号而不必传送。






## 6.2.时域掩蔽效应

![](https://img2022.cnblogs.com/blog/1617829/202206/1617829-20220608190918846-775982788.png)

当强音信号和弱音信号同时出现时，还存在时域掩蔽效应。即两者发生时间很接近的时候，也会发生掩蔽效应。时域掩蔽过程曲线如图所示，分为前掩蔽、同时掩蔽和后掩蔽三部分。

时域掩蔽效应可以分成三种：前掩蔽，同时掩蔽，后掩蔽。前掩蔽是指人耳在听到强信号之前的短暂时间内，已经存在的弱信号会被掩蔽而听不到。同时掩蔽是指当强信号与弱信号同时存在时，弱信号会被强信号所掩蔽而听不到。后掩蔽是指当强信号消失后，需经过较长的一段时间才能重新听见弱信号，称为后掩蔽。这些被掩蔽的弱信号即可视为冗余信号。


## 6.3.音频编解码器选型
OPUS
MP3
AAC
AC3和EAC3 杜比公司的方案 
[详解音频编解码的原理、演进和应用选型等](https://www.jianshu.com/p/6b4c481f4294)

# 7.音视频同步
DTS（Decoding Time Stamp）：即解码时间戳，这个时间戳的意义在于告诉播放器该在什么时候解码这一帧的数据。
PTS（Presentation Time Stamp）：即显示时间戳，这个时间戳用来告诉播放器该在什么时候显示这一帧的数据。  

**音视频同步方式：**
Audio Master：视频跟随音频的播放速度
Video Master：音频跟随视频的播放速度
External Clock Master：音频和视频都跟随外部时钟
  
音视频同步方式：Audio Master > External Clock Master > Video Master，即优先选择Audio Master方式进行音视频同步。 
]]></description></item><item><title>ubuntu遇到 Err:1 http://cn.archive.ubuntu.com/ubuntu bionic InRelease 报错解决</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/05/29/16324800.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Sun, 29 May 2022 12:26:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/05/29/16324800.html</guid><description><![CDATA[```
# 检查ubuntu的版本，这一步很重要，不同版本的ubuntu使用的更新内容有差别.
cat /etc/issue
 Ubuntu 16.04.5 LTS \n \l
sudo cp /etc/apt/sources.list  /etc/apt/sources.list_save

# 换源
sudo vim /etc/apt/sources.list
# 根据Ubuntu版本，将源文件里的内容全部替换为如下内容：
```
16.04 LTS

```
# 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释
deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial main restricted universe multiverse
# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial main restricted universe multiverse
deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-updates main restricted universe multiverse
# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-updates main restricted universe multiverse
deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-backports main restricted universe multiverse
# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-backports main restricted universe multiverse
deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-security main restricted universe multiverse
# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-security main restricted universe multiverse
# 预发布软件源，不建议启用
# deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-proposed main restricted universe multiverse
# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-proposed main restricted universe multiverse
```
18.04 LTS

```
# 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释
deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse
# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse
deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse
# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse
deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse
# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse
deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse
# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse

# 预发布软件源，不建议启用
# deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse
# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse
```



20.04 LTS

```
# 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释
deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiverse
# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiverse
deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted universe multiverse
# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted universe multiverse
deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-backports main restricted universe multiverse
# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-backports main restricted universe multiverse
deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security main restricted universe multiverse
# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security main restricted universe multiverse

# 预发布软件源，不建议启用
# deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-proposed main restricted universe multiverse
# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-proposed main restricted universe multiverse
```

21.04 LTS

```
# 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释
deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ hirsute main restricted universe multiverse
# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ hirsute main restricted universe multiverse
deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ hirsute-updates main restricted universe multiverse
# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ hirsute-updates main restricted universe multiverse
deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ hirsute-backports main restricted universe multiverse
# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ hirsute-backports main restricted universe multiverse
deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ hirsute-security main restricted universe multiverse
# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ hirsute-security main restricted universe multiverse

# 预发布软件源，不建议启用
# deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ hirsute-proposed main restricted universe multiverse
# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ hirsute-proposed main restricted universe multiverse
```

21.10 LTS
```
# 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释
deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ impish main restricted universe multiverse
# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ impish main restricted universe multiverse
deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ impish-updates main restricted universe multiverse
# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ impish-updates main restricted universe multiverse
deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ impish-backports main restricted universe multiverse
# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ impish-backports main restricted universe multiverse
deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ impish-security main restricted universe multiverse
# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ impish-security main restricted universe multiverse

# 预发布软件源，不建议启用
# deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ impish-proposed main restricted universe multiverse
# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ impish-proposed main restricted universe multiverse
```

参考：[链接](https://blog.csdn.net/wlc_1111/article/details/124528341)
[链接2](https://blog.csdn.net/PAN_Andy/article/details/105053890)
]]></description></item><item><title>C++中的#和##</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/05/28/16321773.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Sat, 28 May 2022 12:03:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/05/28/16321773.html</guid><description><![CDATA[\#\#组合出来的字符串代表一个标识符
\#组合出来的字符串就是一个字符串
```
#include <iostream>
#define t(x) hello##x//合并操作符##将出现在其左右的字符序列合并成一个新的标识符 
#define s(y) #y//将传入的参数变为字符串，字符串化

using namespace std;

int main()
{
	int hello1 = 10;
	cout << t(1) << endl;//将hello和1链接形成hello1,hello1是一个变量。输出：10
	cout << s(hello) << endl;//将hello变为字符串。输出：hello
	return 0;
}
```
[参考链接](https://blog.csdn.net/zhang_chou_chou/article/details/80737339)]]></description></item><item><title> multipart/form-data的HTTP消息文本</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/05/28/16321759.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Sat, 28 May 2022 11:53:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/05/28/16321759.html</guid><description><![CDATA[下面是通过post方式发送的请求：
```
POST http://www.example.com HTTP/1.1
Content-Type:multipart/form-data; boundary=----WebKitFormBoundaryyb1zYhTI38xpQxBK

------WebKitFormBoundaryyb1zYhTI38xpQxBK
Content-Disposition: form-data; name="city_id"

111111
------WebKitFormBoundaryyb1zYhTI38xpQxBK
Content-Disposition: form-data; name="company_id"

222222
------WebKitFormBoundaryyb1zYhTI38xpQxBK
Content-Disposition: form-data; name="file"; filename="chrome.png"
Content-Type: image/png

PNG ... content of chrome.png ...
```
第一行是请求行，指明了方法、URI 和 HTTP 版本号；
第二行是消息头（简单起见，只有一个 Content-Type)；
然后空出一行；
接下来就是消息体。可以看到使用 multipart/form-data 时，消息体通过 boundary 来分隔多个字段，被分隔的每个字段都有自己的小头部和小消息体，且也用空行分隔。






参考：[multipart/form-data的HTTP消息文本](https://www.jianshu.com/p/8251fff48a59)]]></description></item><item><title>linux下源码编译安装的一般步骤：安装编译、动态库和环境变量配置</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/05/28/16321101.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Sat, 28 May 2022 08:55:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/05/28/16321101.html</guid><description><![CDATA[# 1.安装

(./configure）–＞ 编译（sudo make） –＞ 安装（sudo make install）。

1.配置：这是编译源代码的第一步，通过 ./configure 命令完成（图形化可以用cmake-gui来配置）。执行此步以便为编译源代码作准备。常用的选项有 --prefix=PREFIX，用以指定程序的安装位置。更多的选项可通过 --help 查询。也有某些程序无需执行此步。
2.编译：一旦配置通过，可即刻使用 make 指令来执行源代码的编译过程。视软件的具体情况而定，编译所需的时间也各有差异，我们所要做的就是耐心等候和静观其变。此步虽然仅下简单的指令，但有时候所遇到的问题却十分复杂。较常碰到的情形是程序编译到中途却无法圆满结束。此时，需要根据出错提示分析以便找到应对之策。
3.安装：如果编译没有问题，那么执行 sudo make install 就可以将程序安装到系统中了。

例子：
```
//0.有时候需要先安装依赖库
//1.解压缩
tar -zxf nagios-4.0.2.tar.gz  
//2.进入目录
cd nagios-4.0.2
//3.配置
./configure --prefix=/usr/local/nagios     
//4.编译
make -j4
//5.安装
make install
```
参考：[链接](https://blog.csdn.net/qq_38455499/article/details/118465821)

# 2.配置
## 2.1.动态库配置
使用--prefix指定安装目录后，运行所需的动态库也会被安装在这个目录下。当程序运行时，linux系统不会去这个目录下查找动态库，那么程序就会由于缺少动态库而无法运行，一般会出现如下错误：error while loading shared libraries。
为了让linux系统找到动态库所在路径，必须做如下操作：
```
在/etc/ld.so.conf中添加动态库所在路径，或在/etc/ld.so.conf.d目录下建立xxxx.conf，然后再在xxxx.conf中添加动态库所在路径【xxxx随便什么都可以】
命令行输入：sudo /sbin/ldconfig
```

参考[链接](https://www.cnblogs.com/codingbigdog/p/16320965.html)

## 2.2.环境变量配置
在ubuntu系统中，经常会遇到修改环境变量的需要，修改的方式有三种，区别在于生效的范围：当前终端、当前用户、所有用户
- 1.在命令行窗口内执行如下命令export PATH=$PATH:<你的要加入的路径>，只对当前终端有效，执行命令后立即生效

- 2.在~目录下修改.bashrc 隐藏文件，添加如下语句 export PATH=<你要加入的路径1>:<你要加入的路径2>: ...... :$PATH，只对当前用户有效，需要重新打开命令行窗口生效。下面是一个实例：
```
sudo vim ~/.bashrc

# 在文件末尾添加两行
export PATH=$PATH:/home/lorien/work/media/ffmpeg/install/bin
export LD_LIBRARY_PATH=/home/lorien/work/media/ffmpeg/install/lib

source ~/.bashrc
```
- 3.在~目录下还有一个.profile隐藏文件，和.bashrc类似，但是该文件在用户登录时候被读取执行，所以需要重启生效。

- 4.在/etc目录下修改profile文件，添加如下语句export PATH=<你要加入的路径>:$PATH，对所有用户有效，需要重启或者执行source /etc/profile命令使得立即生效

下面是一个实例：
```
# 加入全局环境变量路径：
dxb@dxb-virtual-machine:~$ sudo vi /etc/profile
在文件中加入以下内容:
export PATH="/usr/local/ffmpeg/bin:$PATH"  
# PATH="/usr/local/ffmpeg/bin:$PATH"表示在$PATH前添加"/usr/local/ffmpeg/bin:"，然后将整体返回给$PATH

然后保存并运行source /etc/profile
每个新开的终端都需要输入source /etc/profile以后，才能直接运行软件。

重启以后，新开的终端不用运行source /etc/profile，就可以直接运行软件。
```

参考：[链接](https://blog.csdn.net/weixin_40571066/article/details/123257988)
]]></description></item><item><title>linux Ｃ\C++动态库（共享库）编译和运行时的链接</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/05/28/16320965.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Sat, 28 May 2022 08:26:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/05/28/16320965.html</guid><description><![CDATA[#　0.C\C++动态库（共享库）编译和运行时的链接简介

库文件在编译（静态库和共享库）和运行（仅限于使用共享库的程序）时被使用，在使用之前肯定需要在一些搜索路径下查找库文件，看库文件是否存在，搜索路径是在系统中进行设置的。一般Linux系统把/lib和/usr/lib这两个目录作为默认的库搜索路径，所以使用这两个目录中的库时不需要进行设置搜索路径即可直接使用。对于处于默认库搜索路径之外的库，需要将库的位置添加到库的搜索路径之中。

**搜索路径分为两种，分别为编译时搜索路径和运行时搜索路径。**
- 添加编译时搜索路径的方式：pkg-config和LIBRARY_PATH。LIBRARY_PATH只用添加编译时的搜索路径，pkg-config可以用于添加编译时的搜索路径和头文件所在路径。程序的编译阶段，还可以通过-L参数添加编译时的搜索路径。

- 添加运行时搜索路径的方式：LD_LIBRARY_PATH和ldconfig。还可以通过-Wl,-rpath参数添加运行时的搜索路径。

-L和-Wl,-rpath设置的路径将被优先搜索。

&nbsp;

**下面是对编译时库的查找与运行时库的查找做一个简单的比较：**

1）编译时查找的是静态库或动态库， 而运行时，查找的是动态库；

2）编译时可以用-L、pkg-config、LIBRARY_PATH指定查找路径， 而运行时可以用-Wl,rpath、修改/etc/ld.so.conf、LD_LIBRARY_PATH指定查找路径

3）编译时用的链接器是ld，而运行时用的链接器是/lib/ld-linux.so.2

4）编译时与运行时都会查找默认路径/lib、/usr/lib

5）编译时还有一个默认路径/usr/local/lib，而运行时不会默认查找该路径；

说明： -Wl,rpath选项虽然是在编译时传递的，但是其实是工作在运行时。其本身其实也不算是gcc的一个选项，而是ld的选项，gcc只不过是一个包装器而已。我们可以执行man ld来进一步了解相关信息


下面介绍一下这几种链接方式。













# 1./etc/ld.so.conf和ldconfig

在/etc/ld.so.conf文件中添加库的搜索路径，将库文件的绝对路径直接写进/etc/ld.so.conf文件中就OK了，一行一个。比如：
```
/usr/X11R6/lib
/usr/local/lib
/opt/lib
```
我们也可以在/etc/ld.so.conf.d目录下建立xxxx.conf，然后再在xxxx.conf中添加以上内容。可以这样做的原因是：/etc/ld.so.conf文件中通过“include /etc/ld.so.conf.d/*.conf”包含了目录ld.so.conf.d下的所有.conf文件。

在/etc/ld.so.conf添加路径以后，需要使用/sbin/ldconfig更新一下，才会生效。原因如下：为了加快程序执行时对共享库的定位速度，避免使用搜索路径查找共享库的低效率，所以是直接读取库列表文件/etc/ld.so.cache的方式从中进行搜索。/etc/ld.so.cache是一个非文本的数据文件，不能直接编辑，需要使用/sbin/ldconfig命令更新/etc/ld.so.cache（ldconfig命令要以root权限执行）。


# 2.LD_LIBRARY_PATH

修改/etc/ld.so.conf文件的方式需要 root 权限，以改变 /etc/ld.so.conf 文件并执行 /sbin/ldconfig 命令。而且，当系统重新启动后，所有的基于 GTK2 的程序在运行时都将使用新安装的 GTK+ 库。不幸的是，由于 GTK+ 版本的改变，这有时会给应用程序带来兼容性的问题，造成某些程序运行不正常。为了避免出现上面的这些情况，在 GTK+ 及其依赖库的安装过程中对于库的搜索路径的设置将采用修改LD_LIBRARY_PATH的方式进行。这种设置方式不需要 root 权限，设置也简单：
```
export LD_LIBRARY_PATH=/opt/gtk/lib:$LD_LIBRARY_PATH
```
上述命令设置了/opt/gtk/lib为程序运行时的搜索路径。

LIBRARY_PATH和LD_LIBRARY_PATH差不多，LIBRARY_PATH的设置命令如下：
```
export LIBRARY_PATH=/opt/gtk/lib:$LIBRARY_PATH
```
上述命令设置了/opt/gtk/lib为程序编译时的搜索路径。


#3.Linux中pkg-config
请直接参考：[链接](https://blog.csdn.net/newchenxf/article/details/51750239)，下面做简要的总结：

在源代码**编译**时，pkg-config可用于查询某个库文件所依赖的头文件和库文件所在位置。为了让pkg-config可以得到一个库的信息，就要求库的提供者提供一个.pc文件。如：
``` 
gcc -o test test.c pkg-config --libs --cflags opencv.0 #　--cflags一般用于指定头文件，--libs一般用于指定库文件。
```
上述命令执行时，pkg-config默认会到/usr/lib/pkconfig/目录下去寻找opencv.pc文件。然而假如我们安装了一个库，其生成的.pc文件并不在这个默认目录中的话，pkg-config就找不到了。此时我们需要通过PKG_CONFIG_PATH环境变量来指定pkg-config去哪些地方去寻找.pc文件。我们可以通过如下命令来设置PKG_CONFIG_PATH环境变量：
```
export PKG_CONFIG_PATH=$PKG_CONFIG_PATH:/usr/local/lib/pkgconfig/
```
这样pkg-config就会在/usr/local/lib/pkgconfig/目录下寻找.pc文件了。
另外还需要注意的是,上述环境变量的设置只对当前的终端窗口有效。为了让其永久生效，我们可以将上述命令写入/etc/.bashrc或者/home/chenxf/.bashrc的文件末尾。





# 4. -L和-Wl,rpath，以及实战
-Wl,-rpath选项的作用就是指定程序运行时的库搜索目录，是一个链接选项，生效于设置的环境变量之前(LD_LIBRARY_PATH)。下面我们通过一个例子来说明：
项目的结构：
```
├── add.c
├── add.h
└── main.c
```
```
// add.h
int add(int i, int j);
 
// add.c
#include "add.h"
 
int add(int i, int j)
{
	return i + j;
}
 
// main.c
#include <stdio.h>
#include <stdlib.h>
#include "add.h"
 
int main(int argc, char *argv[]) 
{
	printf("1 + 2 = %d\n", add(1, 2));
	return 0;
}
```
add.h和add.c用于生成一个so库，实现了一个简单的加法，main.c中引用共享库计算1 + 2。
编译：
```
# 编译共享库
gcc add.c -fPIC -shared -o libadd.so  # -fPIC：生成位置无关目标代码，适用于动态连接；
                                      # -shared：生成一个共享库文件；
# 编译主程序
gcc main.c -ladd -o app      # ladd相当于libadd.so的简写
/usr/bin/ld: cannot find -ladd
collect2: error: ld returned 1 exit status
```
可以看到编译时无法找到库libadd.so，此时可以通过设置pkg-config、LIBRARY_PATH和-L的方式添加编译时的搜索路径（任选一种）:
-L方式：
```
gcc main.c -L . -ladd -o app  # "-L ."代表编译阶段在当前目录下查找库
```
LIBRARY_PATH方式：
```
export  LIBRARY_PATH=/home/server/projects/test/test4:$LIBRARY_PATH
gcc main.c  -ladd -o app
```
/home/server/projects/test/test4请替换成自己的libadd.so所在目录

pkg-config方式【感觉比较麻烦，有时间再来写】

编译好后运行程序：
```
./app
输出：
./app: error while loading shared libraries: libadd.so: cannot open shared object file: No such file or directory

ldd app   # ldd用于查看app依赖的库文件
        linux-vdso.so.1 (0x00007fffb1751000)
        libadd.so => not found
        libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f1f2d5ed000)
        /lib64/ld-linux-x86-64.so.2 (0x00007f1f2d7f5000)
```
可以看到， libadd.so这个库没有找到。这是因为我们上面只添加了编译时库文件的搜索路径，并没有添加运行时的搜索路径，添加运行时的搜索路径的方式有LD_LIBRARY_PATH、ldconfig和-Wl,-rpath（任选一种）：
-Wl,-rpath方式：
```
gcc -Wl,-rpath=`pwd` main.c -L. -ladd -o app # pwd代表当前路径
                                             # "-L ."代表链接阶段在当前目录下查找库
                                             # -Wl,-rpath代表运行时，在哪里找库。
./app
输出：
1 + 2 = 3
```
LD_LIBRARY_PATH方式：
```
export LD_LIBRARY_PATH=/home/server/projects/test/test4:$LD_LIBRARY_PATH
./app
输出：
1 + 2 = 3
```
/home/server/projects/test/test4请替换成自己的libadd.so所在目录

ldconfig方式：
```
sudo vim /etc/ld.so.conf  # 在/etc/ld.so.conf中添加目录/home/server/projects/test/test4
sudo /sbin/ldconfig
```
/home/server/projects/test/test4请替换成自己的libadd.so所在目录








# 5.运行时搜索路径的搜索顺序
Linux程序在运行时对动态链接库的搜索顺序如下：

1） 在编译目标代码时所传递的动态库搜索路径（注意，这里指的是通过-Wl,rpath=<path1>:<path2>选项传递的运行时动态库搜索路径，而不是通过-L选项传递的编译时的搜索路径）

例如：
```
gcc -Wl,-rpath,/home/arc/test,-rpath,/lib/,-rpath,/usr/lib/,-rpath,/usr/local/lib test.c
或者
gcc -Wl,-rpath=/home/arc/test:/lib/:/usr/lib/:/usr/local/lib test.c
```

2） 环境变量LD_LIBRARY_PATH指定的动态库搜索路径；

3） 配置文件/etc/ld.so.conf中所指定的动态库搜索路径(更改/etc/ld.so.conf之后，一定要执行命令ldconfig，该命令会将/etc/ld.so.conf文件中所有路径下的库载入内存）;

4） 默认的动态库搜索路径/lib；

5） 默认的动态库搜索路径/usr/lib;









# 6.gcc编译头文件查找路径
对于#include ""，预处理器首先在当前目录查找，如果没找到，就按系统设置目录列表查找头文件。
对于#include<>，预处理器按系统设置目录列表查找头文件。我们常用 -I添加头文件的查找目录。预处理器的查找顺序为：当前目录——>-I设定目录——>系统设置目录。
您还可以使用 -nostdinc 选项阻止预处理器搜索任何默认系统头目录。当您编译操作系统内核或其他不使用标准 C 库工具或标准 C 库本身的程序时，这很有用。

除此之外，我们还可以通过相应的环境变量来指定头文件的搜索路径：
```
export C_INCLUDE_PATH=XXXX:$C_INCLUDE_PATH
export CPLUS_INCLUDE_PATH=XXX:$CPLUS_INCLUDE_PATH
```
可以将以上代码添加到/etc/profile末尾。


# 7.gcc编译选项
```
-I：编译程序按照-I指定的路进去搜索头文件
-L：指定的路径会被优先搜索
-l：-L用于指定库所在的目录，-l用于指定具体的库。
```
注意：-l event指定的是所有库名称中含有“libevent”字串的库。有时“-l event”也写成“-levent”。

下面是一个编译实例：
```
g++ main.cpp -Wl,-rpath=`../lib`  -L ../lib  -l opencv_core -l opencv_imgproc -l opencv_videoio -l opencv_imgcodecs -l opencv_highgui -I ../include/opencv4 -o app 

-Wl,-rpath：指定运行时在哪里找库
-L：指定库目录
-l：指定具体的库文件。即使有了-L，也需要设置-l
-I：指定了头文件所在的目录
```





from：[链接](https://blog.csdn.net/chen_jianjian/article/details/123890413)
]]></description></item><item><title>WARNING: Retrying (Retry(total=0, connect=None, read=None, redirect=None, status=None)) after connection broken by 'ProxyError('Cannot connect to proxy.', NewConnectionError('&lt;pip._vendor.</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/05/26/16313563.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Thu, 26 May 2022 07:13:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/05/26/16313563.html</guid><description><![CDATA[安装 pip 包报错：
```
WARNING: Retrying (Retry(total=4, connect=None, read=None, redirect=None, status=None)) after connection broken by 'ProxyError('Cannot connect to proxy.', NewConnectionError('<pip._vendor.urllib3.connection.HTTPSConnection object at 0x7fc50528c710>: Failed to establish a new connection: [Errno 111] Connection refused'))': /simple
WARNING: Retrying (Retry(total=3, connect=None, read=None, redirect=None, status=None)) after connection broken by 'ProxyError('Cannot connect to proxy.', NewConnectionError('<pip._vendor.urllib3.connection.HTTPSConnection object at 0x7fc50528c590>: Failed to establish a new connection: [Errno 111] Connection refused'))': /simple
WARNING: Retrying (Retry(total=2, connect=None, read=None, redirect=None, status=None)) after connection broken by 'ProxyError('Cannot connect to proxy.', NewConnectionError('<pip._vendor.urllib3.connection.HTTPSConnection object at 0x7fc50528cd50>: Failed to establish a new connection: [Errno 111] Connection refused'))': /simple
WARNING: Retrying (Retry(total=1, connect=None, read=None, redirect=None, status=None)) after connection broken by 'ProxyError('Cannot connect to proxy.', NewConnectionError('<pip._vendor.urllib3.connection.HTTPSConnection object at 0x7fc50528cbd0>: Failed to establish a new connection: [Errno 111] Connection refused'))': /simple
WARNING: Retrying (Retry(total=0, connect=None, read=None, redirect=None, status=None)) after connection broken by 'ProxyError('Cannot connect to proxy.', NewConnectionError('<pip._vendor.urllib3.connection.HTTPSConnection object at 0x7fc50528cd90>: Failed to establish a new connection: [Errno 111] Connection refused'))': /simple
ERROR: Could not install packages due to an EnvironmentError: HTTPSConnectionPool(host='pypi.doubanio.com', port=443): Max retries exceeded with url: /simple (Caused by ProxyError('Cannot connect to proxy.', NewConnectionError('<pip._vendor.urllib3.connection.HTTPSConnection object at 0x7fc50528ce10>: Failed to establish a new connection: [Errno 111] Connection refused')))
```
代理问题，解决方案
```
unset no_proxy;unset https_proxy
```
[参考连接](https://blog.csdn.net/ao1886/article/details/114283556)
]]></description></item><item><title>C++ opencv使用</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/05/24/16307407.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Tue, 24 May 2022 14:10:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/05/24/16307407.html</guid><description><![CDATA[# 安装
请参考：[C++ opencv安装和使用](https://blog.csdn.net/weixin_44796670/article/details/115900538)

通过以下命令，将opencv安装到指定目录中：
```
cmake -D CMAKE_BUILD_TYPE=Release -D CMAKE_INSTALL_PREFIX=/home/ubuntu1/test_c++/opencv  ..
```
将C++ opencv安装到指定目录下以后，可以看到有四个目录bin、include、lib 和 share,分别包含了可执行文件、头文件、库文件和cmake配置文件。在这里,我们只需用到 include 和 lib 这两个文件夹,
  


为什么在OpenCV 3.x和OpenCV 4.x中都有有一个opencv2文件夹？
基于C的OpenCV是API v1，基于C ++的OpenCV是API v2。库版本现在为3.x或4.x，但它们仍使用相同的基于C ++的API。因此，OpenCV构建仍将其头文件保存在opencv2文件夹中。也就是说opencv2代表此库用于C++。


lib中各个库都代表什么？什么时候需要引入什么库？？？


# 使用

只能保存avi，mp4格式编码方式有点迷


```
// 画框cv::rectangle(图片,左上点,右上点,框的颜色);
cv::rectangle(image, cv::Point(400, 400), cv::Point(450, 450), cv::Scalar(0, 0, 255));
```

opencv读取图片：
```
//main.cpp

#include <opencv2/opencv.hpp>
#include<iostream>

int main(int argc, char const *argv[])
{
    cv::VideoCapture cap;
    cap.open("human.mp4");

    if (!cap.isOpened())
        return 0;


  
    cv::Mat frame;
    while(1) {
        cap >> frame;
        if (frame.empty())
            break;
        cv::imshow("hello", frame);
        cv::waitKey(50);
    }
    cap.release();

    return 0;
}
```
使用g++进行编译：
```
g++ main.cpp -Wl,-rpath=./opencv/lib -L ./opencv/lib  -l opencv_core -l opencv_imgproc -l opencv_videoio -l opencv_imgcodecs -l opencv_highgui -I ./opencv/include/opencv4 -o app 

-Wl,-rpath：运行阶段，在这个目录下查找库文件
-L：编译阶段，在这个目录下查找库文件
-l：-L指向目录，-l指向具体的库。
-I：指向头文件所在目录
命令具体可参考：https://www.cnblogs.com/codingbigdog/p/16320965.html
```
]]></description></item><item><title>程序员的出路</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/05/22/16298756.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Sun, 22 May 2022 11:44:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/05/22/16298756.html</guid><description><![CDATA[熟悉公司赚钱和找客户流程，然后自己创业。【可能累死】
参考：[链接](https://www.zhihu.com/question/493709505/answer/2193640005)

混上公司上层，当上架构师，让自己不可或缺。
让自己技术好，让自己即使被裁也不怕。

转产品经理或者项目经理

若果不想长期走技术路线，可以及早开辟一个副业。用2-3年的时间把副业的收入做到主业的一半，慢慢的切换到副业上。比如我喜欢心理学，我可以考虑一下，恋爱市场的心理需求。


评论区：
1.只要技术够好，这个年代程序员不赚钱谁赚钱，我见过月入百万的项目太多了，但首先你技术要好
2.跑路日本吧，在国内绝逼给优化了
3.43岁的程序员鼓励你一下，要是有其他出路不妨一试，但提醒你出去就回不来了。
4.我觉得30岁的程序员如果沟通能力和业务理解能力都较强，管理、产品经理或者项目经理都可以转，这些岗位互通的地方很多。

最好的赚钱方法是：利用信息不对称，合法地炒作，赚到钱就跑路。


最后：不要被贩卖焦虑了，程序员还是可以感到四十多岁的，等到干不动了，钱应该也赚够了，该养老了。
]]></description></item><item><title>C++ webserver from 黑马程序员 </title><link>http://www.cnblogs.com/codingbigdog/archive/2022/05/20/16293559.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Fri, 20 May 2022 11:42:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/05/20/16293559.html</guid><description><![CDATA[# 1.使用抓包工具Wireshark查看三次握手
常用的抓包工具：
- tcpdump：游双的《高性能网络编程》中常用tcpdump进行抓包
- Wireshark：本黑马程序员课程中使用Wireshark进行抓包。抓包程序不要一直开着，不然内存会爆掉。

我首先在虚拟机中开启两个ubuntu系统，此时这两个系统，相当于在同一个网段下面的两台主机。然后使用Wireshark监听网卡VMware Network Adapter VMnet8。【[虚拟网卡的知识参考](https://www.cnblogs.com/lyh233/p/14592566.html)】

**使用抓包工具Wireshark查看三次握手步骤**
假设两台虚拟主机为A和B，A的IP为192.168.154.129，B的IP为192.168.154.130。
1.在主机A中运行黑马程序员课程中所给的代码02_process_tcp_server.c，具体代码如下：
```
#include <stdio.h>
#include <sys/socket.h>
#include <unistd.h>
#include <signal.h>
#include <sys/wait.h>
#include "wrap.h"
void free_process(int sig)
{
	pid_t pid;
	while(1)
	{
		pid = waitpid(-1,NULL,WNOHANG);
		if(pid <=0 )//小于0 子进程全部退出了 =0没有进程没有退出
		{
			break;
		}
		else
		{
			printf("child pid =%d\n",pid);
		}
	}



}
int main(int argc, char *argv[])
{
	sigset_t set;
	sigemptyset(&set);
	sigaddset(&set,SIGCHLD);
	sigprocmask(SIG_BLOCK,&set,NULL);
	//创建套接字,绑定
	int lfd = tcp4bind(8008,NULL);
	//监
	Listen(lfd,128);
	//提取
	//回射
	struct sockaddr_in cliaddr;
	socklen_t len = sizeof(cliaddr);
	while(1)
	{
		char ip[16]="";
		//提取连接,
		int cfd = Accept(lfd,(struct sockaddr *)&cliaddr,&len);
		printf("new client ip=%s port=%d\n",inet_ntop(AF_INET,&cliaddr.sin_addr.s_addr,ip,16),
				ntohs(cliaddr.sin_port));
		//fork创建子进程
		pid_t pid;
		pid = fork();
		if(pid < 0)
		{
			perror("");
			exit(0);
		}
		else if(pid == 0)//子进程
		{
			//关闭lfd
			close(lfd);
			while(1)
			{
			char buf[1024]="";

			int n = read(cfd,buf,sizeof(buf));
			if(n < 0)
			{
				perror("");
				close(cfd);
				exit(0);
			}
			else if(n == 0)//对方关闭j
			{
				printf("client close\n");
				close(cfd);
				exit(0);
			
			}
			else
			{
				printf("%s\n",buf);
				write(cfd,buf,n);
			//	exit(0);	
			}
			}
		
		}
		else//父进程
		{
			close(cfd);
			//回收
			//注册信号回调
			struct sigaction act;
			act.sa_flags =0;
			act.sa_handler = free_process;
			sigemptyset(&act.sa_mask);
			sigaction(SIGCHLD,&act,NULL);
			sigprocmask(SIG_UNBLOCK,&set,NULL);
		
		}
	}
	//关闭



	return 0;
}
```
编译和运行命令：
```
gcc 02_process_tcp_server.c wrap.c 
./a.out
```
wrap.c代码见[函数封装](https://www.cnblogs.com/codingbigdog/p/16245492.html)

2.开启Wireshark监听网卡VMware Network Adapter VMnet8
3.在主机B运行如下命令：
```
nc 192.168.154.129 8008
hello // 发送hello
hello // 发送hello以后，会收到hello
^C    // ctrl+c断开连接
```

Wireshark中抓到的信息如下：
![](https://img2022.cnblogs.com/blog/1617829/202205/1617829-20220520204042214-1685166316.png)


# 2.HTTP协议
常用的请求方法有GET、HEAD、POST。
无连接：服务器处理完客户的请求，并收到客户的应答后，即断开连接。
无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。
从URL中获取参数：从“？”开始到“#”为止之间的部分为参数部分。允许有多个参数，参数与参数之间用“&”作为分隔符。可以从URL中获取参数，传给后台。

## 2.1.请求消息Request
请求消息Request有下面四个部分：
请求行（request line）、请求头部（header）、空行和请求数据
![](https://img2022.cnblogs.com/blog/1617829/202205/1617829-20220520212604859-650996089.png)

如：
![](https://img2022.cnblogs.com/blog/1617829/202205/1617829-20220520214117141-1352557713.png)
其中\r\n代表空行



## 2.2.响应消息Response
HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。
![](https://img2022.cnblogs.com/blog/1617829/202205/1617829-20220520214410051-631001605.png)
Content-Type是必填的；Content-Length可填可不填,填一定填对。

HTTP协议的具体内容可参考：[链接](https://www.cnblogs.com/ranyonsue/p/5984001.html)



# 3.webserver实现
## 一些API
读取目录下所有文件名
```
// dirent用于存储文件信息
struct dirent {
              ino_t          d_ino;       /* inode number */
              off_t          d_off;       /* not an offset; see NOTES */
              unsigned short d_reclen;    /* length of this record */
              unsigned char  d_type;      /* type of file; not supported
                                              by all filesystem types */
              char           d_name[256]; /* filename */
           };

// scandir 读取目录下的文件
struct dirent **mylist : // 指向指针数组的指针，如果要改变这个在指针的指向就需要使用三级指针
int scandir(const char *dirp, struct dirent ***namelist, // 需要改变mylist指针的指向，所以这里namelist使用三级指针
              int (*filter)(const struct dirent *),
              int (*compar)(const struct dirent **, const struct dirent **));
参数: 
        dirp: 目录的路径名
        namelist:  mylist地址，保存目录下的文件
        filter: 过滤的函数入口地址。用于过滤不需要的文件。不需要过滤时写NULL
        compar : 排序函数入口地址   可以直接使用已经写好的函数alphasort，用于字母排序
返回值: 读取文件的个数

```
## 具体实现代码
在黑马程序员课程中，实现了两个webserver，分别为epoll_web.c和event_wb.c。
具体代码可以在https://gitee.com/baba1980/heima_codes_notes的webserver下中找到，我添加了注释，所以代码直接应该可以看懂。
]]></description></item><item><title>C++ UDP 和unix domain socket，from 黑马程序员</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/05/19/16290593.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Thu, 19 May 2022 14:50:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/05/19/16290593.html</guid><description><![CDATA[#1.UDP和TCP区别
TCP: 传输控制协议   安全可靠  丢包重传   面向连接(电话模型) 
UDP: 用户数据报协议  不安全不可靠 丢包不重传  快 不面向连接(邮件模型)，可在应用层是实现安全可靠和丢包重传等内容


**tcp通信流程:**
服务器: 创建流式套接字 绑定 监听 提取 读写 关闭
客户端: 创建流式套接字 连接 读写 关闭
收发数据:
read或recv（推荐使用recv）:
ssize_t recv(int sockfd, void *buf, size_t len, int flags);//flags==MSG_PEEK时， 读数据但不会删除缓冲区的数据
write或send（推荐使用send）:
ssize_t send(int sockfd, const void *buf, size_t len, int flags);//flags一般填0，flags=1代表发送紧急数据

**udp通信流程：**
服务器: 创建报式套接字 绑定 读写 关闭
客户端: 创建报式套接字 读写  关闭
发数据:
```
ssize_t sendto(int sockfd, const void *buf, size_t len, int flags,
                      const struct sockaddr *dest_addr, socklen_t addrlen);
flags一般写0
dest_addr: 目的地的地址信息
addrlen: 结构体大小
```
收数据:
```
ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags,
                        struct sockaddr *src_addr, socklen_t *addrlen);
flags一般写0
src_addr: 对方的地址信息
addrlen: 结构体大小的地址
```




#　2.UDP通信
创建报式套接字
```
int socket(int domain, int type, int protocol);
参数:
    domain : AF_INET
    type :SOCK_DGRAM
    protocol :0
```
**UDP服务器upd_server.c**
```
#include <stdio.h>
#include <sys/socket.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <string.h>
#include <stdlib.h>
int main(int argc, char *argv[])
{
	//创建套接字
	int fd = socket(AF_INET,SOCK_DGRAM,0);
	//绑定
	struct sockaddr_in myaddr;
	myaddr.sin_family = AF_INET;
	myaddr.sin_port = htons(8888);
	myaddr.sin_addr.s_addr = inet_addr("127.0.0.1"); // inet_addr只用于IPv4，inet_pton可用于IPv4和IPv6
	int ret = bind(fd,(struct sockaddr*)&myaddr,sizeof(myaddr));
	if(ret < 0)
	{
		perror("");
		return 0;
	}
	//读写
	char buf[1500]="";
	struct sockaddr_in cliaddr;
	socklen_t len = sizeof(cliaddr);
	while(1)
	{
		memset(buf,0,sizeof(buf)); // 清空，不然会残留上次收到的数据
		int n = recvfrom(fd,buf,sizeof(buf),0,(struct sockaddr *)&cliaddr,&len);
		if(n < 0)
		{
			perror("");
			break;
		}
		else
		{
			printf("%s\n",buf);
			sendto(fd,buf,n,0,(struct sockaddr *)&cliaddr,len);
		
		}
	}
	//关闭
	close(fd);
	return 0;
}
```
**UDP客户端udp_client.c**
```
#include <stdio.h>
#include <string.h>
#include <sys/socket.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <stdlib.h>
int main(int argc, char *argv[])
{
	//创建套接字
	int fd = socket(AF_INET,SOCK_DGRAM,0);
	//绑定
	struct sockaddr_in myaddr;
	myaddr.sin_family = AF_INET;
	myaddr.sin_port = htons(9000);
	//inet_pton
	myaddr.sin_addr.s_addr = inet_addr("127.0.0.1");
	int ret = bind(fd,(struct sockaddr*)&myaddr,sizeof(myaddr));
	if(ret < 0)
	{
		perror("");
		return 0;
	}
	//读写
	char buf[1500]="";
	struct sockaddr_in cliaddr;
	socklen_t len = sizeof(cliaddr);

	struct sockaddr_in dstaddr;
	dstaddr.sin_family = AF_INET;
	dstaddr.sin_port = htons(8888);
	dstaddr.sin_addr.s_addr = inet_addr("127.0.0.1");
	int n=0;
	while(1)
	{
		n = read(STDIN_FILENO,buf,sizeof(buf));	
		sendto(fd,buf,n,0,(struct sockaddr *)&dstaddr,sizeof(dstaddr));
		memset(buf,0,sizeof(buf));
		 n = recvfrom(fd,buf,sizeof(buf),0,NULL,NULL);
		if(n < 0)
		{
			perror("");
		}
		else{
			printf("%s\n",buf);
		
		}
	}
	//关闭
	close(fd);
	return 0;
}
```
# 3.本地套接字实现进程通信（unix domain socket）
可以直接使用网络套接字实现进程通信，也可以使用本地套接字实现进程通信。

套接字用文件来标识,这个文件在绑定之前是不能存在

本地套接字可用于tcp和udp通信，这里以tcp通信为例。
```
int socket(int domain, int type, int protocol);
参数:
    domain : AF_UNIX
    type :SOCK_STREAM
    protocol : 0


绑定
int bind(int sockfd, const struct sockaddr *addr,
                socklen_t addrlen);
sockfd: 本地套接字
addr:  本地套接字结构体地址sockaddr_un
    struct sockaddr_un {
               sa_family_t sun_family;               /* AF_UNIX */
               char        sun_path[108];            /* pathname *///文件的路径名
               };
addrlen: sockaddr_un大小 


提取
int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
    addr: struct sockaddr_un 结构体地址
```

**本地套接字实现tcp服务器：**
```
#include <stdio.h>
#include <fcntl.h>
#include <stddef.h>
#include <sys/socket.h>
#include <unistd.h>
#include <sys/un.h>
#include <arpa/inet.h>
int main(int argc, char *argv[])
{
	unlink("sock.s"); 	// 套接字用文件来标识,这个文件在绑定之前是不能存在。故先删除sock.s
	//创建unix流式套接
	int lfd = socket(AF_UNIX,SOCK_STREAM,0);
	//绑定
	struct sockaddr_un myaddr;
	myaddr.sun_family = AF_UNIX;
	strcpy(myaddr.sun_path ,"sock.s"); // 不能用myaddr.sun_path = "sock.s"。字符串不能用等号
	int len = offsetof(struct sockaddr_un,sun_path)+strlen(myaddr.sun_path); // offsetof(struct sockaddr_un,sun_path)相当于myaddr.sun_family的大小
	bind(lfd,(struct sockaddr *)&myaddr,len); // 也可以写成bind(lfd,(struct sockaddr *)&myaddr,sizeof(myaddr));
	//监听
	listen(lfd,128);
	
	//提取
	struct sockaddr_un cliaddr;
	socklen_t len_c = sizeof(cliaddr);
	int cfd = accept(lfd,(struct sockaddr*)&cliaddr,&len_c);

	printf("new cilent file = %s\n",cliaddr.sun_path);
	//读写
	char buf[1500]="";
	while(1)
	{
		int n = recv(cfd,buf,sizeof(buf),0);
		if(n <= 0)
		{
			printf("err or client close\n");
			break;
		}
		else
		{
			printf("%s\n",buf);
			send(cfd,buf,n,0);
		
		}
	
	}
	//关闭
	close(cfd);
	close(lfd);
	return 0;
}
```
**本地套接字客户端实现:**
```
#include <stdio.h>
#include <stddef.h>
#include <arpa/inet.h>
#include <sys/un.h>
#include <sys/socket.h>
#include <unistd.h>
#include <string.h>
#include <stdlib.h>
int main(int argc, char *argv[])
{
	unlink("sock.c");
	//创建unix流式套接字
	int cfd = socket(AF_UNIX,SOCK_STREAM,0);
	//如果不绑定,就是隐式绑定
	struct sockaddr_un myaddr;
	myaddr.sun_family = AF_UNIX;
	strcpy(myaddr.sun_path,"sock.c");
	int len = offsetof(struct sockaddr_un,sun_path)+strlen("sock.c");
	if(bind(cfd,(struct sockaddr*)&myaddr,len)< 0)
	{
		perror("");
		return 0;
	}
	//连接
	struct sockaddr_un seraddr;
	seraddr.sun_family = AF_UNIX;
	strcpy(seraddr.sun_path,"sock.s");
	connect(cfd,(struct sockaddr*)&seraddr,sizeof(seraddr));
	//读写
	while(1)
	{
		char buf[1500]="";
		int n = read(STDIN_FILENO,buf,sizeof(buf));
		send(cfd,buf,n,0);
		memset(buf,0,sizeof(buf));
		n = recv(cfd,buf,sizeof(buf),0);
		if(n <=0 )
		{
		
			printf("err or server close\n");
			break;
		
		}
		else
		{
			printf("%s\n",buf);
		
		}
	
	
	}
	//关闭
	close(cfd);
	return 0;
}
```
]]></description></item><item><title>C++ 线程池</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/05/18/16286717.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Wed, 18 May 2022 14:47:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/05/18/16286717.html</guid><description><![CDATA[创建几个线程用于处理任务，这些线程暂时不销毁，从而减少线程创建和销毁所需的时间。
将任务放进任务队列中，线程从任务队列中取任务。
这是生成者和消费者模型，需要考虑互斥与同步的问题。实现所需内容如下：
- 一个锁：用于线程互斥访问任务队列
- 两个条件变量：1.当任务队列满时不能添加任务  2.队列中有任务才能取
- 循环队列：用循环队列实现任务队列

实现所需函数如下
```
pthread_cond_wait：等待条件变量满足后，继续执行下面程序
pthread_cond_signal：随机给某一个等待在条件变量的线程发送信号。
pthread_cond_broadcast：给所有等待在等待条件变量的线程发送信号
```
# 1.**epoll加线程池的实现：**
头文件threadpoolsimple.h：
```
#ifndef _THREADPOOL_H
#define _THREADPOOL_H

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <unistd.h>
#include <pthread.h>
#include "sys/epoll.h"
#include "wrap.h"

typedef struct _PoolTask // 代表一个任务。用一个PoolTask数组构造任务队列
{
    int tasknum;//模拟任务编号
    void *arg;//回调函数参数
    void (*task_func)(void *arg);//任务的回调函数
    int fd;
    int epfd;
    struct epoll_event *evs;

}PoolTask ;

typedef struct _ThreadPool // 线程池
{
    int max_job_num;	//最大任务个数
    int job_num;		//实际任务个数
    PoolTask *tasks;	//任务队列数组的首地址
    int job_push;		//入队位置
    int job_pop;		// 出队位置

    int thr_num;		//线程池内线程个数
    pthread_t *threads;	//线程池内线程数组
    int shutdown;		//是否关闭线程池
    pthread_mutex_t pool_lock;	//线程池的锁
    pthread_cond_t empty_task;//任务队列为空的条件
    pthread_cond_t not_empty_task;//任务队列不为空的条件

}ThreadPool;

void create_threadpool(int thrnum,int maxtasknum);//创建线程池--thrnum  代表线程个数，maxtasknum 最大任务个数
void destroy_threadpool(ThreadPool *pool);//摧毁线程池
//void addtask(ThreadPool *pool);//添加任务到线程池
void addtask(ThreadPool *pool,int fd,struct epoll_event *evs);
void taskRun(void *arg);	//任务回调函数

#endif
```

```
//简易版线程池
#include "threadpoolsimple.h"

ThreadPool *thrPool = NULL;

int beginnum = 1000;

void *thrRun(void *arg)
{
    //printf("begin call %s-----\n",__FUNCTION__);
    ThreadPool *pool = (ThreadPool*)arg;
    int taskpos = 0;//任务位置
    PoolTask *task = (PoolTask *)malloc(sizeof(PoolTask));

    while(1)
	{
        //获取任务，先要尝试加锁
        pthread_mutex_lock(&thrPool->pool_lock);

		//无任务并且线程池不是要摧毁
        while(thrPool->job_num <= 0 && !thrPool->shutdown ) // 当pool->not_empty_task为1时，循环退出，并在下面代码中销毁线程
		{
			//如果没有任务，线程会阻塞
            pthread_cond_wait(&thrPool->not_empty_task,&thrPool->pool_lock);
        }
        
        if(thrPool->job_num)
		{
            //有任务需要处理
            taskpos = (thrPool->job_pop++) % thrPool->max_job_num;  // 从循环队列中取任务
            //printf("task out %d...tasknum===%d tid=%lu\n",taskpos,thrPool->tasks[taskpos].tasknum,pthread_self());
			//为什么要拷贝？避免任务被修改，生产者会添加任务
            memcpy(task,&thrPool->tasks[taskpos],sizeof(PoolTask));
            task->arg = task;
            thrPool->job_num--;
            //task = &thrPool->tasks[taskpos];
            pthread_cond_signal(&thrPool->empty_task);// empty_task加一，代表任务队列空余空间增加一
        }

        if(thrPool->shutdown)
		{
            //代表要摧毁线程池，此时线程退出即可
            //pthread_detach(pthread_self());//临死前分家
            pthread_mutex_unlock(&thrPool->pool_lock);
            free(task);
			pthread_exit(NULL);
        }

        //释放锁
        pthread_mutex_unlock(&thrPool->pool_lock);
        printf("001\n");
        task->task_func(task->arg);//执行回调函数
        printf("002\n");
    }
    
    //printf("end call %s-----\n",__FUNCTION__);
}

//创建线程池
void create_threadpool(int thrnum,int maxtasknum)
{
    printf("begin call %s-----\n",__FUNCTION__);
    thrPool = (ThreadPool*)malloc(sizeof(ThreadPool));

    thrPool->thr_num = thrnum;
    thrPool->max_job_num = maxtasknum;
    thrPool->shutdown = 0;//是否摧毁线程池，1代表摧毁
    thrPool->job_push = 0;//任务队列添加的位置
    thrPool->job_pop = 0;//任务队列出队的位置
    thrPool->job_num = 0;//初始化的任务个数为0

    thrPool->tasks = (PoolTask*)malloc((sizeof(PoolTask)*maxtasknum));//申请最大的任务队列

    //初始化锁和条件变量
    pthread_mutex_init(&thrPool->pool_lock,NULL);
    pthread_cond_init(&thrPool->empty_task,NULL);
    pthread_cond_init(&thrPool->not_empty_task,NULL);

    int i = 0;
    thrPool->threads = (pthread_t *)malloc(sizeof(pthread_t)*thrnum);//申请n个线程id的空间
	
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
    for(i = 0;i < thrnum;i++)
	{
        pthread_create(&thrPool->threads[i],&attr,thrRun,(void*)thrPool);//创建多个线程
    }
    //printf("end call %s-----\n",__FUNCTION__);
}
//摧毁线程池
void destroy_threadpool(ThreadPool *pool)
{
    pool->shutdown = 1;// 标志位设为1 
    pthread_cond_broadcast(&pool->not_empty_task);// 给所有阻塞在pool->not_empty_task上的线程发信号

    int i = 0;
    for(i = 0; i < pool->thr_num ; i++)
	{
        pthread_join(pool->threads[i],NULL);  // 这个代码没有必要
    }

    pthread_cond_destroy(&pool->not_empty_task);
    pthread_cond_destroy(&pool->empty_task);
    pthread_mutex_destroy(&pool->pool_lock);

    free(pool->tasks);
    free(pool->threads);
    free(pool);
}

//添加任务到线程池
void addtask(ThreadPool *pool,int fd,struct epoll_event *evs)
{
    //printf("begin call %s-----\n",__FUNCTION__);
    pthread_mutex_lock(&pool->pool_lock);

	//实际任务总数大于最大任务个数则阻塞等待(等待任务被处理)
    while(pool->max_job_num <= pool->job_num)
	{
        pthread_cond_wait(&pool->empty_task,&pool->pool_lock);
    }

    int taskpos = (pool->job_push++)%pool->max_job_num;
    //printf("add task %d  tasknum===%d\n",taskpos,beginnum);
    pool->tasks[taskpos].tasknum = beginnum++;
    pool->tasks[taskpos].arg = (void*)&pool->tasks[taskpos];
    pool->tasks[taskpos].task_func = taskRun;
    pool->tasks[taskpos].fd = fd;
     pool->tasks[taskpos].evs = evs;
    pool->job_num++;

    pthread_mutex_unlock(&pool->pool_lock);

    pthread_cond_signal(&pool->not_empty_task);// not_empty_task加一，代表任务增加一
    //printf("end call %s-----\n",__FUNCTION__);
}

//任务回调函数
void taskRun(void *arg)
{
    printf("003\n");
    PoolTask *task = (PoolTask*)arg;
     char buf[1024]="";
    int n = Read(task->fd , buf,sizeof(buf));
    if(n == 0 )
        {
         close(task->fd);//关闭cfd
        epoll_ctl(task->epfd,EPOLL_CTL_DEL,task->fd,task->evs);//将cfd上树
            printf("client close\n");
        }
    else if(n> 0)
        {
         printf("%s\n",buf );
         Write(task->fd ,buf,n);

        }
 printf("004\n");
   
}


int main()
{
    create_threadpool(3,20);
    int i = 0;
    //创建套接字,绑定
    int lfd = tcp4bind(8000,NULL);
    //监听
    listen(lfd,128);
    //创建树
    int epfd = epoll_create(1);
    struct epoll_event ev,evs[1024];
    ev.data.fd = lfd;
    ev.events = EPOLLIN;//监听读事件
    //将ev上树
    epoll_ctl(epfd,EPOLL_CTL_ADD,lfd,&ev);
    while(1)
    {
        int nready = epoll_wait(epfd,evs,1024,-1);
        if(nready < 0)
            perr_exit("err");
        else if(nready == 0)
            continue;
        else if(nready > 0 )
        {
            for(int i=0;i<nready;i++)
            {
                if(evs[i].data.fd == lfd && evs[i].events & EPOLLIN)//如果是lfd变化,并且是读事件。这个处理很快，所以就不放进任务队列里面了
                {
                        struct sockaddr_in cliaddr;
                        char buf_ip[16]="";
                        socklen_t len  = sizeof(cliaddr);
                        int cfd = Accept(lfd,(struct sockaddr *)&cliaddr,&len);
                        printf("client ip=%s port=%d\n",inet_ntop(AF_INET,
                        &cliaddr.sin_addr.s_addr,buf_ip,sizeof(buf_ip)),
                        ntohs(cliaddr.sin_port));
                        ev.data.fd = cfd;//cfd上树
                        ev.events = EPOLLIN;//监听读事件
                        epoll_ctl(epfd,EPOLL_CTL_ADD,cfd,&ev);//将cfd上树

                }
                else if(evs[i].events & EPOLLIN)//普通的读事件
                {
                    printf("###########1\n");
                    addtask(thrPool,evs[i].data.fd,&evs[i]);
                     printf("###########2\n");
                    // char buf[1024]="";
                    // int n = Read(evs[i].data.fd , buf,sizeof(buf));
                    // if(n <= 0 )
                    // {
                    //     close(evs[i].data.fd);//关闭cfd
                    //     epoll_ctl(epfd,EPOLL_CTL_DEL,evs[i].data.fd,&evs[i]);//将cfd上树
                    //     printf("client close\n");
                    // }
                    // else
                    // {
                    //     printf("%s\n",buf );
                    //     Write(evs[i].data.fd ,buf,n);

                    // }


                }


            }



        }


    }
    close(lfd);

   
    destroy_threadpool(thrPool);

    return 0;
}
```
# 2.复杂版的线程池实现
头文件threadpool.h：
```
#ifndef __THREADPOOL_H_
#define __THREADPOOL_H_

typedef struct threadpool_t threadpool_t;

/**
 * @function threadpool_create
 * @descCreates a threadpool_t object.
 * @param thr_num  thread num
 * @param max_thr_num  max thread size
 * @param queue_max_size   size of the queue.
 * @return a newly created thread pool or NULL
 */
threadpool_t *threadpool_create(int min_thr_num, int max_thr_num, int queue_max_size);

/**
 * @function threadpool_add
 * @desc add a new task in the queue of a thread pool
 * @param pool     Thread pool to which add the task.
 * @param function Pointer to the function that will perform the task.
 * @param argument Argument to be passed to the function.
 * @return 0 if all goes well,else -1
 */
int threadpool_add(threadpool_t *pool, void*(*function)(void *arg), void *arg);

/**
 * @function threadpool_destroy
 * @desc Stops and destroys a thread pool.
 * @param pool  Thread pool to destroy.
 * @return 0 if destory success else -1
 */
int threadpool_destroy(threadpool_t *pool);

/**
 * @desc get the thread num
 * @pool pool threadpool
 * @return # of the thread
 */
int threadpool_all_threadnum(threadpool_t *pool);

/**
 * desc get the busy thread num
 * @param pool threadpool
 * return # of the busy thread
 */
int threadpool_busy_threadnum(threadpool_t *pool);

#endif

```
```
#include <stdlib.h>
#include <pthread.h>
#include <unistd.h>
#include <assert.h>
#include <stdio.h>
#include <string.h>
#include <signal.h>
#include <errno.h>
#include "threadpool.h"

#define DEFAULT_TIME 10                 /*10s检测一次*/
#define MIN_WAIT_TASK_NUM 10            /*如果queue_size > MIN_WAIT_TASK_NUM 添加新的线程到线程池*/ 
#define DEFAULT_THREAD_VARY 10          /*每次创建和销毁线程的个数*/
#define true 1
#define false 0

// 代表一个任务
typedef struct 
{
    void *(*function)(void *);          /* 函数指针，回调函数 */
    void *arg;                          /* 上面函数的参数 */
} threadpool_task_t;                    /* 各子线程任务结构体 */

/* 描述线程池相关信息 */
struct threadpool_t 
{
    pthread_mutex_t lock;               /* 用于锁任务队列 */    
    pthread_mutex_t thread_counter;     /* 记录忙状态线程个数的锁 -- busy_thr_num */

    pthread_cond_t queue_not_full;      /* 当任务队列满时，添加任务的线程阻塞，等待此条件变量 */
    pthread_cond_t queue_not_empty;     /* 任务队列里不为空时，通知等待任务的线程 */
  
    pthread_t *threads;                 /* 存放线程池中每个线程的tid。数组 */
    pthread_t adjust_tid;               /* 存管理线程tid */
    threadpool_task_t *task_queue;      /* 任务队列(数组首地址) */

    int min_thr_num;                    /* 线程池最小线程数 */
    int max_thr_num;                    /* 线程池最大线程数 */
    int live_thr_num;                   /* 当前存活线程个数 */
    int busy_thr_num;                   /* 忙状态线程个数 */
    int wait_exit_thr_num;              /* 要销毁的线程个数 */

    int queue_front;                    /* task_queue队头下标 */
    int queue_rear;                     /* task_queue队尾下标 */
    int queue_size;                     /* task_queue队中实际任务数 */
    int queue_max_size;                 /* task_queue队列可容纳任务数上限 */

    int shutdown;                       /* 标志位，线程池使用状态，true或false */
};

void *threadpool_thread(void *threadpool);

void *adjust_thread(void *threadpool);

int is_thread_alive(pthread_t tid);
int threadpool_free(threadpool_t *pool);

//threadpool_create(3,100,100);  
threadpool_t *threadpool_create(int min_thr_num, int max_thr_num, int queue_max_size)
{
    int i;
    threadpool_t *pool = NULL;
    do 
	{
        if((pool = (threadpool_t *)malloc(sizeof(threadpool_t))) == NULL) 
		{  
            printf("malloc threadpool fail");
            break;                                      /*跳出do while。相当于使用了go to,直接跳转到下面的位置*/
        }

        pool->min_thr_num = min_thr_num;
        pool->max_thr_num = max_thr_num;
        pool->busy_thr_num = 0;
        pool->live_thr_num = min_thr_num;               /* 活着的线程数 初值=最小线程数 */
        pool->wait_exit_thr_num = 0;
        pool->queue_size = 0;                           /* 有0个任务 */
        pool->queue_max_size = queue_max_size;
        pool->queue_front = 0;
        pool->queue_rear = 0;
        pool->shutdown = false;                         /* 不关闭线程池 */

        /* 根据最大线程上限数， 给工作线程数组开辟空间, 并清零 */
        pool->threads = (pthread_t *)malloc(sizeof(pthread_t)*max_thr_num); 
        if (pool->threads == NULL) 
		{
            printf("malloc threads fail");
            break;
        }
        memset(pool->threads, 0, sizeof(pthread_t)*max_thr_num);

        /* 队列开辟空间 */
        pool->task_queue = (threadpool_task_t *)malloc(sizeof(threadpool_task_t)*queue_max_size);
        if (pool->task_queue == NULL) 
		{
            printf("malloc task_queue fail\n");
            break;
        }

        /* 初始化互斥琐、条件变量 */
        if (pthread_mutex_init(&(pool->lock), NULL) != 0
                || pthread_mutex_init(&(pool->thread_counter), NULL) != 0
                || pthread_cond_init(&(pool->queue_not_empty), NULL) != 0
                || pthread_cond_init(&(pool->queue_not_full), NULL) != 0)
        {
            printf("init the lock or cond fail\n");
            break;
        }

		//启动工作线程
		pthread_attr_t attr;
		pthread_attr_init(&attr);
		pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
        for (i = 0; i < min_thr_num; i++) 
		{
            pthread_create(&(pool->threads[i]), &attr, threadpool_thread, (void *)pool);/*pool指向当前线程池*/
            printf("start thread 0x%x...\n", (unsigned int)pool->threads[i]);
        }

		//创建管理者线程，用于根据任务的多少，动态地增加和减少线程的数量
        pthread_create(&(pool->adjust_tid), &attr, adjust_thread, (void *)pool);

        return pool;

    } while (0);

	/* 前面代码调用失败时,释放poll存储空间 */
    threadpool_free(pool);

    return NULL;
}

/* 向线程池中 添加一个任务 */
//threadpool_add(thp, process, (void*)&num[i]);   /* 向线程池中添加任务 process: 小写---->大写*/

int threadpool_add(threadpool_t *pool, void*(*function)(void *arg), void *arg)
{
    pthread_mutex_lock(&(pool->lock));

    /* ==为真，队列已经满， 调wait阻塞 */
    while ((pool->queue_size == pool->queue_max_size) && (!pool->shutdown)) 
	{
        pthread_cond_wait(&(pool->queue_not_full), &(pool->lock));
    }

    if (pool->shutdown) 
	{
        pthread_cond_broadcast(&(pool->queue_not_empty));
        pthread_mutex_unlock(&(pool->lock));
        return 0;
    }

    /* 清空 工作线程 调用的回调函数 的参数arg */
    if (pool->task_queue[pool->queue_rear].arg != NULL) 
	{
        pool->task_queue[pool->queue_rear].arg = NULL;
    }

    /*添加任务到任务队列里*/
    pool->task_queue[pool->queue_rear].function = function;
    pool->task_queue[pool->queue_rear].arg = arg;
    pool->queue_rear = (pool->queue_rear + 1) % pool->queue_max_size;       /* 队尾指针移动, 模拟环形 */
    pool->queue_size++;

    /*添加完任务后，队列不为空，唤醒线程池中 等待处理任务的线程*/
    pthread_cond_signal(&(pool->queue_not_empty));
    pthread_mutex_unlock(&(pool->lock));

    return 0;
}

/* 线程池中各个工作线程 */
void *threadpool_thread(void *threadpool)
{
    threadpool_t *pool = (threadpool_t *)threadpool;
    threadpool_task_t task;

    while (true) 
	{
        /* Lock must be taken to wait on conditional variable */
        /*刚创建出线程，等待任务队列里有任务，否则阻塞等待任务队列里有任务后再唤醒接收任务*/
        pthread_mutex_lock(&(pool->lock));

        /*queue_size == 0 说明没有任务，调 wait 阻塞在条件变量上, 若有任务，跳过该while*/
        while ((pool->queue_size == 0) && (!pool->shutdown)) 
		{  
            printf("thread 0x%x is waiting\n", (unsigned int)pthread_self());
            pthread_cond_wait(&(pool->queue_not_empty), &(pool->lock));//暂停到这

            /*清除指定数目的空闲线程，如果要结束的线程个数大于0，结束线程*/
            if (pool->wait_exit_thr_num > 0) 
			{
                pool->wait_exit_thr_num--;

                /*如果线程池里线程个数大于最小值时可以结束当前线程*/
                if (pool->live_thr_num > pool->min_thr_num) 
				{
                    printf("thread 0x%x is exiting\n", (unsigned int)pthread_self());
                    pool->live_thr_num--;
                    pthread_mutex_unlock(&(pool->lock));
					//pthread_detach(pthread_self());
                    pthread_exit(NULL);
                }
            }
        }

        /*如果指定了true，要关闭线程池里的每个线程，自行退出处理---销毁线程池*/
        if (pool->shutdown) 
		{
            pthread_mutex_unlock(&(pool->lock));
            printf("thread 0x%x is exiting\n", (unsigned int)pthread_self());
            //pthread_detach(pthread_self());
            pthread_exit(NULL);     /* 线程自行结束 */
        }

        /*从任务队列里获取任务, 是一个出队操作*/
        task.function = pool->task_queue[pool->queue_front].function;
        task.arg = pool->task_queue[pool->queue_front].arg;

        pool->queue_front = (pool->queue_front + 1) % pool->queue_max_size;       /* 出队，模拟环形队列 */
        pool->queue_size--;

        /*通知可以有新的任务添加进来*/
        pthread_cond_broadcast(&(pool->queue_not_full));

        /*任务取出后，立即将 线程池琐 释放*/
        pthread_mutex_unlock(&(pool->lock));

        /*执行任务*/ 
        printf("thread 0x%x start working\n", (unsigned int)pthread_self());
        pthread_mutex_lock(&(pool->thread_counter));                            /*忙状态线程数变量琐*/
        pool->busy_thr_num++;                                                   /*忙状态线程数+1*/
        pthread_mutex_unlock(&(pool->thread_counter));

        (*(task.function))(task.arg);                                           /*执行回调函数任务*/
        //task.function(task.arg);                                              /*执行回调函数任务*/

        /*任务结束处理*/ 
        printf("thread 0x%x end working\n", (unsigned int)pthread_self());
        pthread_mutex_lock(&(pool->thread_counter));
        pool->busy_thr_num--;                                       /*处理掉一个任务，忙状态数线程数-1*/
        pthread_mutex_unlock(&(pool->thread_counter));
    }

    pthread_exit(NULL);
}

/* 管理线程 */
void *adjust_thread(void *threadpool)
{
    int i;
    threadpool_t *pool = (threadpool_t *)threadpool;
    while (!pool->shutdown) 
	{

        sleep(DEFAULT_TIME);                                    /*定时 过一段时间就对线程增加或减少一次*/

        pthread_mutex_lock(&(pool->lock));
        int queue_size = pool->queue_size;                      /* 任务数 */
        int live_thr_num = pool->live_thr_num;                  /* 存活的线程数 */
        pthread_mutex_unlock(&(pool->lock));

        pthread_mutex_lock(&(pool->thread_counter));
        int busy_thr_num = pool->busy_thr_num;                  /* 忙着的线程数 */
        pthread_mutex_unlock(&(pool->thread_counter));

        /* 创建新线程 算法： 任务数大于最小线程池个数（不应该任务数大于不忙的线程时才增加吗？）, 且存活的线程数少于最大线程个数时 如：30>=10 && 40<100*/
        if (queue_size >= MIN_WAIT_TASK_NUM && live_thr_num < pool->max_thr_num) 
		{
            pthread_mutex_lock(&(pool->lock));  
            int add = 0;

            /*一次增加 DEFAULT_THREAD 个线程*/
            for (i = 0; i < pool->max_thr_num && add < DEFAULT_THREAD_VARY
                    && pool->live_thr_num < pool->max_thr_num; i++) 
			{
                if (pool->threads[i] == 0 || !is_thread_alive(pool->threads[i])) // 查找数组pool->threads中可用的位置 
				// pool->threads[i] == 0代表pool->threads[i]没存线程号；
				// !is_thread_alive(pool->threads[i])为真代表存储的线程已死
				{
                    pthread_create(&(pool->threads[i]), NULL, threadpool_thread, (void *)pool);
                    add++;
                    pool->live_thr_num++;
                }
            }

            pthread_mutex_unlock(&(pool->lock));
        }

        /* 销毁多余的空闲线程 算法：忙线程X2 小于 存活的线程数 且 存活的线程数 大于 最小线程数时*/
        if ((busy_thr_num * 2) < live_thr_num  &&  live_thr_num > pool->min_thr_num) 
		{
            /* 一次销毁DEFAULT_THREAD个线程, 隨機10個即可 */
            pthread_mutex_lock(&(pool->lock));
            pool->wait_exit_thr_num = DEFAULT_THREAD_VARY;      /* 要销毁的线程数 设置为10 */
            pthread_mutex_unlock(&(pool->lock));

            for (i = 0; i < DEFAULT_THREAD_VARY; i++) 
			{
                /* 通知处在空闲状态的线程, 他们会自行终止*/
                pthread_cond_signal(&(pool->queue_not_empty));
            }
        }
    }

    return NULL;
}

int threadpool_destroy(threadpool_t *pool)
{
    int i;
    if (pool == NULL) 
	{
        return -1;
    }
    pool->shutdown = true;

    /*先销毁管理线程*/
    //pthread_join(pool->adjust_tid, NULL);

    for (i = 0; i < pool->live_thr_num; i++) 
	{
        /*通知所有的空闲线程*/
        pthread_cond_broadcast(&(pool->queue_not_empty));
    }

    /*for (i = 0; i < pool->live_thr_num; i++) 
	{
        pthread_join(pool->threads[i], NULL);
    }*/

    threadpool_free(pool);

    return 0;
}

int threadpool_free(threadpool_t *pool)
{
    if (pool == NULL) 
	{
        return -1;
    }

    if (pool->task_queue) 
	{
        free(pool->task_queue);
    }

    if (pool->threads) 
	{
        free(pool->threads);
        pthread_mutex_lock(&(pool->lock));
        pthread_mutex_destroy(&(pool->lock));
        pthread_mutex_lock(&(pool->thread_counter));
        pthread_mutex_destroy(&(pool->thread_counter));
        pthread_cond_destroy(&(pool->queue_not_empty));
        pthread_cond_destroy(&(pool->queue_not_full));
    }

    free(pool);
    pool = NULL;

    return 0;
}

int threadpool_all_threadnum(threadpool_t *pool)
{
    int all_threadnum = -1;

    pthread_mutex_lock(&(pool->lock));
    all_threadnum = pool->live_thr_num;
    pthread_mutex_unlock(&(pool->lock));

    return all_threadnum;
}

int threadpool_busy_threadnum(threadpool_t *pool)
{
    int busy_threadnum = -1;

    pthread_mutex_lock(&(pool->thread_counter));
    busy_threadnum = pool->busy_thr_num;
    pthread_mutex_unlock(&(pool->thread_counter));

    return busy_threadnum;
}

int is_thread_alive(pthread_t tid)
{
    int kill_rc = pthread_kill(tid, 0);     //发0号信号，测试线程是否存活
    if (kill_rc == ESRCH) 
	{
        return false;
    }

    return true;
}

/*测试*/ 

#if 1
/* 线程池中的线程，模拟处理业务 */
void *process(void *arg)
{
    printf("thread 0x%x working on task %d\n ",(unsigned int)pthread_self(),*(int *)arg);
    sleep(1);
    printf("task %d is end\n", *(int *)arg);

    return NULL;
}

int main(void)
{
    /*threadpool_t *threadpool_create(int min_thr_num, int max_thr_num, int queue_max_size);*/
    threadpool_t *thp = threadpool_create(3,100,100);   /*创建线程池，池里最小3个线程，最大100，队列最大100*/
    printf("pool inited");

    //int *num = (int *)malloc(sizeof(int)*20);
    int num[20], i;
    for (i = 0; i < 20; i++) 
	{
        num[i]=i;
        printf("add task %d\n",i);
        threadpool_add(thp, process, (void*)&num[i]);   /* 向线程池中添加任务 */
    }

    sleep(10);                                          /* 等子线程完成任务 */
    threadpool_destroy(thp);

    return 0;
}

#endif
```
]]></description></item><item><title>vscode中配置python调试环境</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/05/17/16282625.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Tue, 17 May 2022 14:09:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/05/17/16282625.html</guid><description><![CDATA[# 1.launch.json
新建launch.json，内容如下：

```
{
    // 使用 IntelliSense 了解相关属性。 
    // 悬停以查看现有属性的描述。
    // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387
    "version": "0.2.0",
    "configurations": [
        {
            "name": "Python: Current File",
            "type": "python",
            "request": "launch",
            "program": "${file}",
            "pythonPath":"/usr/bin/python3",
            "args":[
                
            ],
            "console": "integratedTerminal",
            "justMyCode": true
        }
    ]
}

```
【注】打开哪个文件，就会运行哪个文件。故运行文件A时，记得要打开文件A，然后再点运行。
]]></description></item><item><title>Linux下端口被占用（例如端口3000），关掉端口占用的进程的方法</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/05/17/16282619.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Tue, 17 May 2022 14:06:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/05/17/16282619.html</guid><description><![CDATA[Linux下端口被占用（例如端口3000），关掉端口占用的进程的方法：
```
# 查询进程号
# netstat -tln | grep 8090
sudo lsof -i:8090
# 杀死进程
sudo kill -9 进程号
```]]></description></item><item><title>Label class 79 exceeds nc=79 in /home/zwl/study/ML_DL/yolov5-master/data/cla</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/05/17/16282597.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Tue, 17 May 2022 14:01:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/05/17/16282597.html</guid><description><![CDATA[
错误：
Label class 79 exceeds nc=79 in /home/zwl/study/ML_DL/yolov5-master/data/cla
解决：
txt格式的labels每个种类标的是有序号的，序号从0开始以此递增。
我出现错误的原因是：有79个类，但序号却是从0到21，23到79，缺少了22。
故将序号改为0~79就行了
参考：[此链接的评论区](https://blog.csdn.net/qq_45714906/article/details/120528631)]]></description></item><item><title>组会</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/05/16/16276741.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Mon, 16 May 2022 05:58:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/05/16/16276741.html</guid><description><![CDATA[


检测是否有物体和分类分开进行：互相依赖的，不能分开。
除非说，你检测出人，然后利用得到的人的框，检测这里面有没有救生衣。那还是要有检测人这一项，
检测出物体，是个伪命题，什么是物体。也就说物体必须有明确地指向。即要得到物体的框，就必须要指明物体的类型。







yolov5原理是什么：






问题：
如果你要在八十类上面添加第八十一类。必须考虑：
1.加入第八十一的数据集中，如果图片包含前八十类的，那么就必须把这八十类也框出来，不然就会影响前八十类的检测受到影响。
2.由于要输出八十一类，故需要修改网络结构。故需要将第八十一的数据集和前八十类的数据集都加进去训练。
这就要求我们必须要去检查前八十类的数据集中，如果图片包含第八十一类，就必须要框出来。这个工作量就很大。

解决方法：
1.让第八十一的数据集中只含有一个类，那么第八十一的数据集会过于简单。那么模型就难以预测一个图片中有多个类，因为训练的时候没见过。。
2.coco有八十类。只训练coco的前79类，得到预训练模型，通过预训练模型，增加一类，训练得到80类的模型。
预训练模型跑得需要时间一两天，有时弄错就要重新跑，还没弄完。


问题：
yolov5在八十类的检测中P就0.4多，R就0.6多。故得到这样的模型没有实际的意义。只是为了写论文，刷榜才有用。当类别多了以后，检测出来就不准了。
![](https://user-images.githubusercontent.com/26833433/90222759-949d8800-ddc1-11ea-9fa1-1c97eed2b963.png)

有意义的事，是去识别少量的类。就像临水项目中那样，让检测的准确率高一些（95%以上）


至于用八十类的预训练模型，识别一个类，这就是临时水项目中师兄做的————用预训练模型去实现人员检测，最后达到95%，用了上万的数据集







一百三个轮次以后，概率区域稳定。p:6点多，R：五点多，因为昨晚断电了，忘记截图保存了。
一个用于训练一个类的结果：




# 1200
![](https://img2022.cnblogs.com/blog/1617829/202205/1617829-20220531101954193-1061825470.png)

17个epoch之后模型性能不在提升。反而下降

![](https://img2022.cnblogs.com/blog/1617829/202205/1617829-20220531143113931-2035376920.png)
![](https://img2022.cnblogs.com/blog/1617829/202205/1617829-20220531143257153-646705527.png)


#600

![](https://img2022.cnblogs.com/blog/1617829/202205/1617829-20220531145959997-1829286325.png)

![](https://img2022.cnblogs.com/blog/1617829/202205/1617829-20220531150054621-1786873946.png)

![](https://img2022.cnblogs.com/blog/1617829/202205/1617829-20220531150133106-688146962.png)


# 300   
![](https://img2022.cnblogs.com/blog/1617829/202205/1617829-20220531153152703-1238758818.png)

![](https://img2022.cnblogs.com/blog/1617829/202205/1617829-20220531153210848-160108225.png)

![](https://img2022.cnblogs.com/blog/1617829/202205/1617829-20220531153235899-677496670.png)


# 400
![](https://img2022.cnblogs.com/blog/1617829/202205/1617829-20220531164906867-2056168351.png)

![](https://img2022.cnblogs.com/blog/1617829/202205/1617829-20220531165000918-403547539.png)

![](https://img2022.cnblogs.com/blog/1617829/202205/1617829-20220531165015632-1913259977.png)

超过100个epoch没有提升，就跳出

# 500
![](https://img2022.cnblogs.com/blog/1617829/202205/1617829-20220531193756965-583848355.png)
![](https://img2022.cnblogs.com/blog/1617829/202205/1617829-20220531193905016-491802746.png)

![](https://img2022.cnblogs.com/blog/1617829/202205/1617829-20220531193834294-648608736.png)





不同的类需要的数据量可能不一致？
不可能实验很多个类然后做平均吧，太麻烦了。而且数据集去哪找。可以找到也是个大的工程，
只能说输进去多少，达到多少的准确率。如果你想要更大的准确率，就请多输入点数据。
这就跑个模型，
感觉所有需要跑的人，都可以会跑，，，而且还可以直接改改网络。自己看看想冻结什么网络就冻结什么网络，跑出来效果肯定更好
提供接口供别人轻易地使用？？？
只能说算个大概，





# 只有mask时
## 1200
![](https://img2022.cnblogs.com/blog/1617829/202205/1617829-20220531202938132-1961088668.png)
![](https://img2022.cnblogs.com/blog/1617829/202205/1617829-20220531203444955-1549647547.png)


# 20220606

后端代码的实现流程

视频显示有问题，看ffmpeg、opencv




C++的编译链接问题



  
]]></description></item><item><title>mongoose实现web服务器</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/05/14/16271138.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Sat, 14 May 2022 11:43:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/05/14/16271138.html</guid><description><![CDATA[# 1.简介
Mongoose Web Server是一款易于使用的Web服务器，它可以嵌入到其它应用程序中，为其提供Web接口。
mongoose的代码着实轻量，先看看它的特点：
1. 在整个的实现是使用C语言编写
2. 整个代码也只有一个mongoose.c和mongoose.h两个文件， 从引入第三方的考虑上也着实不多。
3. 实现的功能还是非常多的，从使用的层面上来说功能还是比较全面。只不过不知道是否是为了第三方使用的方便还是怎么地，它的代码只用了两个源文件罢了。诸多的功能也大以宏的开始与结束来区分。
4. 示例非常齐全，所有的功能都有单独的示例。
5.支持夸平台。


# 2.数据结构
## 2.1.mg_mgr

mg_mgr是mongoose中进行事件管理的结构体，事件分为5种类型， 共享同一个回调函数，事件类型通过传参区分。
```
#define MG_EV_POLL 0    /* Sent to each connection on each mg_mgr_poll() call */
#define MG_EV_ACCEPT 1  /* New connection accepted. union socket_address * */
#define MG_EV_CONNECT 2 /* connect() succeeded or failed. int *  */
#define MG_EV_RECV 3    /* Data has been received. int *num_bytes */
#define MG_EV_SEND 4    /* Data has been written to a socket. int *num_bytes */
#define MG_EV_CLOSE 5   /* Connection is closed. NULL */
#define MG_EV_TIMER 6   /* now >= conn->ev_timer_time. double * */
```
完整数据结构如下：
```
/*
 * Mongoose event manager.
 */
struct mg_mgr {
  struct mg_connection *active_connections;
#if MG_ENABLE_HEXDUMP
  const char *hexdump_file; /* Debug hexdump file path */
#endif
#if MG_ENABLE_BROADCAST
  sock_t ctl[2]; /* Socketpair for mg_broadcast() */
#endif
  void *user_data; /* User data */
  int num_ifaces;
  struct mg_iface **ifaces; /* network interfaces */
  const char *nameserver;   /* DNS server to use */
};

#define MG_SOCKET_IFACE_VTABLE \
{ \
mg_socket_if_init, \
mg_socket_if_free, \
mg_socket_if_add_conn, \
mg_socket_if_remove_conn, \
mg_socket_if_poll, \
mg_socket_if_listen_tcp, \
mg_socket_if_listen_udp, \
mg_socket_if_connect_tcp, \
mg_socket_if_connect_udp, \
mg_socket_if_tcp_send, \
mg_socket_if_udp_send, \
mg_socket_if_recved, \
mg_socket_if_create_conn, \
mg_socket_if_destroy_conn, \
mg_socket_if_sock_set, \
mg_socket_if_get_conn_addr, \
}
```
重要成员：
```
active_connections ：当前活动的连接，如果有多个，则以链表形式挂接
ctl：　broadcast 的socket
ifaces：网络相关的接口集合，在linux下默认为socket相关接口 
```


## 2.2. mg_connection
mg_connection是一个具体连接实例 

完整数据结构如下：
```
/*
 * Mongoose connection.
 */
struct mg_connection {
  struct mg_connection *next, *prev; /* mg_mgr::active_connections linkage */
  struct mg_connection *listener;    /* Set only for accept()-ed connections */
  struct mg_mgr *mgr;                /* Pointer to containing manager */

  sock_t sock; /* Socket to the remote peer */
  int err;
  union socket_address sa; /* Remote peer address */
  size_t recv_mbuf_limit;  /* Max size of recv buffer */
  struct mbuf recv_mbuf;   /* Received data */
  struct mbuf send_mbuf;   /* Data scheduled for sending */
  time_t last_io_time;     /* Timestamp of the last socket IO */
  double ev_timer_time;    /* Timestamp of the future MG_EV_TIMER */
#if MG_ENABLE_SSL
  void *ssl_if_data; /* SSL library data. */
#endif
  mg_event_handler_t proto_handler; /* Protocol-specific event handler */
  void *proto_data;                 /* Protocol-specific data */
  void (*proto_data_destructor)(void *proto_data);
  mg_event_handler_t handler; /* Event handler function */
  void *user_data;            /* User-specific data */
  union {
    void *v;
    /*
     * the C standard is fussy about fitting function pointers into
     * void pointers, since some archs might have fat pointers for functions.
     */
    mg_event_handler_t f;
  } priv_1;
  void *priv_2;
  void *mgr_data; /* Implementation-specific event manager's data. */
  struct mg_iface *iface;
  unsigned long flags;
/* Flags set by Mongoose */
#define MG_F_LISTENING (1 << 0)          /* This connection is listening */
#define MG_F_UDP (1 << 1)                /* This connection is UDP */
#define MG_F_RESOLVING (1 << 2)          /* Waiting for async resolver */
#define MG_F_CONNECTING (1 << 3)         /* connect() call in progress */
#define MG_F_SSL (1 << 4)                /* SSL is enabled on the connection */
#define MG_F_SSL_HANDSHAKE_DONE (1 << 5) /* SSL hanshake has completed */
#define MG_F_WANT_READ (1 << 6)          /* SSL specific */
#define MG_F_WANT_WRITE (1 << 7)         /* SSL specific */
#define MG_F_IS_WEBSOCKET (1 << 8)       /* Websocket specific */

/* Flags that are settable by user */
#define MG_F_SEND_AND_CLOSE (1 << 10)       /* Push remaining data and close  */
#define MG_F_CLOSE_IMMEDIATELY (1 << 11)    /* Disconnect */
#define MG_F_WEBSOCKET_NO_DEFRAG (1 << 12)  /* Websocket specific */
#define MG_F_DELETE_CHUNK (1 << 13)         /* HTTP specific */
#define MG_F_ENABLE_BROADCAST (1 << 14)     /* Allow broadcast address usage */
#define MG_F_TUN_DO_NOT_RECONNECT (1 << 15) /* Don't reconnect tunnel */

#define MG_F_USER_1 (1 << 20) /* Flags left for application */
#define MG_F_USER_2 (1 << 21)
#define MG_F_USER_3 (1 << 22)
#define MG_F_USER_4 (1 << 23)
#define MG_F_USER_5 (1 << 24)
#define MG_F_USER_6 (1 << 25)
};
```
结构体重要成员：
```
next、prev：  下、上一个连接
mgr：对应的事件管理
sock： 对应的socket
sa： socket的地址
recv_mbuf、send_mbuf ： 发送和接受的buffer
proto_handler、handler： 协议的回调函数和事件回调函数
```



## 2.3.实现方式

整个流程其实很简单，可分为以下三步

1.mg_mgr_init：先对mgr进行初始化，主要是将相关的socket接口函数集合赋值给mgr.ifaces

2.mg_bind：该步骤主要为一个mg_connection申请内存，并将事件回调函数ev_handler注册到该连接里，并且初始化若干个（由网卡数量决定）http端口的socket进行监听

3.mg_mgr_poll：该函数调用mongoose中提供的poll接口：mg_socket_if_poll。在该函数中，对所有初始化的socket进行select操作,在退出select的阻塞后，根据read_fd_set, write_fd_set, err_fd_set 进行判断，将退出阻塞的socket分类，然后进行分类处理。


# 3.使用 mongoose 实现简单的封装

在https://github.com/cesanta/mongoose中下载mongoose.c和mongoose.h两个文件

HttpService .h 的实现：
```
#pragma once
 
/*
Http服务
*/
 
 
#ifdef _WIN32
#include <winsock2.h>
#include <stdio.h>
#pragma comment(lib,"ws2_32.lib")
#endif
 
#include "mongoose.h"
 
class HttpService {
  public:
    bool start(const char *port);
  private:
    static void mgEvHandler(struct mg_connection *nc, int ev, void *p);
    static void mgSendBody(struct mg_connection *nc, const char *content); //发送body信息
    static void mgSendFile(struct mg_connection *nc, struct http_message *hm, const char* filePath);
    static struct mg_serve_http_opts s_http_server_opts;
};
```
HttpService .cpp 的实现：
```
  
#include "HttpService.h"
 
struct mg_serve_http_opts HttpService::s_http_server_opts;
 
//请求事件处理
void HttpService::mgEvHandler(struct mg_connection *nc, int ev, void *p) { // 形参好像固定是这三种类型
    //处理request
    if (ev == MG_EV_HTTP_REQUEST) {
        struct http_message *msg = (struct http_message *)p;
 
        //body内容
        char* body = new char[msg->body.len + 1];
        memset(body, 0, msg->body.len + 1);
        memcpy(body, msg->body.p, msg->body.len);
 
        //uri内容
        char* uri = new char[msg->uri.len + 1];
        memset(uri, 0, msg->uri.len + 1);
        memcpy(uri, msg->uri.p, msg->uri.len);
 
        //返回body信息
        mgSendBody(nc, "body content");
 
        //返回下载文件
        //mgSendFile("相对于s_http_server_opts.document_root的文件路径");
 
        delete uri;
        delete body;
    }
}
 
//发送body信息
void HttpService::mgSendBody(struct mg_connection *nc, const char *content) {
    mg_send_head(nc, 200, strlen(content), "Content-Type: text/plain\r\nConnection: close");
    mg_send(nc, content, strlen(content));
    nc->flags |= MG_F_SEND_AND_CLOSE;
}
 
//发送文件，文件的位置是相对于s_http_server_opts.document_root的路径
void HttpService::mgSendFile(struct mg_connection *nc, struct http_message *hm, const char* filePath) {
    mg_http_serve_file(nc, hm, filePath, mg_mk_str("text/plain"), mg_mk_str(""));
}
 
//初始化并启动
bool HttpService::start(const char *port) {
    struct mg_mgr mgr;
    struct mg_connection *nc;
 
    mg_mgr_init(&mgr, NULL);
    printf("Starting web server on port %s\n", port);
    nc = mg_bind(&mgr, port, mgEvHandler);
    if (nc == NULL) {
        printf("Failed to create listener\n");
        return false;
    }
 
    // Set up HTTP server parameters
    mg_set_protocol_http_websocket(nc);
    s_http_server_opts.document_root = ".";  //文件相对路径 Serve current directory
    s_http_server_opts.enable_directory_listing = "yes";
 
    for (;;) {
        mg_mgr_poll(&mgr, 1000); //1s轮训一次
    }
    mg_mgr_free(&mgr);
 
    return true;
}

int main(){
	HttpService server;
	server.start("8090");
	return 0;
}
```

运行命令：
```
g++ mongoose.c HttpService.cpp -lpthread -o server
```
HttpService.cpp调用mongoose.c中的函数，即C++中调用c，不知道为什么，可以直接进行编译，不过要加上-lpthread就行










参考：[mongoose(WEB服务器) 简单走读](https://www.cnblogs.com/luo-ruida/p/7732287.html)

[利用mongoose实现http服务](https://blog.csdn.net/houxian1103/article/details/113765217)
[C语言和C++的混合编译](http://c.biancheng.net/view/7494.html)]]></description></item><item><title>vue基础</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/05/12/16264808.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Thu, 12 May 2022 14:50:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/05/12/16264808.html</guid><description><![CDATA[# 1.安装和运行
**1.安装node.js**
node.js下载链接：https://nodejs.org/en/download/
安装node.js以后，npm就默认被安装了
查看是否安装成功
```
node -v
npm -v
```

**2.安装cnpm**
npm国内速度太慢，下载cnpm来用：
```
npm install -g cnpm --registry=https://registry.npm.taobao.org
```
这个过程不用管warning

利用cnpm -v看是否安装成功

**3.安装vue cli**
```
cnpm install -g @vue/cli
vue -V    # 检查是否安装成功
```
```
vue create serv  # 创建项目serv    
cd serv
npm run serve    # 运行项目
```

一些插件的安装：[链接](https://blog.csdn.net/seimeii/article/details/121115540)。使用cnpm安装更快。

**3.vscode中安装eslint**
在vscode中安装eslint:https://www.cnblogs.com/sheseido/p/12357144.html
记得安装完了要重启。
每一次ctrl+s保存后，都会自动格式化

# 2.
HTML DOM 定义了访问和操作 HTML 文档的标准方法。
DOM 以树结构表达 HTML 文档。
![](https://img2022.cnblogs.com/blog/1617829/202205/1617829-20220513101551679-1440404150.png)



CDN：导入远程的在线js文件


# 3.vue语法
参考：[菜鸟教程](https://www.runoob.com/vue3/vue3-intro.html)

在HTML文件中引入 vue.global.js 文件来测试学习。

```
Vue.createApp(HelloVueApp).mount('#hello-vue')   # 将组件HelloVueApp挂载到id为DOM 元素
```














鱼皮的介绍的一些网站，用于制作网站：https://www.bilibili.com/video/BV1CM4y137kF

vue就是一个单纯的前端，没有什么后端的操作吗？？如果是的话，那我直接找一个写好的前端来用，不更省事？？
]]></description></item><item><title>makefile使用</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/05/12/16262239.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Thu, 12 May 2022 06:06:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/05/12/16262239.html</guid><description><![CDATA[# 1.Makefile
## 1.1.Makefile简介
makefile用于编译整个项目.
一个工程中的源文件不计其数，其按类型、功能、模块分别放在若干个目录中，makefile定义了一系列的规则来指定，哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为 makefile就像一个Shell脚本一样，其中也可以执行操作系统的命令。

Makefile带来的好处就是——“自动化编译”，一旦写好，只需要一个make命令，整个工程完全自动编译，极大的提高了软件开发的效率。make是一个命令工具，是一个解释makefile中指令的命令工具，一般来说，大多数的IDE都有这个命令，比如：Delphi的make，Visual C++的nmake，Linux下GNU的make。可见，makefile都成为了一种在工程方面的编译方法。

make主要解决两个问题：
1) 大量代码的关系维护
大项目中源代码比较多，手工维护、编译时间长而且编译命令复杂，难以记忆及维护
把代码维护命令及编译命令写在makefile文件中，然后再用make工具解析此文件自动执行相应命令，可实现代码的合理编译
2) 减少重复编译时间
n 在改动其中一个文件的时候，能判断哪些文件被修改过，可以只对该文件进行重新编译，然后重新链接所有的目标文件，节省编译时间

Makefile文件命名规则：makefile和Makefile都可以，推荐使用Makefile。

make工具的安装：sudo apt install make

## 1.2.make与cmake
不同平台有自己的make标准。如果软件想跨平台，必须要保证能够在不同平台编译。而如果使用上面的 Make 工具，就得为每一种标准写一次 Makefile ，这将是一件让人抓狂的工作。
CMake就是针对上面问题所设计的工具：它首先允许开发者编写一种平台无关的 CMakeList.txt 文件来定制整个编译流程，然后再根据目标用户的平台进一步生成所需的本地化 Makefile 和工程文件，如 Unix 的 Makefile 或 Windows 的 Visual Studio 工程。从而做到“Write once, run everywhere”。
cmake知识可参考：[cmake入门
](https://www.cnblogs.com/codingbigdog/p/16459532.html)


[参考](https://blog.csdn.net/qq_28038207/article/details/80791694)



# 2.Makefile语法规则
## 2.1.一条规则
一条规则：
```
目标：依赖文件列表
<Tab>命令列表
```

Makefile基本规则三要素：
1）目标：
通常是要产生的文件名称，目标可以是可执行文件或其它obj文件，也可是一个动作的名称
2）依赖文件：
- 用来输入从而产生目标的文件
- 一个目标通常有几个依赖文件（可以没有）

3）命令：
- make执行的动作，一个规则可以含几个命令（可以没有）
- 有多个命令时，每个命令占一行
 
示例代码：
```
test:
  echo "hello world"
```
依赖文件可以没有；
echo前面要Tab一下;
```
all:test1  test2
  echo "hello all"

test1:
  echo "hello test1"

test2:
  echo "hello test2"
```
test依赖test1和test2，然后通过test下面代码就可以获取到test1和test2。
依赖test1和test2用空格隔开。
执行命令：make -f 1.mk 
执行结果：
```
echo "hello test1"
hello test1
echo "hello test2"
hello test2
echo "hello all"
hello all
```
还可以执行：
make test1 -f 1.mk   # 执行其他目标
make test1 test2 -f 1.mk  # 执行多个目标


## 2.2.make命令格式
make是一个命令工具，它解释Makefile 中的指令（应该说是规则）。

make命令格式：
make [ -f file ][ options ][ targets ]

**1.[ -f file ]**
make默认在工作目录中寻找名为GNUmakefile、makefile、Makefile的文件作为makefile输入文件
-f 可以指定以上名字以外的文件作为makefile输入文件

**2.[ options ]**

-v： 显示make工具的版本信息
-w： 显示开始处理makefile时所在的工作目录和显示结束makefile文件的处理时所在的工作路径
-C dir：读取目录dir下的makefile文件，如make -C 7makefile/ -f. 1.mk：读取7makefile目录下的1.mk文件
-n：只打印要执行的命令但不执行
-s：执行但不显示执行的命令

**3.[ targets ]**

若使用make命令时没有指定目标，则make工具默认会实现makefile文件内的第一个目标，然后退出
指定了make工具要实现的目标，目标可以是一个或多个（多个目标间用空格隔开）。



## 2.3.Makefile示例
假设有测试程序： test.c add.c sub.c mul.c div.c，内容如下：
```
// add.c
#include "sampleMath.h"
 
int add(int i, int j)
{
	return i + j;
}

// div.c
#include "sampleMath.h"

int div(int i, int j)
{
    if (j != 0)
        return i / j;
    else
        return 0;
}

// sub.c
#include "sampleMath.h"
 
int sub(int i, int j)
{
	return i-j;
}

// mul.c
#include "sampleMath.h"
 
int mul(int i, int j)
{
	return i*j;
}

// sampleMath.h
int add(int i, int j);
int mul(int i, int j);
int sub(int i, int j);
int div(int i, int j);

// test.c
#include <stdio.h>
#include "sampleMath.h"
 
int main(int argc, char *argv[]) 
{
	printf("1 + 2 = %d\n", add(1, 2));
	printf("1/2 = %d\n", div(1, 2));
	printf("1*2 = %d\n", mul(1, 2));
	printf("1-2 = %d\n", sub(1, 2));
	return 0;
}
```


**1.最简单的Makefile**
Makefile文件如下：
```
test:test.c add.c sub.c mul.c div.c
    gcc test.c add.c sub.c mul.c div.c -o test
```
在Makefile所在目录下输入，make即可执行Makefile。
缺点：效率低，修改一个文件，所有文件会被全部编译

**2.第二个版本Makefile**
Makefile文件如下：
```
test:test.o add.o sub.o mul.o div.o
	gcc test.o add.o sub.o mul.o div.o -o test
test.o:test.c
	gcc -c test.c -o test.o
add.o:add.c
	gcc -c add.c -o add.o
sub.o:sub.c
	gcc -c sub.c -o sub.o
mul.o:mul.c
	gcc -c mul.c -o mul.o
div.o:div.c
	gcc -c div.c -o div.o
```
test依赖test.o add.o sub.o mul.o div.o，如果从当前目录中无法找到这些.o文件，那么就会自动在各条规则中是否有相匹配的目标。
对于使用上述Makefile文件，如果修改add.c文件，那么make命令只会重新编译add.c文件，其他文件不会重新编译。
但是这样的文件又长又臭，下面我们将逐步介绍简化的方法。

## 2.4.Makefile中的变量

在Makefile中使用变量有点类似于C语言中的宏定义，使用该变量相当于内容替换，使用变量可以使Makefile易于维护,修改内容变得简单变量定义及使用。

### 2.4.1.自定义变量

1）定义变量方法：
变量名=变量值

2）引用变量：
$(变量名)或${变量名}
 
3）makefile的变量名：
- makefile变量名可以以数字开头
- 变量是大小写敏感的
- 变量一般都在makefile的头部定义
- 变量几乎可在makefile的任何地方使用
 

第三个版本Makefile：

```
#变量
OBJS=add.o sub.o mul.o div.o test.o
TARGET=test
$(TARGET):$(OBJS)
	gcc $(OBJS) -o $(TARGET) 
add.o:add.c
	gcc -c add.c -o add.o​
sub.o:sub.c
	gcc -c sub.c -o sub.o
mul.o:mul.c
	gcc -c mul.c -o mul.o
div.o:div.c
	gcc -c div.c -o div.o
test.o:test.c
	gcc -c test.c -o test.o
clean:
	rm -rf $(OBJS) $(TARGET)
```
除了使用用户自定义变量，makefile中也提供了一些变量（变量名大写）供用户直接使用，我们可以直接对其进行赋值。
> CC = gcc  # 选择gcc作为编译器
CPPFLAGS : C预处理的选项 如:CPPFLAGS = -I
CFLAGS: C编译器的选项 如CFLAGS = -Wall -g -c
LDFLAGS : 链接器选项，如LDFLAGS = -L -l

上述代码运行：make clean # 实现清理工作


### 2.4.2.自动变量
- $@: 表示规则中的目标
- $<: 表示规则中的第一个依赖
- $^: 表示规则中的所有依赖, 组成一个列表, 以空格隔开,如果这个列表中有重复的项则消除重复项。

注意：自动变量只能在规则的命令中使用

第四个版本Makefile：
```
#变量
OBJS=add.o sub.o mul.o div.o test.o add.o
TARGET=test
CC=gcc
$(TARGET):$(OBJS)    # 这里不能使用$^，因为自动变量只能在规则的命令中使用
	$(CC) $^ -o $@   # 等价于#$(CC) $(OBJS) -o $(TARGET) 
	echo $@          # 输出看看$@是不是目标
	echo $<
	echo $^
add.o:add.c
	$(CC) -c $< -o $@ 
sub.o:sub.c
	$(CC) -c $< -o $@ 
mul.o:mul.c
	$(CC) -c $< -o $@ 
div.o:div.c
	$(CC) -c $< -o $@ 
test.o:test.c
	$(CC) -c $< -o $@
clean:
	rm -rf $(OBJS) $(TARGET)
```


### 2.4.3.模式规则
模式规则示例:
```
%.o:%.c
```
第五个版本Makefile：
```
OBJS=test.o add.o sub.o mul.o div.o
TARGET=test
$(TARGET):$(OBJS)
    gcc $(OBJS) -o $(TARGET) 

%.o:%.c               ​# 模式匹配所有的.o都依赖对应的.c
    gcc -c $< -o $@   # 将所有的.c生成对应的.o
clean:
    rm -rf $(OBJS) $(TARGET)
```




# 3.Makefile中的函数
```
makefile中的函数有很多，在这里给大家介绍两个最常用的。

wildcard – 查找指定目录下的指定类型的文件
src = $(wildcard *.c) //找到当前目录下所有后缀为.c的文件,赋值给src

patsubst – 匹配替换
obj = $(patsubst %.c,%.o, $(src)) //把src变量里所有后缀为.c的文件替换成.o
```
在makefile中所有的函数都是有返回值的。

第六个版本Makefile：
```
SRC=$(wildcard *.c)
OBJS=$(patsubst %.c, %.o, $(SRC))
TARGET=test
$(TARGET):$(OBJS)
    gcc $(OBJS) -o $(TARGET) 
%.o:%.c
    gcc -c $< -o $@
clean:
    rm -rf $(OBJS) $(TARGET)
```


# 4.Makefile中的伪目标
clean用途: 清除编译生成的中间.o文件和最终目标文件
make clean 如果当前目录下有同名clean文件，则不执行clean对应的命令，解决方案：

伪目标声明: .PHONY:clean
声明目标为伪目标之后，makefile将不会该判断目标是否存在或者该目标是否需要更新，而是直接执行Makefile中的clean命令


第七个版本Makefile：
```
SRC=$(wildcard *.c)
OBJS=$(patsubst %.c, %.o, $(SRC))
TARGET=test
$(TARGET):$(OBJS)
    gcc $(OBJS) -o $(TARGET) 
​
%.o:%.c
    @gcc -c $< -o $@  # 最前面加了一个"@"，代表只执行不显示执行命令
.PHONY:clean
clean:
    -rm -rf $(OBJS) $(TARGET) # 最前面加了一个"-"，代表此条命令出错，make也会继续执行后续的命令
```
**命令中的特殊符号：**
- “-”此条命令出错，make也会继续执行后续的命令。如:“-rm main.o”
- “@”不显示命令本身,只显示结果。如:“@echo clean done”

总结： 一条规则，两个函数，三个变量。



# 5.Makefile工作原理
**1.生成目标**
若想生成目标, 检查规则中的依赖条件（依赖文件）是否存在,如不存在,则寻找是否有规则用来生成该依赖文件
![](https://img2022.cnblogs.com/blog/1617829/202205/1617829-20220512191937952-1478668155.png)

比如：
```
test:test.o add.o sub.o mul.o div.o
	gcc test.o add.o sub.o mul.o div.o -o test
test.o:test.c
	gcc -c test.c -o test.o
add.o:add.c
	gcc -c add.c -o add.o
sub.o:sub.c
	gcc -c sub.c -o sub.o
mul.o:mul.c
	gcc -c mul.c -o mul.o
div.o:div.c
	gcc -c div.c -o div.o
```
上述代码，目标test依赖test.o，但是目录下没有test.o文件，此时就在Makefile中寻找是否有目标为test.o的规则，最后通过规则生成test.o。
先在目录下查找test.o，如果没有找到，再去查找是否有生成test.o的规则。
**2.更新目标**
检查规则中的目标是否需要更新，必须先检查它的所有依赖,依赖中有任一个被更新,则目标必须更新
![](https://img2022.cnblogs.com/blog/1617829/202205/1617829-20220512192631759-2011245100.png)

from 黑马程序员笔记





# 6.其他

## 6.1.“=”与“:=”
**“=”：**make会将整个makefile展开后，再决定变量的值。也就是说，变量的值将会是整个makefile中最后被指定的值。看例子：
```
x = foo
y = $(x) bar
x = xyz
```
在上例中，y的值将会是 xyz bar ，而不是 foo bar 。


**“:=”：**表示变量的值决定于它在makefile中的位置，而不是整个makefile展开后的最终值。
```
x := foo
y := $(x) bar
x := xyz
```
在上例中，y的值将会是 foo bar ，而不是 xyz bar 了。

参考：[Makefile 中:= ?= += =的区别](https://www.cnblogs.com/wanqieddy/archive/2011/09/21/2184257.html)

##6.2.ifeq、ifneq、ifdef和ifndef（条件判断）

ifeq 和 ifneq：判断两个参数是否相等



注意：条件语句只能用于控制 make 实际执行的 Makefile 文件部分，不能控制规则的 shell 命令执行的过程。
上面这句是什么意思？

参考：[Makefile ifeq、ifneq、ifdef和ifndef（条件判断）](http://c.biancheng.net/view/7068.html)



## 6.5 .PHONY的作用
**.PHONY的作用一：不产生目标文件**
.PHONY是一个伪目标，Makefile中将.PHONY放在一个目标前就是指明这个目标是伪文件目标。其作用就是防止在Makefile中定义的执行命令的目标和工作目录下的实际文件出现名字冲突。例子如下：
```
clean :
  rm *.o temp
```
上述Makefile文件在第一次执行make clean以后会产生clean文件，导致第二次运行make clean失败。
```
.PHONY : clean
clean :
  rm *.o temp
```
上述Makefile文件在第一次执行make clean以后不会产生clean文件，不会导致第二次运行make clean失败。


**.PHONY的作用二：编译多个文件**
```
all : prog1 prog2 prog3
.PHONY : all
prog1 : prog1.o utils.o
  cc -o prog1 prog1.o utils.o
prog2 : prog2.o
  cc -o prog2 prog2.o
prog3 : prog3.o sort.o utils.o
  cc -o prog3 prog3.o sort.o utils.o
```
上述Makefile文件设置了伪目标all，执行Makefile不会生成all文件，但是all的依赖文件prog1、prog2和prog3会被生成。
这样我们就使用Makefile文件编译生成了三个可执行文件——prog1、prog2和prog3。



参考：[如何用一个makefile编译多个目标](https://blog.csdn.net/a815064247/article/details/79442567)



## 6.4.一个makefile示例
makefile的示例学习。本代码摘录于具体项目，有完整的注释，直接看代码学习即可。
```
cc        := g++
name      := pro
workdir   := workspace
srcdir    := src
objdir    := objs
stdcpp    := c++11
syslib    := /home/xd2/.local/lib/python3.6/site-packages/trtpy/lib
cpp_pkg   := /home/zwl/software


cpp_srcs := $(shell find src -name "*.cpp") # 查找src目录下所有.cpp文件，返回字串，示例：src/1.cpp src/2.cpp src/3.cpp
cpp_objs := $(cpp_srcs:.cpp=.o)				# 将cpp_srcs中的.cpp后缀改为.o后缀，返回字串，示例:src/1.o src/2.o src/3.o
cpp_objs := $(cpp_objs:src/%=objs/%)		# 将src/改为objs
cpp_mk   := $(cpp_objs:.o=.mk)				# makefile (mk)文件

c_srcs := $(shell find src -name "*.c")
c_objs := $(c_srcs:.c=.co)
c_objs := $(c_objs:src/%=objs/%)
c_mk   := $(c_objs:.co=.cmk)




include_paths := src              \
	$(cpp_pkg)/opencv4.2/include/opencv4 \
	/home/zwl/software/anaconda3/envs/yolov5Env/include/python3.9


library_paths := $(syslib) $(cpp_pkg)/opencv4.2/lib /home/zwl/software/anaconda3/envs/yolov5Env/lib


# link_librarys := opencv_core opencv_imgproc opencv_videoio  opencv_imgcodecs opencv_highgui \
			stdc++ dl
link_librarys := stdc++ dl python3.9			# 动态库的动态链接需要dl，否则报错。

paths := $(foreach item,$(library_paths),-Wl,-rpath=$(item)) 	 # 循环将$(library_paths)中的单词取出来放进item，然后执行表达式-Wl,-rpath=$(item)
																 # 返回的结果为-Wl,-rpath=item1 -Wl,-rpath=item2 -Wl,-rpath=item3等
																 # -Wl,-rpath=指定运行时链接到的库
include_paths := $(foreach item,$(include_paths),-I$(item))		 # 编译程序按照-I指定的路径进去搜索头文件
library_paths := $(foreach item,$(library_paths),-L$(item))		 # -L指定的路径会被优先搜索
link_librarys := $(foreach item,$(link_librarys),-l$(item))		 # -L用于指定库所在的目录，-l用于指定具体的库

# 如果是其他显卡，请修改-gencode=arch=compute_75,code=sm_75为对应显卡的能力
# 显卡对应的号码参考这里：https://developer.nvidia.com/zh-cn/cuda-gpus#compute
# 如果是 jetson nano，提示找不到-m64指令，请删掉 -m64选项。不影响结果
cpp_compile_flags := -std=c++11 -fPIC -m64 -g -fopenmp -w -O0 # The -m64 option sets int to 32bits and long and pointer to 64 bits and generates code for AMD’s x86-64 architecture.  
															  # 如果想用调试器执行一个可执行文件， 在用gcc编译时必须加上-g选项
															  # -fopenmp：开启多线程支持
															  # -w：关闭编译时的警告，编译后不显示任何warning，因为有时在编译之后编译器会显示一些例如数据转换之类的警告，这些警告是我们平时可以忽略的。
															  # -O0：最少的优化，产生最多代码调试信息
link_flags        := -pthread -fopenmp -Wl,-rpath='$$ORIGIN'  # '$$ORIGIN'表示当前路径，'pwd'也表示当前路径

cpp_compile_flags += $(include_paths) 	# +=用于添加单词
link_flags 		  += $(library_paths) $(link_librarys) $(paths)

ifneq ($(MAKECMDGOALS), clean) # make clean时，不起作用
-include $(cpp_mk) $(c_mk)     # 忽略当前此行命令执行时候所遇到的错误。比如删除一个不存在的文件等，那么也不要管，继续执行make。
							   # include命令可以用来引入其他makefile文件。-include代表不引入这些makefile文件
endif

pro    : workspace/pro
workspace/pro : $(c_objs) $(cpp_objs)
	@echo Link $@
	@mkdir -p $(dir $@)	# dir取出$@的目录部分。mkdir -p 确保目录名称存在，不存在的就建一个
	@g++ $^ -o $@ $(link_flags) 

objs/%.o : src/%.cpp		# .o文件就是静态库文件
	@echo Compile CXX $<
	@mkdir -p $(dir $@)
	@g++ -c $< -o $@ $(cpp_compile_flags) $(link_flags)

objs/%.co : src/%.c
	@echo Compile C $<
	@mkdir -p $(dir $@)
	@g++ -c $< -o $@ $(cpp_compile_flags)

objs/%.mk : src/%.cpp
	@echo Compile depends CXX $<
	@mkdir -p $(dir $@)
	@g++ -M $< -MF $@ -MT $(@:.mk=.o) $(cpp_compile_flags)           		
# -M输出$<依赖哪些头文件。-MF将-M输出的内容放入$@中
# g++ -M main.cpp -MF main.mk：mian.mk中存储的是main.o的依赖。
# -MT重新定义目标对象名,比如将上面的目标mian.o改为hello.o。默认的目标对象名和源文件相同
# g++ -M main.cpp -MF main.mk -MT hello.o
# 由于默认的目标对象名和源文件相同，故-MT $(@:.mk=.o)可以去掉
# $(@:.mk=.o)将$@中的每个.mk结尾字串的后缀改变为.o结尾的后缀


objs/%.cmk : src/%.c   # linux下后缀名一般不起作用，怎么方便怎么取
	@echo Compile depends C $<
	@mkdir -p $(dir $@)
	@g++ -M $< -MF $@ -MT $(@:.cmk=.o) $(cpp_compile_flags)   
	

run : workspace/pro
	@cd workspace && ./pro

debug :
	@echo $(includes)

clean :
	@rm -rf objs workspace/pro build

.PHONY : clean run debug

```






 
]]></description></item><item><title>源码查看</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/05/11/16258345.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Wed, 11 May 2022 08:00:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/05/11/16258345.html</guid><description><![CDATA[
源码阅读：https://github.com/shouxieai/tensorRT_Pro/tree/main/restful_server

# 组会
想要实现检测视频流，而不是检测一张一张图片


# 整体流程
使用mongoose网络库作为底层的数据收发。
yolov5推理器放在一个类中进行实现。只要在写controller子类的时候，添加一个推理器对象就可以了。
controller的作用


整体的流程是创建controller和server，将链接和处理函数的对应关系放在controller中，然后将controller加入到server中。
初始化server：
- 绑定用于处理request和close的函数。
- 开启一个线程搁那循环，用于监听用户的请求。
- 开启num_threads个线程。每个线程用于处理一个连接（会话）。（为啥不用epoll，是因为mongoose内部已经用来poll了吗？）。线程的处理函数都是worker_thread_proc，worker_thread_proc不断监听队列job_中的会话。

当一个请求到来的时候，
1.会调用HttpServerImpl::on_http_event函数处理请求。
2.在HttpServerImpl::on_http_event中首先创建一个新的会话A，然后对请求进行解析，将请求中的请求方法、url、body等东西提取出来，放进会话A的request结构体中。最后将会话A放进会话队列jobs_中。
3.线程worker_thread_proc监听到jobs_存在会话时，会取出会话中的url，并调用此url对应的处理函数。





# 任务和问题
1.服务器用C++写，算法使用python进行实现，如何在C++中调用python写的算法？
答：1.在C++中调用python脚本
2.用C++写算法。
3.在C++调用python的函数。python中设计一个接口函数，C++中调用接口函数从而实现对算法的调用。


2.习惯每日对git的使用


3.将检测结果放入数据库中。将图片post到后台，后台进行检测，将输出的结果存储到相应的目录下，将此图片的路径存储在数据库中。
保存所有检测图片，保证图片命令不重复。


4.输入图片的格式有所限制——自动判断图片类型


5.配合石中西修改json

6.只能保存图片后检测图片——直接提供视频流检测接口。

7.controller类是个父类。如果通过子类继承，进行实现各种控制器，为什么要怎么设计，具体是如何设计的？？

8.给石中西和张鑫玉提供相同的接口才行。

9.只能收mp4文件、返回avi文件：前端判断一下是什么类型，然后发送给我不就行了。


10.mongoose源码阅读：[mongoose的详细说明](https://github.com/cesanta/mongoose/tree/master/docs)
jsoncpp使用、jsoncpp源码阅读
libevent源码阅读
freecplus源码学习：https://freecplus.net/9ebb8276265b404488a3415be224ed85.html，可不看。。

11.登录功能：
登录以后，通过cookie判断是否为正确用户？
用户密码正确，则启动检测并返回结果。

12.上传大文件——实现在线训练功能
![](https://img2022.cnblogs.com/blog/1617829/202206/1617829-20220614152445159-952359619.png)


13.根据师兄发的流程图进行学习


14.vim和vscode结合使用

15.bug: 接收的东西不对时，session->request.body.substr(i1)中的i1就会发生下标越界。


16.放不同模型上去，让人感觉有很多功能。

17.学会修改网络，成为基本的调参侠。

18.口罩检测性能还不是很好

# 小知识
**什么是前后端分离？**
答：我觉得就是前后端只使用json格式的数据进行交互

前后端交互方式
前端占用一个端口运行前端界面，
后端占用一个端口运行后端，等待前端调用相应接口，

为什么github中jsoncpp是个项目，而https://github.com/shouxieai/tensorRT_Pro/tree/main/restful_server
中jsoncpp只包含了json.cpp和json.hpp？？
答：项目restful_server的作者将jsoncpp中的多个.cpp文件都拷贝到了json.cpp中，将jsoncpp中的多个.h文件都拷贝到了json.h中，这可以通过json.cpp和json.h的注释中看出来。








post发送文件的格式
服务器端：首先通过Content-Type获取body的编码方式，然后根据编码方式解析出body中的文件。post传输视频时，Content-Type为application/octet-stream，application/octet-stream格式如下


浏览器：
在某些下载文件的场景中，服务端可能会返回文件流，并在返回头中带上Content-Type:application/octet-stream，告知浏览器这是一个字节流，浏览器处理字节流的默认方式就是下载。Content-Type为application/octet-stream时，一般会配合另一个响应头Content-Disposition，该响应头指示回复的内容该以何种形式展示，是以内联的形式（即网页或者页面的一部分），还是以附件的形式下载并保存到本地。
[响应头Content-Type与Content-Disposition的区别](https://blog.csdn.net/LKJgdut/article/details/104249679)

在客户端，Get方式在通过URL提交数据，数据在URL中可以看到；POST方式，数据放置在HTML HEADER内提交。



rtp c++ 网络视频传输
[C++实现RTSP/RTP服务器](https://blog.csdn.net/longruic/article/details/115817371)
码流是一帧一帧的图片数据，所以传输的时候也是一帧帧来传输的，因此这里就会涉及到各种类型的帧处理了
传过来是字节，如何从字节中获取图片，如何将图片组合成视频，视频的编码是什么







https://blog.csdn.net/yaojiawan/article/details/90260155   restbed -C++ restfull 架构的应用


弄好之后，在vscode命令行下输入：”code .“，就可以用vscode打开当前目录
规范代码快捷键:vscode: shift+alt+F，或者安装某个插件以后，就可以通过ctrl+s进行规范

ctrl+点击：跳转到函数的定义，或在函数定义处使用可查看函数在哪些地方使用了


bind：将已有的变量绑定给函数的形参，并将这个函数作为返回值返回。如果有形参不需要绑定已有变量，就使用占位符进行占位，等到实际调用函数的时候再传入实参。
参考：[链接](https://blog.csdn.net/u013654125/article/details/100140328)
[链接2](https://www.cnblogs.com/yunyuanfeng/p/15032506.html)


typedef int (*func)()  // 定义一种类型func。func声明的变量用于指向返回值为int且形参为空的函数。
所以typedef int (*func)()可以用于实现多态，即同一个函数调用语句，会由于指向函数的不同，而产生不同的效果（多态）
C++11中使用function来代替上述内容
[链接1](https://blog.csdn.net/baoendemao/article/details/41209697)
[链接2](https://zhuanlan.zhihu.com/p/161356621)
]]></description></item><item><title>libevent简介</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/05/09/16251389.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Mon, 09 May 2022 14:40:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/05/09/16251389.html</guid><description><![CDATA[# 1.libevent安装
**1.下载：**在https://libevent.org/中找到安装包并下载
**2.解压：**tar -zxvf libevent-2.1.11-stable.tar.gz

**3.配置安装路径**
```
cd libevent-2.1.11-stable 
 ./configure --prefix=/home/server/projects/test/libeventTest/libevent # 执行configure ,检测环境生成makefile。这里的安装目录请设定为自己的
```
如果不设置prefix，则默认为**/usr/local/lib**。
如果提示错误：
```
configure: error: openssl is a must but can not be found. You should add the directory containing `openssl.pc' to the `PKG_CONFIG_PATH' environment variable, or set `CFLAGS' and `LDFLAGS' directly for openssl, or use `--disable-openssl' to disable support for openssl encryption
```
一般为openssl库的缘故，需要安装openssl，一般ubuntu自带openssl，这里需要openssl-devel，要注意的是在ubuntu中需要使用sudo apt-get install libssl-dev来安装而不是sudo apt-get install openssl-devel。
然后重新执行：
./configure --prefix=/home/server/projects/test/libeventTest/libevent
**4.编译和安装**
```
sudo make && make install
```
安装以后，目录/home/server/projects/test/libeventTest/libevent的结构如下：
```
tree -L 1

├── bin
├── include  # 头文件
└── lib      # 库文件
```




测试代码demo.c：
```
#include <event.h>
#include <stdio.h>

int main()
{
    char ** methods = event_get_supported_methods();//获取libevent后端支持的方法
    int i =0;
    for(i = 0;methods[i] != NULL ;i++)
    {
        printf("%s\n",methods[i]);
    }
    struct event_base * base = event_base_new();
    printf("当前使用的方法：%s\n",event_base_get_method(base));
    return 0;
}
```
编译和运行：
```
gcc demo.c -o demo.out -I ./libevent/include -L ./libevent/lib/ -l event -Wl,-rpath=./libevent/lib/
./demo.out
```


参考：[libevent安装教程](https://blog.csdn.net/superhoner/article/details/112001995)




# 2.libevent API
**1.创建和释放根节点**
创建event_base根节点
```
struct event_base *event_base_new(void);
```
返回值值就是event_base根节点地址

释放根节点
```
void event_base_free(struct event_base *);
```
**2.循环监听**
循环监听:
```
int event_base_dispatch(struct event_base *base);
```
相当于 while(1){epoll_wait}循环监听。【epoll用于监听多个文件描述符上的事件。epoll_wait函数获取就绪事件】
退出循环监听:
```
int event_base_loopexit(struct event_base *base, const struct timeval *tv); //等待固定时间之后退出
int event_base_loopbreak(struct event_base *base);//立即退出
```

**3.libevent事件触发流程**
![](https://img2022.cnblogs.com/blog/1617829/202205/1617829-20220510101602527-1064024598.png)

流程:1.创建事件监听节点 2. 添加文件描述符进行循环监听


**4.构建节点用于上树（即将文件描述符、监听事件和回调函数包装成一个特定的结构event，这个结构称为一个节点）**
```
struct event *event_new(struct event_base *base, evutil_socket_t fd, short events, event_callback_fn cb, void *arg);
参数:
base: event_base根节点
fd: 上树的文件描述符
events: 监听的事件
   #define  EV_TIMEOUT         0x01   //超时事件
   #define  EV_READ                  0x02 //读事件
   #define  EV_WRITE                0x04  //写事件
   #define  EV_SIGNAL              0x08     //信号事件
   #define  EV_PERSIST              0x10   //周期性触发,起到循环监听的作用
   #define  EV_ET      
cb: 回调函数
   typedef void (*event_callback_fn)(evutil_socket_t fd, short events, void *arg);
arg: 传给回调函数的参数
返回值: 初始化好的节点的地址
```

**5.节点上树和下树**
上树：
```
int event_add(struct event *ev, const struct timeval *timeout);

ev: 上树节点的地址
timeout: NULL：永久监听  固定时间：限时等待
```

下树:
```
int event_del(struct event *ev);
ev: 下树节点的地址
```

# 3.使用libevent编写tcp服务器流程

示例代码01_event_tcp_server.c：
```
#include <stdio.h>
#include "wrap.h"  
#include <event.h>

void cfdcb(int cfd,short event,void *arg)
{
	char buf[1500]="";
	
	int n = Read(cfd,buf,sizeof(buf));
	if(n <= 0)
	{
		perror("err or close\n");
		//event_del();//下树。这里下树，是有问题的
	
	}
	else
	{
		printf("%s\n",buf);
		Write(cfd,buf,n);
	
	}

}
void lfdcb(int lfd,short event,void *arg)
{
	struct event_base *base = (struct event_base *)arg; 
	//提取新的cfd
	int cfd = Accept(lfd,NULL,NULL);
	//将cfd上树
	struct event *ev = event_new(base,cfd,EV_READ | EV_PERSIST,cfdcb,NULL);//初始化上树节点
	event_add(ev,NULL);
	
}
int main(int argc, char *argv[])
{
	//创建套接字
	//绑定
	int lfd = tcp4bind(8000,NULL);
	//监听
	Listen(lfd,128);
	//创建event_base根节点
	struct event_base * base = event_base_new();
	//构建节点用于上树，即将文件描述符、监听事件和回调函数包装成一个特定的结构event。
	struct event *ev = event_new(base,lfd,EV_READ | EV_PERSIST,lfdcb,base);
	//上树
	event_add(ev,NULL);
	//循环监听（阻塞了）
	event_base_dispatch(base);//阻塞
	//收尾
	close(lfd);
	event_base_free(base);
	return 0;
}
```
编译命令：gcc 01_event_tcp_server.c -o 01_event_tcp_server.c -levent
本代码未进行下树操作，是有问题的。
修改代码如下：
```
#include <stdio.h>
#include <vector>
#include "wrap.h"
#include "event.h"
#include<iostream>
#define MAX_CLI_ENT 1024
using namespace std;

typedef struct FdEventMap
{
	int fd;			  //文 件描述符
	struct event *ev; //对应事件
} FdEvent;

vector<FdEvent> mFdEvents;

void cfdcb(int cfd, short event, void *arg)
{
	char buf[1500] = "";

	int n = Read(cfd, buf, sizeof(buf));
	if (n <= 0)
	{
		perror("error close\n");

		// 下树
		vector<FdEvent>::iterator itor = mFdEvents.begin();
		for (; itor != mFdEvents.end(); ++itor)
		{
			if (itor->fd == cfd)
			{
				event_del(itor->ev);
				close(itor->fd);
				mFdEvents.erase(itor);
				break;
			}
		}
	}
	else
	{
		printf("%s\n", buf);
		Write(cfd, buf, n);
	}
}
void lfdcb(int lfd, short event, void *arg)
{
	struct event_base *base = (struct event_base *)arg;
	//提取新的cfd
	int cfd = Accept(lfd, NULL, NULL);
	//将cfd上树
	struct event *ev = event_new(base, cfd, EV_READ | EV_PERSIST, cfdcb, NULL); //初始化上树节点
	event_add(ev, NULL);
	FdEvent temp;
	temp.ev = ev;
	temp.fd = cfd;
	mFdEvents.push_back(temp);
}
int main(int argc, char *argv[])
{
	//创建套接字
	//绑定
	int lfd = tcp4bind(8001, NULL);
	//监听
	Listen(lfd, 128);
	//创建event_base根节点
	struct event_base *base = event_base_new();
	//构建节点用于上树，即将文件描述符、监听事件和回调函数包装成一个特定的结构event。
	struct event *ev = event_new(base, lfd, EV_READ | EV_PERSIST, lfdcb, base);
	//上树
	event_add(ev, NULL);
	FdEvent temp;
	temp.ev = ev;
	temp.fd = lfd;
	mFdEvents.push_back(temp);
	//循环监听（阻塞了）
	event_base_dispatch(base); //阻塞
							   //收尾
							   // 下树
	for (vector<FdEvent>::iterator itor = mFdEvents.begin(); itor != mFdEvents.end(); itor++)
	{
		close(itor->fd);
		event_del(itor->ev);
	}

	event_base_free(base);
	return 0;
}
```

# 4.bufferevent事件 
普通的event事件：文件描述符   事件(底层缓冲区的读事件或者写事件) 触发    回调
bufferevent事件： 应用层有两个缓冲区（读/写缓冲区），每个缓冲区对应一个回调函数，此外还有一个事件的回调函数，总共3个回调函数。

![](https://img2022.cnblogs.com/blog/1617829/202205/1617829-20220511230236886-905309846.png)





## 4.1.bufferevent事件的API
**1.创建新的节点**
```
struct bufferevent *bufferevent_socket_new(struct event_base *base, evutil_socket_t fd, int options);

参数: 
    base  : event_base 根节点
    fd: 要初始化上树的文件描述符
    options : 
           BEV_OPT_CLOSE_ON_FREE   -- 释放bufferevent自动关闭底层接口   
           BEV_OPT_THREADSAFE      -- 使bufferevent能够在多线程下是安全的    
返回值:
   新建节点的地址
```

**2.设置回调函数并进行上树**

使用bufferevent_setcb就可以设置回调函数并进行上树
```
void bufferevent_setcb(struct bufferevent *bufev,
    bufferevent_data_cb readcb, 
    bufferevent_data_cb writecb,
    bufferevent_event_cb eventcb, void *cbarg);


参数:
    bufev : 新建的节点的地址
    readcb : 读回调
    writecb : 写回调
    eventcb : 异常回调
    cbarg: 传给回调函数的参数
```
bufferevent_setcb设置节点对应文件描述符事件触发的回调并进行上树。

回调函数长下面这样：
```
typedef void (*bufferevent_data_cb)(struct bufferevent *bev, void *ctx);             // 读写回调
typedef void (*bufferevent_event_cb)(struct bufferevent *bev, short what, void *ctx);// 事件回调

What代表对应的事件:
    BEV_EVENT_EOF, 对方关闭连接
    BEV_EVENT_ERROR，出错
    BEV_EVENT_TIMEOUT,超时
    BEV_EVENT_CONNECTED 建立连接成功
```

bufferevent_setcb自动监听三个事件（读、写和异常），下面函数用于设置是否在发生某个事件（读、写和异常）的时候触发回调函数
int bufferevent_enable(struct bufferevent *bufev, short event);//EV_READ  EV_WRITE,异常事件也被当成EV_READ
int bufferevent_disable(struct bufferevent *bufev, short event);//EV_READ  EV_WRITE,异常事件也被当成EV_READ



**3.发送数据**
```
int bufferevent_write(struct bufferevent *bufev, const void *data, size_t size);
bufferevent_write是将data的数据写到bufferevent的写缓冲区。写进应用层的写缓冲区，而不是写进内核的写缓冲区。如果内核的写缓冲区有空间，那么应用层的写缓冲区里的内容会进一步放到内核的写缓冲区，从而触发写事件。
```

**4.接收数据**
```
size_t bufferevent_read(struct bufferevent *bufev, void *data, size_t size);
bufferevent_read 是将bufferevent的读缓冲区数据读到data中，同时将读到的数据从bufferevent的读缓冲清除。
```

更详细的bufferevent说明，请见黑马程序员课程发的doc文件。 

## 4.2.连接侦听器
连接侦听器用于创建套接字、绑定、监听和提取
```
struct evconnlistener *evconnlistener_new_bind(struct event_base *base,
        evconnlistener_cb cb, 
        void *ptr, unsigned flags, int backlog,
        const struct sockaddr *sa, int socklen);

参数: 
    base : base根节点
    cb : 通过accept得到套接字以后调用的回调函数 
    ptr : 传给回调的参数
    flags : 
         LEV_OPT_LEAVE_SOCKETS_BLOCKING   文件描述符为阻塞的
         LEV_OPT_CLOSE_ON_FREE            关闭时自动释放
         LEV_OPT_REUSEABLE                端口复用
         LEV_OPT_THREADSAFE               分配锁，线程安全
         flags经常写为LEV_OPT_CLOSE_ON_FREE|LEV_OPT_REUSEABLE
    backlog : -1
    sa : 绑定的地址信息
    socklen : sa的大小
    
返回值: 连接侦听器的地址
```


cb的原型如下：
```
typedef void (*evconnlistener_cb)(struct evconnlistener *evl, evutil_socket_t fd, struct sockaddr *cliaddr, int socklen, void *ptr);
参数:
    evl :  链接侦听器的地址
    fd :  cfd
    cliaddr: 客户端的地址信息
    ptr:  evconnlistener_new_bind传过来的参数
```
 


## 4.3.创建套接字 连接服务器
```
struct bufferevent *bufferevent_socket_new(struct event_base *base,-1, int options);
int bufferevent_socket_connect(struct bufferevent *bev, struct sockaddr *serv, int socklen);
    bev: 新建的节点
    serv: 服务器的地址信息
    socklen: serv长度
```

## 4.4.bufferevent实现tcp服务器
helloworld.c:
```
/*
  This exmple program provides a trivial server program that listens for TCP
  connections on port 9995.  When they arrive, it writes a short message to
  each client connection, and closes each connection once it is flushed.

  Where possible, it exits cleanly in response to a SIGINT (ctrl-c).
*/


#include <string.h>
#include <errno.h>
#include <stdio.h>
#include <signal.h>
#ifndef WIN32
#include <netinet/in.h>
# ifdef _XOPEN_SOURCE_EXTENDED
#  include <arpa/inet.h>
# endif
#include <sys/socket.h>
#endif

#include <event2/bufferevent.h>
#include <event2/buffer.h>
#include <event2/listener.h>
#include <event2/util.h>
#include <event2/event.h>

static const char MESSAGE[] = "Hello, World!\n";

static const int PORT = 9995;

static void conn_readcb(struct bufferevent *bev, void *user_data);
static void listener_cb(struct evconnlistener *, evutil_socket_t,
    			struct sockaddr *, int socklen, void *);
static void conn_writecb(struct bufferevent *, void *);
static void conn_eventcb(struct bufferevent *, short, void *);
static void signal_cb(evutil_socket_t, short, void *);

int main(int argc, char **argv)
{
	struct event_base *base;
	struct evconnlistener *listener;
	struct event *signal_event;

	struct sockaddr_in sin;
#ifdef WIN3 // 配置一些环境
	WSADATA wsa_data;
	WSAStartup(0x0201, &wsa_data);
#endif

	base = event_base_new();//创建event_base根节点
	if (!base) {
		fprintf(stderr, "Could not initialize libevent!\n");
		return 1;
	}

	memset(&sin, 0, sizeof(sin)); // 这里已经将IP设为0.0.0.0
	sin.sin_family = AF_INET;
	sin.sin_port = htons(PORT);

	//创建链接侦听器
	listener = evconnlistener_new_bind(base, listener_cb, (void *)base,
	    			LEV_OPT_REUSEABLE|LEV_OPT_CLOSE_ON_FREE, -1,
	    			(struct sockaddr*)&sin,
	    			sizeof(sin));

	if (!listener) {
		fprintf(stderr, "Could not create a listener!\n");
		return 1;
	}

	//创建信号触发的节点。evsignal_new就是event_new，定义如下：#define evsignal_new(b, x，cb,arg) event_new((b),(x)+EV_SIGNAL | EV_PERSIST,(cb),(arg)) 
	signal_event = evsignal_new(base, SIGINT, signal_cb, (void *)base); // event_new构建节点用于上树
	//将信号节点上树
	if (!signal_event || event_add(signal_event, NULL)<0) { // event_add用于上树
		fprintf(stderr, "Could not create/add a signal event!\n");
		return 1;
	}

	event_base_dispatch(base);//循环监听

	evconnlistener_free(listener);//释放链接侦听器
	event_free(signal_event);//释放信号节点
	event_base_free(base);//释放event_base根节点

	printf("done\n");
	return 0;
}

static void
listener_cb(struct evconnlistener *listener, evutil_socket_t fd,
    struct sockaddr *sa, int socklen, void *user_data)
{
	struct event_base *base = user_data;
	struct bufferevent *bev;

	//将fd上树
	//新建一个buffervent节点
	bev = bufferevent_socket_new(base, fd, BEV_OPT_CLOSE_ON_FREE);
	if (!bev) {
		fprintf(stderr, "Error constructing bufferevent!");
		event_base_loopbreak(base);
		return;
	}
	//设置回调
	bufferevent_setcb(bev, conn_readcb, conn_writecb, conn_eventcb, NULL);
	bufferevent_enable(bev, EV_WRITE | EV_READ);//设置读写事件使能
	//bufferevent_disable(bev, EV_READ);//设置读事件非使能

	bufferevent_write(bev, MESSAGE, strlen(MESSAGE));//给cfd发送消息 helloworld
}
static void conn_readcb(struct bufferevent *bev, void *user_data)
{
	char buf[1500]="";
	int n = bufferevent_read(bev,buf,sizeof(buf));
	printf("%s\n",buf);
	bufferevent_write(bev, buf,n);//给cfd发送消息 



}

static void
conn_writecb(struct bufferevent *bev, void *user_data)
{
	struct evbuffer *output = bufferevent_get_output(bev);//获取缓冲区类型
	if (evbuffer_get_length(output) == 0) {   // 判断应用缓冲区的数据是否都写入了内核缓冲区
		
	//	printf("flushed answer\n");
	//	bufferevent_free(bev);//释放节点 自动关闭
	}
}

static void
conn_eventcb(struct bufferevent *bev, short events, void *user_data)
{
	if (events & BEV_EVENT_EOF) {
		printf("Connection closed.\n");
	} else if (events & BEV_EVENT_ERROR) {
		printf("Got an error on the connection: %s\n",
		    strerror(errno));/*XXX win32*/
	}
	/* None of the other events can happen here, since we haven't enabled
	 * timeouts */
	bufferevent_free(bev);
}

static void
signal_cb(evutil_socket_t sig, short events, void *user_data)
{
	struct event_base *base = user_data;
	struct timeval delay = { 2, 0 };

	printf("Caught an interrupt signal; exiting cleanly in two seconds.\n");

	event_base_loopexit(base, &delay);//退出循环监听
}
```
编译运行：
```
gcc hello-world.c -o hello-world -levent
./hello-world 
```
开启另一个终端，输入：
```
nc 127.1 9995  #127.1代表127.0.0.1
```

## 4.5.bufferevent实现tcp客户端
**客户端创建套接字,连接服务器的API：**
```
struct bufferevent *bufferevent_socket_new(struct event_base *base,-1, int options); // 创建新节点。这里fd填-1，在bufferevent_socket_connect中会实现套接字的创建。
int bufferevent_socket_connect(struct bufferevent *bev, struct sockaddr *serv, int socklen);
    bev: 新建的节点
    serv: 服务器的地址信息
    sockle  n: serv长度
```

bufferevent实现tcp客户端bufferevent_client.c：
```
//bufferevent建立客户端的过程
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <errno.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <event.h>
#include <event2/bufferevent.h>
#include <event2/buffer.h>
#include <event2/util.h>

int tcp_connect_server(const char* server_ip, int port);
void cmd_msg_cb(int fd, short events, void* arg);
void server_msg_cb(struct bufferevent* bev, void* arg);
void event_cb(struct bufferevent *bev, short event, void *arg);
//./a.out  192.168.1.1  9995
int main(int argc, char** argv)
{
    if( argc < 3 )
    {
        //两个参数依次是服务器端的IP地址、端口号
        printf("please input 2 parameter\n");
        return -1;
    }
    //创建根节点
    struct event_base *base = event_base_new();
    //创建并且初始化buffer缓冲区
    struct bufferevent* bev = bufferevent_socket_new(base, -1,
                                                     BEV_OPT_CLOSE_ON_FREE);

    //监听终端输入事件 设置标准输入的监控,设置回调是 cmd_msg_cb 
    struct event* ev_cmd = event_new(base, STDIN_FILENO,
                                     EV_READ | EV_PERSIST,
                                     cmd_msg_cb, (void*)bev);
    // 上面相当于创建了两个节点bev和ev_cmd，等待上树

	printf("001\n");
    //上树 开始监听标准输入的读事件
    event_add(ev_cmd, NULL);
    
    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr) );
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(atoi(argv[2]));
    //将ip地址转换为网络字节序
    inet_aton(argv[1], &server_addr.sin_addr);

    //连接到 服务器ip地址和端口 初始化了 socket文件描述符 socket+connect 
    bufferevent_socket_connect(bev, (struct sockaddr *)&server_addr,
                               sizeof(server_addr));
    //设置buffer的回调函数并上树。 主要设置了读回调 server_msg_cb ,传入参数是标准输入的读事件
    bufferevent_setcb(bev, server_msg_cb, NULL, event_cb, (void*)ev_cmd);
    bufferevent_enable(bev, EV_READ | EV_PERSIST);
	printf("002\n");

    event_base_dispatch(base);//循环等待
    event_free(ev_cmd);
    bufferevent_free(bev);
    event_base_free(base);
    printf("finished \n");
    return 0;
}
//终端输入回调
void cmd_msg_cb(int fd, short events, void* arg)
{
    char msg[1024];

    int ret = read(fd, msg, sizeof(msg));
    if( ret < 0 )
    {
        perror("read fail ");
        exit(1);
    }
    //得到bufferevent指针,目的是为了写到bufferevent的写缓冲区
    struct bufferevent* bev = (struct bufferevent*)arg;

    //把终端的消息发送给服务器端
    bufferevent_write(bev, msg, ret);
}

void server_msg_cb(struct bufferevent* bev, void* arg)
{
	
	printf("001\n");
    char msg[1024];

    size_t len = bufferevent_read(bev, msg, sizeof(msg));
    msg[len] = '\0';
	printf("002\n");

    printf("recv %s from server\n", msg);
}

void event_cb(struct bufferevent *bev, short event, void *arg)
{

    if (event & BEV_EVENT_EOF)
        printf("connection closed\n");
    else if (event & BEV_EVENT_ERROR)
        printf("some other error\n");
    else if( event & BEV_EVENT_CONNECTED)
    {
        printf("the client has connected to server\n");
        return ;
    }


    //这将自动close套接字和free读写缓冲区
   bufferevent_free(bev);
    //释放event事件 监控读终端
  struct event *ev = (struct event*)arg;
    event_free(ev);
	exit(0);
}
```
首先运行bufferevent实现tcp服务器，然后再运行bufferevent实现tcp客户端
]]></description></item><item><title>C++ Restful API 框架库</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/05/09/16249503.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Mon, 09 May 2022 07:49:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/05/09/16249503.html</guid><description><![CDATA[规范见：[链接1](https://www.cnblogs.com/bigsai/p/14099154.html)
[链接2](https://restfulapi.cn/)

![](https://img2022.cnblogs.com/blog/1617829/202205/1617829-20220509154417976-1246343575.png)

表格中第二列和第三列是性能指标，第四列体现易用性。从表中，我们可以很容易发现，巨硬（微软）开源的Restful库的性能最差，甚至不如PHP语言实现的，这简直是对C++的侮辱啊！其中性能最好的库——pistache，性能大约是PHP版本的2.17倍，不过易用性跟PHP差了很多：PHP仅仅用14行就可以写出一个Restful接口，而C++需要大约40行。

从上面的评测，我们可以看到不论是性能还是易用性方面，pistache在所有C++实现的Restful库中表现最为出色。


参考：[链接](https://www.jianshu.com/p/38c3ce4dfbb3)



https://jishuin.proginn.com/p/763bfbd2f0ca]]></description></item><item><title>C++ 信号</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/05/08/16246557.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Sun, 08 May 2022 11:36:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/05/08/16246557.html</guid><description><![CDATA[#1.信号的概念

信号是 Linux 进程间通信的最古老的方式。信号是软件中断，它是在软件层次上对中断机制的一种模拟，是一种异步通信的方式 。信号可以导致一个正在运行的进程被另一个正在运行的异步进程中断，转而处理某一个突发事件。
“中断”在我们生活中经常遇到，譬如，我正在房间里打游戏，突然送快递的来了，把正在玩游戏的我给“中断”了，我去签收快递( 处理中断 )，处理完成后，再继续玩我的游戏。
这里我们学习的“信号”就是属于这么一种“中断”。我们在终端上敲“Ctrl+c”，就产生一个“中断”，相当于产生一个信号，接着就会处理这么一个“中断任务”（默认的处理方式为中断当前进程）。
中断：先停下本进程，去处理信号。
异步：不知道信号什么时候来

内核进程可以利用它来通知用户空间进程发生了哪些系统事件。


## 1.1信号的编号(了解)
1）信号编号：
Unix早期版本就提供了信号机制，但不可靠，信号可能丢失。Berkeley 和 AT&T都对信号模型做了更改，增加了可靠信号机制。但彼此不兼容。POSIX.1对可靠信号例程进行了标准化。

Linux 可使用命令：kill -l（"l" 为字母），查看相应的信号和对应的编号。
不存在编号为0的信号。其中1-31号信号称之为常规信号（也叫普通信号或标准信号），34-64称之为实时信号，驱动编程与硬件相关。名字上区别不大。而前32个名字各不相同。

2） Linux常规信号一览表 【加粗的为重点】:
| 编号    | 信号                  | 对应事件                                                                 | 默认动作          |
| ----- | ------------------- | -------------------------------------------------------------------- | ------------- |
| 1     | SIGHUP              | 用户退出shell时，由该shell启动的所有进程将收到这个信号。由于默认动作时终止进程，所以当终端被关闭以后，终端里面的后台\前台进程都会被终止                                     | 终止进程          |
| 2     | **SIGINT**              | 当用户按下了<Ctrl+C>组合键时，用户终端向正在运行中的由该终端启动的程序发出此信号                         | 终止进程          |
| 3     | **SIGQUIT**             | 用户按下<ctrl+\\>组合键时产生该信号，用户终端向正在运行中的由该终端启动的程序发出些信号                      | 终止进程          |
| 4     | SIGILL              | CPU检测到某进程执行了非法指令：c语言中可内嵌汇编语言，此时如果你写了一个非法的指令，就会发出SIGILL信号                                                     | 终止进程并产生core文件 |
| 5     | SIGTRAP             | 该信号由断点指令或其他 trap指令产生                                                 | 终止进程并产生core文件 |
| 6     | SIGABRT             | 调用abort函数时产生该信号                                                      | 终止进程并产生core文件 |
| 7     | SIGBUS              | 非法访问内存地址，包括内存对齐出错                                                    | 终止进程并产生core文件 |
| 8     | SIGFPE              | 在发生致命的运算错误时发出。不仅包括浮点运算错误，还包括溢出及除数为0等所有的算法错误                          | 终止进程并产生core文件 |
| 9     | SIGKILL             | 无条件终止进程。本信号不能被忽略，用于处理和阻塞                                               | 终止进程，可以杀死任何进程 |
| 10    | SIGUSE1             | 用户定义的信号。即程序员可以在程序中定义并使用该信号                                           | 终止进程          |
| 11    | **SIGSEGV**             | 指示进程进行了无效内存访问(段错误)                                                   | 终止进程并产生core文件 |
| 12    | SIGUSR2             | 另外一个用户自定义信号，程序员可以在程序中定义并使用该信号                                        | 终止进程          |
| 13    | **SIGPIPE**             | Broken pipe向一个没有读端的管道写数据                                             | 终止进程          |
| 14    | SIGALRM             | 定时器超时，超时的时间 由系统调用alarm设置                                             | 终止进程          |
| 15    | SIGTERM             | 程序结束信号，与SIGKILL不同的是，该信号可以被阻塞和终止。通常用来要示程序正常退出。执行shell命令Kill时，缺省产生这个信号 | 终止进程          |
| 16    | SIGSTKFLT           | Linux早期版本出现的信号，现仍保留向后兼容                                              | 终止进程          |
| 17    | **SIGCHLD**             | 子进程结束时，父进程会收到这个信号。由于默认忽略这个信号，所以当子进程退出，而父进程未对子进程进行清理，就会出现”僵尸子进程“。                                                    | 忽略这个信号        |
| 18    | SIGCONT             | 如果进程已停止，则使其继续运行                                                      | 继续/忽略         |
| 19    | SIGSTOP             | 停止进程的执行。信号不能被忽略，处理和阻塞                                                | 为终止进程         |
| 20    | SIGTSTP             | 停止终端交互进程的运行。按下<ctrl+z>组合键时发出这个信号                                     | 暂停进程          |
| 21    | SIGTTIN             | 后台进程读终端控制台                                                           | 暂停进程          |
| 22    | SIGTTOU             | 该信号类似于SIGTTIN，在后台进程要向终端输出数据时发生                                       | 暂停进程          |
| 23    | SIGURG              | 套接字上有紧急数据时，向当前正在运行的进程发出些信号，报告有紧急数据到达。如网络带外数据到达                       | 忽略该信号         |
| 24    | SIGXCPU             | 进程执行时间超过了分配给该进程的CPU时间 ，系统产生该信号并发送给该进程                                | 终止进程          |
| 25    | SIGXFSZ             | 超过文件的最大长度设置                                                          | 终止进程          |
| 26    | SIGVTALRM           | 虚拟时钟超时时产生该信号。类似于SIGALRM，但是该信号只计算该进程占用CPU的使用时间                        | 终止进程          |
| 27    | SIGPROF             | 类似于SIGVTALRM，它不公包括该进程占用CPU时间还包括执行系统调用时间                              | 终止进程          |
| 28    | SIGWINCH            | 窗口变化大小时发出                                                            | 忽略该信号         |
| 29    | SIGIO               | 此信号向进程指示发出了一个异步IO事件                                                  | 忽略该信号         |
| 30    | SIGPWR              | 关机                                                                   | 终止进程          |
| 31    | SIGSYS              | 无效的系统调用                                                              | 终止进程并产生core文件 |
| 34~64 | SIGRTMIN ～ SIGRTMAX | LINUX的实时信号，它们没有固定的含义（可以由用户自定义）                                       | 终止进程          |

加粗的为重要的。
通过自定义信号处理函数，可以修改信号的默认动作。




## 1.2.信号四要素
每个信号必备4要素，分别是：

1）编号 2）名称 3）事件 4）默认处理动作

可通过man 7 signal查看帮助文档获取：
![](https://img2022.cnblogs.com/blog/1617829/202205/1617829-20220508203954849-228479650.png)
在标准信号中，有一些信号是有三个“Value”，第一个值通常对alpha和sparc架构有效，中间值针对x86、arm和其他架构，最后一个应用于mips架构。一个‘-’表示在对应架构上尚未定义该信号。故要让程序具有系统可移植性，最好使用信号的名称而不是编号。

不同的操作系统定义了不同的系统信号。因此有些信号出现在Unix系统内，也出现在Linux中，而有的信号出现在FreeBSD或Mac OS中却没有出现在Linux下。这里我们只研究Linux系统中的信号。

Action为默认动作：
Term：终止进程
Ign： 忽略信号 (默认即时对该种信号忽略操作)
Core：终止进程，生成Core文件。(查验死亡原因，用于gdb调试)
Stop：停止（暂停）进程
Cont：继续运行进程
注意通过man 7 signal命令查看帮助文档，其中可看到 : The signals SIGKILL and SIGSTOP cannot be caught, blocked, or ignored.

这里特别强调了9) SIGKILL 和19) SIGSTOP信号，不允许忽略和捕捉，只能执行默认动作。甚至不能将其设置为阻塞。【什么叫做信号阻塞】

另外需清楚，只有每个信号所对应的事件发生了，该信号才会被递送(但不一定递达，有可能丢失)，不应乱发信号！！

 

## 1.3.信号的状态

**1） 产生**

a) 当用户按某些终端键时，将产生信号。

终端上按“Ctrl+c”组合键通常产生中断信号 SIGINT

终端上按“Ctrl+\”键通常产生中断信号 SIGQUIT

终端上按“Ctrl+z”键通常产生中断信号 SIGSTOP 等。

b) 硬件异常将产生信号。

除数为 0，无效的内存访问等。这些情况通常由硬件检测到，并通知内核，然后内核产生适当的信号发送给相应的进程。

c) 软件异常将产生信号。

当检测到某种软件条件已发生(如：定时器alarm)，并将其通知有关进程时，产生信号。

d) 调用系统函数(如：kill、raise、abort)将发送信号。

注意：接收信号进程和发送信号进程的所有者必须相同，或发送信号进程的所有者必须是超级用户。

e) 运行 kill /killall命令将发送信号。

此程序实际上是使用 kill 函数来发送信号。也常用此命令终止一个失控的后台进程。

 

**2) 未决状态**：没有被处理，处理函数未被调用

**3) 递达状态**：信号被处理了，处理函数已被调用




## 1.4.阻塞信号集和未决信号集
信号的实现手段导致信号有很强的延时性，但对于用户来说，时间非常短，不易察觉。
Linux内核的**进程控制块PCB**是一个结构体task_struct, 除了包含进程id，状态，工作目录，用户id，组id，文件描述符表，还包含了信号相关的信息，主要指阻塞信号集和未决信号集。

阻塞信号集(信号屏蔽字)：将某些信号加入集合，对他们设置屏蔽。当屏蔽x信号后，收到的信号x将不会被处理，直到解除屏蔽以后才会被处理。

未决信号集：信号产生后由于某些原因(主要是阻塞)不能抵达，这类信号的集合称之为未决信号集。信号产生，未决信号集中描述该信号的位立刻翻转为1，表示信号处于未决状态。当信号被处理时，对应位翻转回为0。这一时刻往往非常短暂。

这两个信号集都是内核使用位图机制来实现的。但操作系统不允许我们直接对其进行位操作。而需自定义另外一个集合，借助信号集操作函数来对PCB中的这两个信号集进行修改。
![](https://img2022.cnblogs.com/blog/1617829/202205/1617829-20220509134516989-1501924538.png)

每一个PCB中都有阻塞信号集和未决信号集
### 1.4.1.自定义信号集函数
为了方便对多个信号进行处理，一个用户进程常常需要对多个信号做出处理，在 Linux 系统中引入了信号集（信号的集合）。

这个信号集有点类似于我们的 QQ 群，一个个的信号相当于 QQ 群里的一个个好友。

信号集是一个能表示多个信号的数据类型，sigset_t set，set即一个信号集。既然是一个集合，就需要对集合进行添加/删除等操作。

相关函数说明如下：
```
#include <signal.h>  
​
int sigemptyset(sigset_t *set);       //将set集合置空
int sigfillset(sigset_t *set)；          //将所有信号加入set集合
int sigaddset(sigset_t *set, int signo);  //将signo信号加入到set集合。信号是由一个个的int类型组成
int sigdelset(sigset_t *set, int signo);   //从set集合中移除signo信号
int sigismember(const sigset_t *set, int signo); //判断信号是否存在
```
除sigismember外，其余操作函数中的set均为传出参数。sigset_t类型的本质是位图。但不应该直接使用位操作，而应该使用上述函数，保证跨系统操作有效。
示例程序:
```
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <signal.h>

int main()
{
    sigset_t set;   // 定义一个信号集变量
    int ret = 0;
​
    sigemptyset(&set); // 清空信号集的内容
​
    // 判断 SIGINT 是否在信号集 set 里
    // 在返回 1， 不在返回 0
    ret = sigismember(&set, SIGINT);
    if (ret == 0)
    {
        printf("SIGINT is not a member of set \nret = %d\n", ret);
    }
​
    sigaddset(&set, SIGINT); // 把 SIGINT 添加到信号集 set
    sigaddset(&set, SIGQUIT);// 把 SIGQUIT 添加到信号集 set
​
    // 判断 SIGINT 是否在信号集 set 里
    // 在返回 1， 不在返回 0
    ret = sigismember(&set, SIGINT);
    if (ret == 1)
    {
        printf("SIGINT is a member of set \nret = %d\n", ret);
    }
​
    sigdelset(&set, SIGQUIT); // 把 SIGQUIT 从信号集 set 移除
​
    // 判断 SIGQUIT 是否在信号集 set 里
    // 在返回 1， 不在返回 0
    ret = sigismember(&set, SIGQUIT);
    if (ret == 0)
    {
        printf("SIGQUIT is not a member of set \nret = %d\n", ret);
    }
​
    return 0;
}
```

### 1.4.2.sigprocmask函数——修改阻塞集合
信号阻塞集也称信号屏蔽集、信号掩码。每个进程都有一个阻塞集，创建子进程时子进程将继承父进程的阻塞集。信号阻塞集用来描述哪些信号递送到该进程的时候被阻塞（在信号发生时记住它，直到进程准备好时再将信号通知进程）。

所谓阻塞并不是禁止传送信号, 而是将传送的信号阻塞。若将被阻塞的信号从信号阻塞集中删除，进程将会收到相应的信号。
【注】若发送同一个信号多次，但由于这个信号被阻塞而无法传送，当将被阻塞的信号从信号阻塞集中删除后，进程只处理一次这个信号（即使它发了很多次）

我们可以通过 sigprocmask() 修改当前的信号掩码来改变信号的阻塞情况。
```
#include <signal.h>

int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);
功能：
    检查或修改信号阻塞集，根据 how 指定的方法对进程的阻塞集合进行修改，新的信号阻塞集由 set 指定，而原先的信号阻塞集合由 oldset 保存。
​
参数：
    how : 信号阻塞集合的修改方法，有 3 种情况：
        SIG_BLOCK（加）：向信号阻塞集合中添加 set 信号集，新的信号掩码是set和旧信号掩码的并集。相当于 mask = mask|set。
        SIG_UNBLOCK（减）：从信号阻塞集合中删除 set 信号集，从当前信号掩码中去除 set 中的信号。相当于 mask = mask & ~ set。
        SIG_SETMASK（覆盖）：将信号阻塞集合设为 set 信号集，相当于原来信号阻塞集的内容清空，然后按照 set 中的信号重新设置信号阻塞集。相当于mask = set。
    set : 要操作的信号集地址。
        若 set 为 NULL，则不改变信号阻塞集合，函数只把当前信号阻塞集合保存到 oldset 中。
    oldset : 保存原先信号阻塞集地址
​
返回值：
    成功：0，
    失败：-1，失败时错误代码只可能是 EINVAL，表示参数 how 不合法。
```
示例程序：
```
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <signal.h>

// 信号处理函数
void signal_handler(int signo)
{
	if (signo == SIGINT)
	{
		printf("recv SIGINT\n");
	}
	else if (signo == SIGQUIT)
	{
		printf("recv SIGQUIT\n");
	}
}

int main()
{	
	int ret;
	sigset_t set, oldset;
	printf("wait for SIGINT OR SIGQUIT\n");

	/* SIGINT: Ctrl+c ; SIGQUIT: Ctrl+\ */
	// 信号注册函数
	signal(SIGINT, signal_handler);
	signal(SIGQUIT, signal_handler);


	printf("按下任意键阻塞信号2\n");
	getchar();

	sigemptyset(&oldset);
	sigemptyset(&set);
	sigaddset(&set, SIGINT);

	//设置屏蔽编号为2的信号
	ret = sigprocmask(SIG_BLOCK, &set, &oldset);
	if (-1 == ret){
		perror("sigprocmaSk");
		return 1;
	}
	printf("设置屏蔽编号为2的信号成功....\n");

	printf("按下任意键解除编号为2的信号的阻塞...\n");
	getchar();
	//将信号屏蔽集设置为原来的集合
	ret = sigprocmask(SIG_SETMASK, &oldset, NULL);
	if (-1 == ret) {
		perror("sigp rocmask");
	}
	return 1;
}

```
![](https://img2022.cnblogs.com/blog/1617829/202205/1617829-20220509142950419-1123283785.png)
在被阻塞期间我们发送了八个SIGINT信号，但是在阻塞解除时，进程只调用了一次信号处理函数


### 1.4.3.sigpending函数——读取当前进程的未决信号集


```
#include <signal.h>
​
int sigpending(sigset_t *set);
功能：读取当前进程的未决信号集
参数：
    set：未决信号集
返回值：
    成功：0
    失败：-1
```
示例程序:
```
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <signal.h>
#include <unistd.h>
int main()
{
	// 自定义信号集
	sigset_t myset, old;
	sigemptyset(&myset);// 清空　－》　０

	// 添加要阻塞的信号
	sigaddset(&myset, SIGINT);
	sigaddset(&myset, SIGQUIT);
	sigaddset(&myset, SIGKILL);

	// 自定义信号集设置到内核中的阻塞信号集
	sigprocmask(SIG_BLOCK, &myset, &old);

	sigset_t pend;
	int i = 0;
	while (1)
	{
		// 读内核中的未决信号集的状态
		sigpending(&pend);
		for (int i = 1; i < 32; ++i)
		{
			if (sigismember(&pend, i))
			{
				printf("1");
			}
			else if (sigismember(&pend, i) == 0)
			{
				printf("0");
			}
		}
		printf("\n");
		sleep(1);
		i++;

		// 10s之后解除阻塞
		if (i > 10)
		{
			// sigprocmask(SIG_UNBLOCK, &myset, NULL);
			sigprocmask(SIG_SETMASK, &old, NULL);
		}
	}

	return 0;
}
```







# 2.信号产生函数

## 2.1.kill函数
和kill命令的使用类似
```
#include <sys/types.h>
#include <signal.h>
​
int kill(pid_t pid, int sig);
功能：给指定进程发送指定信号
​
参数：
    pid : 取值有 4 种情况 （和waitpid函数的参数pid一样）:
        pid > 0:  将信号传送给进程 ID 为pid的进程。
        pid = 0 :  将信号传送给当前进程所在进程组中的所有进程。
        pid = -1 : 将信号传送给系统内所有的进程。
        pid < -1 : 将信号传给指定进程组的所有进程。这个进程组号等于 pid 的绝对值。
    sig : 信号的编号，这里可以填数字编号，也可以填信号的宏定义，可以通过命令 kill - l("l" 为字母)进行相应查看。不推荐直接使用数字，应使用宏名，因为不同操作系统信号编号可能不同，但名称一致。
​
返回值：
    成功：0
    失败：-1
```
super用户(root)可以发送信号给任意用户，普通用户是不能向系统用户发送信号的。

kill -9 (root用户的pid) 是不可以的。同样，普通用户也不能向其他普通用户发送信号，终止其进程。 只能向自己创建的进程发送信号。

普通用户基本规则是：发送者实际或有效用户ID == 接收者实际或有效用户ID

程序示例:
```
#include <stdio.h>
#include <stdlib.h> 
#include <string.h>
#include <sys/types.h>
#include <signal.h>
#include <unistd.h>

int main()
{
    pid_t pid = fork();
    if (pid == 0)
    {//子进程
        int i = 0;
        for (i = 0; i<5; i++)
        {
            printf("in son process\n");
            sleep(1);
        }
    }
    else
    {//父进程
        printf("in father process\n");
        sleep(2);
        printf("kill sub process now \n");
        kill(pid, SIGINT);
    }
​
    return 0;
}
```

## 2.2.raise函数——自己给自己发信号
```
#include <signal.h>
​
int raise(int sig);
功能：给当前进程发送指定信号(自己给自己发)，等价于 kill(getpid(), sig)
参数：
    sig：信号编号
返回值：
    成功：0
    失败：非0值
```

## 2.3.abort函数——给自己发送异常终止信号SIGABRT
```
#include <stdlib.h>
​
void abort(void);
功能：给自己发送异常终止信号 6) SIGABRT，并产生core文件，等价于kill(getpid(), SIGABRT);
​
参数：无
​
返回值：无
```
好的编程习惯：
```
写if(4 == i)
而不写
if(i == 4),
因为当我们写错成if(4 = i)时，会报错。
```


## 2.4.alarm函数(闹钟)——定时给自己发送SIGALRM信号
alarm函数是非阻塞的
```
#include <unistd.h>
​
unsigned int alarm(unsigned int seconds);
功能：
    设置定时器(闹钟)。在指定seconds后，内核会给当前进程发送14）SIGALRM信号。进程收到该信号，默认动作终止。每个进程都有且只有唯一的一个定时器。
    取消定时器alarm(0)，返回旧闹钟余下秒数。
参数：
    seconds：指定的时间，以秒为单位
返回值：
    返回0或剩余的秒数
```

定时，与进程状态无关(自然定时法)！就绪、运行、挂起(阻塞、暂停)、终止、僵尸……无论进程处于何种状态，alarm都计时（因为alarm是由内核进行运行的）。

测试程序:

```
int main()
{
    int seconds = 0;
​
    seconds = alarm(5);
    printf("seconds = %d\n", seconds);
​
    sleep(2);
    seconds = alarm(5); // 没有超时的闹钟被新的闹钟给覆盖了
    printf("seconds = %d\n", seconds);  // seconds输出为3，因为seconds是上一次闹钟剩余的时间
​
    while (1);
    return 0;
}
```
设置alarm(5)函数以后，程序还会执行5秒。

## 2.5.setitimer函数（定时器）
```
#include <sys/time.h>
​
int setitimer(int which,  const struct itimerval *new_value, struct itimerval *old_value);
功能：
    设置定时器(闹钟)。 可代替alarm函数。精度微秒us，可以实现周期定时。
参数：
    which：指定定时方式
        a) 自然定时：ITIMER_REAL,计算自然时间。返回14）SIGALRM
        b) 虚拟空间计时(用户空间)：ITIMER_VIRTUAL,只计算进程占用cpu的时间。返回26）SIGVTALRM  
        c) 运行时计时(用户 + 内核)：ITIMER_PROF,计算占用cpu及执行系统调用的时间。返回27）SIGPROF
    new_value：struct itimerval, 负责设定timeout时间
        struct itimerval {
            struct timerval it_interval; // 闹钟触发周期，每个多久触发一次
            struct timerval it_value;    // 闹钟触发时间，第一次执行function所延迟的秒数
        };
        struct timeval {
            long tv_sec;            // 秒
            long tv_usec;           // 微秒
        }
        itimerval.it_value： 设定第一次执行function所延迟的秒数 
        itimerval.it_interval：  设定以后每几秒执行function
​
    old_value： 存放旧的timeout值，一般指定为NULL
返回值：
    成功：0
    失败：-1
```
示例程序：
```
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/time.h>

void myfunc(int sig)
{
    printf("hello\n");
}
​
int main()
{
    struct itimerval new_value;
​
    //定时周期
    new_value.it_interval.tv_sec = 1;
    new_value.it_interval.tv_usec = 0;
​
    //第一次触发的时间：延迟两秒触发
    new_value.it_value.tv_sec = 2;
    new_value.it_value.tv_usec = 0;
​
    signal(SIGALRM, myfunc); //信号处理
    setitimer(ITIMER_REAL, &new_value, NULL); //定时器设置
​
    while (1);
​
    return 0;
}
​
```
\#include\<sys/xxx.h\>是Linux系统中的系统头文件，这些头文件下面的函数A，都可以通过man A来查看A的用法

# 3.信号捕捉
信号捕捉内核实现信号捕捉过程：
![](https://img2022.cnblogs.com/blog/1617829/202205/1617829-20220509134108341-56449946.png)
【注】SIGKILL 和 SIGSTOP 不能更改信号的处理方式，因为它们向用户提供了一种使进程终止的可靠方法。

 

## signal函数
```
#include <signal.h>
​
typedef void(*sighandler_t)(int);
sighandler_t signal(int signum, sighandler_t handler);
功能：
    注册信号处理函数（不可用于 SIGKILL、SIGSTOP 信号），即确定收到信号后处理函数的入口地址。此函数不会阻塞。
​
参数：
    signum：信号的编号，这里可以填数字编号，也可以填信号的宏定义(最好使用宏)，可以通过命令 kill - l("l" 为字母)进行相应查看。
    handler : handler存储的是函数的起始地址，取值有 3 种情况：
          SIG_IGN：忽略该信号
          SIG_DFL：执行系统默认动作
          信号处理函数名：自定义信号处理函数，如：func。SIGKILL 和 SIGSTOP 不能更改信号的处理方式，因为它们向用户提供了一种使进程终止的可靠方法。
          回调函数的定义如下：
            void func(int signo)
            {
                // signo 为触发的信号，为 signal() 第一个参数的值
            }
​
返回值：
    成功：第一次返回 NULL，下一次返回此信号上一次注册的信号处理函数的地址。如果需要使用此返回值，必须在前面先声明此函数指针的类型。
    失败：返回 SIG_ERR
```
该函数由ANSI定义，由于历史原因在不同版本的Unix和不同版本的Linux中可能有不同的行为。**因此应该尽量避免使用它，取而代之使用sigaction函数。**

示例程序:

```
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <signal.h>

// 信号处理函数
void signal_handler(int signo)
{
    if (signo == SIGINT)
    {
        printf("recv SIGINT\n");
    }
    else if (signo == SIGQUIT)
    {
        printf("recv SIGQUIT\n");
    }
}

int main()
{
    printf("wait for SIGINT OR SIGQUIT\n");
    
    /* SIGINT: Ctrl+c ; SIGQUIT: Ctrl+\ */
    // 信号注册函数
    signal(SIGINT, signal_handler);
    signal(SIGQUIT, signal_handler);
    
    while (1); //不让程序结束

    return 0;
}
```
 
]]></description></item><item><title>C++进程控制</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/05/08/16245627.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Sun, 08 May 2022 06:59:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/05/08/16245627.html</guid><description><![CDATA[# 进程相关的命令
## ps
进程是一个具有一定独立功能的程序，它是操作系统动态执行的基本单元。
ps命令可以查看进程的详细状况，常用选项(选项可以不加“-”，不加时输出结果更详细)如下：
| 选项   | 含义                   |
| ---- | -------------------- |
| -a   | 显示终端上的所有进程，包括其他用户的进程 |
| -u   | 显示进程的详细状态            |
| -x   | 显示没有控制终端的进程          |
| -w   | 显示加宽，以便显示更多的信息       |
| -r   | 只显示正在运行的进程           |

ps aux与ps ef等价
ps -a结果如下：
![](https://img2022.cnblogs.com/blog/1617829/202205/1617829-20220508150536215-860536992.png)
其中TTY代表终端，直接在终端中输入tty可显示终端名称：
![](https://img2022.cnblogs.com/blog/1617829/202205/1617829-20220508150605140-1301104498.png)

ps命令常用于查找进程PID，以便于杀死进程。

## top
top命令用来动态显示运行中的进程。top命令能够在运行后，在指定的时间间隔更新显示信息。可以在使用top命令时加上-d 来指定显示信息更新的时间间隔。

在top命令执行后，可以按下按键得到对显示的结果进行排序：

| 按键   | 含义                 |
| ---- | ------------------ |
| M    | 根据内存使用量来排序         |
| P    | 根据CPU占有率来排序        |
| T    | 根据进程运行时间的长短来排序     |
| U    | 可以根据后面输入的用户名来筛选进程  |
| K    | 可以根据后面输入的PID来杀死进程。 |
| q    | 退出                 |
| h    | 获得帮助               |

知道有top这个东西就可以，没必要记后面的参数。

## kill
kill命令：使用某个信号来处理进程，需要配合 ps 使用。
使用格式：
kill [-signal] pid
-signal默认为-15
其中信号-9为绝对终止，可以处理一般信号无法终止的进程（即有些进程不能直接杀死，这时候我们需要加一个参数“ -9 ”，“ -9 ” 代表强制结束）。
查询可用的信号量：kill -l

杀死进程的流程：
```
ps aux| grep name  # 找到名字为name的进程的进程号
kill number        # 通过进程号杀死进程
```
killall -9 name  # 杀死名字为name的所有进程（可能有很多个同名的进程）



# 进程退出和子进程的清理
## 进程退出(exit() 和_exit())
```
#include <stdlib.h>
void exit(int status);
​
#include <unistd.h>
void _exit(int status);
功能：
    结束调用此函数的进程。
参数：
    status：返回给父进程的参数（低 8 位有效），至于这个参数是多少根据需要来填写。
返回值：
    无
```
exit() 和_exit() 函数功能和用法是一样的，无非时所包含的头文件不一样，还有的区别就是：_exit()属于标准库函数，exit()属于系统调用函数。
![](https://img2022.cnblogs.com/blog/1617829/202205/1617829-20220508152450512-898654668.png)
举例如下：
```
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
//结束进程
int main(void)
{
	printf("hello world"); // 要输出"hello world"，就必须刷新I/O缓冲区
	
	//exit(0); // 等价于return 0;,会输出"hello world"
	
	//_ exit(0);  // 直接退出不做任何时候清理，不会输出"hello world"。等价于_Exit(0);
	
	return 0;
}

```
## 等待子进程退出并清理子进程（wait() 和 waitpid()）
在每个进程退出的时候，内核释放该进程所有的资源、包括打开的文件、占用的内存等。但是仍然为其保留一定的信息，这些信息主要主要指进程控制块PCB的信息（包括进程号、退出状态、运行时间等）。

父进程可以通过调用wait或waitpid得到它的退出状态同时彻底清除掉这个进程。
wait() 和 waitpid() 函数的功能一样，区别在于，wait() 函数会阻塞，waitpid() 可以设置不阻塞，waitpid() 还可以指定等待哪个子进程结束。

注意：一次wait或waitpid调用只能清理一个子进程，清理多个子进程应使用循环。

### wait函数
函数说明：
```
#include <sys/types.h>
#include <sys/wait.h>
​
pid_t wait(int *status);
功能：
    等待任意一个子进程结束，如果任意一个子进程结束了，此函数会回收该子进程的资源。
参数：
    status : 进程退出时的状态信息。
返回值：
    成功：已经结束子进程的进程号
    失败： -1
```
调用 wait() 函数的进程会挂起（阻塞），直到它的一个子进程退出或收到一个不能被忽视的信号时才被唤醒（相当于继续往下执行）。

若调用进程没有子进程，该函数立即返回；若它的子进程已经结束，该函数同样会立即返回，并且会回收那个早已结束进程的资源。
所以，wait()函数的主要功能为回收已经结束子进程的资源。

如果参数 status 的值不是 NULL，wait() 就会把子进程退出时的状态取出并存入其中，这是一个整数值（int），指出了子进程是正常退出还是被非正常结束的。

这个退出信息在一个 int 中包含了多个字段，直接使用这个值是没有意义的，我们需要用宏定义取出其中的每个字段。
**宏函数可分为如下三组：**
1\) WIFEXITED(status)：为非0 → 进程正常结束

WEXITSTATUS(status)：如WIFEXITED(status)为真，则可使用WEXITSTATUS(status)获取进程退出状态 (exit的参数)

2\) WIFSIGNALED(status)：为非0 → 进程异常终止

WTERMSIG(status)：如WIFSIGNALED(status)为真，则可使用WTERMSIG(status)取得使进程终止的那个信号的编号。

3\) WIFSTOPPED(status):为非0 → 进程处于暂停状态

WSTOPSIG(status):如WIFSTOPPED(status)为真，则可使用WSTOPSIG(status)取得使进程暂停的那个信号的编号。

WIFCONTINUED(status):为真 → 进程暂停后已经继续运行

举例如下：
 
```
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>
//等待子进程退出
int main(void)
{
	int status = 0;
	int i = 0;
	int ret = -1;
	pid_t pid = -1;

	//创建子进程
	pid = fork();
	if (-1 == pid)
	{
		perror("fork");
		return 1;
	}
	if (0 == pid)
	{
		for (i = 0; i < 15; i++)
		{
			printf("child process %d do thing %d\n", getpid(),i + 1);
			sleep(1);
			//子进程终止
		}

		exit(10);
	}
	//父进程执行
	printf("父进程等待子进程退出，回收其资源\n");
	ret = wait(&status); // 父进程等待子进程退出，回收其资源
	if (-1 == ret)
	{
		perror("wait");
		return 1;
	}

	printf("父进程回收了子进程资源...\n");


	//属于正常退出
	if (WIFEXITED(status))
	{       
		printf("子进程退出状态码: %d\n", WEXITSTATUS(status));
	}
	else if (WIFSIGNALED(status))
	{
                // 通过kill pid或kill -9 pid杀死进程pid
		printf("子进程被信号%d杀死了... \n", WTERMSIG(status));
	}
	else if (WIFSTOPPED(status))
	{
                // 通过kill -19 pid挂起进程，通过kill -18 pid继续运行进程
                // 通过kill -l可查看-18和-19的含义
		printf("子进程被信号%d暂停...\n", WSTOPSIG(status));
	}

	return 0;
}
```

### waitpid函数
waitpid() 可以设置不阻塞，waitpid() 还可以指定等待哪个子进程结束。
函数说明：
```
#include <sys/types.h>
#include <sys/wait.h>
​
pid_t waitpid(pid_t pid, int *status, int options);
功能：
    等待子进程终止，如果子进程终止了，此函数会回收子进程的资源。
​
参数：
    pid : 参数 pid 的值有以下几种类型：
      pid > 0  等待进程 ID 等于 pid 的子进程。
      pid = 0  等待同一个进程组中的任何子进程，如果子进程已经加入了别的进程组，waitpid 不会等待它。
      pid = -1 等待任一子进程，此时 waitpid 和 wait 作用一样。
      pid < -1 等待指定进程组中的任何子进程，这个进程组的 ID 等于 pid 的绝对值。
​
    status : 进程退出时的状态信息。和 wait() 用法一样。
​
    options : options 提供了一些额外的选项来控制 waitpid()。
            0：同 wait()，阻塞父进程，等待子进程退出。
            WNOHANG：没有任何已经结束的子进程，则立即返回。
            WUNTRACED：如果子进程暂停了则此函数马上返回，并且不予以理会子进程的结束状态。（由于涉及到一些跟踪调试方面的知识，加之极少用到）
                 
返回值：
    waitpid() 的返回值比 wait() 稍微复杂一些，一共有 3 种情况：
        1) 当正常返回的时候，waitpid() 返回收集到的已经回收子进程的进程号；
        2) 如果设置了选项 WNOHANG，而调用中 waitpid() 发现没有已退出的子进程可等待，则返回 0；
        3) 如果调用中出错，则返回-1，这时 errno 会被设置成相应的值以指示错误所在，如：当 pid 所对应的子进程不存在，或此进程存在，但不是调用进程的子进程，waitpid() 就会出错返回，这时 errno 被设置为 ECHILD；

 ```

父进程还没运行到wait()或waitpid()，子进程就结束了。接下来父进程运行到wait()或waitpid()时，就会对这个已结束的子进程进行清理，而不是跳过这个已结束的子进程。
]]></description></item><item><title>网络编程常用函数的封装 from 黑马程序员</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/05/08/16245492.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Sun, 08 May 2022 06:03:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/05/08/16245492.html</guid><description><![CDATA[

# 1.socket通信函数的封装
```
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <errno.h>
#include <string.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <strings.h>

void perr_exit(const char *s)
{
	perror(s);
	exit(-1);
}

int Accept(int fd, struct sockaddr *sa, socklen_t *salenptr)
{
	int n;

again:
	if ((n = accept(fd, sa, salenptr)) < 0) {
		if ((errno == ECONNABORTED) || (errno == EINTR))//如果是被信号中断和软件层次中断,不能退出
			goto again;
		else
			perr_exit("accept error");
	}
	return n;
}

int Bind(int fd, const struct sockaddr *sa, socklen_t salen)
{
    int n;

	if ((n = bind(fd, sa, salen)) < 0)
		perr_exit("bind error");

    return n;
}

int Connect(int fd, const struct sockaddr *sa, socklen_t salen)
{
    int n;

	if ((n = connect(fd, sa, salen)) < 0)
		perr_exit("connect error");

    return n;
}

int Listen(int fd, int backlog)
{
    int n;

	if ((n = listen(fd, backlog)) < 0)
		perr_exit("listen error");

    return n;
}

int Socket(int family, int type, int protocol)
{
	int n;

	if ((n = socket(family, type, protocol)) < 0)
		perr_exit("socket error");

	return n;
}
```
问题：为什么信号中断时，就不能终止读取？
由于没有东西可以读时，就会阻塞在那里，但是却由于信号过来了，本进程要中断阻塞状态去处理别的事件。这时候此阻塞状态就会被打断。
所以我们应该让进程处理完中断信号后，继续处于待读数据的阻塞状态。

# 2.黏包
黏包：接收到两个数据包，但是不清楚从哪开始是一个数据包，从哪开始是另一个数据包。
黏包解决方法：
- 约定好，一次发送固定的字节数
- 数据的结尾加一个标记
- 头部加上数据的大小


要实现上述功能，就有必要实现读取固定字节大小的函数，如下所示：
```
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <errno.h>
#include <string.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <strings.h>


// 从fd中读取nbytes个字节，并用ptr指向
ssize_t Read(int fd, void *ptr, size_t nbytes)
{
	ssize_t n;

again:
	if ( (n = read(fd, ptr, nbytes)) == -1) {
		if (errno == EINTR)//如果是被信号中断,不应该退出
			goto again;
		else
			return -1;
	}
	return n;
}

// 向fd中写入nbytes个字节，并用ptr指向带写入数据
ssize_t Write(int fd, const void *ptr, size_t nbytes)
{
	ssize_t n;

again:
	if ( (n = write(fd, ptr, nbytes)) == -1) {
		if (errno == EINTR)
			goto again;
		else
			return -1;
	}
	return n;
}

int Close(int fd)
{
    int n;
	if ((n = close(fd)) == -1)
		perr_exit("close error");

    return n;
}

/*应该读取固定的字节数数据*/
ssize_t Readn(int fd, void *vptr, size_t n)
{
	size_t  nleft;              //usigned int 剩余未读取的字节数
	ssize_t nread;              //int 实际读到的字节数
	char   *ptr;

	ptr = vptr;                // 当前读取的位置
	nleft = n;

	while (nleft > 0) {
		if ((nread = read(fd, ptr, nleft)) < 0) {
			if (errno == EINTR)
				nread = 0;
			else
				return -1;
		} else if (nread == 0)
			break;

		nleft -= nread;
		ptr += nread;
	}
	return n - nleft;
}

/*:固定的字节数数据*/
ssize_t Writen(int fd, const void *vptr, size_t n)
{
	size_t nleft;
	ssize_t nwritten;
	const char *ptr;

	ptr = vptr;
	nleft = n;
	while (nleft > 0) {
		if ( (nwritten = write(fd, ptr, nleft)) <= 0) {
			if (nwritten < 0 && errno == EINTR)
				nwritten = 0;
			else
				return -1;
		}

		nleft -= nwritten;
		ptr += nwritten;
	}
	return n;
}

static ssize_t my_read(int fd, char *ptr)
{
	static int read_cnt;    // 静态的变量初始化为零
	static char *read_ptr;
	static char read_buf[100]; // 一次行读一百个字节，但每次只返回一个字节

	if (read_cnt <= 0) {
again:
		if ( (read_cnt = read(fd, read_buf, sizeof(read_buf))) < 0) {
			if (errno == EINTR)
				goto again;
			return -1;
		} else if (read_cnt == 0) // 当read_cnt为零时，说明fd中无数据，只有一个头部——这说明客户端发送了关闭报文
			return 0;
		read_ptr = read_buf;
	}
	read_cnt--;
	*ptr = *read_ptr++;

	return 1;
}

// 读取一行，即遇到\n就结束
ssize_t Readline(int fd, void *vptr, size_t maxlen) // 读到的数据存储在vptr中
{
	ssize_t n, rc;
	char    c, *ptr;

	ptr = vptr;
	for (n = 1; n < maxlen; n++) {
		if ( (rc = my_read(fd, &c)) == 1) {
			*ptr++ = c;
			if (c  == '\n')
				break;
		} else if (rc == 0) {
			*ptr = 0; 
			return n - 1;
		} else
			return -1;
	}
	*ptr  = 0; // 最后加上个0

	return n;
}
```
# 3.完整代码
头文件wrap.h
```
#ifndef __WRAP_H_
#define __WRAP_H_
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <errno.h>
#include <string.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <strings.h>

void perr_exit(const char *s);
int Accept(int fd, struct sockaddr *sa, socklen_t *salenptr);
int Bind(int fd, const struct sockaddr *sa, socklen_t salen);
int Connect(int fd, const struct sockaddr *sa, socklen_t salen);
int Listen(int fd, int backlog);
int Socket(int family, int type, int protocol);
ssize_t Read(int fd, void *ptr, size_t nbytes);
ssize_t Write(int fd, const void *ptr, size_t nbytes);
int Close(int fd);
ssize_t Readn(int fd, void *vptr, size_t n);
ssize_t Writen(int fd, const void *vptr, size_t n);
ssize_t my_read(int fd, char *ptr);
ssize_t Readline(int fd, void *vptr, size_t maxlen);
int tcp4bind(short port,const char *IP);
#endif
```
wrap.c
```
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <errno.h>
#include <string.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <strings.h>

void perr_exit(const char *s)
{
	perror(s);
	exit(-1);
}

int Accept(int fd, struct sockaddr *sa, socklen_t *salenptr)
{
	int n;

again:
	if ((n = accept(fd, sa, salenptr)) < 0) {
		if ((errno == ECONNABORTED) || (errno == EINTR))//如果是被信号中断和软件层次中断,不能退出
			goto again;
		else
			perr_exit("accept error");
	}
	return n;
}

int Bind(int fd, const struct sockaddr *sa, socklen_t salen)
{
    int n;

	if ((n = bind(fd, sa, salen)) < 0)
		perr_exit("bind error");

    return n;
}

int Connect(int fd, const struct sockaddr *sa, socklen_t salen)
{
    int n;

	if ((n = connect(fd, sa, salen)) < 0)
		perr_exit("connect error");

    return n;
}

int Listen(int fd, int backlog)
{
    int n;

	if ((n = listen(fd, backlog)) < 0)
		perr_exit("listen error");

    return n;
}

int Socket(int family, int type, int protocol)
{
	int n;

	if ((n = socket(family, type, protocol)) < 0)
		perr_exit("socket error");

	return n;
}

ssize_t Read(int fd, void *ptr, size_t nbytes)
{
	ssize_t n;

again:
	if ( (n = read(fd, ptr, nbytes)) == -1) {
		if (errno == EINTR)//如果是被信号中断,不应该退出
			goto again;
		else
			return -1;
	}
	return n;
}

ssize_t Write(int fd, const void *ptr, size_t nbytes)
{
	ssize_t n;

again:
	if ( (n = write(fd, ptr, nbytes)) == -1) {
		if (errno == EINTR)
			goto again;
		else
			return -1;
	}
	return n;
}

int Close(int fd)
{
    int n;
	if ((n = close(fd)) == -1)
		perr_exit("close error");

    return n;
}

/*参三: 应该读取固定的字节数数据*/
ssize_t Readn(int fd, void *vptr, size_t n)
{
	size_t  nleft;              //usigned int 剩余未读取的字节数
	ssize_t nread;              //int 实际读到的字节数
	char   *ptr;

	ptr = vptr;
	nleft = n;

	while (nleft > 0) {
		if ((nread = read(fd, ptr, nleft)) < 0) {
			if (errno == EINTR)
				nread = 0;
			else
				return -1;
		} else if (nread == 0)
			break;

		nleft -= nread;
		ptr += nread;
	}
	return n - nleft;
}
/*:固定的字节数数据*/
ssize_t Writen(int fd, const void *vptr, size_t n)
{
	size_t nleft;
	ssize_t nwritten;
	const char *ptr;

	ptr = vptr;
	nleft = n;
	while (nleft > 0) {
		if ( (nwritten = write(fd, ptr, nleft)) <= 0) {
			if (nwritten < 0 && errno == EINTR)
				nwritten = 0;
			else
				return -1;
		}

		nleft -= nwritten;
		ptr += nwritten;
	}
	return n;
}

static ssize_t my_read(int fd, char *ptr)
{
	static int read_cnt;    // 静态的变量初始化为零
	static char *read_ptr;
	static char read_buf[100]; // 一次行读一百个字节，但每次只返回一个字节

	if (read_cnt <= 0) {
again:
		if ( (read_cnt = read(fd, read_buf, sizeof(read_buf))) < 0) {
			if (errno == EINTR)
				goto again;
			return -1;
		} else if (read_cnt == 0) // 当read_cnt为零时，说明fd中无数据，只有一个头部——这说明客户端发送了关闭报文
			return 0;
		read_ptr = read_buf;
	}
	read_cnt--;
	*ptr = *read_ptr++;

	return 1;
}

// 读取一行，即遇到\n就结束
ssize_t Readline(int fd, void *vptr, size_t maxlen) // 读到的数据存储在vptr中
{
	ssize_t n, rc;
	char    c, *ptr;

	ptr = vptr;
	for (n = 1; n < maxlen; n++) {
		if ( (rc = my_read(fd, &c)) == 1) {
			*ptr++ = c;
			if (c  == '\n')
				break;
		} else if (rc == 0) {
			*ptr = 0; 
			return n - 1;
		} else
			return -1;
	}
	*ptr  = 0; // 最后加上个0

	return n;
}

int tcp4bind(short port,const char *IP)
{
    struct sockaddr_in serv_addr;
    int lfd = Socket(AF_INET,SOCK_STREAM,0);
    bzero(&serv_addr,sizeof(serv_addr));
    if(IP == NULL){
        //如果这样使用 0.0.0.0,任意ip将可以连接
        serv_addr.sin_addr.s_addr = INADDR_ANY;
    }else{
        if(inet_pton(AF_INET,IP,&serv_addr.sin_addr.s_addr) <= 0){
            perror(IP);//转换失败
            exit(1);
        }
    }
    serv_addr.sin_family = AF_INET;
    serv_addr.sin_port   = htons(port);
   // int opt = 1;
	//setsockopt(lfd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

    Bind(lfd,(struct sockaddr *)&serv_addr,sizeof(serv_addr));
    return lfd;
}
```
]]></description></item><item><title>多进程实现并发服务器</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/05/08/16245477.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Sun, 08 May 2022 05:59:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/05/08/16245477.html</guid><description><![CDATA[多进程实现并发服务器流程:
创建套接字lfd
绑定
监听
while(1)
{
    提取连接，使用cfd与客户端进行通信
    fork创建子进程，这时子进程就复制了一份lfd和cfd吗？？
    在子进程中,关闭lfd,服务客户端
    在父进程关闭cfd,回收子进程的资源
}
关闭
根据具体代码修改上面流程。。。。。

子进程退出时，会给父进程发送SIGCHLD信号，此时父进程就可以回收子进程的资源
]]></description></item><item><title>Linux fcntl函数详解</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/05/07/16244318.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Sat, 07 May 2022 14:10:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/05/07/16244318.html</guid><description><![CDATA[fcntl系统调用是控制文件描述符属性的通用POSIX(POSIX是一种通用的规范)方法。
```
//头文件：
#include <unistd.h>    
#include <fcntl.h>

//定义函数：
int fcntl(int fd, int cmd);
int fcntl(int fd, int cmd, long arg);
int fcntl(int fd, int cmd, struct flock * lock);
```
fd：文件描述符
cmd：对fd的操作

# cmd选项

参考：[链接1](http://c.biancheng.net/cpp/html/233.html)
[链接2](https://www.cnblogs.com/xuyh/p/3273082.html)
还没参考，这两写呢.........


close-on-exec, 从字面意思即可理解为：如果对描述符设置了FD_CLOEXEC，在使用execl调用执行的程序里，此描述符将在子进程中会被自动关闭，不能使用了。




# execl函数
```
#include <unistd.h>
#include <fcntl.h>
#include <stdio.h>
#include <sys/types.h>
#include <string.h>

int main(int argc, char *argv[])
{
    // execl函数
    // int execl(const char *pathname, const char *arg, ...

    //  pathname: 要执行的文件的路径（推荐使用绝对路径）
    //  接下来的参数代表执行该文件时传递过去的argv[0], argv[1], ..., 最后一个参数必须用空指针(NULL)作结束.
    //  argv[0]是程序名称，argv[1],...为程序后面所需要跟着的参数

    if (fork() > 0)
    {
        printf("I'm parent process: pid: %d\n", getpid());
        sleep(1);
    }
    else
    {
        // 当前是子进程
        // execl("/mnt/c/Users/x/Pictures/code/lesson14/2", "2", NULL);

        execl("/bin/ps", "ps", "a", "u", "x", NULL);

        printf("I'm child process: %d", getpid());
    }
    for (int i = 0; i < 3; i++)
    {
        printf("i=%d, pid: %d\n", i, getpid());
    }
}

```
这个函数是没有返回值的，因为从调用该函数开始，用户区就被调用的二进制程序给替换掉了，已经不再受我们控制
可以看到在程序运行时，printf("I'm child process: %d", getpid())并没有执行


参考：[链接1](https://blog.csdn.net/ma_de_hao_mei_le/article/details/122952159)
[链接2](http://c.biancheng.net/cpp/html/271.html)]]></description></item><item><title>游双 第九章 I/O复用 + 黑马程序员I/O复用</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/05/07/16244095.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Sat, 07 May 2022 12:45:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/05/07/16244095.html</guid><description><![CDATA[# 0.高并发服务器实现方法
1.阻塞等待：进程开启线程去服务客户，每个线程服务一个客户，阻塞等待客户发送消息——消耗资源
2.非阻塞忙轮询：进程循环询问客户，问它上面是否有消息，有消息就进行处理。——消耗cpu
3.多路IO转接(多路IO复用): **内核**监听多个文件描述符的属性(**读写缓冲区**)变化。如果某个文件描述符的读/写缓冲区变化了,这个时候就是可以读了,将这个事件告知应用层。比如同时监听套接字上是否有客户请求和客户套接字上是否有数据传送过来，所以我觉得多路IO复用就是指同时监听多个套接字。
三种多路IO
- select：windwos中常用，select可跨平台
- poll：很少用
- epoll：linux中常用 

# 1.select函数
## 1.1 select函数定义
```
#include <sys/select.h>
 /* According to earlier standards */
#include <sys/time.h>
#include <sys/types.h>
#include <unistd.h>

int select(int nfds, fd_set *readfds, fd_set *writefds,
           fd_set *exceptfds, struct timeval *timeout);
功能: 监听多个文件描述符的属性变化(读,写,异常)
在集合中进行增删改查等操作:
       void FD_CLR(int fd, fd_set *set);  // 将fd从set中删除
       int  FD_ISSET(int fd, fd_set *set); // 判断fd是否再set中
       void FD_SET(int fd, fd_set *set); // 将fd加入到set集合中
       void FD_ZERO(fd_set *set); // 将集合清零
参数:
    nfds  : 最大文件描述符+1。监听0~nfds的文件描述符
    readfds : 需要监听的读的文件描述符存放集合。事件：数据到达了读缓冲区，触发读事件，即有数据来了，快去读取。比如有用户向服务器发送了请求，服务器上面接收到请求，就会触发读事件，从而将请求从读缓冲区中取出。
    writefds :需要监听的写的文件描述符存放集合。事件：写缓存区满了，当写缓冲区有空余时，就触发可写事件，即有地方放了，快把数据放进去。常设为NULL
    exceptfds : 需要监听的异常的文件描述符存放集合。常设为NULL
    timeout: 多长时间监听一次   固定的时间    NULL：永久监听
        struct timeval {
               long    tv_sec;         /* seconds */ 秒
               long    tv_usec;        /* microseconds */微妙
           };

返回值: 返回的是变化的文件描述符的个数
注意: 变化的文件描述符会存在监听的集合（readfds、writefds和exceptfds）中,未变化的文件描述符会从集合中删除
```


## 1.2 select实现服务器
示例代码：
```
#include <stdio.h>
#include <sys/select.h>
#include <sys/types.h>
#include <unistd.h>
#include "wrap.h"
#include <sys/time.h>
#define PORT 8888
int main(int argc, char *argv[])
{
	//创建套接字,绑定
	int lfd = tcp4bind(PORT,NULL);
	//监听
	Listen(lfd,128);
	int maxfd = lfd;//最大的文件描述符
	fd_set oldset,rset;
	FD_ZERO(&oldset);
	FD_ZERO(&rset);
	//将lfd添加到oldset集合中
	FD_SET(lfd,&oldset);
	while(1)
	{	
		rset = oldset;//将oldset赋值给需要监听的集合rset
		
		int n = select(maxfd+1,&rset,NULL,NULL,NULL);
		if(n < 0)
		{
			perror("");
			break;
		}
		else if(n == 0)
		{
			continue;//如果没有变化,重新监听
		}
		else//监听到了文件描述符的变化
		{
			//lfd变化 代表有新的连接到来
			if( FD_ISSET(lfd,&rset))  // 变化的文件描述符都放在了rset集合中，如果lfd在rset中，就说明lfd变化了
			{
				struct sockaddr_in cliaddr;
				socklen_t len =sizeof(cliaddr);
				char ip[16]="";
				//提取新的连接
				int cfd = Accept(lfd,(struct sockaddr*)&cliaddr,&len);
				printf("new client ip=%s port=%d\n",inet_ntop(AF_INET,&cliaddr.sin_addr.s_addr,ip,16),
						ntohs(cliaddr.sin_port));
				//将cfd添加至oldset集合中,以下次监听
				FD_SET(cfd,&oldset);
				//更新maxfd
				if(cfd > maxfd)
					maxfd = cfd;
				//如果只有lfd变化,直接continue
				if(--n == 0)
					continue;

			}


			//cfd  遍历lfd之后的文件描述符是否在rset集合中,如果在则cfd变化
			for(int i = lfd+1;i<=maxfd;i++) // 假设现在 4-1023个文件描述符需要监听,但是5-1000这些文件描述符关闭了
                                                        // 本代码对于这种情况，还是遍历了4-1023
			{
				//如果i文件描述符在rset集合中
				if(FD_ISSET(i,&rset)) 
				{
					char buf[1500]=""; // 因为网络中的最大传输单元为1500
					int ret = Read(i,buf,sizeof(buf));
					if(ret < 0)//出错,将cfd关闭,从oldset中删除cfd
					{
						perror("");
						close(i);
						FD_CLR(i,&oldset);
					}
					else if(ret == 0) // 客户关闭了连接
					{
						printf("client close\n");
						close(i);
						FD_CLR(i,&oldset);
						
					}
					else
					{
						printf("%s\n",buf);
						Write(i,buf,ret);
					
					}
				
				}
				
			
			}
			
		
		}

		
	
	}

	return 0;
}
```

select优点: 跨平台
select缺点:
- 文件描述符数量限制在1024以下，需要修改内核的FD_SETSIZE参数，然后重新编译内核，才能修改1024
- 只是返回变化的文件描述符的个数,具体哪个那个变化需要遍历。当有大量的客户请求了连接但只有少量客户与服务器进行交互（即监听的文件描述符个数多，但是变化的文件描述符少），这种情况下，我们还是需要遍历全部的文件描述符才能找到变化的文件描述符。也就是说大量并发,少了活跃,select效率低。
- select对多个文件描述符进行监听是在内核中进行的，所以每次都需要将需要监听的文件描述集合由应用层符拷贝到内核


## 1.3 select实现服务器【升级版】
假设现在 4-1023个文件描述符需要监听,但是5-1000这些文件描述符关闭了?——本代码修改后，可以解决。解决如下：
```
//进阶版select，通过数组防止遍历1024个描述符
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <arpa/inet.h>
#include <ctype.h>

#include "wrap.h"

#define SERV_PORT 8888

int main(int argc, char *argv[])
{
    int i, j, n, maxi;

    int nready, client[FD_SETSIZE];                 /* 自定义数组client, 防止遍历1024个文件描述符  FD_SETSIZE默认为1024 */
    int maxfd, listenfd, connfd, sockfd;
    char buf[BUFSIZ], str[INET_ADDRSTRLEN];         /* #define INET_ADDRSTRLEN 16 */
    struct sockaddr_in clie_addr, serv_addr;
    socklen_t clie_addr_len;
    fd_set rset, allset;                            /* rset 读事件文件描述符集合 allset用来暂存 */

    listenfd = Socket(AF_INET, SOCK_STREAM, 0);
    //端口复用
    int opt = 1;
    setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));


    bzero(&serv_addr, sizeof(serv_addr));
    serv_addr.sin_family= AF_INET;
    serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);
    serv_addr.sin_port= htons(SERV_PORT);


    Bind(listenfd, (struct sockaddr *)&serv_addr, sizeof(serv_addr));
    Listen(listenfd, 128);

    maxfd = listenfd;                                           /* 起初 listenfd 即为最大文件描述符 */

    maxi = -1;                                                  /* 将来用作client[]的下标, 初始值指向0个元素之前下标位置 */
    for (i = 0; i < FD_SETSIZE; i++)
        client[i] = -1;                                         /* 用-1初始化client[] */

    FD_ZERO(&allset);
    FD_SET(listenfd, &allset);                                  /* 构造select监控文件描述符集 */

    while (1) {   
        rset = allset;                                          /* 每次循环时都从新设置select监控信号集 */

        nready = select(maxfd+1, &rset, NULL, NULL, NULL);      //2  1--lfd  1--connfd
        if (nready < 0)
            perr_exit("select error");

        if (FD_ISSET(listenfd, &rset)) {                        /* 说明有新的客户端链接请求 */

            clie_addr_len = sizeof(clie_addr);
            connfd = Accept(listenfd, (struct sockaddr *)&clie_addr, &clie_addr_len);       /* Accept 不会阻塞 */
            printf("received from %s at PORT %d\n",
                    inet_ntop(AF_INET, &clie_addr.sin_addr, str, sizeof(str)),
                    ntohs(clie_addr.sin_port));

            for (i = 0; i < FD_SETSIZE; i++)
                if (client[i] < 0) {                            /* 找client[]中没有使用的位置 */
                    client[i] = connfd;                         /* 保存accept返回的文件描述符到client[]里 */
                    break;
                }

            if (i == FD_SETSIZE) {                              /* 达到select能监控的文件个数上限 1024 */
                fputs("too many clients\n", stderr);
                exit(1);
            }

            FD_SET(connfd, &allset);                            /* 向监控文件描述符集合allset添加新的文件描述符connfd */

            if (connfd > maxfd)
                maxfd = connfd;                                 /* select第一个参数需要 */

            if (i > maxi)
                maxi = i;                                       /* 保证maxi存的总是client[]最后一个元素下标 */

            if (--nready == 0)
                continue;
        } 

        for (i = 0; i <= maxi; i++) {                               /* 检测哪个clients 有数据就绪 */

            if ((sockfd = client[i]) < 0)
                continue;//数组内的文件描述符如果被释放有可能变成-1
            if (FD_ISSET(sockfd, &rset)) {

                if ((n = Read(sockfd, buf, sizeof(buf))) == 0) {    /* 当client关闭链接时,服务器端也关闭对应链接 */
                    Close(sockfd);
                    FD_CLR(sockfd, &allset);                        /* 解除select对此文件描述符的监控 */
                    client[i] = -1;
                } else if (n > 0) {
                    for (j = 0; j < n; j++)
                        buf[j] = toupper(buf[j]);    // 转化维大写的
                    Write(sockfd, buf, n);
                    Write(STDOUT_FILENO, buf, n);
                }
                if (--nready == 0)
                    break;                                          /* 跳出for, 但还在while中 */
            }
        }
    }

    Close(listenfd);

    return 0;
}
```
虽然本代码还是需要遍历，但是效率提高了一些。


## 1.4 select处理带外数据
Linux下实现I/O复用的系统调用主要有select、poll和epoll
select系统调用：在一段指定时间内，监听用户感兴趣的文件描述符上的可读、可写和异常等事件
socket上接收到普通数据和带外数据都将使select返回，但socket处于不同的就绪状态：前者处于可读状态，后者处于异常状态。代码清单9-1描述了select是如何同时处理二者的。
```
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <assert.h>
#include <stdio.h>
#include <unistd.h>
#include <errno.h>
#include <string.h>
#include <fcntl.h>
#include <stdlib.h>

int main(int argc, char* argv[])
{
	if (argc <= 2)
	{
		printf("usage: %s ip_address port_number\n", basename(argv[0]));
		return 1;
	}
	const char* ip = argv[1];
	int port = atoi(argv[2]);
	printf("ip is %s and port is %d\n", ip, port);

	int ret = 0;
	struct sockaddr_in address;
	bzero(&address, sizeof(address));
	address.sin_family = AF_INET;
	inet_pton(AF_INET, ip, &address.sin_addr);
	address.sin_port = htons(port);

	int listenfd = socket(PF_INET, SOCK_STREAM, 0);
	assert(listenfd >= 0);

	ret = bind(listenfd, (struct sockaddr*)&address, sizeof(address));
	assert(ret != -1);

	ret = listen(listenfd, 5);
	assert(ret != -1);

	struct sockaddr_in client_address;
	socklen_t client_addrlength = sizeof(client_address);
	int connfd = accept(listenfd, (struct sockaddr*)&client_address, &client_addrlength);
	if (connfd < 0)
	{
		printf("errno is: %d\n", errno);
		close(listenfd);
	}

	char remote_addr[INET_ADDRSTRLEN];
	printf("connected with ip: %s and port: %d\n", inet_ntop(AF_INET, &client_address.sin_addr, remote_addr, INET_ADDRSTRLEN), ntohs(client_address.sin_port));

	char buf[1024];
	fd_set read_fds;
	fd_set exception_fds;

	// 每次调用select前都要重新在read_fds和exception_fds中设置文件描述符connfd，
	// 因为事件发生之后，文件描述符集合将被内核修改
	FD_ZERO(&read_fds);  // 清除fdset的所有位
	FD_ZERO(&exception_fds);

	int nReuseAddr = 1;
	setsockopt(connfd, SOL_SOCKET, SO_OOBINLINE, &nReuseAddr, sizeof(nReuseAddr));
	while (1)
	{
		memset(buf, '\0', sizeof(buf));
		FD_SET(connfd, &read_fds);
		FD_SET(connfd, &exception_fds);

		ret = select(connfd + 1, &read_fds, NULL, &exception_fds, NULL);
		printf("select one\n");
		if (ret < 0)
		{
			printf("selection failure\n");
			break;
		}

		// 对于可读事件，采用普通的recv函数读取数据
		if (FD_ISSET(connfd, &read_fds))
		{
			ret = recv(connfd, buf, sizeof(buf) - 1, 0);
			if (ret <= 0)
			{
				break;
			}
			printf("get %d bytes of normal data: %s\n", ret, buf);
		}

		// 对于异常事件，采用带MSG_OOB标志的recv函数读取带外数据
		else if (FD_ISSET(connfd, &exception_fds))
		{
			ret = recv(connfd, buf, sizeof(buf) - 1, MSG_OOB);
			if (ret <= 0)
			{
				break;
			}
			printf("get %d bytes of oob data: %s\n", ret, buf);
		}

	}

	close(connfd);
	close(listenfd);
	return 0;
}
```
【采用书中代码清单5-6（即[链接](https://www.cnblogs.com/codingbigdog/p/16243321.html)第五节的）来发送外带数据，为什么无法进入else if (FD_ISSET(connfd, &exception_fds))中】

# 2.poll

## 2.1 poll函数定义
```
#include <poll.h>
int poll(struct pollfd *fds, nfds_t nfds, int timeout);
功能: 监听多个文件描述符的属性变化
参数:
    fds : 监听的数组的首元素地址
    nfds: 数组有效元素的最大下标+1
    timeout : 超时时间 -1是永久监听 >=0 限时等待

数组元素:
            struct pollfd {
               int   fd;         /* file descriptor */ 需要监听的文件描述符
               short events;     /* requested events */需要监听文件描述符什么事件  EPOLLIN 读事件   EPOLLOUT写事件，其他事件可以通过man poll查看
               short revents;    /* returned events */ 返回监听到的事件    EPOLLIN 读事件   EPOLLOUT写事
           };
```
poll相对与sellect的优缺点
优点:
- 没有文件描述符1024的限制
- 请求和返回是分离的【select中，readfds表示监听的事件集，而且将返回的有读事件的文件描述符也放在readfds中，这就叫做请求和返回是不分离的】

缺点和select一样:
- 只是返回变化的文件描述符的个数,具体哪个那个变化需要遍历。当有大量的客户请求了连接但只有少量客户与服务器进行交互（即监听的文件描述符个数多，但是变化的文件描述符少），这种情况下，我们还是需要遍历全部的文件描述符才能找到变化的文件描述符。也就是说大量并发,少了活跃,poll效率低。
- poll对多个文件描述符进行监听是在内核中进行的，所以每次都需要将需要监听的文件描述集合由应用层符拷贝到内核


poll相对于select没有最大1024文件描述符限制，大小限制。但poll其实也是有最大文件描述符限制，如下：
```
ulimit -a                  # 查看最多打开多少个文件（open files）
ulimit -n 2048             # 将最多打开文件个数修改成2048
cat /proc/sys/fs/file-max  # ulimit -n最大可修改的量
```

## 1.2 poll实现服务器
```
#include <stdio.h>
#include <stdlib.h>
#include<netinet/in.h>
#include<poll.h>
#include<errno.h>
#include <unistd.h>
#include <string.h>
#include <arpa/inet.h>
#include <ctype.h>

#include "wrap.h"

#define MAXLINE 80
#define SERV_PORT 8000
#define OPEN_MAX 1024


int main(int argc, char *argv[])
{
	int i, j, maxi, listenfd, connfd, sockfd;
	int nready;   // 接收poll返回值，记录满足监听事件的fd个数
	ssize_t n;

	char buf[MAXLINE],str[INET_ADDRSTRLEN];
	socklen_t clilen;

	struct pollfd client[OPEN_MAX] ;//定义pol1的数组
	struct sockaddr_in cliaddr,servaddr;

	listenfd = Socket(AF_INET, SOCK_STREAM, 0);
	int opt = 1;
	setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR,&opt, sizeof(opt));//设置端口复用

	bzero(&servaddr, sizeof(servaddr));
	servaddr.sin_family = AF_INET;
	servaddr.sin_addr.s_addr = htonl(INADDR_ANY);
	servaddr.sin_port = htons(SERV_PORT);

	Bind(listenfd, (struct sockaddr *) &servaddr, sizeof(servaddr));
	Listen(listenfd,128);

	client[0].fd = listenfd;   /*要监听的第一一个文件描述符存入client[0]*/
	client[0].events = POLLIN; /* listenfd监听普通读事件*/
	for (i = 1; i < OPEN_MAX; i++)
		client[i].fd = -1;				// 用-1初始化client[]里剩下元素 0也是文件描述符,
	maxi = 0;                            /* client[]数组有效元素中最大元素下标*/




	for (;;) { // 等价与while循环 
		nready = poll(client, maxi + 1, -1); /* 阻塞监听是否有客户端链接请求*/
		if (client[0].revents & POLLIN) {      // listenfd有 读事件就绪。这里用&，而不用==
			clilen = sizeof(cliaddr);
			connfd = Accept(listenfd, (struct sockaddr *) &cliaddr, &clilen);
			printf("received from %s at PORT %d\n",
				inet_ntop(AF_INET, &cliaddr.sin_addr, str, sizeof(str)),
				ntohs(cliaddr.sin_port));
			for (i = 1; i < OPEN_MAX; i++)
				if (client[i].fd < 0) {
					client[i].fd = connfd;  // 找到client []中空闲的位置,存放accept返回的connfd
					break;
				}
			if (i == OPEN_MAX)  /*达到了最大客户端数*/
				perr_exit("too many clients");

			client[i].events = POLLIN;  /*设置刚刚返回的connfd, 监控读事件*/
			if (i > maxi)
				maxi = i;             /*更新client[]中最大元素下标*/
			if (--nready <= 0)
				continue;            /*没有更多就绪事件时,继续回到po11阻塞*/
		}
		for (i = 1; i <= maxi; i++) {

			if ((sockfd = client[i].fd) < 0)
				continue;				//找到第一-个大于0的

			if (client[i].revents & POLLIN) {
				if ((n = Read(sockfd, buf, MAXLINE)) < 0) {
					if (errno == ECONNRESET) { /* 收到RST标志，代表对方想要关闭连接*/
						printf("client[%d] aborted connection\n", i);
						Close(sockfd);
						client[i].fd = -1;    // poll中不监控该文件描述符,直接置为-1即可，不用像se
					}
					else
						perr_exit("read error");
				}
				else if (n == 0) {   /*说明客户端先关闭链接*/
					printf("client[%d] closed connection\n",i);
					Close(sockfd);
					client[i].fd = -1;
				}
				else {
					for (j = 0; j < n; j++)
						buf[j] = toupper(buf[j]);
					Writen(sockfd, buf, n);
				}
				if (--nready <= 0)
					break;
			}
		}
	}
				
	return 0;

}
```


# 3.epoll
## 3.1.epoll API
1.创建一棵红黑树
2.将需要监听的文件描述符放入树中（上树）
3.通过操作树来实现监听

```
// 创建红黑树
#include <sys/epoll.h>
int epoll_create(int size);
参数:
    size :  监听的文件描述符的上限,  2.6版本之后写1即可（因为不够的时候，它会自动扩展）
返回:  返回树的句柄（就相当于返回一棵树）
```

```
// 上树  下树 修改节点
#include <sys/epoll.h>
int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);
参数:
    epfd : 树的句柄
    op : EPOLL_CTL_ADD 上树   EPOLL_CTL_DEL 下树 EPOLL_CTL_MOD 修改
    fd : 待上树或修改或下树的文件描述符
    event : 上树的节点，event里面包含文件描述符和文件描述符需要监听的事件。这不就和fd重复了？
            答：虽然按道理传个event就行，但它就要求你传fd和event，那你就老老实实传啊。
           typedef union epoll_data { // 共用体，一般只使用共用体中的一个数据。
               void        *ptr;
               int          fd;  // 经常使用这个
               uint32_t     u32;
               uint64_t     u64;
           } epoll_data_t;

           struct epoll_event {
               uint32_t     events;      /* Epoll events */  需要监听的事件
               epoll_data_t data;        /* User data variable */ 需要监听的文件描述符，经常只使用fd就行
           };

示例：将cfd上树
int epfd =  epoll_create(1);
struct epoll_event ev;
ev.data.fd = cfd;
ev.events = EPOLLIN;
epoll_ctl(epfd, EPOLL_CTL_ADD,cfd, &ev);
```

```
//监听
#include <sys/epoll.h>
int epoll_wait(int epfd, struct epoll_event *events,
               int maxevents, int timeout);
功能: 监听树上文件描述符的变化
参数：
    epfd : 树
    events : 接收变化的节点的数组的首地址
    maxevents :  数组元素的个数
    timeout : -1 永久监听  大于等于0 限时等待
返回值: 返回的是变化的文件描述符个数

```

优点：
- 和poll一样，没有文件描述符1024的限制，但是还是有上限的。见poll中说明
- 以后每次监听都不要在此将需要监听的文庙描述符拷贝到内核
- 返回的是己经变化的文件描述符,不需要遍历树

## 3.2 父进程监听子进程是否向管道中发送数据
```
#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <sys/epoll.h>
int main(int argc, char *argv[])
{
	int fd[2];
	pipe(fd);    // fd中保存管道的读端和写端
	//创建子进程
	pid_t pid;
	pid = fork();
	if(pid < 0)
		perror("");
	else if(pid == 0) // 为子进程
	{
		close(fd[0]);  // 子进程的读端没有用，故关掉
		char buf[5];
		char ch='a';
		while(1)
		{
			sleep(3); // 每隔三秒写一次数据
			memset(buf,ch++,sizeof(buf));
			write(fd[1],buf,5); // 子进程向管道的写端写数据
		}

	}
	else
	{
		close(fd[1]);
		//创建树
		int epfd = epoll_create(1);
		struct epoll_event ev,evs[1];
		ev.data.fd = fd[0];
		ev.events = EPOLLIN;  // 读事件：有数据来了，就触发读事件
		epoll_ctl(epfd,EPOLL_CTL_ADD,fd[0],&ev);  //上树
		//监听
		while(1)
		{
			int n = epoll_wait(epfd,evs,1,-1);
			if(n == 1)
			{
				char buf[128]="";
				int ret  = read(fd[0],buf,sizeof(buf));
				if(ret <= 0)
				{
					close(fd[0]);
					epoll_ctl(epfd,EPOLL_CTL_DEL,fd[0],&ev);
					break;
				}
				else
				{
					printf("%s\n",buf);
				}
			
			}
		
		
		}

	
	
	}


	return 0;
}

```

## 3.3 epoll实现服务器
```
#include <stdio.h>
#include <fcntl.h>
#include "wrap.h"
#include <sys/epoll.h>
int main(int argc, char *argv[])
{
	//创建套接字 绑定
	int lfd = tcp4bind(8000,NULL);
	//监听
	Listen(lfd,128);
	//创建树
	int epfd = epoll_create(1);
	//将lfd上树
	struct epoll_event ev,evs[1024];
	ev.data.fd = lfd;
	ev.events = EPOLLIN; // 读事件，即有连接到达lfd了，需要我们去读。不设置为边沿触发，使用默认的水平触发
	epoll_ctl(epfd,EPOLL_CTL_ADD,lfd,&ev);
	//while监听
	while(1)
	{
		int nready = epoll_wait(epfd,evs,1024,-1);//监听
		printf("epoll wait _________________\n");
		if(nready <0)
		{
			perror("");
			break;
		}
		else if( nready == 0)
		{
			continue;
		}
		else//有文件描述符变化
		{
			for(int i=0;i<nready;i++)
			{
				//判断lfd变化,并且是读事件变化
				if(evs[i].data.fd == lfd && evs[i].events & EPOLLIN)
				{
					struct sockaddr_in cliaddr;
					char ip[16]="";
					socklen_t len = sizeof(cliaddr);
					int cfd = Accept(lfd,(struct sockaddr *)&cliaddr,&len);//提取新的连接

					printf("new client ip=%s port =%d\n",inet_ntop(AF_INET,&cliaddr.sin_addr.s_addr,ip,16)
							,ntohs(cliaddr.sin_port));
					//设置cfd为非阻塞
					int flags = fcntl(cfd,F_GETFL);//获取的cfd的标志位
					flags |= O_NONBLOCK;
					fcntl(cfd,F_SETFL,flags);
					//将cfd上树
					ev.data.fd =cfd;  // 前面将ev中的内容上树完成之后，ev就没什么用，所以这里可以重复使用ev 
					ev.events =EPOLLIN | EPOLLET;  // EPOLLIN表示读事件。EPOLLET设置为边沿触发，不设置的话，默认为水平触发
					epoll_ctl(epfd,EPOLL_CTL_ADD,cfd,&ev);
				
				}
				else if( evs[i].events & EPOLLIN)//cfd变化 ,而且是读事件变化
				{
					while(1) // 循环读取读缓冲区，直到读缓冲区没有数据为止。从而实现epoll边沿模式下可以一次将数据读走
					{
						char buf[4]="";
						// 如果读一个缓冲区,缓冲区没有数据,如果是带阻塞,就阻塞等待。
                                                // 如果是非阻塞,返回值等于-1,并且会将errno 值设置为EAGAIN
						int n = read(evs[i].data.fd,buf,sizeof(buf)); // 由于前面cfd被设为了非阻塞，所以如果读缓冲区中没有数据，这里也不会阻塞，而是返回-1 并将errno 值设置为EAGAIN
						if(n < 0)//出错,cfd下树
						{
							//如果缓冲区读干净了,这个时候应该跳出while(1)循环,继续监听
							if(errno == EAGAIN)
							{
								break;
							
							}
							//普通错误  
							perror("");
							close(evs[i].data.fd);//将cfd关闭
							epoll_ctl(epfd,EPOLL_CTL_DEL,evs[i].data.fd,&evs[i]);
							break;
						}
						else if(n == 0)//客户端关闭 ,
							{
								printf("client close\n");
								close(evs[i].data.fd);//将cfd关闭
								epoll_ctl(epfd,EPOLL_CTL_DEL,evs[i].data.fd,&evs[i]);//下树
								break;
							}
						else
						{
							// printf("%s\n",buf);  // 由于buf的末尾没有'\0'，所以打印会出错
							write(STDOUT_FILENO,buf,4);  // 用于代替printf("%s\n",buf); 
							write(evs[i].data.fd,buf,n);
							

						}
					}

				}
			
			
			}
		
		}
	
	
	}
	
	return 0;
}
```




## 3.4 epoll 中 ET 和 LT 与 阻塞/非阻塞 IO
**1.监听读缓冲区的变化：**
水平触发（LT）:在LT模式下，只要读缓冲区有数据就会触发epo11_ wait，直到读缓冲区没有数据。
边沿触发（ET）:在ET模式下，缓冲区从不可读变成可读时，会触发epo11_ wait一次，而缓冲区数据变少的情况，则不会再唤醒应用进程。这就要求必须一次性将数据都读走。
**2.监听写缓冲区的变化:**
水平触发:只要可以写，就会触发。（这会导致一直触发，所以一般不用）
边沿触发:数据从有到无,就会触发

因为设置为水平触发,只要缓存区有数据epoll_wait就会被触发，这样调用的次数就会比较多。而epoll_wait是一个系统调用,应该尽量少调用。
所以尽量使用边沿触发,边沿出触发数据来一次只触发一次,这个时候要求一次性将数据读完。“epoll实现服务器”的代码就使用了边沿触发，并一次性将数据读完。

**3.下面介绍一下epoll 中 ET 和 LT 与 阻塞/非阻塞 IO**
从[阻塞IO与非阻塞IO是什么意思？为什么ET模式需要将文件设置为非阻塞的原因？](https://blog.csdn.net/wuguinianjing/article/details/111099280)中，可知阻塞和非阻塞代表什么意思。

博文[实例浅析epoll的水平触发和边缘触发](https://blog.csdn.net/liqihang_dev/article/details/104508677)的验证代码中将监听的socket文件描述符用sockfd表示，将accept()返回的文件描述符(即要读写的文件描述符)用connfd表示。
验证代码验证了如下情况：
1.水平触发的非阻塞sockfd
2.边缘触发的非阻塞sockfd
3.水平触发的阻塞connfd
4.水平触发的非阻塞connfd
5.边缘触发的阻塞connfd
6.边缘触发的非阻塞connfd

以上没有验证阻塞的sockfd，因为读取sockfd阻塞的话，肯定是如下情况：通过accept从sockfd中读取数据（从sockfd中获取客户请求），发现没有数据，此时就会阻塞。
但是epoll_wait()只有检测到sockfd上有数据（有客户请求），才会触发并调用accept函数，所以肯定不会在accept处阻塞。所以将sockfd设置为阻塞和不阻塞的效果都是不阻塞。
【注】accept命令就是从sockfd中读取数据，这个数据是客户端的套接字connfd。

1.水平触发的非阻塞sockfd：当第一个客户连接到达服务器端时，epoll_wait()被触发，并通过accept从sockfd中读取一个客户套接字，并进行相应的处理。在处理的过程中，有很多其他的客户也向服务器端发送了请求，此时不对这些请求进行处理。
当处理完了第一个请求以后，由于sockfd中有很多客户请求（sockfd中有数据可读），对于水平触发来说，如果sockfd中有数据，那么可读事件就会被触发，即epoll_wait()就会被触发。所以sockfd的客户请求会被一个一个处理，直到sockfd中没有数据（sockfd中没有客户请求）为止。

2.边缘触发的非阻塞sockfd：当第一个客户连接到达服务器端时，epoll_wait()被触发，并通过accept从sockfd中读取一个客户套接字，并进行相应的处理。在处理的过程中，有很多其他的客户也向服务器端发送了请求，此时不对这些请求进行处理。
当处理完了第一个请求以后，由于sockfd中有很多客户请求（sockfd中有数据可读），但是对于边缘触发来说，只有当读缓冲区从无到有时，才会触发。所以如果处理第一个请求的时间比较长，则sockfd中将会累积有很多客户请求【假设请求为 connfd2 connfd3 connfd4 ...】，此时只会处理connfd2，因为只有connfd2让读缓冲区从无到有。【这段话其实是有错的，因为在实际实验的过程中发现当请求很多的时候，其实不止处理了connfd2.至于为什么错误我还不知道？？】


为什么ET模式的文件描述符都应该是非阻塞的？
ET模式时，需要通过循环将数据一次全部读出来，所以我们必须知道什么时候数据读完了，这就需要设置文件描述符为非阻塞。因为文件描述符设置为阻塞时，即使数据读取完成也不会发出任何信息，而是卡在read处。


**总结：**
1.对于监听的sockfd，最好使用水平触发模式，边缘触发模式会导致高并发情况下，有的客户端会连接不上。如果非要使用边缘触发，网上有的方案是用while来循环accept()【如何弄呢？？】。

2.对于读写的connfd，水平触发模式下，阻塞和非阻塞效果都一样，不过为了防止特殊情况【什么特殊情况呢？？】，还是建议设置非阻塞。

3.对于读写的connfd，边缘触发模式下，必须使用非阻塞IO，并要一次性全部读写完数据。、

第一点和第二点中，由于读取套接字时，套接字上必有数据，所以不会出现阻塞的情况，所以套接字设不设为阻塞都无所谓。第三点中，由于循环读取数据的过程中，最终会将数据都读完，然后卡在读取数据的为止，所以要设置为非阻塞。





## 3.5 LT和ET模式
```
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <assert.h>
#include <stdio.h>
#include <unistd.h>
#include <errno.h>
#include <string.h>
#include <fcntl.h>
#include <stdlib.h>
#include <sys/epoll.h>
#include <pthread.h>

#define MAX_EVENT_NUMBER 1024
#define BUFFER_SIZE 10

// 将文件描述符设置成非阻塞的
int setnonblocking(int fd)
{
	int old_option = fcntl(fd, F_GETFL); //fcntl()用来操作文件描述词的一些特性.。
										 // F_GETFL 取得文件描述词状态旗标, 此旗标为open()的参数flags.常见的flags为只读只写等
	int new_option = old_option | O_NONBLOCK; // 设置成非阻塞的
	fcntl(fd, F_SETFL, new_option);		 // F_SETFL 设置文件描述词状态旗标, 参数arg 为新旗标, 但只允许O_APPEND、
										// O_NONBLOCK 和O_ASYNC 位的改变, 其他位的改变将不受影响
	return old_option;
}

// 将文件描述符fd上的EPOLLIN注册到epollfd指示的epoll内核事件表中，参数enable_et指定是否对fd启用ET模式
void addfd(int epollfd, int fd, bool enable_et)
{
	epoll_event event;
	event.data.fd = fd;
	event.events = EPOLLIN;
	if (enable_et)
	{
		event.events |= EPOLLET;
	}
	epoll_ctl(epollfd, EPOLL_CTL_ADD, fd, &event);
	setnonblocking(fd);
}

// LT模式的工作流程
void lt(epoll_event* events, int number, int epollfd, int listenfd)
{
	char buf[BUFFER_SIZE];
	for (int i = 0; i < number; i++)
	{
		int sockfd = events[i].data.fd;
		if (sockfd == listenfd)
		{
			struct sockaddr_in client_address;
			socklen_t client_addrlength = sizeof(client_address);
			int connfd = accept(listenfd, (struct sockaddr*)&client_address, &client_addrlength);
			addfd(epollfd, connfd, false);   // 对connfd禁用ET模式
		}
		else if (events[i].events & EPOLLIN)
		{
		// 只要socket读缓存中还有未读出的数据，这段代码就被触发
			printf("event trigger once\n");
			memset(buf, '\0', BUFFER_SIZE);
			int ret = recv(sockfd, buf, BUFFER_SIZE - 1, 0);
			if (ret <= 0)
			{
				close(sockfd);
				continue;
			}
			printf("get %d bytes of content: %s\n", ret, buf);
		}
		else
		{
			printf("something else happened \n");
		}
	}
}

// ET模式的工作流程
void et(epoll_event* events, int number, int epollfd, int listenfd)
{
	char buf[BUFFER_SIZE];
	for (int i = 0; i < number; i++)
	{
		int sockfd = events[i].data.fd;
		if (sockfd == listenfd)
		{
			struct sockaddr_in client_address;
			socklen_t client_addrlength = sizeof(client_address);
			int connfd = accept(listenfd, (struct sockaddr*)&client_address, &client_addrlength);
			addfd(epollfd, connfd, true);
		}
		else if (events[i].events & EPOLLIN)
		{
			printf("event trigger once\n");
			while (1)
			{
				memset(buf, '\0', BUFFER_SIZE);
				int ret = recv(sockfd, buf, BUFFER_SIZE - 1, 0);
				if (ret < 0)
				{
					if ((errno == EAGAIN) || (errno == EWOULDBLOCK))
					{
						printf("read later\n");
						break;
					}
					close(sockfd);
					break;
				}
				else if (ret == 0)
				{
					close(sockfd);
				}
				else
				{
					printf("get %d bytes of content: %s\n", ret, buf);
				}
			}
		}
		else
		{
			printf("something else happened \n");
		}
	}
}

int main(int argc, char* argv[])
{
	if (argc <= 2)
	{
		printf("usage: %s ip_address port_number\n", basename(argv[0]));
		return 1;
	}
	const char* ip = argv[1];
	int port = atoi(argv[2]);

	int ret = 0;
	struct sockaddr_in address;
	bzero(&address, sizeof(address));
	address.sin_family = AF_INET;
	inet_pton(AF_INET, ip, &address.sin_addr);
	address.sin_port = htons(port);

	int listenfd = socket(PF_INET, SOCK_STREAM, 0);
	assert(listenfd >= 0);

	ret = bind(listenfd, (struct sockaddr*)&address, sizeof(address));
	assert(ret != -1);

	ret = listen(listenfd, 5);
	assert(ret != -1);

	epoll_event events[MAX_EVENT_NUMBER];
	int epollfd = epoll_create(5);
	assert(epollfd != -1);
	addfd(epollfd, listenfd, true);

	while (1)
	{
		int ret = epoll_wait(epollfd, events, MAX_EVENT_NUMBER, -1);
		if (ret < 0)
		{
			printf("epoll failure\n");
			break;
		}

		lt(events, ret, epollfd, listenfd);
		//et( events, ret, epollfd, listenfd );
	}

	close(listenfd);
	return 0;
}
```



## 3.6 epoll反应堆
本小节看懂就行，不需要会写。
epoll反应堆：将文件描述符、事件和回调函数封装在一起。当事件发生时，自动调用回调函数。
使用结构体进行封装。

### 一个简单的epoll反应堆
```
//反应堆简单版
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <fcntl.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <sys/epoll.h>
#include "wrap.h"

#define _BUF_LEN_  1024
#define _EVENT_SIZE_ 1024

//全局epoll树的根
int gepfd = 0;

//事件驱动结构体
typedef struct xx_event{
    int fd;
    int events;
    void (*call_back)(int fd,int events,void *arg);
    void *arg;
    char buf[1024];
    int buflen;
    int epfd;
}xevent;

xevent myevents[_EVENT_SIZE_+1]; // 全局变量默认初始化为零

void readData(int fd,int events,void *arg);

//添加事件
//eventadd(lfd,EPOLLIN,initAccept,&myevents[_EVENT_SIZE_-1],&myevents[_EVENT_SIZE_-1]);
void eventadd(int fd,int events,void (*call_back)(int ,int ,void *),void *arg,xevent *ev)
{
    ev->fd = fd;
    ev->events = events;
    //ev->arg = arg;//代表结构体自己,可以通过arg得到结构体的所有信息
    ev->call_back = call_back;

    struct epoll_event epv;
    epv.events = events;
    epv.data.ptr = ev; //核心思想
    epoll_ctl(gepfd,EPOLL_CTL_ADD,fd,&epv);//上树
}

//修改事件
//eventset(fd,EPOLLOUT,senddata,arg,ev);
void eventset(int fd,int events,void (*call_back)(int ,int ,void *),void *arg,xevent *ev)
{
    ev->fd = fd;
    ev->events = events;
    //ev->arg = arg;
    ev->call_back = call_back;

    struct epoll_event epv;
    epv.events = events;
    epv.data.ptr = ev;
    epoll_ctl(gepfd,EPOLL_CTL_MOD,fd,&epv);//修改
}

//删除事件
void eventdel(xevent *ev,int fd,int events)
{
	printf("begin call %s\n",__FUNCTION__);

    ev->fd = 0;
    ev->events = 0;
    ev->call_back = NULL;
    memset(ev->buf,0x00,sizeof(ev->buf));
    ev->buflen = 0;

    struct epoll_event epv;
    epv.data.ptr = NULL;
    epv.events = events;
    epoll_ctl(gepfd,EPOLL_CTL_DEL,fd,&epv);//下树
}

//发送数据
void senddata(int fd,int events,void *arg)
{
    printf("begin call %s\n",__FUNCTION__);

    xevent *ev = arg;
    Write(fd,ev->buf,ev->buflen);
    eventset(fd,EPOLLIN,readData,arg,ev);
}

//读数据
void readData(int fd,int events,void *arg)
{
    printf("begin call %s\n",__FUNCTION__);
    xevent *ev = arg;

    ev->buflen = Read(fd,ev->buf,sizeof(ev->buf)); // 读完数据，并没有直接将数据发送回去。而是监听fd是否可写（可发送）后，再进行发送
    if(ev->buflen>0) //读到数据
	{	
		//void eventset(int fd,int events,void (*call_back)(int ,int ,void *),void *arg,xevent *ev)
        eventset(fd,EPOLLOUT,senddata,arg,ev); // 修改fd，使其监听写事件。一旦可写就将收到的数据发送回去
											   // senddata中，修改fd，使其重新监听读事件。

    }
	else if(ev->buflen==0) //对方关闭连接
	{
        Close(fd);
        eventdel(ev,fd,EPOLLIN);
    }

}
//新连接处理
void initAccept(int fd,int events,void *arg)
{
    printf("begin call %s,gepfd =%d\n",__FUNCTION__,gepfd);//__FUNCTION__ 函数名

    int i;
    struct sockaddr_in addr;
    socklen_t len = sizeof(addr);
    int cfd = Accept(fd,(struct sockaddr*)&addr,&len);//是否会阻塞？
	
	//查找myevents数组中可用的位置
    for(i = 0 ; i < _EVENT_SIZE_; i ++)
	{
        if(myevents[i].fd==0)
		{
            break;
        }
    }

    //设置读事件
    eventadd(cfd,EPOLLIN,readData,&myevents[i],&myevents[i]);
}

// epoll反应堆的使用
int main(int argc,char *argv[])
{
	//创建socket
    int lfd = Socket(AF_INET,SOCK_STREAM,0);

    //端口复用
    int opt = 1;
    setsockopt(lfd,SOL_SOCKET,SO_REUSEADDR,&opt,sizeof(opt));

	//绑定
    struct sockaddr_in servaddr;
    servaddr.sin_family = AF_INET;
    servaddr.sin_port = htons(8888);
    servaddr.sin_addr.s_addr = htonl(INADDR_ANY);
    Bind(lfd,(struct sockaddr*)&servaddr,sizeof(servaddr));
    
	//监听
    Listen(lfd,128);

	//创建epoll树根节点
    gepfd = epoll_create(1024); 
    printf("gepfd === %d\n",gepfd);

    struct epoll_event events[1024]; // 用保存哪些事件发生了

    // 初始化数据myevents[_EVENT_SIZE_]，并将描述符lfd上树
    eventadd(lfd,EPOLLIN,initAccept,&myevents[_EVENT_SIZE_],&myevents[_EVENT_SIZE_]);
    //void eventadd(int fd,int events,void (*call_back)(int ,int ,void *),void *arg,xevent *ev)

    while(1)
	{
        int nready = epoll_wait(gepfd,events,1024,-1); // 同时监听树上的所有节点，包括节点lfd和cfd
		if(nready<0) //调用epoll_wait失败
		{
			perr_exit("epoll_wait error");
			
		}
        else if(nready>0) //调用epoll_wait成功,返回有事件发生的文件描述符的个数
		{
            int i = 0;
            for(i=0;i<nready; i++)
			{
                xevent *xe = events[i].data.ptr;//取ptr指向结构体地址
                printf("fd=%d\n",xe->fd);

                if(xe->events & events[i].events) // 监听的事件和发生的事件一致时。这个其实写不写都无所谓
				{
                    xe->call_back(xe->fd,xe->events,xe);//调用事件对应的回调
                }
            }
        }
    }

	//关闭监听文件描述符
	Close(lfd);

    return 0;
}

```

### 一个较复杂的epoll反应堆（可以不看，看懂上面那个简单的反应堆就可以了）
```
/*
 * epoll基于非阻塞I/O事件驱动
 */
#include <stdio.h>
#include <sys/socket.h>
#include <sys/epoll.h>
#include <arpa/inet.h>
#include <fcntl.h>
#include <unistd.h>
#include <errno.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>

#define MAX_EVENTS  1024                                    //监听上限数
#define BUFLEN      4096
#define SERV_PORT   8080

void recvdata(int fd, int events, void *arg);
void senddata(int fd, int events, void *arg);

/* 描述就绪文件描述符相关信息 */

struct myevent_s {
    int fd;                                                 //要监听的文件描述符
    int events;                                             //对应的监听事件
    void *arg;                                              //泛型参数
    void (*call_back)(int fd, int events, void *arg);       //回调函数
    int status;                                             //是否在监听:1->在红黑树上(监听), 0->不在(不监听)
    char buf[BUFLEN];
    int len;
    long last_active;                                       //记录每次加入红黑树的时间。如果是不活跃的，就会被剔除掉
};

int g_efd;                                                  //全局变量, 保存epoll_create返回的文件描述符
struct myevent_s g_events[MAX_EVENTS+1];                    //自定义结构体类型数组. +1-->listen fd


/*将结构体 myevent_s 成员变量 初始化*/

void eventset(struct myevent_s *ev, int fd, void (*call_back)(int, int, void *), void *arg)
{
    ev->fd = fd;
    ev->call_back = call_back;
    ev->events = 0;
    ev->arg = arg;
    ev->status = 0;
    //memset(ev->buf, 0, sizeof(ev->buf));
    //ev->len = 0;
    ev->last_active = time(NULL);    //调用eventset函数的时间

    return;
}

/* 向 epoll监听的红黑树 添加一个 文件描述符 */

void eventadd(int efd, int events, struct myevent_s *ev)
{
    struct epoll_event epv = {0, {0}};
    int op;
    epv.data.ptr = ev;
    epv.events = ev->events = events;       //EPOLLIN 或 EPOLLOUT

    if (ev->status == 1) {                                          //已经在红黑树 g_efd 里
        op = EPOLL_CTL_MOD;                                         //修改其属性
    } else {                                //不在红黑树里
        op = EPOLL_CTL_ADD;                 //将其加入红黑树 g_efd, 并将status置1
        ev->status = 1;
    }

    if (epoll_ctl(efd, op, ev->fd, &epv) < 0)                       //实际添加/修改
        printf("event add failed [fd=%d], events[%d]\n", ev->fd, events);
    else
        printf("event add OK [fd=%d], op=%d, events[%0X]\n", ev->fd, op, events);

    return ;
}

/* 从epoll 监听的 红黑树中删除一个 文件描述符*/

void eventdel(int efd, struct myevent_s *ev)
{
    struct epoll_event epv = {0, {0}};

    if (ev->status != 1)                                        //不在红黑树上
        return ;

    epv.data.ptr = ev;
    ev->status = 0;                                             //修改状态
    epoll_ctl(efd, EPOLL_CTL_DEL, ev->fd, &epv);                //从红黑树 efd 上将 ev->fd 摘除

    return ;
}

/*  当有文件描述符就绪, epoll返回, 调用该函数 与客户端建立链接 */
// 回调函数 - 监听的文件描述符发送读事件时被调用
void acceptconn(int lfd, int events, void *arg)
{
    struct sockaddr_in cin;
    socklen_t len = sizeof(cin);
    int cfd, i;

    if ((cfd = accept(lfd, (struct sockaddr *)&cin, &len)) == -1) {
        if (errno != EAGAIN && errno != EINTR) {
            /* 暂时不做出错处理 */
        }
        printf("%s: accept, %s\n", __func__, strerror(errno));
        return ;
    }

    do {
        for (i = 0; i < MAX_EVENTS; i++)                                //从全局数组g_events中找一个空闲元素
            if (g_events[i].status == 0)                                //类似于select中找值为-1的元素
                break;                                                  //跳出 for

        if (i == MAX_EVENTS) {
            printf("%s: max connect limit[%d]\n", __func__, MAX_EVENTS);
            break;                                                      //跳出do while(0) 不执行后续代码
        }

        int flag = 0;
        if ((flag = fcntl(cfd, F_SETFL, O_NONBLOCK)) < 0) {             //将cfd也设置为非阻塞
            printf("%s: fcntl nonblocking failed, %s\n", __func__, strerror(errno));
            break;
        }

        /* 给cfd设置一个 myevent_s 结构体, 回调函数 设置为 recvdata */

        eventset(&g_events[i], cfd, recvdata, &g_events[i]);
        eventadd(g_efd, EPOLLIN, &g_events[i]);                         //将cfd添加到红黑树g_efd中,监听读事件

    } while(0);

    printf("new connect [%s:%d][time:%ld], pos[%d]\n", 
            inet_ntoa(cin.sin_addr), ntohs(cin.sin_port), g_events[i].last_active, i);
    return ;
}

// 回调函数 - 通信的文件描述符发生读事件时候被调用
void recvdata(int fd, int events, void *arg)
{
    struct myevent_s *ev = (struct myevent_s *)arg;
    int len;

    len = recv(fd, ev->buf, sizeof(ev->buf), 0);            //读文件描述符, 数据存入myevent_s成员buf中

    eventdel(g_efd, ev);        //将该节点从红黑树上摘除

    if (len > 0) {

        ev->len = len;
        ev->buf[len] = '\0';                                //手动添加字符串结束标记
        printf("C[%d]:%s\n", fd, ev->buf);

        eventset(ev, fd, senddata, ev);                     //设置该 fd 对应的回调函数为 senddata
        eventadd(g_efd, EPOLLOUT, ev);                      //将fd加入红黑树g_efd中,监听其写事件

    } else if (len == 0) {
        close(ev->fd);
        /* ev-g_events 地址相减得到偏移元素位置 */
        printf("[fd=%d] pos[%ld], closed\n", fd, ev-g_events);
    } else {
        close(ev->fd);
        printf("recv[fd=%d] error[%d]:%s\n", fd, errno, strerror(errno));
    }

    return;
}

// 回调函数 - 通信的文件描述符发生写事件时候被调用
void senddata(int fd, int events, void *arg)
{
    struct myevent_s *ev = (struct myevent_s *)arg;
    int len;

    len = send(fd, ev->buf, ev->len, 0);                    //直接将数据 回写给客户端。未作处理
    /*
    printf("fd=%d\tev->buf=%s\ttev->len=%d\n", fd, ev->buf, ev->len);
    printf("send len = %d\n", len);
    */

    if (len > 0) {

        printf("send[fd=%d], [%d]%s\n", fd, len, ev->buf);
        eventdel(g_efd, ev);                                //从红黑树g_efd中移除
        eventset(ev, fd, recvdata, ev);                     //将该fd的 回调函数改为 recvdata
        eventadd(g_efd, EPOLLIN, ev);                       //从新添加到红黑树上， 设为监听读事件

    } else {
        close(ev->fd);                                      //关闭链接
        eventdel(g_efd, ev);                                //从红黑树g_efd中移除
        printf("send[fd=%d] error %s\n", fd, strerror(errno));
    }

    return ;
}

/*创建 socket, 初始化lfd */

void initlistensocket(int efd, short port)
{
    int lfd = socket(AF_INET, SOCK_STREAM, 0);
    fcntl(lfd, F_SETFL, O_NONBLOCK);                                            //将socket设为非阻塞

    /* void eventset(struct myevent_s *ev, int fd, void (*call_back)(int, int, void *), void *arg);  */
    eventset(&g_events[MAX_EVENTS], lfd, acceptconn, &g_events[MAX_EVENTS]);

    /* void eventadd(int efd, int events, struct myevent_s *ev) */
    eventadd(efd, EPOLLIN, &g_events[MAX_EVENTS]);

    struct sockaddr_in sin;
	memset(&sin, 0, sizeof(sin));                                               //bzero(&sin, sizeof(sin))
	sin.sin_family = AF_INET;
	sin.sin_addr.s_addr = INADDR_ANY;
	sin.sin_port = htons(port);

	bind(lfd, (struct sockaddr *)&sin, sizeof(sin));

	listen(lfd, 20);

    return ;
}

int main(int argc, char *argv[])
{
    unsigned short port = SERV_PORT;

    if (argc == 2)
        port = atoi(argv[1]);                           //使用用户指定端口.如未指定,用默认端口

    g_efd = epoll_create(MAX_EVENTS+1);                 //创建红黑树,返回给全局 g_efd 
    if (g_efd <= 0)
        printf("create efd in %s err %s\n", __func__, strerror(errno));

    initlistensocket(g_efd, port);                      //初始化监听socket

    struct epoll_event events[MAX_EVENTS+1];            //保存已经满足就绪事件的文件描述符数组
	printf("server running:port[%d]\n", port);

    int checkpos = 0, i;
    while (1) {
		
        /* 超时验证，每次测试100个链接，不测试listenfd 当客户端60秒内没有和服务器通信，则关闭此客户端链接。不是重点不用看。 */
        long now = time(NULL);                          //当前时间
        for (i = 0; i < 100; i++, checkpos++) {         //一次循环检测100个。 使用checkpos控制检测对象
            if (checkpos == MAX_EVENTS)
                checkpos = 0;
            if (g_events[checkpos].status != 1)         //不在红黑树 g_efd 上
                continue;

            long duration = now - g_events[checkpos].last_active;       //客户端不活跃的世间

            if (duration >= 60) {
                close(g_events[checkpos].fd);                           //关闭与该客户端链接
                printf("[fd=%d] timeout\n", g_events[checkpos].fd);
                eventdel(g_efd, &g_events[checkpos]);                   //将该客户端 从红黑树 g_efd移除
            }
        }


        /*监听红黑树g_efd, 将满足的事件的文件描述符加至events数组中, 1秒没有事件满足, 返回 0*/
        int nfd = epoll_wait(g_efd, events, MAX_EVENTS+1, 1000);
        if (nfd < 0) {
            printf("epoll_wait error, exit\n");
            break;
        }

        for (i = 0; i < nfd; i++) {
            /*使用自定义结构体myevent_s类型指针, 接收 联合体data的void *ptr成员*/
            struct myevent_s *ev = (struct myevent_s *)events[i].data.ptr;  

            if ((events[i].events & EPOLLIN) && (ev->events & EPOLLIN)) {           //读就绪事件
                ev->call_back(ev->fd, events[i].events, ev->arg);
            }
            if ((events[i].events & EPOLLOUT) && (ev->events & EPOLLOUT)) {         //写就绪事件
                ev->call_back(ev->fd, events[i].events, ev->arg);
            }
        }
    }

    /* 退出前释放所有资源 */
    return 0;
}
```
]]></description></item><item><title>有四篇在简书上还没复制过来。。。。</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/05/07/16243378.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Sat, 07 May 2022 09:20:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/05/07/16243378.html</guid><description><![CDATA[222]]></description></item><item><title>游双的 第6、7、8章</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/05/07/16243326.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Sat, 07 May 2022 09:13:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/05/07/16243326.html</guid><description><![CDATA[第6章 高级I/O函数 && 第7章 Linux服务器程序规范 && 第8章 高性能服务器程序框架
# 1.使用printf发送数据（使用dup将标准IO重定向到socket）
使用printf发送数据
```
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <assert.h>
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <errno.h>
#include <string.h>

int main( int argc, char* argv[] )
{
    if( argc <= 2 )
    {
        printf( "usage: %s ip_address port_number\n", basename( argv[0] ) );
        return 1;
    }
    const char* ip = argv[1];
    int port = atoi( argv[2] );

    struct sockaddr_in address;
    bzero( &address, sizeof( address ) );
    address.sin_family = AF_INET;
    inet_pton( AF_INET, ip, &address.sin_addr );
    address.sin_port = htons( port );

    int sock = socket( PF_INET, SOCK_STREAM, 0 );
    assert( sock >= 0 );

    int ret = bind( sock, ( struct sockaddr* )&address, sizeof( address ) );
    assert( ret != -1 );

    ret = listen( sock, 5 );
    assert( ret != -1 );

    struct sockaddr_in client;
    socklen_t client_addrlength = sizeof( client );
    int connfd = accept( sock, ( struct sockaddr* )&client, &client_addrlength );
    
    if ( connfd < 0 )
    {
        printf( "errno is: %d\n", errno );
    }
    else
    {
        close( STDOUT_FILENO );
        dup( connfd );
        printf( "abcd\n" );
        close( connfd );
    }

    close( sock );
    return 0;
}
```
接收的数据
```
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <assert.h>
#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>

#define BUF_SIZE 1024

int main( int argc, char* argv[] )
{
    if( argc <= 2 )
    {
        printf( "usage: %s ip_address port_number\n", basename( argv[0] ) );
        return 1;
    }
    const char* ip = argv[1];
    int port = atoi( argv[2] );

    struct sockaddr_in server_address;
    bzero( &server_address, sizeof( server_address ) );
    server_address.sin_family = AF_INET;
    inet_pton( AF_INET, ip, &server_address.sin_addr );
    server_address.sin_port = htons( port );

    int sockfd = socket( PF_INET, SOCK_STREAM, 0 );
    assert( sockfd >= 0 ); //如果表达式为假，那么就打印错误并终止程序。assert一般用于调试，可以添加#define NDEBUG 来禁用assert调用
    
    if (  connect( sockfd, ( struct sockaddr* )&server_address,sizeof( server_address ) ) < 0 )
    {
        printf( "connection failed\n" );
    }
    else
    {
        char buffer[ BUF_SIZE ];

        memset( buffer, '\0', BUF_SIZE ); 	// 用来给某一块内存空间进行赋值的
        int ret = recv( sockfd, buffer, BUF_SIZE-1, 0 );
        printf( "got %d bytes of normal data '%s'\n", ret, buffer );
    }

    close( sockfd );
    return 0;
}
```
# 2.readv函数（分散读）和writev函数（集中写）
writev函数将多块分散的内存数据一并写入文件描述符中，在本代码中就是使用writev发送两个字符数组。
```
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <assert.h>
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <errno.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <fcntl.h>
#include<sys/uio.h>

#define BUFFER_SIZE 1024
/*定义两种HTTP状态码和状态信息*/
static const char* status_line[2] = { "200 OK", "500 Internal server error" };

int main( int argc, char* argv[] )
{
    if( argc <= 3 )
    {
        printf( "usage: %s ip_address port_number filename\n", basename( argv[0] ) );
        return 1;
    }
    const char* ip = argv[1];
    int port = atoi( argv[2] );
    const char* file_name = argv[3]; /*将目标文件作为程序的第三个参数传入*/

    struct sockaddr_in address;
    bzero( &address, sizeof( address ) );
    address.sin_family = AF_INET;
    inet_pton( AF_INET, ip, &address.sin_addr );
    address.sin_port = htons( port );

    int sock = socket( PF_INET, SOCK_STREAM, 0 );
    assert( sock >= 0 );

    int ret = bind( sock, ( struct sockaddr* )&address, sizeof( address ) );
    assert( ret != -1 );

    ret = listen( sock, 5 ); // 
    assert( ret != -1 );

    struct sockaddr_in client;
    socklen_t client_addrlength = sizeof( client );
    int connfd = accept( sock, ( struct sockaddr* )&client, &client_addrlength );
    if ( connfd < 0 )
    {
        printf( "errno is: %d\n", errno );
    }
    else
    {
        char header_buf[ BUFFER_SIZE ]; /*用于保存HTTP应答的状态行、头部字段和一个空行的缓存区*/
        memset( header_buf, '\0', BUFFER_SIZE );
        char* file_buf; /*用于存放目标文件内容的应用程序缓存*/
        struct stat file_stat; /*用于获取目标文件的属性，比如是否为目录，文件大小等*/
        			// struct stat这个结构体是用来描述一个linux系统文件系统中的文件属性的结构
        bool valid = true;	/*记录目标文件是否是有效文件*/
        int len = 0;		/*缓存区header_buf目前已经使用了多少字节的空间*/
        if( stat( file_name, &file_stat ) < 0 ) /*目标文件不存在*/ // stat()函数获取file_name文件的属性结构
        {
            valid = false;
        }
        else // 将文件存入一个字符数组中
        {
            if( S_ISDIR( file_stat.st_mode ) ) /*目标文件是一个目录*/
            {
                valid = false;
            }
            else if( file_stat.st_mode & S_IROTH ) /*当前用户有读取目标文件的权限*/
            {
            	/*动态分配缓存区file_buf，并指定其大小为目标文件的大小file_stat.st_size
加1，然后将目标文件读入缓存区file_buf中*/
                int fd = open( file_name, O_RDONLY );
                file_buf = new char [ file_stat.st_size + 1 ];
                memset( file_buf, '\0', file_stat.st_size + 1 );
                if ( read( fd, file_buf, file_stat.st_size ) < 0 ) //将fd指向的文件，存入file_buf中。
                {
                    valid = false;
                }
            }
            else
            {
                valid = false;
            }
        }
        
        if( valid )
        {
  /*下面这部分内容将HTTP应答的状态行、“Content-Length”头部字段和一个空行依次加入header_buf中*/
            ret = snprintf( header_buf, BUFFER_SIZE-1, "%s %s\r\n", "HTTP/1.1", status_line[0] ); //  snprintf将字符串"%s %s\r\n"存入header_buf字符数组中。
            len += ret;
            ret = snprintf( header_buf + len, BUFFER_SIZE-1-len, 
                             "Content-Length: %ld\r\n", file_stat.st_size );
            len += ret;
            ret = snprintf( header_buf + len, BUFFER_SIZE-1-len, "%s", "\r\n" );
          /*利用writev将header_buf和file_buf的内容一并写出*/
            struct iovec iv[2];
            iv[ 0 ].iov_base = header_buf;
            iv[ 0 ].iov_len = strlen( header_buf );
            iv[ 1 ].iov_base = file_buf;
            iv[ 1 ].iov_len = file_stat.st_size;
            ret = writev( connfd, iv, 2 );
        }
        else
        {
            ret = snprintf( header_buf, BUFFER_SIZE-1, "%s %s\r\n", "HTTP/1.1", status_line[1] );
            len += ret;
            ret = snprintf( header_buf + len, BUFFER_SIZE-1-len, "%s", "\r\n" );
            send( connfd, header_buf, strlen( header_buf ), 0 );
        }
        close( connfd );
        delete [] file_buf;
    }

    close( sock );
    return 0;
}
```
Kongming20上输入：./6-2testwritev.out 192.168.154.130 12345 6-2testwritev.cpp
ernest-laptop上输入：telnet 192.168.154.130 12345，ernest-laptop就可以获取到6-2testwritev.cpp的内容
# 3.用sendfile函数传输文件
sendfile函数在两个文件描述符之间直接传递数据（完全在内核中操作），从而避免了内核缓冲区和用户缓冲区之间的数据拷贝，效率很高，这被称为零拷贝。
```
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <assert.h>
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <errno.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/sendfile.h>

int main( int argc, char* argv[] )
{
    if( argc <= 3 )
    {
        printf( "usage: %s ip_address port_number filename\n", basename( argv[0] ) );
        return 1;
    }
    const char* ip = argv[1];
    int port = atoi( argv[2] );
    const char* file_name = argv[3];

    int filefd = open( file_name, O_RDONLY );
    assert( filefd > 0 );
    struct stat stat_buf;
    fstat( filefd, &stat_buf );

    struct sockaddr_in address;
    bzero( &address, sizeof( address ) );
    address.sin_family = AF_INET;
    inet_pton( AF_INET, ip, &address.sin_addr );
    address.sin_port = htons( port );

    int sock = socket( PF_INET, SOCK_STREAM, 0 );
    assert( sock >= 0 );

    int ret = bind( sock, ( struct sockaddr* )&address, sizeof( address ) );
    assert( ret != -1 );

    ret = listen( sock, 5 );
    assert( ret != -1 );

    struct sockaddr_in client;
    socklen_t client_addrlength = sizeof( client );
    int connfd = accept( sock, ( struct sockaddr* )&client, &client_addrlength );
    if ( connfd < 0 )
    {
        printf( "errno is: %d\n", errno );
    }
    else
    {
        sendfile( connfd, filefd, NULL, stat_buf.st_size );
        close( connfd );
    }

    close( sock );
    return 0;
}
```
使用1中的接收数据的代码，即可接收到数据 

# 4.使用splice函数实现的回射服务器
splice函数用于在两个文件描述符之间移动数据，也是零拷贝操作。
```
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <assert.h>
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <errno.h>
#include <string.h>
#include <fcntl.h>

int main( int argc, char* argv[] )
{
    if( argc <= 2 )
    {
        printf( "usage: %s ip_address port_number\n", basename( argv[0] ) );
        return 1;
    }
    const char* ip = argv[1];
    int port = atoi( argv[2] );

    struct sockaddr_in address;
    bzero( &address, sizeof( address ) );
    address.sin_family = AF_INET;
    inet_pton( AF_INET, ip, &address.sin_addr );
    address.sin_port = htons( port );

    int sock = socket( PF_INET, SOCK_STREAM, 0 );
    assert( sock >= 0 );

    int ret = bind( sock, ( struct sockaddr* )&address, sizeof( address ) );
    assert( ret != -1 );

    ret = listen( sock, 5 );
    assert( ret != -1 );

    struct sockaddr_in client;
    socklen_t client_addrlength = sizeof( client );
    int connfd = accept( sock, ( struct sockaddr* )&client, &client_addrlength );
    if ( connfd < 0 )
    {
        printf( "errno is: %d\n", errno );
    }
    else
    {
        int pipefd[2];
        assert( ret != -1 );
        ret = pipe( pipefd ); /*创建管道*/
        /*将connfd上流入的客户数据定向到管道中*/
        ret = splice( connfd, NULL, pipefd[1], NULL, 32768, SPLICE_F_MORE | SPLICE_F_MOVE ); 
        assert( ret != -1 );
        /*将管道的输出定向到connfd客户连接文件描述符*/
        ret = splice( pipefd[0], NULL, connfd, NULL, 32768, SPLICE_F_MORE | SPLICE_F_MOVE );
        assert( ret != -1 );
        close( connfd );
    }

    close( sock );
    return 0;
}
```
Kongming20上输入：./6-4testsplice.out 192.168.154.130 12345
ernest-laptop上输入：telnet 192.168.154.130 12345,然后随便输入一串字符，就可以得到相同字符的返回
# 5.tee函数同时输出数据到终端和文件的程序
tee函数在两个管道文件描述符之间复制数据，也是零拷贝操作。它不消耗数据，因此源文件描述符上的数据仍然可以用于后续的读操作
```
#include <assert.h>
#include <stdio.h>
#include <unistd.h>
#include <errno.h>
#include <string.h>
#include <fcntl.h>

int main( int argc, char* argv[] )
{
	if ( argc != 2 )
	{
		printf( "usage: %s <file>\n", argv[0] );
		return 1;
	}
	int filefd = open( argv[1], O_CREAT | O_WRONLY | O_TRUNC, 0666 );
	assert( filefd > 0 );

	int pipefd_stdout[2];
        int ret = pipe( pipefd_stdout );
	assert( ret != -1 );

	int pipefd_file[2];
        ret = pipe( pipefd_file );
	assert( ret != -1 );

	//close( STDIN_FILENO );
	// dup2( pipefd_stdout[1], STDIN_FILENO );
	//write( pipefd_stdout[1], "abc\n", 4 );
	/*将标准输入内容输入管道pipefd_stdout*/
	ret = splice( STDIN_FILENO, NULL, pipefd_stdout[1], NULL, 32768, SPLICE_F_MORE | SPLICE_F_MOVE );
	assert( ret != -1 );
	/*将管道pipefd_stdout的输出复制到管道pipefd_file的输入端*/
	ret = tee( pipefd_stdout[0], pipefd_file[1], 32768, SPLICE_F_NONBLOCK ); 
	assert( ret != -1 );
	/*将管道pipefd_file的输出定向到文件描述符filefd上，从而将标准输入的内容写入文件*/
	ret = splice( pipefd_file[0], NULL, filefd, NULL, 32768, SPLICE_F_MORE | SPLICE_F_MOVE );
	assert( ret != -1 );
	/*将管道pipefd_stdout的输出定向到标准输出，其内容和写入文件的内容完全一致*/
	ret = splice( pipefd_stdout[0], NULL, STDOUT_FILENO, NULL, 32768, SPLICE_F_MORE | SPLICE_F_MOVE );
	assert( ret != -1 );

	close( filefd );
        close( pipefd_stdout[0] );
        close( pipefd_stdout[1] );
        close( pipefd_file[0] );
        close( pipefd_file[1] );
	return 0;
}
```
本程序数据的流向如下：
首先STDIN_FILENO里的内容被放进管道pipefd_stdout中，此时STDIN_FILENO里的内容就没了，无法再读STDIN_FILENO来获取相同的内容。
然后为了让数据保留在管道pipefd_stdout中以便后续使用，故使用了tee函数将管道pipefd_stdout中的数据复制到管道pipefd_file，再将数据从管道pipefd_file传到 filefd。为什么不直接将管道pipefd_stdout的数据复制到 filefd？答：因为tee只能在两个管道之间复制数据，而filefd不是管道。
最后将保留再管道pipefd_stdout中的数据传到 STDOUT_FILENO

# 6.切换root用户为形参指定用户
```
// 切换root用户为形参指定用户
static bool switch_to_user( uid_t user_id, gid_t gp_id ) // 形参为目标用户ID，为目标组ID
{
    if ( ( user_id == 0 ) && ( gp_id == 0 ) ) // 两个都等于零，代表是root用户
    {
        return false;
    }

    gid_t gid = getgid();
    uid_t uid = getuid();
    if ( ( ( gid != 0 ) || ( uid != 0 ) ) && ( ( gid != gp_id ) || ( uid != user_id ) ) ) // 当前用户如果是root或者目标用户时，就不进入if中。保证当前用户只能是root和目标用户
    {
        return false;
    }
	
    /*由于前面保证了当前用户只能是root和目标用户.如果不是root，则已经是目标用户*/
    if ( uid != 0 ) 
    {
        return true;
    }

    if ( ( setgid( gp_id ) < 0 ) || ( setuid( user_id ) < 0 ) )
    {
        return false;
    }

    return true;
}
```
# 7.守护进程的编写
```
bool daemonize()
{
    /*创建子进程，关闭父进程，这样可以使程序在后台运行*/
    pid_t pid = fork();
    if ( pid < 0 )
    {
        return false;
    }
    else if ( pid > 0 )
    {
        exit( 0 );
    }
    
    /*设置文件权限掩码。当进程创建新文件（使用open(const char*pathname,int flags,mode_t mode)系统调用）时，文件的权限将是mode＆0777*/
    umask( 0 );

    /*创建新的会话，设置本进程为进程组的首领*/
    pid_t sid = setsid();
    if ( sid < 0 )
    {
        return false;
    }

    /*切换工作目录*/
    if ( ( chdir( "/" ) ) < 0 )
    {
        /* Log the failure */
        return false;
    }
    
    /*关闭标准输入设备、标准输出设备和标准错误输出设备*/
    close( STDIN_FILENO );
    close( STDOUT_FILENO );
    close( STDERR_FILENO );
    
    /*关闭其他已经打开的文件描述符，代码省略*/
    /*将标准输入、标准输出和标准错误输出都定向到/dev/null文件*/
    open( "/dev/null", O_RDONLY );
    open( "/dev/null", O_RDWR );
    open( "/dev/null", O_RDWR );
    return true;
}
```
# 8.有限状态机

分析HTTP请求行和头部字段并返回不同的字符串：
本代码HTTP请求的一行（包括请求行和头部字段）为行，每一行都有一对回车(\r)换行(\n)符。
HTTP格式可参考：[HTTP协议格式详解](https://www.jianshu.com/p/8fe93a14754c)。其中Http请求消息结构如下：
![](https://img2022.cnblogs.com/blog/1617829/202205/1617829-20220507171406077-1887215386.png)


```
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
#include <string.h>
#include <fcntl.h>

#define BUFFER_SIZE 4096 /*读缓冲区大小*/
// 主状态机的两种可能状态，分别表示：当前正在分析请求行，当前正在分析头部字段
enum CHECK_STATE { CHECK_STATE_REQUESTLINE = 0, CHECK_STATE_HEADER, CHECK_STATE_CONTENT };
// 从状态机的三种可能状态，即行的读取状态，分别表示：读取到一个完整的行、行出错和行数据尚且不完整
enum LINE_STATUS { LINE_OK = 0, LINE_BAD, LINE_OPEN };
// 服务器处理HTTP请求的结果：
// NO_REQUEST表示请求不完整，需要继续读取客户数据；
// GET_REQUEST表示获得了一个完整的客户请求；
// BAD_REQUEST表示客户请求有语法错误；
// FORBIDDEN_REQUEST表示客户对资源没有足够的访问权限；
// INTERNAL_ERROR表示服务器内部错误；
// CLOSED_CONNECTION表示客户端已经关闭连接了
enum HTTP_CODE { NO_REQUEST, GET_REQUEST, BAD_REQUEST, FORBIDDEN_REQUEST, INTERNAL_ERROR, CLOSED_CONNECTION };
// 为了简化问题，我们没有给客户端发送一个完整的HTTP应答报文，而只是根据服务器的处理结果发送如下成功或失败信息
static const char* szret[] = { "I get a correct result\n", "Something wrong\n" };

// 从状态机:解析一行，得出是否从状态机的状态。
// 从状态机的三种可能状态，即行的读取状态，分别表示：读取到一个完整的行、行出错和行数据尚且不完整
LINE_STATUS parse_line(char* buffer, int& checked_index, int& read_index)
{
	char temp;
	// checked_index指向buffer（应用程序的读缓冲区）中当前正在分析的字节，
	// read_index指向buffer中客户数据的尾部的下一字节。
	// buffer中第0～checked_index字节都已分析完毕，第checked_index～(read_index-1)字节由下面的循环挨
	// 个分析
	for (; checked_index < read_index; ++checked_index)
	{
		// 获得当前要分析的字节
		temp = buffer[checked_index];
		// 如果当前的字节是“\r”，即回车符，则说明可能读取到一个完整的行
		if (temp == '\r')
		{
			// 如果“\r”字符碰巧是目前buffer中的最后一个数据，那么这次分析没有读取到一个完整的行，\r后面应
			// 该还有一个\n，返回LINE_OPEN以表示还需要继续读取客户数据才能进一步分析
			if ((checked_index + 1) == read_index)
			{
				return LINE_OPEN;
			}
			// 如果下一个字符是“\n”，则说明我们成功读取到一个完整的行
			else if (buffer[checked_index + 1] == '\n')
			{
				buffer[checked_index++] = '\0';  // 将\r置为\0
				buffer[checked_index++] = '\0';  //  将\n置为\0
				return LINE_OK;
			}
			// 否则的话，说明客户发送的HTTP请求存在语法问题
			return LINE_BAD;
		}
		// 如果当前的字节是“\n”，即换行符，则也说明可能读取到一个完整的行
		else if (temp == '\n')
		{
			if ((checked_index > 1) && buffer[checked_index - 1] == '\r')
			{
				buffer[checked_index - 1] = '\0';
				buffer[checked_index++] = '\0';
				return LINE_OK;
			}
			return LINE_BAD;
		}
	}
	// 如果所有内容都分析完毕也没遇到“\r”字符，则返回LINE_OPEN，
	// 表示还需要继续读取客户数据才能进一步分析
	return LINE_OPEN;
}

// 分析请求行
HTTP_CODE parse_requestline(char* szTemp, CHECK_STATE& checkstate)
{
	// 如果请求行中没有空格“\t”字符，则HTTP请求必有问题
	char* szURL = strpbrk(szTemp, " \t"); // 返回char指针，指向szTemp中为\t的字符的位置
	if (!szURL)
	{
		return BAD_REQUEST;
	}
	*szURL++ = '\0'; // 将空格置零，然后指针指向下一个字符

	char* szMethod = szTemp;
	if (strcasecmp(szMethod, "GET") == 0)
	{
		printf("The request method is GET\n"); // 仅支持GET方法
	}
	else
	{
		return BAD_REQUEST;
	}

	szURL += strspn(szURL, " \t");   // szURL所指位置为下一个空格。strspn( szURL, " \t" )表示在szURL中找到\t的下标。
	char* szVersion = strpbrk(szURL, " \t");
	if (!szVersion)
	{
		return BAD_REQUEST;
	}
	*szVersion++ = '\0';
	szVersion += strspn(szVersion, " \t");
	if (strcasecmp(szVersion, "HTTP/1.1") != 0)
	{
		return BAD_REQUEST;
	}

	if (strncasecmp(szURL, "http://", 7) == 0)
	{
		szURL += 7;
		szURL = strchr(szURL, '/');    // 检索第一次出现'/'的位置
	}

	if (!szURL || szURL[0] != '/')
	{
		return BAD_REQUEST;
	}

	//URLDecode( szURL );
	printf("The request URL is: %s\n", szURL);
	checkstate = CHECK_STATE_HEADER;
	return NO_REQUEST;
}

// 分析头部字段
HTTP_CODE parse_headers(char* szTemp)
{
	// 遇到一个空行，说明我们得到了一个正确的HTTP请求
	if (szTemp[0] == '\0') // 因为parse_line()将空行（回车换行）都弄成了\0
	{
		return GET_REQUEST;
	}
	else if (strncasecmp(szTemp, "Host:", 5) == 0)   // 处理“HOST”头部字段
	{
		szTemp += 5;    // 跳到Host:之后
		szTemp += strspn(szTemp, " \t");
		printf("the request host is: %s\n", szTemp);
	}
	else // 其他头部字段都不处理
	{
		printf("I can not handle this header\n");
	}

	return NO_REQUEST;
}

// 分析HTTP请求的入口函数
HTTP_CODE parse_content(char* buffer, int& checked_index, CHECK_STATE& checkstate, int& read_index, int& start_line)
{
	LINE_STATUS linestatus = LINE_OK;   // 记录当前行的读取状态
	HTTP_CODE retcode = NO_REQUEST;   // 记录HTTP请求的处理结果
	while ((linestatus = parse_line(buffer, checked_index, read_index)) == LINE_OK) // 主状态机，用于从buffer中取出所有完整的行
	{
		char* szTemp = buffer + start_line;	// start_line是行在buffer中的起始位置
		start_line = checked_index;			// 记录下一行的起始位置
		switch (checkstate)					// checkstate记录主状态机当前的状态
		{
		case CHECK_STATE_REQUESTLINE:		// 第一个状态，分析请求行
		{
			retcode = parse_requestline(szTemp, checkstate);
			if (retcode == BAD_REQUEST)
			{
				return BAD_REQUEST;
			}
			break;
		}
		case CHECK_STATE_HEADER:			// 第二个状态，分析头部字段
		{
			retcode = parse_headers(szTemp);
			if (retcode == BAD_REQUEST)
			{
				return BAD_REQUEST;
			}
			else if (retcode == GET_REQUEST)
			{
				return GET_REQUEST;
			}
			break;
		}
		default:
		{
			return INTERNAL_ERROR;
		}
		}
	}
	if (linestatus == LINE_OPEN)	// 若没有读取到一个完整的行，则表示还需要继续读取客户数据才能进一步分析
	{
		return NO_REQUEST;
	}
	else
	{
		return BAD_REQUEST;
	}
}

int main(int argc, char* argv[])
{
	if (argc <= 2)
	{
		printf("usage: %s ip_address port_number\n", basename(argv[0]));
		return 1;
	}
	const char* ip = argv[1];
	int port = atoi(argv[2]);

	struct sockaddr_in address;
	bzero(&address, sizeof(address));
	address.sin_family = AF_INET;
	inet_pton(AF_INET, ip, &address.sin_addr);
	address.sin_port = htons(port);

	int listenfd = socket(PF_INET, SOCK_STREAM, 0);
	assert(listenfd >= 0);

	int ret = bind(listenfd, (struct sockaddr*)&address, sizeof(address));
	assert(ret != -1);

	ret = listen(listenfd, 5);
	assert(ret != -1);

	struct sockaddr_in client_address;
	socklen_t client_addrlength = sizeof(client_address);
	int fd = accept(listenfd, (struct sockaddr*)&client_address, &client_addrlength);
	if (fd < 0)
	{
		printf("errno is: %d\n", errno);
	}
	else
	{
		char buffer[BUFFER_SIZE];
		memset(buffer, '\0', BUFFER_SIZE);
		int data_read = 0;
		int read_index = 0;
		int checked_index = 0;
		int start_line = 0;
		CHECK_STATE checkstate = CHECK_STATE_REQUESTLINE;
		while (1)
		{
			data_read = recv(fd, buffer + read_index, BUFFER_SIZE - read_index, 0);
			if (data_read == -1)
			{
				printf("reading failed\n");
				break;
			}
			else if (data_read == 0)
			{
				printf("remote client has closed the connection\n");
				break;
			}

			read_index += data_read;
			HTTP_CODE result = parse_content(buffer, checked_index, checkstate, read_index, start_line);
			if (result == NO_REQUEST)
			{
				continue;
			}
			else if (result == GET_REQUEST)
			{
				send(fd, szret[0], strlen(szret[0]), 0);
				break;
			}
			else
			{
				send(fd, szret[1], strlen(szret[1]), 0);
				break;
			}
		}
		close(fd);
	}

	close(listenfd);
	return 0;
}
```
我们前面学习的都是发字符串操作，这就是最有用的操作。网络传输中多数的数据都是以字符串进行传输的，然后再对字符串的内容进行解析得到不同的结果。如图片链接会解析成具体的图片。]]></description></item><item><title>第5章 Linux网络编程基础API</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/05/07/16243321.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Sat, 07 May 2022 09:12:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/05/07/16243321.html</guid><description><![CDATA[请结合《Linux高性能服务器编程 by 游双》进行阅读。







#1.判断机器字节序
```
#include <stdio.h>
void byteorder()
{
	union 
	{
		short value;                            // short占 2 字节
		char union_bytes[ sizeof( short ) ];   // sizeof返回一个对象或者类型所占的内存字节数。char占一个字节
	} test;
	test.value = 0x0102;        // 十六进制，每两位占一个字节
	if (  ( test.union_bytes[ 0 ] == 1 ) && ( test.union_bytes[ 1 ] == 2 ) ) // union_bytes[ 0 ]为低地址，01为高位，故为大端模式
	{
		printf( "big endian\n" );
	}
	else if ( ( test.union_bytes[ 0 ] == 2 ) && ( test.union_bytes[ 1 ] == 1 ) )
	{
		printf( "little endian\n" );
	}
	else
	{
		printf( "unknown...\n" );
	}
}
```
共同体Union和结构体类似。结构体和共用体的区别在于：结构体的各个成员会占用不同的内存，互相之间没有影响；而共用体的所有成员共用同一段内存，修改一个成员会影响其余所有成员。
由于value和union_bytes共用一块内存，所以对value的赋值后，union_bytes访问的就是赋值后的那一部分内存
# 2.点分十进制字符串与网络字节序整数的互相转换
```
#include<iostream>
#include<arpa/inet.h>
using namespace std;
int main(){
    cout<<inet_addr("192.168.2.125")<<endl; // 输出2097326272
    struct in_addr network;
    network.s_addr=2097326272;
    cout<<inet_ntoa(network)<<endl; // 输出192.168.2.125
    return 0; 
}
```
inet_addr函数将用点分十进制字符串表示的IPv4地址转化为用网络字节序整数表示的IPv4地址。它失败时返回INADDR_NONE。
inet_ntoa函数将用网络字节序整数表示的IPv4地址转化为用点分十进制字符串表示的IPv4地址
# 3.服务器开启监听
任务：backlog参数对listen系统调用的影响
```
#include＜sys/socket.h＞
int listen(int sockfd,int backlog);
```
监听队列的长度如果超过backlog，服务器将不受理新的客户连接，客户端也将收到ECONNREFUSED错误信息
```
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <signal.h>
#include <unistd.h>
#include <stdlib.h>
#include <assert.h>
#include <stdio.h>
#include <string.h>

static bool stop = false;
/*SIGTERM信号的处理函数，触发时结束主程序中的循环*/
static void handle_term( int sig )
{
    stop = true;
}

int main( int argc, char* argv[] )
{
    signal( SIGTERM, handle_term ); // 如果收到ctrl+c的种子信号，就会终止程序

    if( argc <= 3 )
    {
        printf( "usage: %s ip_address port_number backlog\n", basename( argv[0] ) );
        return 1;
    }
    const char* ip = argv[1];
    int port = atoi( argv[2] );	// 将字符串转换成int
    int backlog = atoi( argv[3] );

    int sock = socket( PF_INET, SOCK_STREAM, 0 );
    assert( sock >= 0 );
    /*创建一个IPv4 socket地址*/
    struct sockaddr_in address;
    bzero( &address, sizeof( address ) ); // 将内存前sizeof(address)个字节清零
    address.sin_family = AF_INET;
    inet_pton( AF_INET, ip, &address.sin_addr ); // 需要将IP转化成网络字节序
    address.sin_port = htons( port );

    int ret = bind( sock, ( struct sockaddr* )&address, sizeof( address ) );
    assert( ret != -1 );
    /*循环等待连接，直到有SIGTERM信号将它中断*/
    ret = listen( sock, backlog );
    assert( ret != -1 );

    while ( ! stop )
    {
        sleep( 1 );
    }

    close( sock );
    return 0;
}
```
argc代表数组argv的元素个数，为int类型。argv的第一个元素argv[0]是可执行程序名称，并且包含程序所在的完整路径。argv的除第一个元素外的其他元素为传入的参数。
argc至少为1，即argv数组至少包含程序名。
netstat -nt|grep 12345 :netstat -nt可查看所有tcp连接信息，包括端口接收和发送的信息的数量、连接双方的地址以及连接所处的状态。grep 12345代表查阅有包含12345的行。
#４.接收连接
```
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <assert.h>
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <errno.h>
#include <string.h>

int main( int argc, char* argv[] )
{
    if( argc <= 2 )
    {
        printf( "usage: %s ip_address port_number\n", basename( argv[0] ) );
        return 1;
    }
    const char* ip = argv[1];
    int port = atoi( argv[2] );

    struct sockaddr_in address;
    bzero( &address, sizeof( address ) );
    address.sin_family = AF_INET;
    inet_pton( AF_INET, ip, &address.sin_addr );
    address.sin_port = htons( port );

    int sock = socket( PF_INET, SOCK_STREAM, 0 );
    assert( sock >= 0 );

    int ret = bind( sock, ( struct sockaddr* )&address, sizeof( address ) );
    assert( ret != -1 );

    ret = listen( sock, 5 );
    assert( ret != -1 );

    struct sockaddr_in client;
    socklen_t client_addrlength = sizeof( client );
    int connfd = accept( sock, ( struct sockaddr* )&client, &client_addrlength );
    if ( connfd < 0 )
    {
        printf( "errno is: %d\n", errno );
    }
    else
    {
        char remote[INET_ADDRSTRLEN ];
        printf( "connected with ip: %s and port: %d\n", 
            inet_ntop( AF_INET, &client.sin_addr, remote, INET_ADDRSTRLEN ), ntohs( client.sin_port ) );
        close( connfd );
    }

    close( sock );
    return 0;
}
```
# 5.发送和接收带外数据
发送带外数据
```
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <assert.h>
#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <stdlib.h>

int main( int argc, char* argv[] )
{
    if( argc <= 2 )
    {
        printf( "usage: %s ip_address port_number\n", basename( argv[0] ) );
        return 1;
    }
    const char* ip = argv[1];
    int port = atoi( argv[2] );

    struct sockaddr_in server_address;
    bzero( &server_address, sizeof( server_address ) );
    server_address.sin_family = AF_INET;
    inet_pton( AF_INET, ip, &server_address.sin_addr );
    server_address.sin_port = htons( port );

    int sockfd = socket( PF_INET, SOCK_STREAM, 0 );
    assert( sockfd >= 0 ); //如果表达式为假，那么就打印错误并终止程序。assert一般用于调试，可以添加#define NDEBUG 来禁用assert调用
    if ( connect( sockfd, ( struct sockaddr* )&server_address, sizeof( server_address ) ) < 0 )
    {
        printf( "connection failed\n" );
    }
    else
    {
        printf( "send oob data out\n" );
        const char* oob_data = "abc";
        const char* normal_data = "123";
        send( sockfd, normal_data, strlen( normal_data ), 0 );
        send( sockfd, oob_data, strlen( oob_data ), MSG_OOB );
        send( sockfd, normal_data, strlen( normal_data ), 0 );
    }

    close( sockfd );
    return 0;
}
```
接收带外数据
```
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <assert.h>
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <errno.h>
#include <string.h>

#define BUF_SIZE 1024

int main( int argc, char* argv[] )
{
    if( argc <= 2 )
    {
        printf( "usage: %s ip_address port_number\n", basename( argv[0] ) );
        return 1;
    }
    const char* ip = argv[1];
    int port = atoi( argv[2] );

    struct sockaddr_in address;
    bzero( &address, sizeof( address ) );
    address.sin_family = AF_INET;
    inet_pton( AF_INET, ip, &address.sin_addr );
    address.sin_port = htons( port );

    int sock = socket( PF_INET, SOCK_STREAM, 0 );
    assert( sock >= 0 );

    int ret = bind( sock, ( struct sockaddr* )&address, sizeof( address ) );
    assert( ret != -1 );

    ret = listen( sock, 5 );
    assert( ret != -1 );

    struct sockaddr_in client;
    socklen_t client_addrlength = sizeof( client );
    int connfd = accept( sock, ( struct sockaddr* )&client, &client_addrlength );
    if ( connfd < 0 )
    {
        printf( "errno is: %d\n", errno );
    }
    else
    {
        char buffer[ BUF_SIZE ];

        memset( buffer, '\0', BUF_SIZE ); 	// 用来给某一块内存空间进行赋值的
        ret = recv( connfd, buffer, BUF_SIZE-1, 0 );
        printf( "got %d bytes of normal data '%s'\n", ret, buffer );

        memset( buffer, '\0', BUF_SIZE );
        ret = recv( connfd, buffer, BUF_SIZE-1, MSG_OOB );
        printf( "got %d bytes of oob data '%s'\n", ret, buffer );

        memset( buffer, '\0', BUF_SIZE );
        ret = recv( connfd, buffer, BUF_SIZE-1, 0 );
        printf( "got %d bytes of normal data '%s'\n", ret, buffer );

        close( connfd );
    }

    close( sock );
    return 0;
}
```
# 6.TIME_WAIT状态立即被重用
使sock处于TIME_WAIT状态，与之绑定的socket地址也可以立即被重用
```
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <assert.h>
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <errno.h>
#include <string.h>

int main( int argc, char* argv[] )
{
    if( argc <= 2 )
    {
        printf( "usage: %s ip_address port_number\n", basename( argv[0] ) );
        return 1;
    }
    const char* ip = argv[1];
    int port = atoi( argv[2] );

    int sock = socket( PF_INET, SOCK_STREAM, 0 );
    assert( sock >= 0 );
    int reuse = 1;
    setsockopt( sock, SOL_SOCKET, SO_REUSEADDR, &reuse, sizeof( reuse ) );

    struct sockaddr_in address;
    bzero( &address, sizeof( address ) );
    address.sin_family = AF_INET;
    inet_pton( AF_INET, ip, &address.sin_addr );
    address.sin_port = htons( port );
    int ret = bind( sock, ( struct sockaddr* )&address, sizeof( address ) );
    assert( ret != -1 );

    ret = listen( sock, 5 );
    assert( ret != -1 );

    struct sockaddr_in client;
    socklen_t client_addrlength = sizeof( client );
    int connfd = accept( sock, ( struct sockaddr* )&client, &client_addrlength );
    if ( connfd < 0 )
    {
        printf( "errno is: %d\n", errno );
    }
    else
    {
        char remote[INET_ADDRSTRLEN ];
        printf( "connected with ip: %s and port: %d\n", 
            inet_ntop( AF_INET, &client.sin_addr, remote, INET_ADDRSTRLEN ), ntohs( client.sin_port ) );
        close( connfd );
    }

    close( sock );
    return 0;
}
```
# 7.tcpdump
tcpdump是命令行形式的抓包工具。可以用wireshark 读取tcpdump 生成的pcap文件，用wireshark的图形化界面分析tcpdump 结果数据。
可参考：[tcpdump详解](https://www.cnblogs.com/111testing/p/13620931.html)
# 8.设置发送和接收缓冲区大小
设置发送缓冲区大小
```
#include <sys/socket.h>
#include <arpa/inet.h>
#include <assert.h>
#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <stdlib.h>

#define BUFFER_SIZE 512

int main( int argc, char* argv[] )
{
    if( argc <= 3 )
    {
        printf( "usage: %s ip_address port_number send_bufer_size\n", basename( argv[0] ) );
        return 1;
    }
    const char* ip = argv[1];
    int port = atoi( argv[2] );

    struct sockaddr_in server_address;
    bzero( &server_address, sizeof( server_address ) );
    server_address.sin_family = AF_INET;
    inet_pton( AF_INET, ip, &server_address.sin_addr );
    server_address.sin_port = htons( port );

    int sock = socket( PF_INET, SOCK_STREAM, 0 );
    assert( sock >= 0 );

    int sendbuf = atoi( argv[3] );
    int len = sizeof( sendbuf );
    /*先设置TCP发送缓冲区的大小，然后立即读取之*/
    setsockopt( sock, SOL_SOCKET, SO_SNDBUF, &sendbuf, sizeof( sendbuf ) );
    getsockopt( sock, SOL_SOCKET, SO_SNDBUF, &sendbuf, ( socklen_t* )&len );
    printf( "the tcp send buffer size after setting is %d\n", sendbuf );

    if ( connect( sock, ( struct sockaddr* )&server_address, sizeof( server_address ) ) != -1 )
    {
        char buffer[ BUFFER_SIZE ];
        memset( buffer, 'a', BUFFER_SIZE );
        send( sock, buffer, BUFFER_SIZE, 0 );
    }

    close( sock );
    return 0;
}
```
设置接受缓存区大小
```
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <assert.h>
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <errno.h>
#include <string.h>

#define BUFFER_SIZE 1024

int main( int argc, char* argv[] )
{
    if( argc <= 3 )
    {
        printf( "usage: %s ip_address port_number receive_buffer_size\n", basename( argv[0] ) );
        return 1;
    }
    const char* ip = argv[1];
    int port = atoi( argv[2] );

    struct sockaddr_in address;
    bzero( &address, sizeof( address ) );
    address.sin_family = AF_INET;
    inet_pton( AF_INET, ip, &address.sin_addr );
    address.sin_port = htons( port );

    int sock = socket( PF_INET, SOCK_STREAM, 0 );
    assert( sock >= 0 );
    int recvbuf = atoi( argv[3] );
    int len = sizeof( recvbuf );
    setsockopt( sock, SOL_SOCKET, SO_RCVBUF, &recvbuf, sizeof( recvbuf ) );
    getsockopt( sock, SOL_SOCKET, SO_RCVBUF, &recvbuf, ( socklen_t* )&len );
    printf( "the receive buffer size after settting is %d\n", recvbuf );

    int ret = bind( sock, ( struct sockaddr* )&address, sizeof( address ) );
    assert( ret != -1 );

    ret = listen( sock, 5 );
    assert( ret != -1 );

    struct sockaddr_in client;
    socklen_t client_addrlength = sizeof( client );
    int connfd = accept( sock, ( struct sockaddr* )&client, &client_addrlength );
    if ( connfd < 0 )
    {
        printf( "errno is: %d\n", errno );
    }
    else
    {
        char buffer[ BUFFER_SIZE ];
        memset( buffer, '\0', BUFFER_SIZE );
        while( recv( connfd, buffer, BUFFER_SIZE-1, 0 ) > 0 ){}
        close( connfd );
    }

    close( sock );
    return 0;
}
```
# 9.通过主机名字获取IP和端口
```
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h>
#include <stdio.h>
#include <unistd.h>
#include <assert.h>

int main( int argc, char *argv[] )
{
	assert( argc == 2 );
	char *host = argv[1];
	
	/*获取目标主机地址信息*/
	struct hostent* hostinfo = gethostbyname( host ); // 从hostinfo可获取IP
	assert( hostinfo );
	/*获取daytime服务信息*/
	struct servent* servinfo = getservbyname( "daytime", "tcp" );  // 从servinfo可获取端口号
	assert( servinfo );
	printf( "daytime port is %d\n", ntohs( servinfo->s_port ) );

	struct sockaddr_in address;
	address.sin_family = AF_INET;
	address.sin_port = servinfo->s_port;
	/*注意下面的代码，因为h_addr_list本身是使用网络字节序的地址列表，所以使用其
	中的IP地址时，无须对目标IP地址转换字节序*/
	address.sin_addr = *( struct in_addr* )*hostinfo->h_addr_list;

	int sockfd = socket( AF_INET, SOCK_STREAM, 0 );
	int result = connect( sockfd, (struct sockaddr* )&address, sizeof( address ) );
	assert( result != -1 );

	char buffer[128];
	result = read( sockfd, buffer, sizeof( buffer ) );
	assert( result > 0 );
	buffer[ result ] = '\0';
	printf( "the day tiem is: %s", buffer );
	close( sockfd );
    return 0;
}
```
]]></description></item><item><title>colab使用</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/05/07/16243295.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Sat, 07 May 2022 09:08:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/05/07/16243295.html</guid><description><![CDATA[基础使用参见[链接](https://blog.csdn.net/qq_36890370/article/details/106160805#commentBox)
注：创建了一个Untitled0.ipynb并装载成功以后，我们就可以在其中输入linux下的命令来运行我们的程序了，命令的前面要加!，这和使用juypter notebook是一样。

友情提醒：如果需要购买Google drive内存的朋友，在网页上好像是不能用国内的银行卡支付的，本人在这个问题上困扰了很久，最后解决的方法是本人在手机上下载了一个Google云端硬盘App,然后利用苹果APP Store绑定的银行卡就可以用国内的银行卡支付啦。
### 想到什么补充什么系列
Google Colab也有一些比较坑的地方，如下：
1.挂载只有12个小时，也就是说12小时之后你就需要重现挂载一次，所以就需要我们在进行模型训练的时候记得要加上checkpoint，不然你如果训练的模型超过12小时，Google断开挂载你就白白浪费12小时啦。
2.每次使用都需要重新配置你上次自己安装的环境，默认环境当然就不用啦。还有就是CUDA和Cudnn不需要重新配置（亲测），我也不知道为什么...欢迎指正。然后给大家安利一个方法，就是独立出一个页面把你要配的环境的代码都写在该页面下，下次打开只需要运行所有单元格就可以再开一个页面来跑你需要跑的程序啦。
3.模型在训练的过程中 有可能会出现连接中断需要重新连接的情况，不要怕点击重新连接就行，如果经常出现推荐给大家一个脚本神器按键精灵，人不在电脑边上只需要F10启动脚本左键点击功能。
4.如果电脑自动关机了，或者是自动更新什么的，只要时间不是很长，你只需要重启，恢复网页还是可以继续训练的，比较训练是挂载在Google上，但是时间久了也就要重新训练了。
5.如果是断网了也只需要联网点击重新连接即可，同上如果断网太久也就只能重新训练了
参考：(链接)[https://zhuanlan.zhihu.com/p/54389036]]]></description></item><item><title>我的计划</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/05/07/16243284.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Sat, 07 May 2022 09:06:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/05/07/16243284.html</guid><description><![CDATA[ # 英语计划
**目标**：听说读写能力、过六级口语和六级
英语适合碎片化的持续学习，不能一下吃成一个胖子

**计划**：
口语：我连最简单的对话都无法完成，故练习各个场景下的常见对话。
背新概念英语第一册，并做相应的笔记[]()
最好每天背五节课以上，并且多听。
**时间：**
早上刚来时，背至少一句。
每次休息时，拿一句来背一背。
休息完毕后，每天拿一篇六级阅读来读读。

#  专业计划
问题：每次可能遇到面试，自己感觉都没有可以拿得出来的东西
**专业知识**：游双、陈硕、复习C++（目标：面试不怕）：每天一早上
**刷leetcode**：中午十一点二十以后、下午五点以后、晚上十点以后
1.从易到难，刷到中等难度基本足以
2.按照数据结构类型来刷，比如一个时间段，只刷链表题，待刷得差不多的时候，接下来再刷二叉树的题

整理华挑所学
微表情检测系统
论文复现与修改（few-shot and zero-shot）：除早上以外的时间。

严格按照番茄时间来学，会比较轻松
早睡早起
## C++
1.学过的东西，很容易就忘。那就因为没有练习，可以通过运行敲代码、做项目、写博客的方式，来加深记忆。
2.举代码例子，来说明知识点。

# 其他
1.严格按番茄计划，可能会学得比较轻松一些。

# 如果再一个星期我就需要找工作，我该怎么办
学游双、看面试的C++题目、刷leetcode

# 自律
1.将自律培养成习惯
2.接收自律失败的自己并改正，只要你行走在路上就是进步。（好的情绪是自律的关键）
方法：
3.如果觉得做这个习惯很困难，那就告诉你自己只坚持先做一点点，做完一点点，看能不能再坚持做一点点，以此类推。
4.完成一个番茄，就在便利贴上打一个勾，让自己的努力可见。
5.冥想：安静坐好，专注呼吸。有利于抵御诱惑。
6.散散步、睡觉、调整放慢呼吸。
只有3和4是现在直接能做的。]]></description></item><item><title>C++工作要求</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/05/07/16243289.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Sat, 07 May 2022 09:06:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/05/07/16243289.html</guid><description><![CDATA[C++基础（最重要）
熟悉linux，熟悉多线程，熟悉常用数据结构和算法，
熟悉网络通信机制，TCP/HTTP/SOCKET等常用协议

附加：
图像方向：
5、图像开发基础，有OpenCV/OpenGL开发经验为佳；
6、底层硬件CPU/GPU加速开发经验优先；
7、有端上CV/CG/AR/ML系统设计开发经验：Lens/SparkAR/MediaPipe/游戏引擎/推理引擎优先

浏览器引擎（Lynx 自渲染引擎）方向：
2. 精通 C++ 研发技术，熟悉 Android / iOS 技术栈；
3. 熟悉计算机图形学及渲染管线相关知识；熟悉 2D 图形库（Skia）或 3D 渲染技术（OpenGL/Vulkan/Metal）者优先
4. 熟悉 Chromium / Flutter 等内核渲染层技术原理者优先；拥有React Native / Weex 或浏览器内核研发经验者优先
3. 熟练掌握C++，精通C++语言基础特性，熟悉C++11/14语法特性；熟悉标准库、Boost及常用C++库；对使用C++进行进/线程间通信、网络通信、内存管理等平台级开发知识有较好掌握；熟练使用C++常用编译及调试工具等。C++开发经验3年以上者为佳；
4. 熟悉移动端（Android或iOS）跨平台开发技术，熟悉Weex / ReactNative等框架实现原理；熟悉Flutter引擎实现原理优先；
5. 熟悉浏览器引擎技术（Chrome，Blink，Servo等），熟悉现代浏览器的DOM构建、管理及表示、渲染架构、CSS实现、排版布局等核心技术优先；
6. 熟悉计算机图形学相关知识，了解OpenGL / Vulkan / Metal 开发的优先，有音视频多媒体处理经验的优先；

其他1：
4.有微软MFC、COM经验者优先；

其他2：
5、熟悉docker、k8s虚拟化环境下的开发、调试、部署及问题排查

其他3：
2、精通C++；有大中型项目Linux后台开发经验(熟悉GDB调试优先)；
4、熟悉Oracle/DB2/MySQL等关系数据库管理、开发，1年以上数据库应用经验；熟悉Redis、FastDB等内存数据库的使用和开发；


qt开发：
2.熟悉MFC/C++软件，
3.熟练掌握SqlServer、Access、Sqlite等相关数据库；
4.熟悉QT软件开发或者LINUX系统开发优先考虑；
5.熟练掌握TCPIP、UDP等网络开发技术；
6.熟悉GPIB、USB、RS232、PXI接口的优先考虑；
7.具有测试自动化开发、ATE系统开发经验的优先考虑。
8.熟练使用Labview软件的优先考虑；


安全方向：
2、熟悉Win程序开发，包括：QT常规界面，多线程、虚拟内存、Hook等技术；
4、有逆向分析或Windows安全产品开发经验的优先。、

网络编程：
5.精通面向对象设计方法和设计模式，逻辑能力佳，熟悉UML设计工具；
6.熟悉TCP/IP、HTTP、WebSocket等协议，熟悉ONVIF、GB28181、SNMP等协议的优先；
7.熟练掌握至少一种数据库pg、Oracle、MySQL,有数据库优化经历者优先；

其他4:
4. 熟悉Linux平台基本使用/常用命令/shell脚本；


其他5：
3.熟悉Redis/HBase/MongoDB/ElasticSearch/Spark/Flink/Faiss/Annoy等，具有任一框架优化经验者更佳；
4.具有底层基础库优化经验者优先，包括但不限于JVM、CPU/GPU、OpenBLAS/MKL等；
5.具有分布式机器学习算法开发经验者优先。



算法：工作内容1、研发前沿计算机视觉, 图像处理, 深度学习算法；2、结合深度学习技术研发计算成像，计算摄影，传感器信号处理等相关产品3、在相关行业进行算法优化与落地。职位要求1、计算机,电子,信息工程等相关专业本科或以上学历, 希望有机器学习,计算机视觉,图像/信号处理相关背景；2、熟悉主流计算机视觉，图像处理算法；3、熟练使用C/C++, python等编程语言, 有编程竞赛获奖经历者优先；4、熟练使用pytorch，tensorflow，caffe等深度学习训练框架；5、有OpenCL，Neon，Hexagon DSP，Cadence DSP等移动端系统优化经验者优先；6、有手机行业, 传感器行业或摄像头行业技术研发类岗位从业经验者优先。]]></description></item><item><title>临时存</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/05/07/16243279.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Sat, 07 May 2022 09:05:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/05/07/16243279.html</guid><description><![CDATA[# 元学习
https://zhuanlan.zhihu.com/p/136975128
李宏毅元学习


# Cosine Normalization: Using Cosine Similarity Instead of Dot Product in Neural Networks
激活函数的输入是前一层的输出和权重的点积。由于点积没有大小限制，所以方差可能太大。而大的方差会对输入的分布比较敏感，这会导致泛化性变差和减慢训练速度。
我们提出了 cosine normalization， cosine normalization使用cosine similarity 或 centered cosine similarity来代替点积。
# Dynamic Few-Shot Visual Learning without Forgetting
在不忘记以前所学类的基础上学会识别更多的类，
To achieve that goal we propose (a) to extend an object recognition system withan attention based few-shot classification weight generator,and (b) to redesign the classifier of a ConvNet model as the cosine similarity function between feature representations
and classification weight vectors. ]]></description></item><item><title>numpy使用</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/05/07/16243270.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Sat, 07 May 2022 09:03:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/05/07/16243270.html</guid><description><![CDATA[# numpy分片中常见的错误：
```
a = np.array([[1,2,3,4],])
a = np.array([[1,2,3,4],[1,2,3,4],[1,2,3,4],[1,2,3,4],[1,2,3,4]])
a[1:3][1:3]    # 代表得到b=a[1:3]，然后再取b[1:3]
Out[5]: array([[1, 2, 3, 4]])
a[1:3,1:3] 
Out[6]: 
array([[2, 3],
       [2, 3]])
```
```
a = np.array([[1,2,3,4],[1,2,3,4],[1,2,3,4],[1,2,3,4],[1,2,3,4]])
a[[1,3],[1,3]]
Out[12]: array([2, 4])
```
结果不是array([[2, 3],
                        [2,3]])]]></description></item><item><title>背新概念第一册</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/05/07/16243262.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Sat, 07 May 2022 09:02:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/05/07/16243262.html</guid><description><![CDATA[1~19.
Is this your shirt
whose shirt is that
get ……back
here is/this is 
what is your job?
what nationality are you?
Catch!
come upstairs and see it
it is **the same color**
**is there**  a problem?
Your passports,please 
what is the matter?
all right=ok，如 are you ok = are you all right?
here you are
2，]]></description></item><item><title>栈、链表</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/05/07/16243256.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Sat, 07 May 2022 09:01:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/05/07/16243256.html</guid><description><![CDATA[# 1.栈
```
// 栈的使用
stack<int> inStack;     // 定义
inStack.top();              // 取栈顶元素
inStack.push(1)          // 元素进栈
inStack.pop();            // 栈顶元素出栈
inStack.empty();        // 判断栈是否为空。为空时，返回true
INT_MAX                  // int类型的最大值。直接可使用，无需引入头文件。如果不能直接使用，则引入头文件#include <limits.h>
INT_MIN
::min(a,b)                         // 取a和b中的较小值。::min代表使用的是类外的函数min。min来自#include <algorithm>
```
##1.1. [用两个栈实现队列](https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/)
思路：
- 进队：元素进入栈inStack
- 出栈：元素从outStack出栈。outStack为空时，将inStack里的元素全部出栈到outStack中，然后元素再从outStack出栈。
```
class CQueue {
private:
    stack<int> inStack, outStack;

    void in2out() {
        while (!inStack.empty()) {
            outStack.push(inStack.top());
            inStack.pop();
        }
    }

public:
    CQueue() {}

    void appendTail(int value) {
        inStack.push(value);
    }

    int deleteHead() {
        if (outStack.empty()) {
            if (inStack.empty()) {
                return -1;
            }
            in2out();
        }
        int value = outStack.top();
        outStack.pop();
        return value;
    }
};
```
##1.2. [包含min函数的栈](https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/)
题目：定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。
思路：每一次stack的入栈，min_stack都会入栈此刻stack中最小的元素，这样使得stack和min_stack大小始终一样大。当stack中的最小元素出栈时，min_stack中的最小元素也会恰好出栈。
```
class MinStack {
    stack<int> x_stack;
    stack<int> min_stack;
public:
    MinStack() {
        min_stack.push(INT_MAX);
    }
    
    void push(int x) {
        x_stack.push(x);
        min_stack.push(::min(min_stack.top(), x));   // ::min代表使用的是类外的函数min。min来自#include <algorithm>
    }
    
    void pop() {
        x_stack.pop();
        min_stack.pop();
    }
    
    int top() {
        return x_stack.top();
    }
    
    int min() {
        return min_stack.top();
    }
};
```
# 2.链表
```
// vector（动态数组）的使用
void push_back(const T& x):向量尾部增加一个元素X
void pop_back():删除向量中最后一个元素
```
题目：输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。
思路：从链头开始进行进栈，然后出栈即可
```
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    vector<int> reversePrint(ListNode* head) {
        /* 根据返回值定义存储结果的变量 */
        vector<int> result;
        /* 因为要反向输出值所以先把数据放入栈立里面然后在拿出来 */
        stack<int> st;
        ListNode* cur = head;
        /* 将数据压入栈 */
        while(cur != NULL) {
            st.push(cur->val);
            cur = cur->next;
        }
        /* 将栈中的数据弹出 利用栈的性质可以反向输出结果 */
        while(!st.empty()) {
            result.push_back(st.top());
            st.pop();
        }
        return result;

    }
};
```

















































From leetcode]]></description></item><item><title>C++ 虚基类、 多继承的构造和析构顺序</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/05/07/16243249.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Sat, 07 May 2022 09:00:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/05/07/16243249.html</guid><description><![CDATA[多继承：子类有两个或两个以上的父类。
多继承的构造函数调用顺序：基类的构造函数，成员对象的构造函数，子类的构造函数。析构函数与此顺序相反


虚基类中的构造和析构顺序]]></description></item><item><title>C++ 拷贝构造函数</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/05/07/16243235.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Sat, 07 May 2022 08:59:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/05/07/16243235.html</guid><description><![CDATA[#1.简介
拷贝构造函数（一种特殊的构造函数）：用一个对象初始化一个新建立的对象。默认拷贝构造函数的功能是把传入的对象的每个数据成员的值依次复制到新建立的对象中。
拷贝构造函数在三种情况下被调用：1）用于用一个对象初始化另一个对象 2）对象作为实参传递给形参 3）作为函数的返回值。举例如下：
```
#include<iostream>
using namespace std;

class Clock {
private:
	int H, M, S;
public:
	Clock(int h = 0, int m = 0, int s = 0) {	// 构造函数 
		H = h, M = m, S = s;
		cout << "constructor:" << H << ":" << M << ":" << S << endl;
	}

	~Clock() {
		cout<<"destructor:" << H << ":" << M << ":" << S << endl;
	}

	// 拷贝构造函数
	Clock(Clock &p) { // 由于一般不修改p，所以Clock(Clock &p)一般写为Clock(const Clock &p)
		H = p.H;
		M = p.M;
		S = p.S;
		cout << "copy constructor,before call:" << H << ":" << M << ":" << S << endl;
	}
};

Clock fun(Clock c) {
	return c;
}

int main() {
	Clock c1(8, 0, 0); // 调用构造函数
	Clock c2(9, 0, 0); // 调用构造函数
	Clock c3(c2); // 等价于Clock c3 =c2;，这里调用拷贝构造函数
	fun(c2); // c2作为实参传入时，调用一次拷贝构造函数。返回Clock对象时，又调用一次拷贝构造函数

	Clock c4;
	c4 = c2;	// c2和c4都是已存在的对象。此时不调用拷贝构造函数

	return 0;
}
```
结果如下：
```
constructor:8:0:0           // Clock c1(8, 0, 0); 输出
constructor:9:0:0           // Clock c2(9, 0, 0);输出
copy constructor,before call:9:0:0      // Clock c3(c2); 输出
copy constructor,before call:9:0:0      // c2作为实参传入fun(c2)时，调用一次拷贝构造函数。
copy constructor,before call:9:0:0      // fun(c2)返回Clock对象时，又调用一次拷贝构造函数
destructor:9:0:0
destructor:9:0:0
constructor:0:0:0          //  Clock c4;输出
```
额外说明：当对象作为函数的返回值时需要调用拷贝构造函数，此时C++将从堆中动态建立一个临时对象，将函数返回的对象复制给该临时对象，并把该临时对象的地址存储到寄存器里，从而由该临时对象完成函数返回值的传递。

# 2.深拷贝构造函数
深拷贝构造函数：默认拷贝构造函数是将一个对象的所有数据成员的值，复制给另一个对象的所有数据成员。但是当数据成员中存在指针时，默认拷贝构造函数只会拷贝地址到另一个对象。这就会导致两个不同的指针指向同一个地址，两个对象中的指针指向同一个内存空间，可能会导致内存的多次释放。
这个时候就需要重写拷贝构造函数来开辟新的内存空间，从而让两个不同的指针指向的地址不同且不同地址中存储的数据是相同的。举例如下：
```
#include <iostream>
using namespace std;

class test {
public:
	char* Str;

	test(const char* str) {
		int a = strlen(str);//改为sizeof就是错的
		Str = new char[a + 1];
	
		strcpy_s(Str, a+1,str); 
	}
	~test() {
		delete[] Str;
		Str = nullptr;
	}
};



int main() {
	test t1("aaaaaaa1"); // 
	test t2(t1);		//  t2.Str指向的地址和t1.Str指向的地址是一样的。

	return 0;
}
```
test t2(t1);使用默认拷贝构造函数，t2.Str指向的地址和t1.Str指向的地址是一样的，假设都指向地址A。那么对象t1和t2都会调用析构函数来释放地址A上的空间，这就会导致重复释放同一个空间，从而导致错误。
重写拷贝构造函数，修改代码为：
```
#include <iostream>
using namespace std;

class test {
public:
	char* Str;

	test(const char* str) {
		int a = strlen(str);//改为sizeof就是错的
		Str = new char[a + 1];
	
		strcpy_s(Str, a+1,str); 
	}
	~test() {
		delete[] Str;
		Str = nullptr;
	}
	test(const test &p) {
		int a = strlen(p.Str);//改为sizeof就是错的
		Str = new char[a + 1];

		strcpy_s(Str, a + 1, p.Str);
	}

	
};

int main() {
	test t1("aaaaaaa1"); // 
	test t2(t1);		// t2,Str指向的地址和t1.Str指向的地址是一样的。

	return 0;
}
```]]></description></item><item><title>C++　友元、虚基类、多态、虚函数</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/05/07/16243244.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Sat, 07 May 2022 08:59:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/05/07/16243244.html</guid><description><![CDATA[本文对友元、虚基类、多态和虚函数四个看起来高大上的概念进行介绍。

# 1.友元
友元：让其他函数（类外函数或者其他类的成员函数）可以访问对象的private和protect类型成员
## 1.1.友元函数
友元函数：在类内定义或声明的一个函数为友元，友元函数中创建的对象可以访问private和protect类型的数据成员。【注】友元函数不属于这个类中的成员函数，而是一个普通的类外函数或者其他类的成员函数。下面举两个实例进行说明：
友元函数为普通的类外函数：
```
#include <iostream>
#include <string>

class A {
private:
	int a;
	void printFun() {
		std::cout << a;
	}
public:
	A() {
		a = 1;
	}
	friend void accessPrivate(A b);  
};
void accessPrivate(A b) {
	b.printFun();
}

int main()
{
	A b = A();
	accessPrivate(b);
}
```
友元函数friend void accessPrivate(A b) 声明在类的任何位置都是可以的，即使声明在private下也可以。不过习惯将友元函数声明在类的最后面。

友元函数为其他类的成员函数：
```
#include <iostream>
#include <string>

class A;

class B {
public:
	void accessPrivate(A A1);  // 使用A，所以前面必须有A的声明
};

class A {
private:
	int a;
	void printFun() {
		std::cout << a;
	}
public:
	A() {
		a = 1;
	}
	friend void B::accessPrivate(A b); 
};

// 由于函数accessPrivate中调用了类A的printFun()函数，
// 所以必须等到类A的函数printFun()声明或定义完成后，
// 函数accessPrivate才能具体进行定义。
void B::accessPrivate(A A1) {  
	A1.printFun();
}


int main()
{
	B B1 = B();
	A A1 = A();
	B1.accessPrivate(A1);
}

```
## 1.2.友元类
友元类：将A声明为B的友元类，那么A的任意成员函数中创建的B类对象b，b都可以访问private和protect类型的数据成员。
``` 
#include <iostream>
#include <string>

class B;

class A {
private:
	int a;
	void printFun() {
		std::cout << a;
	}
public:
	A() {
		a = 1;
	}
	friend class B; 
};

class B {
public:
	void accessPrivate(A A1) {
		A1.printFun();
	}
};

int main()
{
	B B1 = B();
	A A1 = A();
	B1.accessPrivate(A1);
}
```
# 2.二义性问题
## 2.1.间接二义性问题（由虚基类解决）
间接二义性：首先我们知道子类继承父类中成员是将成员复制一份。当B和C都继承了A，然后D又继承了B和C。如果A中有成员a，那么D中就有两个名字相同的a。
虚基类：虚基类就是让当B和C都“虚”继承了A，如果D又继承了B和C。如果A中有成员a，那么D只有一个a。
举例如下：
```
#include<iostream>
using namespace std;

class base {
public:
	base() {
		a = 5; 
		cout << "base=" << a << endl;
	}

protected:
	int a;
};

class base1 :virtual public base {
public:
	base1() { 
		a += 10;
		cout << "base1=" << a << endl;
	}
};

class base2 :virtual public base {
public:
	base2() { 
		a += 20; 
		cout << "base2=" << a << endl; 
	}
};

class derived :public base1, public base2 {
public:
	derived() {
		cout << "derived a =" << a << endl; 
	}
};

int  main()
{
	derived obj;
	return 0;
}
```


## 2.2.多继承的二义性问题

多继承：子类有两个或两个以上的父类。
 二义性问题：多个基类中拥有同名的成员A，子类调用A时编译器无法确定调用的是哪个A。
二义性解决：
1）利用类的作用域分辨符。如Car::show()代表调用了类Car的函数show。
2）派生类中重定义此函数。
 3）将部分基类中的A改名。

# 3.多态
##3.1.多态
多态：假设B和C都继承于基类A，则B和C的对象都可以用基类的对象的指针a进行指向。当a调用方法x时，由于B和C类的方法x的实现是不一样，同样使用a->x得到的效果是不同。多态指的就是：使用相同的代码a->x，却可以根据a具体指向的对象而实现出不同的效果，这个不同的效果就是多态。
举例：
```
#include <iostream> 
using namespace std;

class Shape {
protected:
	int width, height;
public:
	Shape(int a = 0, int b = 0)
	{
		width = a;
		height = b;
	}
	int area()
	{
		cout << "Parent class area :" << endl;
		return 0;
	}
};
class Rectangle : public Shape {
public:
	Rectangle(int a = 0, int b = 0) :Shape(a, b) { }
	int area()
	{
		cout << "Rectangle class area :" << width * height << endl;
		return (width * height);
	}
};
class Triangle : public Shape {
public:
	Triangle(int a = 0, int b = 0) :Shape(a, b) { }
	int area()
	{
		cout << "Triangle class area :" << width * height / 2 << endl;
		return (width * height / 2);
	}
};
// 程序的主函数
int main()
{
	Shape *shape;
	Rectangle rec(10, 7);
	Triangle  tri(10, 5);

	// 存储矩形的地址
	shape = &rec;
	// 调用矩形的求面积函数 area
	shape->area();

	// 存储三角形的地址
	shape = &tri;
	// 调用三角形的求面积函数 area
	shape->area();

	return 0;
}
```
当上面的代码被编译和执行时，它会产生下列结果：
```
Parent class area :
Parent class area :
```
这就说明了shape->area()只调用了基类Shape中的area函数。
导致错误输出的原因是，调用函数 area() 被编译器设置为基类中的版本，这就是所谓的静态多态，或静态链接 - 函数调用在程序执行前就准备好了。有时候这也被称为早绑定，因为 area() 函数在程序编译期间就已经设置好了。
但现在，让我们对程序稍作修改，在 Shape 类中，area() 的声明前放置关键字 virtual，如下所示：
```
#include <iostream> 
using namespace std;

class Shape {
protected:
	int width, height;
public:
	Shape(int a = 0, int b = 0)
	{
		width = a;
		height = b;
	}
	virtual int area()
	{
		cout << "Parent class area :" << endl;
		return 0;
	}
};
class Rectangle : public Shape {
public:
	Rectangle(int a = 0, int b = 0) :Shape(a, b) { }
	int area()
	{
		cout << "Rectangle class area :" << width * height << endl;
		return (width * height);
	}
};
class Triangle : public Shape {
public:
	Triangle(int a = 0, int b = 0) :Shape(a, b) { }
	int area()
	{
		cout << "Triangle class area :" << width * height / 2 << endl;
		return (width * height / 2);
	}
};
// 程序的主函数
int main()
{
	Shape *shape;
	Rectangle rec(10, 7);
	Triangle  tri(10, 5);

	// 存储矩形的地址
	shape = &rec;
	// 调用矩形的求面积函数 area
	shape->area();

	// 存储三角形的地址
	shape = &tri;
	// 调用三角形的求面积函数 area
	shape->area();

	return 0;
}
```
修改后，当编译和执行前面的实例代码时，它会产生以下结果：
```
Rectangle class area :70
Triangle class area :25
```
此时，编译器看的是指针的内容，而不是它的类型。因此，由于 tri 和 rec 类的对象的地址存储在 *shape 中，所以会调用各自的 area() 函数。
#3.2.虚函数
虚函数是在基类中使用关键字 virtual 声明的函数。在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链接到该函数。我们想要的是在程序中任意点可以根据所调用的对象类型来选择调用的函数，这种操作被称为动态链接，或后期绑定。
**纯虚函数：**
您可能想要在基类中定义虚函数，以便在派生类中重新定义该函数更好地适用于对象，但是您在基类中又不能对虚函数给出有意义的实现，这个时候就会用到纯虚函数。
我们可以把基类中的虚函数 area() 改写如下：
```
class Shape {
   protected:
      int width, height;
   public:
      Shape( int a=0, int b=0)
      {
         width = a;
         height = b;
      }
      // pure virtual function
      virtual int area() = 0;
};
```
= 0 告诉编译器，函数没有主体，上面的虚函数是纯虚函数。


[菜鸟教程](https://www.runoob.com/cplusplus/cpp-polymorphism.html)还有七篇笔记没看，我先去睡觉，以后再看。。。。。。

参考：[菜鸟教程](https://www.runoob.com/cplusplus/cpp-polymorphism.html)
C++语言程序设计教程 第3版  沈显君 
]]></description></item><item><title>C++操作符重载</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/05/07/16243232.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Sat, 07 May 2022 08:58:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/05/07/16243232.html</guid><description><![CDATA[操作符重载：定义用操作符来操作对象时所产生的效果，如定义用加号来操作对象时所产生的效果（加法的重载）：
```
#include <iostream>
using namespace std;

class complex
{
public:
	complex(double a, double b);
	complex operator+(const complex & A)const;

	void display()const;
private:
	double real;   //复数的实部
	double imag;   //复数的虚部
};


complex::complex(double a, double b)
{
	real = a;
	imag = b;
}

//打印复数
void complex::display()const
{
	cout << real << " + " << imag << " i ";
}

//重载加法操作符
complex complex::operator+(const complex & A)const
{
	complex B(0,0);
	B.real = real + A.real;
	B.imag = imag + A.imag;
	return B;
}


int main()
{
	complex c1(4.3, -5.8);
	complex c2(8.4, 6.7);
	complex c3(0,0);

	//复数的加法
	c3 = c1 + c2;
	cout << "c1 + c2 = ";
	c3.display();
	cout << endl;

	return 0;
}
```]]></description></item><item><title>C++ inline</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/05/07/16243219.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Sat, 07 May 2022 08:57:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/05/07/16243219.html</guid><description><![CDATA[## 1.1.函数与inline
将函数替换成函数中具体的表达式，从而防止使用太多的函数而导致栈溢出。【栈空间就是指放置程序的局部数据（也就是函数内数据）的内存空间】
```
#include <stdio.h>
 
inline const char *num_check(int v)
{
    return (v % 2 > 0) ? "奇" : "偶";
}
 
int main(void)
{
    int i;
    for (i = 0; i < 100; i++)
        printf("%02d   %s\n", i, num_check(i));
    return 0;
}
```
内部任何调用 num_check(i)的地方都换成了 (v % 2 > 0) ? "奇" : "偶"，这样就避免了频繁调用函数对栈内存重复开辟所带来的消耗。

【注】
- inline 函数体内的代码一般是**简单**的，不能包含复杂的结构控制语句例如 while、switch，并且不能内联函数本身不能是直接递归函数（即，自己内部还调用自己的函数）。仅当函数体内包含常量开销O(1)的简单语句才使用inline关键字修饰成员函数
- inline 函数仅仅是一个**对编译器的建议**，如果编译器认为该函数过长，通常是O(n)级以上的消耗，编译器会忽略该请求。
- inline的问题：1.如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。2.另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。

使用inline的原因：1.防止栈溢出 2.函数切换时间相对于函数执行时间太大。

## 1.2.类中的成员函数与inline
定义在类中的成员函数默认都是内联的，如果在类定义时就在类内给出函数定义，那当然最好。如果在类中未给出成员函数定义，而又想内联该函数的话，那在类外要加上 inline，否则就认为不是内联的。
```
// 头文件
class A
{
    public:
    void Foo(int x, int y);
}
 
// 定义文件
inline void A::Foo(int x, int y){}
```
 值得注意的是： 如果在类体外定义inline函数，则必须将类定义和成员函数的定义都放在同一个头文件中(或者写在同一个源文件中)，否则编译时无法进行置换(将函数代码的拷贝嵌入到函数调用点)。 但是这样做，不利于类的接口与类的实现分离，不利于信息隐蔽。虽然程序的执行效率提高了，但从软件工程质量的角度来看，这样做并不是好的办法。只有在类外定义的成员函数规模很小而调用频率较高时，才将此成员函数指定为内置函数。
【[C++ 中的 inline 用法](https://www.runoob.com/w3cnote/cpp-inline-usage.html)中为什么说类中声明函数，类外使用内联函数，是比较好的编程习惯？这不是脱裤子放屁吗？直接在类中定义不就行了？】
【”定义在类中的成员函数默认都是内联的“这句话是什么意思？】

参考：[C++ 中的 inline 用法](https://www.runoob.com/w3cnote/cpp-inline-usage.html)
]]></description></item><item><title>C++　模板</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/05/07/16243223.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Sat, 07 May 2022 08:57:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/05/07/16243223.html</guid><description><![CDATA[#　1.模板
模版分为：类模版、函数模版、成员模板。
## 1.1.类模板
用一个实例进行说明：
```
template<typename T>	// 类模板，
class complex{
private:
    T re, im;	// 模板
    friend complex& __doap1 (complex *ths, const complex& r); 	// 友元函数

public:
    complex(T r = 0, T i = 0) : re(r), im(i){}	// 默认参数、初始化列表
    complex& operate+=(const complex&);	// 重载运算符
    T real() const { return re; }		// 成员函数-常函数
    T imag() const { return im; }
};

int main(){
    complex<double> c1(1.1, 2.2);
    complex<int> c2(3, 4);
}
```
在类complex的定义前，加一个template<typename T>：代表数据类型T是在声明对象的时候指定的，如complex<double> c1(1.1, 2.2);指定了T为double类型。
注：template<typename T>有时也写成template<class T>，它们是一样的，只是早期一般使用template<class T>。


## 1.2. 函数模板
用一个实例进行说明：
```
#include <iostream>

// 函数模板
template<class T>
inline T& min(T& a,  T& b) {
	return b < a ? b : a;	// 运算符< 可被重载
}

class stone {
	private:
		int _w, _h, _weight;
	public:
		stone(int w, int h, int we) : _w(w), _h(h), _weight(we) {}
		// 重载运算符<
		bool operator <(const stone& rhs) {
			return this->_weight < rhs._weight;
		}

		int getWeight() {
			return _weight;
		}
};

int main() {
	stone r1(2, 3,5), r2(3, 3,1);
	// 调用模板函数min，类型推导
	// 类型推导T为stone类型，进一步调用stone::operator<()
	stone r3 = min(r1, r2);
	std::cout << r3.getWeight();

	return 0;
}
```
注：函数模板使用时，不必显式指定具体的泛型类型。编译器会对函数模板进行实参推导/类型推导（argument deduction）。类模板使用时，需显式指定具体的泛型类型。


## 1.3.成员模版
成员模板：类模板中的成员函数也为模板。举例如下：
```
template <typename T>
 
class A {
public:
  template <typename U>
  void assign(const D<U>& u)
  {
    v = u.getvalue();
  }
  
  T getvalue()
  {
    return v;
  }
private:
  T v;
}
```
【注】成员模板不能是virtual

模板构造函数：一种特殊的成员模板
```
#include <iostream>

template <typename T>
class A
{
public:
	template <typename U>
	A(const U& a) {
		std::cout << "template constructor" << std::endl;
	}

	A(const A& a) {
		std::cout << "copy constructor" << std::endl;
	}
	A() {
		std::cout << "default constructor" << std::endl;
	}
};

int main() {
	A<int> i; // default constructor
	A<int> ii(i); // implicitly generated copy constructor
	A<double> d(i); // template constructor

	std::cin.get();
	return 0;
}
```
结果为：
```
default constructor
copy constructor
template constructor
```
由于ii和i的类型是一样的，所以调用类A<int>的拷贝构造函数A(const A& a) 对ii进行初始化。
由于d和i的类型是不一样的，所以调用A<double>的模板构造函数 A(const U& a) 来对d进行初始化。其中U的类型为A<int>。这就相当于A<double> d(i)就实现了用类A<int>初始化类A<double>，也就是说实现了隐式的类型转换。
”ii和i的类型是一样时，调用类A<int>的拷贝构造函数对ii进行初始化“，这就说明了A<int> ii(i)没有调用模板构造函数 A(const U& a) ，而是调用了拷贝构造函数A(const A& a)。也就是说模板构造函数 A(const U& a)没有覆盖掉拷贝构造函数A(const A& a)的作用。

参考：[链接1](https://blog.csdn.net/luoshabugui/article/details/104619151)
]]></description></item><item><title>W3Cschool:C++ Web 编程</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/05/07/16243212.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Sat, 07 May 2022 08:55:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/05/07/16243212.html</guid><description><![CDATA[# 1.CGI简介
##　1.1.简介和环境配置
公共网关接口（CGI），是一套标准，定义了信息是如何在 Web 服务器和客户端脚本之间进行交换的。CGI 程序包括网络通信的客户端和服务器。CGI 程序可以用 Python、PERL、Shell、C 或 C++ 等进行编写。
Apache（音译为阿帕奇）是世界使用排名第一的Web服务器软件

参考[CGI环境配置（Ubuntu）](https://www.cnblogs.com/paopaolx/p/14275964.html)，进行CGI环境配置。如果出现问题，建议重头再试来一遍。
C++的可执行文件放在/var/www/html/cgi-bin/目录下。除了C++的可执行文件外，/var/www/html/cgi-bin/目录下还可以存放各种各样的脚本程序。
## 1.2.第一个 CGI 程序：
在/var/www/html/cgi-bin/目录创建helloworld.cpp为文件，文件内容如下：
```
#include <iostream>
using namespace std;
 
int main ()
{
    
   cout << "Content-type:text/html\r\n\r\n";    cout << "<html>\n";
   cout << "<head>\n";
   cout << "<title>Hello World - 第一个 CGI 程序</title>\n";
   cout << "</head>\n";
   cout << "<body>\n";
   cout << "<h2>Hello World! 这是我的第一个 CGI 程序</h2>\n";
   cout << "</body>\n";
   cout << "</html>\n";
   
   return 0;
}
```
编译helloworld.cpp，并给可执行文件helloworld.cgi赋予相关权限：
```
gcc helloworld.cpp -o helloworld.cgi
chmod 755 helloworld.cgi
```

## 1.3.HTTP 头信息：
![](https://img2022.cnblogs.com/blog/1617829/202205/1617829-20220507165352832-1019616633.png)


## 1.4.CGI 环境变量
![](https://img2022.cnblogs.com/blog/1617829/202205/1617829-20220507165407514-205275549.png)

所有的 CGI 程序都可以访问下列的环境变量。这些变量在编写 CGI 程序时扮演了非常重要的角色。


# 2.C++ CGI 库的使用
## 2.1.安装 CGI 库
这个cgicc库，似乎是个几百年前的库，感觉现在学，没有什么意义。







参考：[C++ Web 编程](https://www.w3cschool.cn/cpp/cpp-web-programming.html)·]]></description></item><item><title>STL的总结</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/05/07/16243199.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Sat, 07 May 2022 08:53:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/05/07/16243199.html</guid><description><![CDATA[请先看[这个](https://www.jianshu.com/p/29359030ef03)，然后再看本文
# 0.简介

容器的概念：容器就是类模板，此类模板是用来生成不同数据类型下的数据结构，如生成int型栈、char型栈等。容器是个类肯定包含对数据结构的操作，如进栈、出栈、获取栈中元素个数等。
容器一般都在命名空间std中，所以在#include<容器名>后， 一般还需要写using namespace std;


# 1.容器中一般都拥有的函数
容器中一般拥有以下的函数：
以下函数的具体使用直接参考[官方](http://www.cplusplus.com/reference/stl/)提供的代码实例，就可以很容易使用。
iterators：指向第一个元素和最后一个元素的 iterator，如begin、end、rbegin、rend等
size：元素个数、empty：是否为空
max_size： 容器的成员函数max_size()取得 STL容器的capacity属性，表示STL在发生realloc前能允许的最大元素数，也可以理解为预分配的内存空间。 例如一个vector<int> v的capacity为5，当插入第6个元素时，vector会realloc，vector内部数据会复制到另外一个内存区域。
front和back：返回第一个元素和最后一个元素
pop_front和pop_back：弹出第一个或最后一个元素
erase：擦除对应位置上的元素
swap：将两个对象的值进行交换
resize：通过删除后面的元素和增加零（或增加指定元素），来使对象中的元素变为指定大小
clear：清空对象
insert：在迭代器指向的位置插入元素
splice：将一个对象A中的连续的多个元素插入到另一个对象B中，此时这些元素在A中被删除。
remove：移除特定值的元素、remove_if移除满足条件的元素
unique：移除重复元素，或移除满足条件的元素
reverse：翻转元素顺序
merge：拼接已经排序好的两个对象时，输出的还是排序好的对象。拼接的两个对象其中有一或两个未排序好，则直接将两个对象拼接在一起。可以按指定条件拼接两个对象。
sort：将元素进行排序。除了容器本身带有的sort函数，我们还可以使用全局的::sort来实现排序。但是如果容器自带sort，使用自带的最好；如果容器没有自带sort，再使用全局的::sort。
assign：用于给容器分配元素，相当于初始化对象。
#　2.list
list（双向链表）：每个元素均有指针指向前一个元素和下一个元素（快速 插入或删除）。list 容器中的元素可以分散存储在内存空间里，而不是必须存储在一整块连续的内存空间中。不可通过[]访问元素（快速查找）。可使用push_back、pop_back、push_front、pop_front
```
#include <iostream>
#include <list>
using namespace std;
int main()
{	
	// 初始化list
	//std::list<double> values;  //创建空的 list 容器
	std::list<double> values(10, 5); // 创建了一个包含 10 个元素并且值都为 5 个 values 容器。

	//拷贝普通数组，创建list容器
	//int a[] = { 1,2,3,4,5 };
	//std::list<int> values(a, a + 5);

	//拷贝其它类型的容器，创建 list 容器
	//std::array<int, 5>arr{ 11,12,13,14,15 };
	//std::list<int>values(arr.begin() + 2, arr.end());//拷贝arr容器中的{13,14,15}

	//向容器中添加元素
	values.push_back(3.1);  // 也可使用push_front()在双向链表的前面添加元素
	values.push_back(2.2);
	cout << "values size：" << values.size() << endl;
	//对容器中的元素进行排序
	values.sort();
	//使用迭代器顺序输出list容器中的元素（不知道为什么这个才是顺序输出）
	for (std::list<double>::iterator it = values.end(); it != values.begin();) {
		std::cout << *(--it) << " ";
	}
	cout << std::endl;
	//使用迭代器倒序输出list容器中的元素
	for (std::list<double>::iterator it = values.begin(); it != values.end();++it) {
		std::cout << *it << " ";
	}
	return 0;
}
```


list是双向链表，那指向上一元素和下一个元素的指针是什么？？答：似乎没有提供这样的指针，只能使用迭代器进行访问。也就是说list是双向链表是指它的存储的采用的是双向链表的方式，从而让list 容器中的元素可以分散存储在内存空间里.
参考：[C++ list（STL list）容器完全攻略（超级详细）](http://c.biancheng.net/view/6892.html)
[c++官方STL手册](http://www.cplusplus.com/reference/stl/)

# 3.stack
stack和queue是不允许使用迭代器iterator，因为这会破坏栈和队列访问元素的特性。
```
// 栈的使用
stack<int> inStack;     // 定义
inStack.top();              // 取栈顶元素
inStack.push(1)          // 元素进栈
inStack.pop();            // 栈顶元素出栈
inStack.empty();        // 判断栈是否为空。为空时，返回true
```
# 4.vector
```
// vector（动态数组）的使用
void push_back(const T& x):向量尾部增加一个元素X
void pop_back():删除向量中最后一个元素
```
vector不可使用push_front和pop_front
![](https://img2022.cnblogs.com/blog/1617829/202205/1617829-20220507165055942-864464924.png)


# 5.deque（双端队列）
给vector分配的总空间都是2的整数倍。当扩充vector类型的数据时，如果发现空间不够，就会将数据搬移到一个更大的空间中去。新的空间大小是旧的空间的小的$2^n$倍（根据扩充的数据多少，选择最小的n）。在使用vector类型数据的时候，每次空间不够都需要将空间进行翻倍，这就会导致分配的空间可能有冗余，即有些空间没有被用。
deque（双端队列）：与vector类似，这里的双端指的是可以从数组的两端插入数据。从前端或后端以push_front()或push_back()添加元素。在增加数据元素时,如果deque容器内原先定义的内存空间不足,deque容器会将新增加的数据元素存储到另外一块内存中。可通过[]访问元素（快速查找）




# 6.map以及迭代器的使用
## 6.1.插入、查看、删除
map就是用来保存键值对的，即<key,value>。
元素的插入、查看、删除。这里我们以一个实际可运行的程序，进行说明，以便以后进行参考和使用。
```
#include<map>  //注意，STL头文件没有扩展名.h
#include<iostream>
#include<string>
using namespace std;

int main() {
	map<int, string> mapStudent;

	// 插入元素的三种方法
	// mapStudent.insert(pair<int, string>(0, "student_zero"));		// 不用纠结pair是什么，反正它就是这么写的
	// mapStudent.insert(map<int, string>::value_type(0,"student_zero"));
	mapStudent[0] = "student_zero";
	
	// 当使用insert插入的<key,value>时，mapStudent已经存在key了。此时insert不会生效
	pair<map<int, string>::iterator, bool> Insert_Pair;			// 接收插入失败的信息
	Insert_Pair = mapStudent.insert(map<int, string>::value_type(0, "student_one"));
	if (!Insert_Pair.second)
		cout << "Error insert new element" << endl;
	// mapStudent[0] = "student_one"; // 覆盖<0,"student_zero">为<0,"student_one">


	// 访问元素的两种方法
	//map<int,string>::iterator iter=  mapStudent.find(0);		// 使用迭代器访问元素
	//cout <<iter->first<<endl;		// 输出0
	//cout << iter->second << endl;    // 输出student_zero
	cout << mapStudent[0]<<endl;			// 数组方式访问元素。输出student_zero

	
	mapStudent[1] = "student_one";		// 插入新元素

	// 使用迭代器访问mapStudent中的所有元素
	map<int, string>::iterator iter;
	cout << "删除前" << endl;
	for (iter = mapStudent.begin(); iter != mapStudent.end(); iter++){
		cout << "iter->first:" << iter->first << "iter->second:" << iter->second << endl;
	}
		
	//int n =  mapStudent.erase(1);	// 删除key为1的元素。如果刪除了會返回1，否則返回0
	mapStudent.erase(mapStudent.begin(), mapStudent.end());//用迭代器范围刪除 : 把整个map清空
	cout << "删除后" << endl;
	for (iter = mapStudent.begin(); iter != mapStudent.end(); iter++) {
		cout << "iter->first:" << iter->first << "iter->second:" << iter->second << endl;
	}

	return 0;
}
```
pair的作用就是将两种类型包装成一个整体，具体可参考[链接](https://blog.csdn.net/sevenjoin/article/details/81937695)
## 6.2.map的操作函数总结
     C++ map是一种关联式容器，包含“关键字/值”对
     begin()         返回指向map头部的迭代器
     clear(）        删除所有元素
     count()         返回指定元素出现的次数, (帮助评论区理解： 因为key值不会重复，所以只能是1 or 0)
     empty()         如果map为空则返回true
     end()           返回指向map末尾的迭代器
     equal_range()   返回特殊条目的迭代器对
     erase()         删除一个元素
     find()          查找一个元素
     get_allocator() 返回map的配置器
     insert()        插入元素
     key_comp()      返回比较元素key的函数
     lower_bound()   返回键值>=给定元素的第一个位置
     max_size()      返回可以容纳的最大元素个数
     rbegin()        返回一个指向map尾部的逆向迭代器
     rend()          返回一个指向map头部的逆向迭代器
     size()          返回map中元素的个数
     swap()           交换两个map
     upper_bound()    返回键值>给定元素的第一个位置
     value_comp()     返回比较元素value的函数

## 6.3.map与vector的深拷贝
map1=map2和vec1 = vec2进行的就是深拷贝，vec1和vec2之间就没有关联，map1和map2之间就没有关联


#7.迭代器
迭代器：一种通用的方法访问具有不同结构的各种容器中的每个元素，是广义的指针。每种容器定义自己的迭代器，如list<T>::iterator、vector<T>::iterator

迭代器++是找到下一个元素，迭代器－－是找到上一个元素。
在双向链表list中，我们可以知道下一个元素就是next所指元素，上一个元素就是prev所指元素。list的迭代器的++操作，就会访问list节点对应的next指针。也就是说list的迭代器的++与指针的++不一样，后者只是地址的增加，而迭代器会根据具体的容器类型执行不同的“++”操作，迭代器是相当于一个智能指针。

其他三种迭代器：reverse_iterator（用于反向遍历）,const_iterator（返回一个常数值）,const_reverse_iterator

#8.操作容器的通用函数
操作容器的通用函数在<algorithm>头文件中定义，以函数模板的形式给出，使用迭代器对数据进行访问。
如果容器有自带某种函数，那么优先使用自带的。如：对于vector对象a，可使用a.sort()进行排序，就不要使用<algorithm>中的sort进行排序。



#其他
**1.emplace、emplace_front、emplace_back和push、push_front、push_back的区别：**
```
S.push(data(1,2));
S.emplce(data(1,2)); // push可以怎么使用，emplace就可以怎么使用。反之，不行。
S.emplce(1,2);  // 与S.emplce(data(1,2));等价，但是由于没有创建data(1,2)所以就节省了内存
```
注意：emplace_back(type) 对应 push_back(type)
emplace(i, type) 对应于 insert(type, i)
emplace_front(type) 对应于 push_front()
但是！对于stack 和 queue，只有push操作，所以也只有emplace操作，此时它们是相对应的。

详细讲解见：[STL - emplace 与 push 的区别](https://blog.csdn.net/Kprogram/article/details/82055673)



**2.STL迭代器辅助函数**
![](https://img2022.cnblogs.com/blog/1617829/202205/1617829-20220507165228885-1962770713.png)






参考：[C/C++中深浅拷贝(map、vector)与内存释放](https://blog.csdn.net/hanxiaoyong_/article/details/112150777)
[C++ map用法总结（整理）](https://blog.csdn.net/sevenjoin/article/details/81943864)
[C++ 教程](https://www.w3cschool.cn/cpp)
[C++中的STL中map用法详解](https://www.cnblogs.com/fnlingnzb-learner/p/5833051.html)
C++语言程序设计教程 第3版  沈显君 ]]></description></item><item><title>W3Cschool:C++多线程</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/05/07/16243176.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Sat, 07 May 2022 08:49:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/05/07/16243176.html</guid><description><![CDATA[C++ 不包含多线程应用程序的任何内置支持。相反，它完全依赖于操作系统来提供此功能，如在Linux中就使用POSIX 编写多线程 C++ 程序。下面介绍POSIX 编写多线程 C++ 程序。
```
#include <pthread.h>
pthread_t tid;  // 创建一个用于保存线程的变量
pthread_create (thread, attr, start_routine, arg) 
// thread：被创建的线程
// attr：设置线程属性
// start_routine：线程执行的函数
// arg：start_routine中传入的参数
pthread_exit (status) 
```

写个鸡巴，不想写了，待续。。。。。。。


# 问题
void 类型数据是什么？
什么时候用？
函数前的void *又是干嘛用的？？
pthread_exit (status)中的status除了是NULL，还可以是什么？














参考：[链接](https://www.w3cschool.cn/cpp/cpp-multithreading.html)]]></description></item><item><title>STL与泛型编程笔记 第二讲</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/05/07/16243162.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Sat, 07 May 2022 08:48:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/05/07/16243162.html</guid><description><![CDATA[#　1.查看标准库源码
在Windows系统中，visual studio默认使用的是微软C++编译器（MSVC），当然你可以修改visual studio使用何种编译器。
我是用的是visual studio 2017，它把C++标准库的源码放在了Visual Studio2017\VC\Tools\MSVC\14.16.27023\include下。其他在visual studio 2017中查看源码的方法请参考[使用Visual Studio查看系统库的源码结构](https://blog.csdn.net/qq_40946921/article/details/89266735)


#　2.list不能使用::sort
标准库提供的全局::sort()算法所使用的迭代器必须是随机访问迭代器（Random Access Iterator）。
链表list的迭代器不支持随机访问，无法使用全局::sort()算法进行排序。
vector和deque的迭代器支持随机访问，可使用全局::sort()算法进行排序。
注：随机访问指的就是直接first+N，便可以得到第N个元素的地址，因为这些相邻元素是按顺序连续存储的。


#　3.面向对象和泛型编程的区别？
面向对象编程（OOP，Object-Oriented Programming）：将数据data和操作method相关联。
泛型编程（GP，Generic Programming）：将数据data和操作method相分离。

采用泛型编程的优点：
- 容器（Containers）和算法（Algorithms）可各自独立实现，提供统一的对外接口即可，两者以迭代器（Iterator）作为桥梁。
- 算法（Algorithms）通过迭代器（Iterator）确定操作范围，并通过迭代器（Iterator）获取和使用容器（Containers）元素。


模板的相关知识，请参考：[C++ 模板](https://www.jianshu.com/p/710acc3d5fc1)


# 4.allcator
即使学会了利用allocator，也不建议去使用它。使用new和malloc就可以。但是需要了解它。【都不要去使用它，那了解它干嘛？？】
C++的内存分配函数的底层都是调用了malloc和free，malloc和free再根据不同的操作系统类型(Windows，Linux，Unix等)底层的系统API来获取内存和释放内存。
malloc分配的内存中不止用来存数据，也存储一些额外的数据（如分配出去的空间大小）。如果分配次数越多，那么内存中数据越零散，这些额外的数据开销就越大。所以一个优秀的分配器，应当尽可能的让这些额外的空间占比更小，让速度更快。

GC2.9的alloc分配器的优化思路：malloc分配的内存中不止用来存数据，也存储一些额外的数据（如分配出去的空间大小）。但是因为同一个容器而言，它的内置类型应当是相同的。所以对于容器的分配器，我们可以对此作出优化。









本小节候捷也没有具体讲，等我看完内存管理，再来补充这一节吧，若想提前学习的，请参考：https://blog.csdn.net/weixin_45067603/article/details/122770539



#5.深度探索list
迭代器++是找到下一个元素，迭代器－－是找到上一个元素。在双向链表list中，我们可以知道下一个元素就是next所指元素，上一个元素就是prev所指元素。
list的迭代器的++操作，就会访问list节点对应的next指针。也就是说list的迭代器的++与指针的++不一样，后者只是地址的增加，而迭代器会根据具体迭代器类型执行不同的“++”操作，迭代器是相当于一个智能指针。


list<int>::iterator a;这里的::是什么意思？？


源码探究：为什么下面这个是倒序？？——学会看源码
```
//使用迭代器倒序输出list容器中的元素
	for (std::list<double>::iterator it = values.begin(); it != values.end();++it) {
		std::cout << *it << " ";
	}
	return 0;
```


参考：[【学习笔记】C++STL和泛型编程-侯捷](https://blog.csdn.net/newson92/article/details/122164204)
]]></description></item><item><title>分配器</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/05/07/16243168.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Sat, 07 May 2022 08:48:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/05/07/16243168.html</guid><description><![CDATA[参考：https://blog.csdn.net/weixin_45067603/article/details/122770539]]></description></item><item><title>侯捷-STL与泛型编程笔记（第一讲、容器概述——0.概述）</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/05/07/16243158.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Sat, 07 May 2022 08:47:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/05/07/16243158.html</guid><description><![CDATA[参考：[链接](https://blog.csdn.net/qq_33053671/article/details/84504632)
#一、简介
C++标准库的header files不带.h后缀的，如：#include<cstdio>
这种形式的head files称为新式headers，新式headers内组件封装在namespace “std”（新式统一规定都在std）
using namespace std;（全部加载）
using std::cout;（cout单个）

常用网站：
- CPlusPlus.com
- CppReference.com
- gcc.gnu.org

我最常使用的是CPlusPlus.com。使用方法就是在搜索框中搜索想要的查询的类。千万不要认为这种开发手册就很复杂，而且是英文的，就不去看。你去认真去看了就会发现，开发手册写得很好。因为我英语不好，所以在搜索函数的后，会直接看开发手册给的实例，比如我在搜索vector的insert函数的使用时，会直接看手册中的代码实例，然后可能会去看看英文的讲解或者直接去百度了。
我认为本视频应该需要配套《stl源码剖析（侯捷）》看。
# 二、STL六大部件（components）
>容器（Containers）：容器存储数据
分配器（Allocators）：分配器为容器分配内存
算法（Algorithms）：算法处理容器的数据
迭代器（Iterators）：迭代器为算法提供访问容器的方式
适配器（Adapters）：进行转换，具体如何转换，以后介绍
仿函式（Functors）：仿函数为类似不同的类相加减提供支持。（？？？我还是不懂仿函式是什么？）
六大部件的关系：
![STL六大部件的关系](https://img2022.cnblogs.com/blog/1617829/202205/1617829-20220507164410109-1834572195.png)


## 2.1.一个例子说明六大部件
```
//一个例子说明六大部件
#include <vector>
#include <algorithm>
#include <functional>
#include <iostream>
using namespace std;

int main()
{
	int ia[6] = {27, 210, 12, 47, 109, 83};
	vector<int, allocator<int>> vi(ia,ia + 6);//<>符号表示模板，allocator<int>是一个分配器模板。
                                              // 如果将本行代码改为vector<int>，则vector会使用默认的分配器
	
	cout << count_if(vi.begin(), vi.end(),
			not1(bind2nd(less<int>(), 40)));    // 输出大于等于四十的数的个数
	return 0;
}
//vector是一个容器containers
//count_if是一个算法algorithm，计算vi里符合条件的元素个数
//vi.begin(), vi.end()是一个迭代器iterator。
//vi.begin()指向第一个元素，vi.end()指向最后一个元素的下一个元素  
//less<int>是一个仿函数function
//bind2nd是一个适配器function adapter，它将40绑定到less函数的第二个形参上
//notl是一个适配器function adapter,表示否定。bind2nd(less<int>(), 40)的结果相当于
//{true,false,true,false,false,false}，则not1(bind2nd(less<int>(), 40))就相当于{false,true,false,true,true,true}
```
我现在暂时对泛性编程的理解是：算法独立与数据结构，也就说函数count_if不止可以用于操作vector类型的数据，还可以操作其他类型的数据，如[这个](http://cplusplus.com/reference/functional/not1/?kw=not1)中的例子

## 2.2.遍历容器中所有元素
```
旧版遍历：
Container<T> c;
...
Container<T>::iterator ite = c.begin();
for (; ite != c.end(); ++ite)
	...

C++11遍历：
for (decl:coll){ // 其中coll为容器或者数组
    statement
}
//举例如下：
//1.
for (int i: {2,3,4,5,6,7,8,9,10})
{
	std::cout << i << std::endl;
}
//2.
int ia[] =  {2,3,4,5,6,7,8,9,10}
for (int i: ia)
{
	std::cout << i << std::endl;
}
//3.
std::vector<double> vec;
...
for (auto elem : vec) {  // auto代表让编译器判断，这里应该是个什么类型
	std::cout << elem << std::endl;   // 不需要进行解引用操作
}

for (auto& elem : vec) {   // auto&使得对elem的修改，就相当于对vec中相应元素的修改
	elem *= 3; 
}
```
## 2.3.容器种类
顺序容器Sequence Containers
- Array（固定元素个数）C++11：就是我们平时使用的数组，不过把现在用一个类将它包装起来。数组元素的个数在定义的时候就已经确定，不可扩充。
- Vector（尾部个数可以扩充）
- Deque（头尾个数可以扩充）
- List（双向链表）
- Forward-List（单向链表）C++11

关联容器Associative Container（通过key可以找到value）：关联容器一般使用红黑树进行实现。查找速度快，但由于插入的时候需要调整红黑树而导致插入速度慢。
- Set/Multiset（key=value）：multiset允许重复元素，Set不允许有重复。
- Map/Multimap(key对应value；multimap允许重复元素，map不允许有重复。

不定序容器Unordered Containers（属于关联容器）:使用hash表进行实现。包括unordered_map、unordered_multimap、unordered_set、unordered_multiset，具体使用，请参考cplusplus.com
各个容器的结构：
![各个容器的结构](https://img2022.cnblogs.com/blog/1617829/202205/1617829-20220507164540006-90034695.png)



适配器（看作一种不能使用迭代器的容器）：
有三种适配器：队列(queue)、优先队列( priority queue)和栈(stack)，
适配器不允许使用迭代器iterator，因为这会破坏栈和队列访问元素的特性（先进后出和先进先出）。

接下来侯捷老师讲解了几种容器的使用，可以直接参考[我的写的博客](https://www.jianshu.com/p/5bfcd6ad88a4)，或者直接在[开发手册](http://cplusplus.com/)中进行学习

allocator：在第一章的allocator，啥也没有介绍。

# 问题
1.map的重复元素指的是key重复吗？？
答：是的，指的就是key不可以重复 

2.如果map或set插入相同key的value时，不会报错。map插入相同key的value时，会将key对应的value改成新插入的value。

3.mutimap不可以使用[]来做插入？？
答：应该是因为multimap允许插入重复元素的原因，所以就不可以使用[]来做插入

4.为什么侯捷将容器适配器stack和queue也当成容器来说明？？ 
答：stack和queue的内部使用的deque进行实现的。由于这两种容器没有自己的数据结构，它们是借用deque进行实现的，所以在技术上，有些人将stack和queue称为Container Adapter。
]]></description></item><item><title>mysql数据库学习</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/05/07/16243139.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Sat, 07 May 2022 08:43:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/05/07/16243139.html</guid><description><![CDATA[数据库学习计划：（1）直接学习这个https://www.w3cschool.cn/mysql/
（2）如果有时间可以学一学《SQL必知必会》里面我不知道的内容

ubuntu20.04安装mysql请参考[链接](https://blog.csdn.net/qq_29761395/article/details/104249924)

登录mysql：
```
mysql -u root -p
```]]></description></item><item><title>redis的基本使用</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/05/07/16243136.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Sat, 07 May 2022 08:41:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/05/07/16243136.html</guid><description><![CDATA[# 1.ubuntu安装redis
安装
```
sudo apt update
sudo apt install redis-server
```
一旦安装完成，Redis 服务将会自动启动。想要检查服务的状态，输入下面的命令：
```
sudo systemctl status redis-server
```
你应该看到下面这些：
```
 redis-server.service - Advanced key-value store
     Loaded: loaded (/lib/systemd/system/redis-server.service; enabled; vendor preset: enabled)
     Active: active (running) since Sat 2020-06-06 20:03:08 UTC; 10s ago
```
# 2.配置 Redis 远程访问
打开 Redis 配置文件：
```
sudo vim /etc/redis/redis.conf
```
如果找不到/etc/redis/redis.conf，请参考[链接](https://blog.csdn.net/qq_39552993/article/details/113433319)
定位到以bind 127.0.0.1 ::1开头的一行，并且将它注释。
如果你的服务器有局域网 IP，并且你想要 Redis 从局域网可以访问 Redis，在这一行后面加上服务器局域网 IP 地址，如下：
```
# bind 127.0.0.1 ::1
bind 192.168.154.130 ::1 #  192.168.154.130为本服务器IP
```
保存这个文件，并且重启 Redis 服务，使应用生效：
```
sudo systemctl restart redis-server
```
下一步，你将需要配置你的防火墙，允许网络流量通过 TCP 端口6379。
通常你想要允许从一个指定 IP 地址或者一个指定 IP 范围来访问 Redis 服务器。例如，想要允许从192.168.121.0/24的连接，运行下面的命令：
```
sudo ufw allow proto tcp from 192.168.121.0/24 to any port 6379
```
确保你的防火墙被配置仅仅接受来自受信任 IP 的连接。
此时，你应该可以从远程位置通过 TCP 连接到 Redis 的 6379 端口。
想要验证所有设置都设置好了，你可以尝试使用redis-cli从你的远程机器上 ping 一下 Redis 服务器。
```
redis-cli -h <REDIS_IP_ADDRESS> ping
```
这个命令将会返回一个响应：PONG

参考：[链接](https://developer.aliyun.com/article/764565#:~:text=Redis%205.0%20%E8%A2%AB%E5%8C%85%E5%90%AB%E5%9C%A8%E9%BB%98%E8%AE%A4%E7%9A%84%20Ubuntu%2020.04%20%E8%BD%AF%E4%BB%B6%E6%BA%90%E4%B8%AD%E3%80%82%20%E6%83%B3%E8%A6%81%E5%AE%89%E8%A3%85%E5%AE%83%EF%BC%8C%E4%BB%A5%20root,%E8%BA%AB%E4%BB%BD%E8%BF%90%E8%A1%8C%E4%B8%8B%E9%9D%A2%E7%9A%84%E5%91%BD%E4%BB%A4%EF%BC%9A%20sudo%20apt%20update%20sudo%20apt%20install%20redis-server)
# 3.redis的基本使用
## 3.1.远程登录命令：
```
redis-cli -h 192.168.154.130 -p 6379 -a "mypass"   # 192.168.154.130为服务器IP，mypass为登录密码
```
## 3.2.Redis支持五种数据类型
Redis支持五种数据类型：string（字符串），hash（哈希），list（列表），set（集合）及zset(sorted set：有序集合)。
###3.2.1.Redis 字符串(String)
Redis 字符串(String)：就是添加一个key，以及一个字符串类型的value


###3.2.2.哈希(Hash)
哈希(Hash)：每一个key下，可以创建多个<field,value>
每个 hash 可以存储 $2^{32} - 1$ 键值对（40多亿）【这是指<field,value>的个数为$2^{32} - 1$吗？】
```
HMSET runoobkey name "redis tutorial" description "redis basic commands for caching"
```
key为runoobkey，<field,value>有<name,"redis tutorial" >、<description,"redis basic commands for caching">


###3.2.3.Redis 列表(List)
Redis 列表(List)：每一个key下，可以创建多个字符串。按照插入顺序排序。


###3.2.4.Redis 集合(Set)
每一个key下，可以创建多个字符串。无序排列，成员唯一。



###3.2.5.Redis 有序集合(sorted set)
Redis 有序集合和集合一样也是 string 类型元素的集合,且不允许重复的成员。
不同的是每个元素都会关联一个 double 类型的分数。redis 正是通过分数来为集合中的成员进行从小到大的排序。
有序集合的成员是唯一的,但分数(score)却可以重复。
集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。 集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)。

我把菜鸟教程里的东西抄一遍也没有意义，所以这里知识粗略总结自己的理解。具体可以参考[菜鸟教程](https://www.runoob.com/redis/redis-tutorial.html)。菜鸟教程对各种命令进行了中文的总结，需要的时候，查阅就行。
当然我们也可以直接查阅官网的[命令手册](https://redis.io/commands/)，官方文档对每个命令所举的例子很好。

redis常用的可视化软件为Redis Desktop Manager，不过好像要钱。



# 问题：
redis如何用于保存关系型数据库的数据
redis不能使用sql？？


NoSQL(NoSQL = Not Only SQL )，意即“不仅仅是SQL”。NoSQL数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，尤其是大数据应用难题，包括超大规模数据的存储。redis是属于NoSQL的。
为什么mysql不行，NoSQL就可以解决大数据应用问题。
NoSQL：这些类型的数据存储不需要固定的模式，无需多余操作就可以横向扩展。【这里的固定模式指mysql数据库中的什么？横向扩展又是指什么？】
]]></description></item><item><title>Redis 设计与实现（第二版）笔记</title><link>http://www.cnblogs.com/codingbigdog/archive/2022/05/07/16243111.html</link><dc:creator>好人~</dc:creator><author>好人~</author><pubDate>Sat, 07 May 2022 08:36:00 GMT</pubDate><guid>http://www.cnblogs.com/codingbigdog/archive/2022/05/07/16243111.html</guid><description><![CDATA[参考：[Redis 设计与实现（第二版）](https://www.w3cschool.cn/hdclil/)
# 0.简介
Remote Dictionary Server(Redis) 是一个 由C语言编写的key-value存储系统。

Redis特点：
- Redis将其数据库完全保存在内存中，仅使用磁盘进行持久化。【持久，即把数据（如内存中的对象）保存到可永久保存的存储设备中（如磁盘）。持久化的主要应用是将内存中的对象存储在数据库中，或者存储在磁盘文件中、XML数据文件中等等。】
- 与其它键值数据存储相比，Redis有一组相对丰富的数据类型。【其他数据库不行吗？】
- Redis可以将数据复制到任意数量的从机中。【其他数据库不行吗？】

Redis的数据都是缓存在内存中。周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。
# 1.数据结构与对象
## 1.1.Redis简单动态字符串
redis创建了一个简单动态字符串（simple dynamic string，SDS）来保存字符串，而没有直接采用C 语言传统的字符串表示（以空字符结尾的字符数组，以下简称 C 字符串）。SDS数据结构如下：
```
struct sdshdr{
    //buf已使用的字节数
    int len;
    //buf未使用的字节数
    int free;
    //字节数组，用于保存字符串
    char buf[];
}
```
SDS数据结构中记录着数组buf中已使用的字节和未使用的字节。
len和free是根据输入的字符串自动生成的。

**SDS 与 C 字符串的区别**：
**1.常数复杂度获取字符串长度**。SDS获取一个 SDS 长度的复杂度仅为 O(1)。对于C字符串，由于C字符串不会记录自身长度，因此只能遍历，直到遇到结尾的空字符为止,时间复杂度为O(N)
**2.SDS杜绝缓冲区溢出**。由于C字符串未记录自身长度，容易导致缓冲区溢出。在执行字符串拼接时，如果没有足够的空间，并且相邻内存地址被其他字符串占用时，字符串的数据将溢出，且容易意外修改相邻的字符串内容。相比而言，SDS会将这种情况扼杀在摇篮之中，SDS API先判断空间是否满足，如果不满足则将空间扩展至执行修改所需的大小。
**3.减少修改字符串时带来的内存重分配次数**
**空间预分配（优化字串增长）**：程序不仅会为 SDS 分配修改所必须要的空间， 还会为 SDS 分配额外的未使用空间。在扩展 SDS 空间之前，SDS API 会先检查未使用空间是否足够， 如果足够的话， API 就会直接使用未使用空间， 而无须执行内存重分配。具体为：
- 增加字串长度以后，字串的长度L小于1MB时，则分配2L+1个字节，（额外的一字节用于保存空字符）；
- 字串的长度L大于等于1MB时，则分配L+1MB+1B的空间（额外的一字节用于保存空字符）

**惰性空间释放（优化字串缩短）**：当 SDS 的 API 需要缩短 SDS 保存的字符串时， 程序并不立即使用内存重分配来回收缩短后多出来的字节， 而是使用 free 属性将这些字节的数量记录起来， 并等待将来使用。
**4.SDS API都是二进制安全的。**
C字符串的字符必须符合某种编码，并且中间不能有空字符，否则读取时会被误以为是字符串结尾。种种局限使得C字符串只能存文本，不能存图片，音频，视频，压缩文件等二进制数据。 为确保Redis对不同使用场景的支持，SDS API都是二进制安全的，也就是所有SDS API都会以二进制的方式存取buf中的数据，数据的写入和读出都是一个样的。由于SDS读取时并不是依靠空字符来判断结束的，而是len属性，所以是二进制安全的。
**5.兼容部分C字符串函数。**
SDS虽然都是二进制安全的，但也遵循以空字符结尾的习惯。SDS API总会在buf数组分配空间时多分配一个字节用于容纳空字符，这是为了保存文本的SDS重用一部分<string.h>库函数，避免代码重复。

SDS API中介绍操作SDS的函数


## 1.2.Redis 链表和链表节点的实现
当一个列表键包含了数量比较多的元素，或者列表中包含的元素都是比较长的字符串时，Redis就会使用链表作为列表键的底层实现。
每个链表节点使用一个 adlist.h/listNode 结构来表示：
```
typedef struct listNode {

    // 前置节点
    struct listNode *prev;

    // 后置节点
    struct listNode *next;

    // 节点的值
    void *value;

} listNode;
```
adlist.h/list链表的数据结构：
```
typedef struct list {

    // 表头节点
    listNode *head;

    // 表尾节点
    listNode *tail;

    // 链表所包含的节点数量
    unsigned long len;

    // 节点值复制函数
    void *(*dup)(void *ptr);

    // 节点值释放函数
    void (*free)(void *ptr);

    //  用于对比链表节点所保存的值和另一个输入值是否相等。
    int (*match)(void *ptr, void *key);

} list;
```
## 1.3.字典










参考：[链接](https://zhuanlan.zhihu.com/p/140726424)
[链接2](https://www.w3cschool.cn/hdclil/)]]></description></item></channel></rss>