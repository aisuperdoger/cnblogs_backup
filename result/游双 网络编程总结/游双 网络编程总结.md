原文链接：http://www.cnblogs.com/codingbigdog/archive/2022/09/01/16647770.html
提交日期：Thu, 01 Sep 2022 12:39:00 GMT
博文内容：
读书建议：如果某个地方看不懂，请将你到底不懂什么东西描述出来。你可能会发现作者在下一段就给予了你解释



1.概述：

数据链路层：ARP(IP转MAC)、RARP（MAC转IP）

网络层：IP协议、ICMP（检测网络：就是发出去看有什么回应）

传输层：TCP（可靠、连接、流）、UDP（不可靠、无连接、数据报）

应用层：ping、telnet（远程登录）、OSPF、DNS

2.MTU：帧最多能携带多少上层协议数据（比如IP数据报），如以太网帧的MTU是1500字节

ICMP协议、TCP协议和UDP协议都使用IP协议

应用层协议使用的端口号都可在/etc/services文件中找到

ARP：广播问一下“你们谁的IP是A，请告诉我你的mac为多少”

ARP协议能实现任意网络层地址到任意物理地址的转换，不过本书仅讨论从IP地址到以太网地址（MAC地址）的转换。

ARP有一个高速缓存，保存经常（最近）访问的IP到mac的映射。

Linux下可以使用arp命令来查看和修改ARP高速缓存。

使用tcpdump进行抓包，从而观察ARP通信过程

DNS：域名到IP的映射

/etc/resolv.conf文件来存放DNS服务器的IP地址

使用host命令访问DNS服务器

使用tcpdump进行抓包，从而观察DNS通信过程

socket：数据链路层、网络层和传输层协议处于内核，需要通过socket进行操作。故socket就是一个系统调用。





2.IP协议

IP协议提供无状态、无连接、不可靠的服务。

​	无状态：IP数据报的发送是相互独立的，数据报的发送没有关联。上层协议（如tcp协议）自己处理乱序的、重	复的报	文段。

​	无连接：每次发送都需要指明目的地的IP

​	不可靠：IP层检测到发送失败，IP层不会下达重传命令，而是向传输层报告错误。传输层根据报告的错误进行相	应的处理，如进行重传，当然重传的数据报也会经历传输层、网络层和数据链路层。

分层协议的每一层可以看作一个实现一定功能的函数，函数直接相互独立。上层函数中生成的数据放入下层函数进行处理，下层函数将收到的数据拆解送到上层。

将IPv4的数据报每32个bit（四个字节）分为一行，前三行为一些版本、长度等信息；第四和第五行为32位的源地址和目的地址；故IPv4的头部至少由五行（20个字节）构成。IPv4头部除了前20字节以外，还有40字节的可选选项

IP数据报的头部构成：

​		第一行：4位版本号（如IPv4或IPv6）；4位头部长度：每bit表示4个字节；8位服务类型TOS（表示此数据报要进行什么样的发送，有最小延时，最大吞吐量，最高可靠性和最小费用）；16位数据报总长度（每bit表示一个字节，故最大数据报为65535个字节，但一般MTU为1500字节，故最大数据报为1500字节）

​		第二行：16位标识（同一个分片标识相同）；3位标志字段（分别为保留、禁止分片、这是否是最后一个分片）；13位分片偏移（每bit代表8字节，代表分片在数据报中的位置）

​		第三行：8位生存时间（TTL，经过的路由跳数）；8位协议（数据报交给上层什么协议进行处理，有ICMP、TCP、UDP等）；16位CRC校验位；

​		第四和五行：32位源地址和32位目的地址

​		40字节的可选选项：记录经过的路由IP；记录被在每一跳被转发时的时间；经过指定的所有IP；只能经过指定的所有IP（traceroute程序需要使用）

使用tcpdump观察IPv4头部结构

IP分片，用tcpdump抓取分片





3.IP数据报转发

判断IP数据报是否是给本机的，如果是，则交给传输层；如果不是，则进行转发；这也侧面说明了起转发功能的路由器，只有网络层和数据链路层，没有传输层和应用层。

route命令或netstat命令查看路由表。

路由查找：1）找完全匹配的IP 2）找网络号相同的IP 3）发送给默认路由（网关）

通过route命令可以手动修改路由。BGP、RIP、OSPF等协议可以自动更新路由

主机一般只发送和接收数据报，修改/proc/sys/net/ipv4/ip_forward文件为1，则主机将具有转发功能。

ICMP重定向报文用于更新路由表：当检测到不合理的转发时，告诉说走哪条比较合理

修改/proc/sys/net/ipv4/conf/all/accept_redirects内核参数可指定是否允许接收ICMP重定向报文

主机重定向实例

IPv6协议并不是IPv4协议的简单扩展，而是完全独立的协议。





4.TCP

TCP（可靠、连接、流）、UDP（不可靠、无连接、数据报）

面向连接： 两个人打电话时，双方确认并建立连接后才能进行通信。
面向无连接：在邮局寄信时，你只需要将信放在邮筒里，不需要给收件人通知，收件人也不知道你给他寄信了。

TCP是一对一的；UDP则非常适合于广播和多播

在UDP中，如果有n个send就要有n个recv。如果recv比较少 ，会因为接收数据不及时而产生丢包。是这个意思吗？？？

可靠：每个发送都需要应答。超时重传：超过某时间未收到应答则重发

UDP协议则和IP协议一样，提供不可靠服务。它们都需要上层协议来处理数据确认和超时重传。 上层协议来处理的意思是

TCP头部结构：用于指定通信的源端端口，目的端端口，管理TCP连接等

客户端的端口号由系统自动选取，服务器则使用知名服务端口号

TCP头部选项：修改linux的某些文件启动和关闭某些选项。

使用tcpdump观察TCP头部信息

三次握手建立连接和释放连接

同步报文段和结束报文段没有携带任何应用程序数据，但它们也要占用一个序号值

半关闭状态：我告诉你我的发送已经结束了，但是我还可以收数据的

利用iptable命令过滤收到的数据包

tcpdump抓取超时重连发送的数据

/proc/sys/net/ipv4/tcp_syn_retries中可修改进行超时重连的次数

TCP的三次握手中的每次握手客户端和服务器所处的状态名称

TIME_WAIT：收到服务器的结束报文时客户端处于的状态，然后客户端将会发送确认报文。TIME_WAIT状态在持续2MSL后，会被转化成CLOSED。

TIME_WAIT的作用：1）确认丢失时，对服务器重复发送的结束报文进行处理 2）处理来迟的TCP报文

TIME_WAIT的副作用：如果程序使用的是固定的端口（如知名服务端口号），在程序结束后，端口会被占用一段时间，导致程序重启。

服务器程序可以通过设置socket选项SO_REUSEADDR来强制使用被处于TIME_WAIT状态的连接所占用的socket地址。

我们也可以通过修改内核参数/proc/sys/net/ipv4/tcp_tw_recycle来快速回收被关闭的socket，从而使得TCP连接根本就不进入TIME_WAIT状态

复位报文段：复位报文段就是携带RST标志的报文段，以通知对方关闭连接或重新建立连接。

1）访问不存在端口或处于TIME_WAIT的端口时，对方将会返回复位报文段

2）一旦**发送了**复位报文段，**发送端**所有排队等待发送的数据都将被丢弃。这是异常终止连接的方法。

3）A关闭连接或异常终止了连接，而B没有接收到结束报文段，此时B如果发送信息，A就会返回复位报文段。





5.TCP交互数据流：

​		客户端对服务器返回数据的确认都不带应用程序数据。这是因为要携带应用程序数据要等用户输入才行，而用户输入的速度是比较慢。

​		服务器对客户端返回数据的确认一般都带应用程序数据。这里的确认是指对客户端发送请求的确认，而携带的应用程序数据是指客户端请求的数据。所以一般是将客户端请求的数据和对请求的确认一起发送回客户端。

​		Nagle算法：每输入一个字符就用一个TCP报文进行传输，这样会导致网络拥塞。Nagle算法：报文未被确认之前不发送新的报文，但发送方在等待确认的同时收集本端需要发送的数据，并在确认到来时以一个TCP报文段将它们全部发出。

TCP成块数据流：发送方会连续发送多个TCP报文段，接收方可以一次确认所有这些报文段。服务器每发送4个TCP报文段就传送一个PSH标志（tcpdump输出标志P）给客户端，以通知客户端的应用程序尽快读取数据

外带数据：用于告诉对方本端发生的紧急事件。一般使用TCP头部中的紧急指针标志和紧急指针两个字段。接收端只将紧急事件的最后一个字节读入一个特殊的缓存

TCP设置SO_OOBINLINE选项时，则带外数据将和普通数据一样被TCP模块存放在TCP接收缓冲区中。紧急指针可以用来指出带外数据的位置

iperf是一个测量网络状况的工具

TCP超时重传：TCP服务必须能够重传超时时间内未收到确认的TCP报文段。重传几次后，就尝试利用ARP重新获取目的地的mac地址。

控制超时重传次数的文件：：/proc/sys/net/ipv4/tcp_retries1和/proc/sys/net/ipv4/tcp_retries2。故有这样一个认识，所有我们学习的网络传输协议都是用一个一个文件实现的。如果我们要修改某一个协议中的某一个值时候，只需要百度“linux修改xx”就可以了。所以说linux中万物都是文件。





6.以下内容几乎全部摘录自《计算机网络 by谢希仁》，因为《计算机网络 by谢希仁》和《Linux高性能服务器编程 by 游双》对本部分内容的讲述有所出入。有时间在对这部分内容进行深究。

可靠传输：

​		以字节为单位的滑动窗口：1）A收到确认，根据确认号和接收方窗口值调整窗口 2）B收到从头开始的连续字节，窗口才能向前移动并发出确认

​		超时重传的时间选择

​		SACK：告诉发送方，我那个部分没有收到，请你再发一下。

流量控制：

​		发太快，来不及接收：发送窗口不能比接收方给出的接收窗口大

​		发太小：使用Nagle算法——先将第一个数据字节发送出去，然后就等待对此数据报的确认并在等待期间缓存所有到达的数据。当收到确认或数据达到发送窗口大小的一半或数据达到最大长度，就立刻发送一个报文段。

​		糊涂窗口综合征：接收方发送的确认，它确认的数据太小，使得发送窗口增长缓慢。解决方法：1）等接收缓存可以装一个最长报文时，再发确认。或 2）等接收缓存一半是空闲的。**这样老是等这等那的，不就不能实现实时的传输了？？？？**

拥塞控制：

​		慢开始：拥塞窗口cwnd初始化为2~4SMSS（最大报文段）。每收到一次确认，拥塞窗口就增加min(N,SMSS)，其中N为此次确认中包含的之前未被确认的字节数，SMSS为最大报文段的字节数。每经过一个轮次cwnd就翻倍（具体见计算机网络（谢希仁））。

​		拥塞避免：当cwnd超过门限值时，则每个轮次cwnd都加1（即线性增加），而不是每个轮次cwnd都翻倍。(《Linux高性能服务器编程 by 游双》对线性增加提到了其他的算法)

​							当发生超时，门限值=cwnd/2，cwnd=1

​		快重传：接收方已发送M2的确认后，若未收到M3，则M4、M5……每到达一个都会使接收方发送一个对M2的重复确认。当发送方收到三个重复的确认时，则发送方就会赶快重发M3（快重传）。

​		快恢复：出现快重传时，使用快恢复。门限值=cwnd/2，cwnd=门限值，即立刻开启拥塞避免算法。

拥塞发生依据：1）超时却未收到确认 2）受到三个对同一报文的重复确认





7.linux下设置代理：export http_proxy=“ip:端口”。

正向代理：将我们的请求送给正向代理服务器，让它替我们请求

反向代理：通过反向服务器将众多请求分散给多个服务器，实现负载均衡。大型网站通常将反向代理作为公网访问地址，阻止web攻击

透明代理：我理解的是：网关总是将请求发送给一个正向代理服务器，则称为透明代理。此时不需要对局域网内的所有主机进行设置，所有主机都通过网关使用正向代理服务器。应该就是通过路由器翻墙的原理。

在服务器上配置squid程序就可以实现代理。squid是一个支持所有代理的软件。

使用tcpdump抓取传输数据包

squid程序通过读取/etc/resolv.conf文件获得DNS服务器的IP地址。**这个IP地址是自动生成的吗？？？**

Linux将目标主机名及其对应的IP地址存储在/etc/hosts配置文件，如果程序在/etc/hosts文件中未找到目标机器名对应的IP地址，它将求助于DNS服务。

用户可以通过修改/etc/host.conf文件来自定义系统解析主机名的方法和顺序（一般是先访问本地件/etc/hosts，再访问DNS服务）

TCP连接中，发送结束报文的同时是可以携带数据的

HTTP的请求：HTTP的九种请求方法。Linux中的命令：HEAD、GET和POST。其含义基本与HTTP协议中的同名请求方法相同。

HTTP的应答：状态码（如404）；Cookie（携带用户信息）





8.第五章：
1.socket的主要API都定义在sys/socket.h头文件

实现主机名和IP地址之间的转换，以及服务名称和端口号之间的转换，定义在netdb.h头文件

字节序分为大端字节序（big endian）和小端字节序（little endian）。

现代PC大多采用小端字节序，因此小端字节序又被称为主机字节序。

一般大端字节序也称为网络字节序，即在网络中一般将字节序统一转化为大端进行传播，即接收方收到的第一个字节被当作高位看待

通过c语言的union结构实现机器的字节序的判断

将数据转化为同一种字节序进行传输的四个函数

2.通用socket地址结构体： sockaddr_storage和sockaddr，可以用于存放IPv4或IPv6地址等

地址族与协议族对应表。在bits/socket.h头文件中，地址族与协议族可以混用。

通用socket地址结构体设置与获取IP地址和端口号较烦琐，故一般使用专用socket地址结构体，如sockaddr_in和sockaddr_in6用于IPv4和IPv6。所有专用socket地址（以及sockaddr_storage）类型的变量在实际使用时都需要转化为通用socket地址类型sockaddr（强制转换即可），因为所有socket编程接口使用的地址参数的类型都是sockaddr（所有与socket编程相关的函数使用的地址参数的类型都是sockaddr）。

十进制字符串表示IPv4地址，以及用十六进制字符串表示IPv6地址。

（用点分十进制字符串表示的IPv4地址或用十六进制字符串表示的IPv6地址）和用网络字节序整数表示的IP地址之间的转换的函数



socket在linux中被当成文件描述符

socket函数：初始化socket，返回一个int类型

bind函数：给socket绑定IP和端口

listen函数：让socket处于监听状态

accept函数：从监听队列中获取连接

accept调用对于客户端网络断开毫不知情（这里与作者的实验和我的实验结果完全不一致？？？）

accept只是从监听队列中取出连接，而不论连接处于何种状态（如上面的ESTABLISHED状态和CLOSE_WAIT状态），更不关心任何网络状况的变化（这里与作者的实验和我的实验结果完全不一致？？？）

connnect：与服务器建立连接并返回一个socket供客户端读写，通过对socket的读写来与服务器进行通信。实际上只返回了一个int类型的变量，这就说明了connnect在系统内部完成了对真正的socket进行了一系列操作。

close：关闭指定的套接字。如果不止有一个进程引用了该套接字，则close的作用变为将套接字的引用计数减一。

shutdown：不论是否有其他进程引用了该套接字，都关闭此套接字。shutdown还可以只关socket的读或写。



linux下可以使用read和write或recv和send对数据进行读写。

recv成功时返回实际读取到的数据的长度，它可能小于我们期望的长度len。因此我们可能要多次调用recv，才能读取到完整的数据

send成功时返回实际写入的数据的长度

flags参数为数据收发提供了额外的控制，通常设置为0。flags参数只对send和recv的当前调用生效，而后面我们将看到如何通过setsockopt系统调用永久性地修改socket的某些属性。

发送和接收外带数据（紧急数据）。接收紧急数据会导致正常的数据不能通过一个recv调用全部读出

socket编程接口中用于UDP数据报读写的系统调用是recvfrom和sendto。recvfrom/sendto系统调用也可以用于面向连接（STREAM）的socket的数据读写，只需要把最后两个参数都设置为NULL

socket编程接口还提供了通用数据读写函数（recvmsg和sendmsg）

内核通知应用程序带外数据到达的两种常见方式是：I/O复用产生的异常事件和SIGURG信号。

利用sockatmark判断读取的数据是否为外带数据，然后利用带MSG_OOB标志的recv调用来接收带外数据

获取本端socket地址以及远端的socket地址：getsockname和getpeername



fcntl系统调用是控制文件描述符属性的通用POSIX方法。getsockopt和setsockopt是专门用来读取和设置socket文件描述符属性的方法。getsockopt和setsockopt通过设置socket选项的方法来读取和设置socket文件描述符属性

服务器端的有些soket选项必须在调用listen前进行设置才会有效，即三次握手前设置。客户端的有些soket选项必须在调用connnect前进行设置才会有效，即三次握手前设置。

listen监听队列中接受的连接至少已经完成了TCP三次握手的前两个步骤。connect调用后，TCP三次握手就已完成

对监听socket设置这些socket选项，那么accept返回的连接socket将自动继承这些选项。（这句话什么意思，什么叫监听socket选项）

SO_REUSEADDR选项：

​		服务器程序可以通过设置socket选项SO_REUSEADDR来强制使用被处于TIME_WAIT状态的连接所占用的socket地址。

​		我们也可以通过修改内核参数/proc/sys/net/ipv4/tcp_tw_recycle来快速回收被关闭的socket，从而使得TCP连接根本就不进入TIME_WAIT状态

SO_RCVBUF和SO_SNDBUF选项：

​		设置接受和发送缓存的大小，设置的大小不能低于系统设定的最小值。我们可以修改/proc/sys/net/ipv4/tcp_rmem和/proc/sys/net/ipv4/tcp_wmem来强制TCP接收缓冲区和发送缓冲区的大小没有最小值限制。

​		这里有一个通过tcpdump抓取的通信过程，很有意思可以看一看

SO_RCVLOWAT和SO_SNDLOWAT选项（一般设为1）：大于SO_RCVLOWAT时可读，大于SO_SNDLOWAT可写

SO_LINGER选项：

​		用于控制close系统调用在关闭TCP连接时的行为。（如果通过close没有成功关闭，而是引用计数减一，此时这些行为还会发生吗？？）

​		l_onoff等于0：代表此功能关闭

​		l_onoff不为0，l_linger等于0：丢弃TCP发送缓冲区中残留的数据，发送复位报文段，这种情况给服务器提供了异常终止一个连接的方法

​		l_onoff不为0，l_linger大于0：具体见书中内容



可以用主机明代替IP地址，用服务器名代替端口号。

gethostbyname和gethostbyaddr：

​		gethostbyname函数通常先在本地的/etc/hosts配置文件中查找主机，如果没有找到，再去访问DNS服务器。

​		gethostbyaddr函数根据IP地址获取主机的完整信息。

getservbyname和getservbyport：getservbyname函数根据名称获取某个服务的完整信息，getservbyport函数根据端口号获取某个服务的完整信息。它们实际上都是通过读取/etc/services文件来获取服务的信息的。

上面四个函数都是不可重入的，但有可重入的版本。

正如Linux下所有其他函数的可重入版本的命名规则那样，这些函数的函数名是在原函数名尾部加上_r（re-entrant）。

getaddrinfo：可通过主机名获取IP，通过服务器名获取端口号。

getnameinfo：通过socket地址同时获得以字符串表示的主机名和服务名





第六章 高级I/O函数：本章实际上本质是对文件描述符进行操作的函数进行介绍

用于创建文件描述符的函数，包括pipe、dup/dup2函数

用于读写数据的函数，包括readv/writev、sendfile、mmap/munmap、splice和tee函数。

用于控制I/O行为和属性的函数，包括fcntl函数



pipe函数创建的这两个文件描述符fd[0]和fd[1]分别构成管道的两端。用fd[1]写入的数据，用fd[0]读出。

写端文件描述符fd[1]的引用计数减少至0，则fd[0]的read操作将返回0，即读取到了文件结束标记（EOF）

读端文件描述符fd[0]的引用计数减少至0，则fd[1]的write操作将失败，并引发SIGPIPE信号

我们可以使用fcntl函数来修改管道容量

socketpair函数方便地创建双向管道。



dup和dup2：复制文件描述符。dup——取当前可用最小整数值作为文件描述符。dup——取第一个不小于file_descriptor_two的整数值作为文件描述符。

【注】通过dup和dup2创建的文件描述符并不继承原文件描述符的属性，比如close-on-exec和non-blocking等（这两个是啥？？我怎么不记得见过？？）

先关闭标准输出文件描述符STDOUT_FILENO（其值是1），然后通过dup()复制socket文件描述符connfd。此时由于1是最小可用的，c故onnfd就被复制到了值为1的文件描述符上。此时printf产生的输出会传送到客户端中。



readv函数将数据从文件描述符读到分散的内存块中，即分散读；writev函数则将多块分散的内存数据一并写入文件描述符中，即集中写。

Web服务器上实现集中写的程序



sendfile函数实现：两个文件描述符之间的传递数据完全在内核中操作，从而避免了内核缓冲区和用户缓冲区之间的数据拷贝，这种数据传递也叫零拷贝。

用sendfile函数传输文件的一个程序。和“Web服务器上实现集中写的程序”实现相同功能，但是简单多了。



mmap函数和munmap函数：用于申请和释放内存。申请的内存可以作为进程间通信的共享内存

POSIX是IEEE为要在各种UNIX操作系统上运行的软件而定义的**一系列API标准的总称**

上面提到的大多数函数都是成功时返回0或操作东西的数量，失败则返回-1并设置errno。



splice函数：用于在两个文件描述符之间移动数据，也是零拷贝操作。fd_in和fd_out必须至少有一个是管道文件描述符。

将客户端发送的数据原样返回给客户端的程序



tee：tee函数在两个管道文件描述符之间复制数据，也是零拷贝操作，它不消耗数据（啥叫不消耗数据？？）。fd_in和fd_out必须都是管道文件描述符

6-5代码标注：从STDIN_FILENO就可以看出来，只要使用相应的文件描述符，就可以对系统内已经定义好的文件描述符进行使用



fcntl函数：提供了对文件描述符的各种控制操作，ioctl比fcntl能够执行更多的控制。

将文件描述符设置为非阻塞的（这会产生什么效果呢？？？）

当被关联的文件描述符可读或可写时，系统将触发SIGIO信号；当被关联的文件描述符（而且必须是一个socket）上有带外数据可读时，系统将触发SIGURG信号。将信号和文件描述符关联的方法，就是使用fcntl函数为目标文件描述符指定宿主进程或进程组。使用SIGIO时，还需要利用fcntl设置其O_ASYNC标志。SIGIO和SIGURG这两个信号与其他Linux信号不同





第七章 Linux服务器程序规范

后台进程（守护进程）、日志系统、linux服务器程序拥有自己的运行账户、配置文件、linux服务器进程启动时会生成一个PID文件



**日志这部分没有实例，我完全看不懂？？？？？**

Linux提供一个守护进程来处理系统日志——syslogd，现在一般用rsyslogd（syslogd升级版）

rsyslogd守护进程可以接收用户进程输出的日志和内核日志。

用户进程通过**syslog函数**生成系统日志并将日志放入到/dev/log中，rsyslogd则监听该文件以获取用户进程的输出

内核日志由printk等函数打印至内核的环状缓存（ring buffer）中。环状缓存的内容直接映射到/proc/kmsg文件中。rsyslogd则通过读取该文件获得内核日志。

rsyslogd守护进程的各种配置文件的说明

syslog函数：应用程序使用syslog函数与rsyslogd守护进程通信。

openlog应该是对输出日志内容的补充。对后续syslog调用的行为进行配置。

setlogmask：用于设置掩码，日志级别大于掩码的信息被忽略

closelog()：关闭掩码

什么叫日志，保存日志干嘛，日志保存起来不就行。那处理系统日志——syslogd是用来干嘛的？？举一个例子说明一下，这玩意能干嘛？？找一个有关于rsyslogd和syslog函数的实例



一个进程拥有两个用户ID：UID和EUID

EUID：如果程序设置了set-user-id标志，那么当某用户使用该程序时，此用户的EUID变为该程序拥有者的ID，同时该用户暂时具有该程序拥有者的权限。如使用su程序时，EUID为0（root），用户暂时拥有了root用户的权限，

给程序test_uid设置set-user-id标志：sudo chomd +s  test_uid

将以root身份启动的进程切换为以一个普通用户身份运行。

大部分服务器就必须以root身份启动，但不能以root身份运行

每个进程都具有GID和EGID吗？？它们是干嘛的？？和进程组是什么关系？？



Linux下每个进程都隶属于一个进程组，因此它们除了PID信息外，还有进程组ID（PGID）

每个进程组都有一个首领进程，其PGID和PID相同。

 getpgid：获得进程所在的进程组的ID

setpgid：设置当前进程到某个进程组



一些有关联的进程组将形成一个会话

setsid用于创建会话，该函数**不能**由进程组的首领进程调用。

调用setsid会产生的效果：1）调用进程称为会话首领 2）新建一个进程组，调用进程成为此进程组的首领 3）调用进程甩开终端

getsid获取会话的SID，SID就是首领所在的进程组的PGID。



ps命令可查看进程、进程组和会话之间的关系

用于系统资源限制的函数：getrlimit和setrlimit，如可以设置用户可以创建的进程数限制。

Web服务器的逻辑根目录并非文件系统的根目录“/”，而是站点的根目录（对于Linux的Web服务来说，该目录

一般是/var/www/）。所以需要改变进程的根目录。

获取进程当前工作目录和改变进程工作目录的函数分别是：getcwd和chdir

通过chroot可以改变函数的根目录，chroot并不改变进程的当前工作目录，所以调用chroot之后，我们仍然需要使用chdir(“/”)来将工作目录切换至新的根目录。改变进程的根目录之后，程序可能无法访问类似/dev的文件（和目录），因为这些文件（和目录）并非处于新的根目录之下。

 daemon函数：服务器程序后台化



除了TIME_WAIT，去记录以下FIN_WAIT1等东西是啥，并解决accept那里运行与作者的结果不一致问题。





第八章 高性能服务器程序框架（后续章节的总览）

I/O处理单元、逻辑单元、提高服务器性能的其他建议



I/O处理单元：服务器和客户端之间的通信过程实际上对socket文件的读写过程，也就是一个输入输出的过程（I\O的过程）。所以I/O处理单元应该是用于同时处理多个客户端请求的方式。

逻辑单元：服务器给客户端分配的逻辑单元是由fork系统调用创建的子进程。也就是给每一个客户端的请求都分配一个子进程来进行处理



C/S模型非常适合资源相对集中的场合，并且它的实现也很简单，但其缺点也很明显：服务器是通信的中心，当访问量过大时，可能所有客户都将得到很慢的响应。

P2P模型可以看作C/S模型的扩展：每台主机既是客户端，又是服务器。



服务器程序种类繁多，但其基本框架都一样，不同之处在于逻辑处理

服务器编程框架：I/O处理单元、请求队列、逻辑单元、网络存储单元

I/O处理单元：

​		单个服务器程序：等待并接受新的客户连接。也有可能接收客户数据，将服务器响应数据返回给客户端

​		服务器机群：它实现负载均衡，从所有逻辑服务器中选取负荷最小的一台来为新客户服务。

逻辑单元：

​		单个服务器程序：它分析并处理客户数据，然后将结果传递给I/O处理单元或者直接发送给客户端。一个逻辑单元通常是一个进程或线程

​		服务器机群：一个逻辑单元本身就是一台逻辑服务器。

网络存储单元：可以是数据库、缓存和文件，甚至是一台独立的服务器。但它不是必须的。

请求队列：请求队列是各单元之间的通信方式的抽象（这是什么意思，我不理解？？？）。请求队列通常被实现为池的一部分。



I/O模型 

socket在创建的时候默认是阻塞的。我们可以给socket系统调用的第2个参数传递SOCK_NONBLOCK标志，或者通过fcntl系统调用的F_SETFL命令，将其设置为非阻塞的

阻塞I/O：系统调用可能因为无法立即完成而被操作系统挂起，直到等待的事件发生为止。如调用recv后，需要等待对方send的数据送达。非阻塞I/O中，调用recv后，程序会继续执行下一条命令，在对方send的数据送达时，程序会接收到相应通知（通知一般是内核发送给程序的），并调用相应的处理函数。

socket的基础API中，可能被阻塞的系统调用包括accept、send、recv和connect。

通过I/O复用和SIGIO信号可以实现非阻塞I/O：如，非阻塞I/O中，调用recv后，程序会继续执行下一条命令，在对方send的数据送达时，程序会接收到SIGIO信号，SIGIO信号的信号处理函数将被触发。

I/O复用函数本身是阻塞的，它们能提高程序效率的原因在于它们具有同时监听多个I/O事件的能力，当监听到相应的事件就给相应的程序发送相应的通知。。

I/O复用函数是select、poll和epoll_wait

同步I/O与异步I/O

POSIX规范所定义的异步I/O模型：数据的读写处理完全由内在内核中



两种高效的事件处理模式：Reactor和Proactor。

服务器程序通常需要处理三类事件：I/O事件、信号及定时事件。

同步I/O模型通常用于实现Reactor模式，异步I/O模型则用于实现Proactor模式。不过，也可以使用同步I/O方式模拟出Proactor模式。

Reactor模式：要求主线程（I/O处理单元）只负责监听文件描述上是否有事件发生，有的话就立即将该事件通知工作线程（逻辑单元）。如epoll_wait——注册事件，事件发生后通知主线程，主线程将已经发生的事件放入请求队列，并唤醒请求队列上的某个线程去处理这个事件。

Proactor模式：与Reactor模式不同，Proactor模式将所有I/O操作都交给主线程和内核来处理，工作线程仅仅负责业务逻辑。以aio_read和aio_write为例——注册事件并告诉内核读（写）缓冲区的位置，当socket上的数据被读入用户缓冲区后 或 当用户缓冲区的数据被写入socket之后，向应用程序发送一个信号，以通知应用程序数据处理。
我理解的Proactor模式：以['https://blog.csdn.net/qq_44345567/article/details/106039844">链接1</a>进行操作。<br> <img src="https://img-blog.csdnimg.cn/62f516ee04744fd48a5aio_read和aio_write为例——主线程中注册事件并定义一个变量buf用于接收客户发送过来的数据。事件经过上面的注册以后，当客户发送数据过来的时候，内核就会自动地将数据放入buf中并触发工作线程去处理buf中的数据。也就是说Reactor模式的工作线程处理的是一个一个套接字，然后从套接字中读取数据 或 使用套接字发送数据。
而Proactor模式的工作线程处理的是一个一个具体的数据，而所有的I/O操作都放在了主线程和内核中（即所有对套接字的读写都放在了主线程和内核中）


模拟Proactor模式：主线程执行数据读写操作，读写完成之后，主线程向工作线程通知这一“完成事件”。



服务器的两种高效的并发模式：半同步/半异步（half-sync/half async）模式和领导者/追随者（Leader/Followers）模式。



半同步/半异步模式：

这里的同步和异步和I/O模型中所说的不同。

“同步”指的是程序完全按照代码序列的顺序执行；异步：程序顺序执行的过程中，可能有有各种事件触发各种函数的执行

同步和异步的优缺点

半同步/半异步模式：结合同步和异步。异步线程监听客户请求、将请求插入请求队列中。请求队列将通知某个工作在同步模式的工作线程来读取并处理该请求对象。

为什么感觉I/O模型和半同步/半异步模式描述的是一个东西？？？答：确实好像就是一个东西

半同步/半异步模式的变种——半同步/半反应堆（half-sync/half-reactive）模式：半同步/半反应堆模式采用的事件处理模式是Reactor模式，它要求工作线程自己从socket上读取客户请求和往socket写入服务器应答。

半同步/半反应堆模式的缺点

 高效的半同步/半异步模式：无请求队列，主线程只管理监听socket，连接socket由工作线程来管理。



领导者/追随者模式：轮流做领导去监听I/O事件，有事件时，领导就派追随者去处理或领导自己去处理（此时可调用promote_new_leader选出新的领导）

句柄Handle：一个文件描述符。领导将事件处理器绑定到Handle上，当Handle上检测到事件，领导调用事件处理器进行处理



有限状态机：

根据数据包类型对应不同状态，不同状态编写不同的处理逻辑。执行完一个逻辑后就改变状态，不同的状态就可以执行不同的逻辑。

没看完，看得我很烦！！！以后再说吧！草



提高服务器性能的其他建议：

池：从池中获取硬件资源，池中的资源是预先静态分配的，如果资源不够时，就再动态分配一些并加入池中。池可分为多种，常见的有内存池、进程池、线程池和连接池

- 内存池：用于socket的接收缓存和发送缓存

- 进程池和线程池：用于并发编程。拿一个进程或线程出来处理新来到的客户请求

- 连接池：很多建好的与数据库的连接，只需要从连接池中取出连接，就可以访问数据库。

数据复制

- 当应用程序不关心数据内容时，可以直接用零拷贝
- 当两个工作进程之间要传递大量的数据时，使用共享内存来在它们之间直接共享这些数据，而不是使用管道或者消息队列来传递

上下文切换和锁





# 第九章 I/O复用
I/O复用：监听多个文件描述符上面的事件
先看[我对I/O复用的总结](https://www.cnblogs.com/codingbigdog/p/16244095.html)



EPOLLONESHOT事件：
select、poll和epoll都能同时监听多个文件描述符，通过某种结构体变量来告诉内核监听哪些文件描述符上的哪些事件，并使用该结构体类型的参数来获取内核处理的结果。

select：只能处理可读、可写及异常事件，需要用三个参数分别处理这三种事件
poll：任何事件都被统一处理，接口较为简洁。每次select和poll调用都返回整个用户注册的事件集合（其中包括就绪的和未就绪的）
epoll：它在内核中维护一个事件表，返回就绪的事件
select和poll都只能工作在相对低效的LT模式，而epoll则可以工作在ET高效模式。并且epoll还支EPOLLONESHOT事件。

EPOLLONESHOT事件：一个socket连接在任一时刻都只被一个线程处理，直到此线程处理完毕以后，其他线程才能处理此socket，实现过程如下：文件描述符fd注册了EPOLLONESHOT事件，则操作系统最多触发fd上注册的一个可读、可写或者异常事件，且只触发一次，触发以后，epoll就检测不到fd上面发生的事件。触发事件一般会开启一个线程去处理相应的事件。此线程最后要将fd上的EPOLLONESHOT事件重置，这样使得epoll有机会再次检测到fd上的事件，进而使得其他线程有机会为fd服务。
从上面可以看出，注册了EPOLLONESHOT事件以后，每一个时刻只有一个线程在对fd进行操作。EPOLLONESHOT事件解决的是同一个时刻，有多个线程操作同一个套接字的情况。

EPOLLONESHOT事件的示例代码、其他的示例代码。

linux内部实现了一个超级服务xinetd，用于处理telnet、echo等操作。









# 第十章 信号

信号：通知进程的信息

kill函数：一个进程给其他进程发送信号的API是kill函数

可以自定义一个处理信号的函数，也可以使用SIG_IGN（忽略信号）和SIG_DFL（使用信号的默认处理方式）

Linux信号

使用sigaction函数可以重启被信号中断的系统调用

信号掩码指定哪些信号不能发送给本进程

我有时看到复杂的数据类型的名字的时候我会有点懵，但是没有关系，我就把它理解成一个类（事实上也有可能是一个结构体等）

signal函数：传入信号处理函数的指针和要捕获的信号

sigaction比较高级的signal函数



Linux使用数据结构sigset_t来表示一组信号，以及对sigset_t的一些操作

sigprocmask用于设置或查看进程的信号掩码

被挂起的信号：收到被屏蔽的信号，信号会被挂起。等到屏蔽被取消以后，进程会立即获取该信号。多次获取到同一被屏蔽的信号，屏蔽在被取消以后，该信号的处理函数也只被触发一次

sigpending获得进程当前被挂起的信号集

fork调用产生的子进程将继承父进程的信号掩码，但具有一个空的挂起信号集。



信号处理函数往管道的写端写入信号值，主循环监听管道的读端文件描述符上的可读事件。信号事件就能和其他I/O事件一样被处理，即统一事件源

代码没看



网络编程相关信号

SIGHUP信号可以用来强制服务器重读配置文件

xinetd处理SIGHUP的流程

往一个读端关闭的管道或socket连接中写数据将引发SIGPIPE信号

用SIGURG检测带外数据是否到达。代码还没看


黑马程序员笔记：https://www.cnblogs.com/codingbigdog/p/16246557.html





# 第11章  定时器
定时器：用于计时，时间到了，就去处理相应的任务。如过一定时间就去检测一个客户连接的活动状态。

Linux提供了三种定时方法：**socket选项SO_RCVTIMEO和SO_SNDTIMEO、SIGALRM信号、I/O复用系统调用的超时参数。**

**1.socket选项SO_RCVTIMEO和SO_SNDTIMEO**：使用setsockopt函数和选项SO_RCVTIMEO/SO_SNDTIMEO给socket设置接收数据超时时间和发送数据超时时间。函数send、sendmsg、recv、recvmsg、accept和connect中使用此socket会产生不同的效果。
send、sendmsg、connect：在一定时间没有将数据发送成功，返回错误。
recv、recvmsg、accept：在一定时间没有接收到数据，返回错误。
**代码11-1connect_timeout.cpp**：connect中使用设置定时的套接字——十秒之内没有连接成功，返回错误。

**2.SIGALRM信号：**由alarm和setitimer函数设置的实时闹钟一旦超时，将触发SIGALRM信号（见[C++ 信号处理](https://www.cnblogs.com/codingbigdog/p/16246557.html)）。因此，我们可以利用该信号的信号处理函数来处理定时任务。本书中介绍了两个具体的定时器实现代码：
- 基于升序链表：将定时器都放入一个链表中，链表按照超时时间做升序排序。
代码：util_timer结构体代表一个定时器，其中包含一个时间，包含一个回调函数
sort_timer_lst类：用于生成一个升序的定时器链表，并通过成员函数添加、删除链表中的定时器
- 升序定时器链表的实际应用——关闭非活动连接：将超过一定时间没有使用的套接字从epoll树上删除。
代码：每隔一段时间alarm发送一个SIGALRM信号，信号处理函数通过通道将此信号通知给主循环，主循环中通过tick()遍历定时器链表并删除超时套接字。

**3.I/O复用系统调用的超时参数：**将epoll_wait函数的形参timeout设为相应的值。经过timeout的时间后，epoll_wait会被触发并epoll_wait的返回值为0。



管理定时器的容器：时间轮和时间堆。容器指的是装一个一个定时器的地方。
- 时间轮：一个轮子上有N个槽，每个槽代表一个链表。每一个链表代表一个时间。比如一个槽代表一秒，一圈有六十槽，那么一圈就代表六十秒。当指针指向了第n个槽的时候，可能代表已经过了n秒（假设一个槽代表一秒），也可能代表过了N+n、2N+n、3N+n...秒。处理该槽上超时的节点，并删除此节点。
代码：使用数组tw_timer *slots[N]表示时间轮，slots中每个元素指向一个定时器链表，链表无序。
tw_timer类用于表示定时器，成员变量rotation表示圈数，time_slot表示定时器属于时间轮上哪个槽。在本代码中，一个槽代表一秒，一圈六十秒，所以rotation=x，time_slot=y代表x分t秒。

- 时间堆：使用最小堆来存储定时器，每一次都将堆顶的定时器的超时时间作为依据，当超时时间到了就执行堆顶定时器的任务，并删除堆顶元素。
代码：还没看。











































# 问题：

1.wan和lan的区别？？

2.如何根据IP数据报中的8位服务类型TOS，实现相应服务？？

3.在5.1.2中的内存对齐是什么意思？？ 

4.在5.4中的程序想要说明什么？？？我没看懂？、

5.“3.9 TCP超时重传”有个问题未解决？？？

6."P172内存对齐"是什么？？

7.“p175void指针”

8."宏有什么用？直接定一个变量不就行了"

9.什么叫不可重入？

答：如果一个函数的执行期间被中断后，到重新恢复到断点进行执行的过程中，函数所依赖的环境没

有发生改变，那么这个函数就是可重入的

我们知道中断时确实保存一些上下文，但是仅限于返回地址，cpu寄存器等之类的少量上下文，而函

数内部使用的诸如全局或静态变量，buffer等并不在保护之列，所以如果这些值在函数被中断期间发

生了改变，那么当函数回到断点继续执行时，其结果就不可预料了。

10.CGI服务器啥？？

11.人手一个的web服务器项目，我该如何脱颖而出？
答：C++基础基础较为牢固、算法题做得比较好、还有其他别的项目、我学的正是进去工作以后要用的。。。。。。。。